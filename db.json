{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes\\cactus\\source\\images\\favicon-192x192.png","path":"images/favicon-192x192.png","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\images\\favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\images\\apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\images\\logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\images\\favicon.svg","path":"images/favicon.svg","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\js\\main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\js\\search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\css\\rtl.styl","path":"css/rtl.styl","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\css\\style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\clipboard\\clipboard.min.js","path":"lib/clipboard/clipboard.min.js","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\jquery\\jquery.min.js","path":"lib/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGL-Bold.ttf","path":"lib/meslo-LG/MesloLGL-Bold.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGL-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGL-Regular.ttf","path":"lib/meslo-LG/MesloLGL-Regular.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGM-Bold.ttf","path":"lib/meslo-LG/MesloLGM-Bold.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGL-Italic.ttf","path":"lib/meslo-LG/MesloLGL-Italic.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGM-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGS-Bold.ttf","path":"lib/meslo-LG/MesloLGS-Bold.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGS-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGM-Regular.ttf","path":"lib/meslo-LG/MesloLGM-Regular.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGS-Italic.ttf","path":"lib/meslo-LG/MesloLGS-Italic.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGM-Italic.ttf","path":"lib/meslo-LG/MesloLGM-Italic.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Black.eot","path":"lib/vazir-font/Vazir-Black.eot","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGS-Regular.ttf","path":"lib/meslo-LG/MesloLGS-Regular.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Black.woff","path":"lib/vazir-font/Vazir-Black.woff","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Black.ttf","path":"lib/vazir-font/Vazir-Black.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Bold.eot","path":"lib/vazir-font/Vazir-Bold.eot","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Bold.woff","path":"lib/vazir-font/Vazir-Bold.woff","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Bold.ttf","path":"lib/vazir-font/Vazir-Bold.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Bold.woff2","path":"lib/vazir-font/Vazir-Bold.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Light.ttf","path":"lib/vazir-font/Vazir-Light.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Light.eot","path":"lib/vazir-font/Vazir-Light.eot","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Light.woff","path":"lib/vazir-font/Vazir-Light.woff","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Black.woff2","path":"lib/vazir-font/Vazir-Black.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Medium.eot","path":"lib/vazir-font/Vazir-Medium.eot","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Light.woff2","path":"lib/vazir-font/Vazir-Light.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Medium.woff","path":"lib/vazir-font/Vazir-Medium.woff","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Medium.ttf","path":"lib/vazir-font/Vazir-Medium.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Regular.eot","path":"lib/vazir-font/Vazir-Regular.eot","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Medium.woff2","path":"lib/vazir-font/Vazir-Medium.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Regular.woff","path":"lib/vazir-font/Vazir-Regular.woff","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Thin.eot","path":"lib/vazir-font/Vazir-Thin.eot","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Regular.ttf","path":"lib/vazir-font/Vazir-Regular.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Regular.woff2","path":"lib/vazir-font/Vazir-Regular.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Thin.ttf","path":"lib/vazir-font/Vazir-Thin.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Variable.eot","path":"lib/vazir-font/Vazir-Variable.eot","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Thin.woff2","path":"lib/vazir-font/Vazir-Thin.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Thin.woff","path":"lib/vazir-font/Vazir-Thin.woff","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Variable.ttf","path":"lib/vazir-font/Vazir-Variable.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\font-face.css","path":"lib/vazir-font/font-face.css","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Variable.woff2","path":"lib/vazir-font/Vazir-Variable.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Variable.woff","path":"lib/vazir-font/Vazir-Variable.woff","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\justified-gallery\\css\\justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\justified-gallery\\js\\jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\css\\all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-v4compatibility.ttf","path":"lib/font-awesome/webfonts/fa-v4compatibility.ttf","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-v4compatibility.woff2","path":"lib/font-awesome/webfonts/fa-v4compatibility.woff2","modified":1,"renderable":1},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"source\\_posts\\base_network.md","hash":"6e4f263d7747e64f3565a001b3038a0361f5f4fa","modified":1717937755188},{"_id":"source\\_posts\\browser_eventloop.md","hash":"6d4e6d75fabc992edd1df705a681368aa4c97f44","modified":1718089156497},{"_id":"source\\_posts\\async_await.md","hash":"c421220ff6a90a07de32f8e4939eab540997c176","modified":1718110909300},{"_id":"source\\_posts\\dnssec.md","hash":"9d8004f3c82ce57dca77350a94ee1cceabb80146","modified":1717937730968},{"_id":"source\\_posts\\frp_read.md","hash":"be34f399f42f7d48da73b567b6b5a2fd94e796ab","modified":1718475912754},{"_id":"source\\_posts\\docker-base.md","hash":"2336b42895594be7de6a69496e58ba7acc015a04","modified":1717937777808},{"_id":"source\\_posts\\hello_web.md","hash":"e83a3f89e4b83de2d5cea0f79a7843ac49016502","modified":1717937698204},{"_id":"source\\_posts\\glcm.md","hash":"84b3c4a59a7ead02813354e9084277398714d3fa","modified":1718555940281},{"_id":"source\\_posts\\how-js-run.md","hash":"2ec57c65aa78972110109f3db9fa7ccae621f79e","modified":1717937723359},{"_id":"source\\_posts\\how_does_clash_work.md","hash":"882422659577a5b5bb73cc6760b9fcc75b0474de","modified":1718386490868},{"_id":"source\\_posts\\html_relearn.md","hash":"325d832bb1e82798d61b9a77f7d5181a6fa0d23d","modified":1717937747483},{"_id":"source\\_posts\\how_java_run.md","hash":"09a7683a322c006f7e1bc334c7301663b37a00ee","modified":1717937765055},{"_id":"source\\_posts\\koa2-crud-example.md","hash":"aade51dc5a4c92c16b9fea9bfe7c53eeedf6c7c2","modified":1717937785626},{"_id":"source\\_posts\\js-prototype-chain.md","hash":"61d3dc3b0e8b58e24a4ecd92d2919eee5a547088","modified":1717937718848},{"_id":"source\\_posts\\js-obfuscation-deobfuscation.md","hash":"19d42f71d83323d8c38ee61fed0c632e1f086db8","modified":1717937721238},{"_id":"source\\_posts\\js-scope-and-hoisting.md","hash":"eea0f0fe27e84ce9b793832b7fc675ab46929c68","modified":1717937716794},{"_id":"source\\_posts\\nvm-node.md","hash":"40e6a2468fbc989a7a8cf10eabd5416274d540e9","modified":1717937771441},{"_id":"source\\_posts\\overview-of-nginx-process-model.md","hash":"14822baf2c86f546ddcd98e661121b4c3089e619","modified":1717937713557},{"_id":"source\\_posts\\promise.md","hash":"06b4a64e85b3510ddb6c8b7d9169ad7b8e1eadd4","modified":1718159838008},{"_id":"source\\_posts\\unocss-theme.md","hash":"6fbbeb44e70b69e4823ab65b1aaa7ad4d03035d1","modified":1717937800121},{"_id":"source\\_posts\\where_is_posts.md","hash":"34577754f0e88d5fa2a9d39b98cb09aa48f005f9","modified":1717941033990},{"_id":"source\\_posts\\web-usual-auth.md","hash":"cc5112778c0046d4ef69ab2225fc35b61c8d6657","modified":1717937760175},{"_id":"source\\_posts\\python_in_linux.md","hash":"d20271cba10fc6b70af2b13c8da38632ce0373fa","modified":1717937736568},{"_id":"source\\categories\\index.md","hash":"7824e279bbe3c3969e7a8a8bfde8972d320180db","modified":1717922330483},{"_id":"source\\about\\index.md","hash":"ff731b75aef5fb535f52febeb6abe630aef4ceda","modified":1717925022384},{"_id":"source\\friends\\index.md","hash":"b4da3f571a4f4c773e01fe8cec77b4d4fa803f3e","modified":1717935640278},{"_id":"source\\_posts\\linux_for_freshman.md","hash":"f9e6e637cc6f744b860c86b4aad388b991b3df1d","modified":1717937742717},{"_id":"themes\\cactus\\.gitignore","hash":"044711463cfff978c57dbe9612deeb221269890e","modified":1717915696938},{"_id":"themes\\cactus\\.jshintrc","hash":"d6ee46102ed2ff00acb555557f47241b701e99a4","modified":1717915696945},{"_id":"themes\\cactus\\_config.yml","hash":"bc7a429875f5855745de099d4d4853294707d9bc","modified":1717943422998},{"_id":"themes\\cactus\\.stylintrc","hash":"8bbbee5eae70fbe7dd53c9ce43d244b47d58385b","modified":1717915696947},{"_id":"themes\\cactus\\package.json","hash":"768e4f07b7bc6406d37b84878e1d34be668f5ea4","modified":1717915696994},{"_id":"themes\\cactus\\languages\\ar.yml","hash":"2f1258875dbffa89d192a1d6481c4bd3c337126b","modified":1717915696955},{"_id":"themes\\cactus\\languages\\ca.yml","hash":"6f9897fe8c7b7bf23be7fa58c530602217aea898","modified":1717915696955},{"_id":"themes\\cactus\\languages\\de.yml","hash":"0734bfc33861585a12327142bf52489c882ad34f","modified":1717915696955},{"_id":"themes\\cactus\\languages\\default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1717915696955},{"_id":"themes\\cactus\\languages\\en.yml","hash":"491c87ff300815df52220f6cead8e28edea129df","modified":1717915696955},{"_id":"themes\\cactus\\LICENSE","hash":"06806c75801c9ae870a1b47d588ef8e00d3c7c94","modified":1717915696947},{"_id":"themes\\cactus\\languages\\es.yml","hash":"56ddfd9081641c45272bdc2df750e41ab8b600bf","modified":1717915696955},{"_id":"themes\\cactus\\languages\\it.yml","hash":"501bfc9aed86964ee75354a805378740a02af799","modified":1717915696963},{"_id":"themes\\cactus\\languages\\fa.yml","hash":"05fb8dad765af2b9eec32582f5d277eb2735ffc3","modified":1717915696962},{"_id":"themes\\cactus\\languages\\kr.yml","hash":"ab5be04a1b4c4d87e164b1a045e220f855e85a38","modified":1717915696963},{"_id":"themes\\cactus\\languages\\fr.yml","hash":"4604fc8f94d98f6d53c80535fbae78814f88f32d","modified":1717915696963},{"_id":"themes\\cactus\\languages\\nl.yml","hash":"4c36921322e782775ccff9aec78d4261153cf5e5","modified":1717915696963},{"_id":"themes\\cactus\\languages\\ru.yml","hash":"47fb1672f36d5adadf2f6c3a5c4d1714f5bd563b","modified":1717915696963},{"_id":"themes\\cactus\\languages\\pl.yml","hash":"3677b782edd98986bb82568c6ff6c8b77140b75a","modified":1717915696963},{"_id":"themes\\cactus\\languages\\pt-br.yml","hash":"417d25e3dae260a2503ec6a8f1b590fa00534b14","modified":1717915696963},{"_id":"themes\\cactus\\languages\\vi.yml","hash":"1a1dfc60e952c3429c038f69a9e0ca2057784fca","modified":1717915696963},{"_id":"themes\\cactus\\languages\\ua.yml","hash":"983d0acd3ce19858ec14c641da135a562541c778","modified":1717915696963},{"_id":"themes\\cactus\\languages\\zh-TW.yml","hash":"fa5923f53f6174b044255e2d1655136168ff59c0","modified":1717915696963},{"_id":"themes\\cactus\\languages\\tr.yml","hash":"fcde93b8a92117706b019b51a95385c940e29190","modified":1717915696963},{"_id":"themes\\cactus\\layout\\index.ejs","hash":"6e3a63db6bc43f6e4091361c52df5bcfd5be3339","modified":1717915696994},{"_id":"themes\\cactus\\layout\\404.ejs","hash":"c04829c5ddc417d0b9a66cad55a838cc7eed997b","modified":1717915696963},{"_id":"themes\\cactus\\languages\\zh-CN.yml","hash":"4254824ede1d35398ffc1b0dfdb49bba557d7e4e","modified":1717920481449},{"_id":"themes\\cactus\\layout\\layout.ejs","hash":"c7b73f887d62fad9f14507504c4a2c036860e76c","modified":1717915696994},{"_id":"themes\\cactus\\layout\\archive.ejs","hash":"cda7b4d3f3615a9a591d7610f9e40b615ca68c73","modified":1717915696979},{"_id":"themes\\cactus\\layout\\post.ejs","hash":"9b8e937375f56053f497f437c06d527761b98d1c","modified":1717915696994},{"_id":"themes\\cactus\\scripts\\meta.js","hash":"96b1a52af341adc741a5581ddc7335105abe780e","modified":1717915696994},{"_id":"themes\\cactus\\scripts\\error_404.js","hash":"099d428e1b96b9c219a789da60b87703c509b2bb","modified":1717915696994},{"_id":"themes\\cactus\\layout\\page.ejs","hash":"1700d4f434170e1eeb0e2a9470fc3c0732b2ba7e","modified":1717915696994},{"_id":"themes\\cactus\\scripts\\page_title.js","hash":"03b5c8b6215f0b305327e8d9b5d49add83b4b95f","modified":1717915696994},{"_id":"themes\\cactus\\scripts\\thumbnail.js","hash":"3d841aa267026703a5cc29f4ffbb613f0a2bbd45","modified":1717915696994},{"_id":"themes\\cactus\\scripts\\merge-configs.js","hash":"98b79403945fa7f8dc177e6da283681677d02567","modified":1717915696994},{"_id":"themes\\cactus\\scripts\\cdn.js","hash":"6037ad2ddbdc4d87195d91b3bd9f197c1b40467a","modified":1717915696994},{"_id":"themes\\cactus\\layout\\_partial\\header.ejs","hash":"3eae6c39852c3d7cba8978ad93a5570d20580924","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\footer.ejs","hash":"2336c1eb473fea860f4c3e309c50bc32544d0b4e","modified":1717915696963},{"_id":"themes\\cactus\\layout\\_partial\\search.ejs","hash":"12dba799ae5736dfbf1548e1923bbb7447de8a6d","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\google_analytics.ejs","hash":"82372a68455c05fa6a07c5ecb8defe11f769da7c","modified":1717915696963},{"_id":"themes\\cactus\\layout\\_partial\\scripts.ejs","hash":"46ad130a7a741ca44928116479c2004180979e40","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\head.ejs","hash":"cac3ef9de11b14825599efe69b0939f42d368e25","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\pagination.ejs","hash":"ea8692715a8ea49624638dbd7bfb911af58887ee","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\styles.ejs","hash":"42fd45758d8f8e814bfdd8b26eb676d87b8465b2","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\umami_analytics.ejs","hash":"5a39772aa121652f9d54619282fe880006b2a677","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\comments.ejs","hash":"162fb8592903605789f516be2cd9c678a1a2d207","modified":1717915696963},{"_id":"themes\\cactus\\source\\images\\favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1717915697112},{"_id":"themes\\cactus\\source\\images\\apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1717915697106},{"_id":"themes\\cactus\\README.md","hash":"78c23f149de6869b91e4e1bb9067915f6520d6fc","modified":1717915696947},{"_id":"themes\\cactus\\source\\js\\main.js","hash":"adc9e8e86e82f6bce527d5674df0a9b298ac71a0","modified":1717915697112},{"_id":"themes\\cactus\\source\\css\\_extend.styl","hash":"1b9b2c69b894343068f3384000581a6092c4e868","modified":1717915697012},{"_id":"themes\\cactus\\source\\images\\favicon.svg","hash":"5270db43a400eebd286cbc8e72e7ec9b030c7f50","modified":1717935994550},{"_id":"themes\\cactus\\source\\css\\_mixins.styl","hash":"37093d2a554283ab652b59e5e0ff9b542edced0f","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_fonts.styl","hash":"5c1727836f5d6076a65cf91dbbeaba8d16b5132b","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_util.styl","hash":"1c7bed7376f04d7b77d817e132aee08cf65e6395","modified":1717915697106},{"_id":"themes\\cactus\\source\\css\\rtl.styl","hash":"105284f992de848968d818f6200d2ebbdd5342d0","modified":1717915697106},{"_id":"themes\\cactus\\source\\css\\_variables.styl","hash":"5dcbf89bd23d9dd3c45d07049a1448b0ae95426b","modified":1717915697106},{"_id":"themes\\cactus\\layout\\_partial\\post\\actions_desktop.ejs","hash":"53d0225501f4c33abda7059293f00aa22e3d4364","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\post\\actions_mobile.ejs","hash":"2170a51e5b2637ef55651f29637cafcd111242b2","modified":1717915696979},{"_id":"themes\\cactus\\source\\css\\style.styl","hash":"210406274d091be115a6175929ba5671b8b8f946","modified":1717915697106},{"_id":"themes\\cactus\\layout\\_partial\\post\\date.ejs","hash":"b64d37f8a2cdb3990a5f4cd686b4fa3f2607b5bb","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\post\\gallery.ejs","hash":"725ab823c2fb4a5e444eca3afa617d88f305ef71","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\post\\category.ejs","hash":"62fd0bb73eef411ae0b2d6f529a273d54fd0d277","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\post\\tag.ejs","hash":"424029d2d8e6c51c7370c5f8aabc21799418d3f1","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\post\\share.ejs","hash":"6b037d536ef89c1e7b488f34c20fa977389ae744","modified":1717915696979},{"_id":"themes\\cactus\\layout\\_partial\\post\\title.ejs","hash":"524ad82e6d52b91d20cded8224efb76f2fdacf0b","modified":1717915696979},{"_id":"themes\\cactus\\gulpfile.js","hash":"23b5f0ea4c4d4319dfa8c3d3eaecb7bd70d90336","modified":1717915696953},{"_id":"themes\\cactus\\source\\js\\search.js","hash":"0d2933fa97c4036805011cc219fcc43ae578e230","modified":1717915697112},{"_id":"themes\\cactus\\source\\lib\\clipboard\\clipboard.min.js","hash":"d62dcb0905e038e69ff24ab9eef9e3306d45535e","modified":1717915697112},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1717915697358},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1717915697371},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1717915697371},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1717915697388},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1717915697358},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1717915697405},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1717915697388},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1717915697405},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1717915697413},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1717915697418},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1717915697430},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\font-face.css","hash":"a3dca7ea2f1fedafc2dfb687884d8ac792d15947","modified":1717915697446},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1717915697438},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1717915697430},{"_id":"themes\\cactus\\source\\css\\_colors\\dark.styl","hash":"d2978cb0035ba1da0a58db2ed947a72b0bd41042","modified":1717915697010},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1717915697446},{"_id":"themes\\cactus\\source\\css\\_colors\\white.styl","hash":"a20de63c1cd7ccf25b8313e2d211866a20e86fbe","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_colors\\classic.styl","hash":"3d6c91b03ade77daf1ceb11c5dad48b0e35ac353","modified":1717915696994},{"_id":"themes\\cactus\\source\\css\\_highlight\\androidstudio.styl","hash":"4d67bdab6cc9c614486ca42f98199a04d053e7f0","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_colors\\light.styl","hash":"9b156c15c855677a50c4a27de17a8cb377b69802","modified":1717915697010},{"_id":"themes\\cactus\\source\\css\\_highlight\\arta.styl","hash":"262167aaebcf28de7f85af7ac77a76fa1fa284f7","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_highlight\\agate.styl","hash":"fc289ba8f47ead6331ec3a51533cfa93251c5634","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_highlight\\ascetic.styl","hash":"ca087a3c70998c7ac6b0b42d5cf7a653b8707591","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_highlight\\arduino-light.styl","hash":"591962bfc758a521b4cb907750c19a1a2423b4d5","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-cave-dark.styl","hash":"7e83c7f2acaaaa98864660afe2794745c36c8e51","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-estuary-dark.styl","hash":"1cecd13e0d6b24042ff86372f0596c1441bb834a","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-cave-light.styl","hash":"f47de0b9d66617728f68096ed48371dd6bb9e67a","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-dune-light.styl","hash":"657fe215931fd06e21b56374df699a94890f7ab4","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-dune-dark.styl","hash":"68584ed0e99c7d0e49ef8a2e67cd4dcdad359de4","modified":1717915697012},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-forest-dark.styl","hash":"a741eba35cdfe2cfd67dfbf109655f253d6b4795","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-estuary-light.styl","hash":"2b416a0567a53aa0fa8898b196ddd44315c1a5f3","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-heath-dark.styl","hash":"f186b357dcebded89b7bcc77389b2cff76533d72","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-lakeside-dark.styl","hash":"802979cea895a0a384645cb30a43de9572cb0e3f","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-forest-light.styl","hash":"8d7c7242974aa2454fa792c5d7a47c5f9632355a","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-heath-light.styl","hash":"c1db353e8613607580d40b12ddc162d029560576","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-plateau-dark.styl","hash":"0d51ddc580ccb0a291271fa9632bc91dab632df6","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-lakeside-light.styl","hash":"8659eaae6a0c2e00b4b9199803e50adf4ff0128d","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-seaside-dark.styl","hash":"2f008271299042f2443bca98c9bcadbc8c45e837","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-plateau-light.styl","hash":"96181544eeadc5b0749229f11607e7c01f81e078","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-savanna-dark.styl","hash":"bbad7a9512b4873294e73ce806e36e43973e6ed8","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-savanna-light.styl","hash":"8a5207a0c30262a0bf5e1a41411a306f7a89a7e7","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-sulphurpool-dark.styl","hash":"18dcb00ab9c62eb810d492047214331c51bb654f","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\brown-paper.styl","hash":"d14846542a26b75fd26df5b5df6c5493733f73f6","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-seaside-light.styl","hash":"08e2df313c272d5c70c93e713639663c168180d0","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\codepen-embed.styl","hash":"1de45e603e2c71c7f6b0c1372a3ba00b1bc153a8","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\dark.styl","hash":"98d7884806838a0b46132d759d60ac27c0c4bd9c","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\atelier-sulphurpool-light.styl","hash":"add3d88c9d12567dcfae7a8e49984d119fc72227","modified":1717915697028},{"_id":"themes\\cactus\\source\\css\\_highlight\\color-brewer.styl","hash":"9c4905eab730d0b389e6972e907057577f7e25f1","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\darkula.styl","hash":"8965ad6920601c275ca97e617beff5536925a266","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\docco.styl","hash":"7bd3389ce16d20488ab336d557056cc703c921c7","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\far.styl","hash":"8da83d66724f2ce508a40f21b4f6dc0d704be562","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\foundation.styl","hash":"28c59a31467c33bd51cbf3b6085782c2a724ff6c","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\github.styl","hash":"a84eb710b302006120c3e7f8ca18f9e6fbc231c3","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\googlecode.styl","hash":"7f5082ae008925a23eb713f160773fe647eb3ff7","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\gruvbox-dark.styl","hash":"f66403ce77dcb16b1f98a5061b72f7581630d69f","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\hopscotch.styl","hash":"dd3c78c42d4a865f11623235e5e5f6829d789706","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\github-gist.styl","hash":"71f4b0fca91a587e6eba15a5306dca963bb8f441","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\highlightjs.styl","hash":"fd796a58c5d4590cda67c998187933788d45f30a","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\ir-black.styl","hash":"aa31b30069ebee39e2c3ebb75e2c96ba8678eb14","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\hybrid.styl","hash":"4906456025787de04b48a87c42bb704c5ff67065","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\idea.styl","hash":"e284c1760e8da0848f56cd5601d867ceeb0192d7","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\kimbie.dark.styl","hash":"3b998c640eeb2c6192fee24bc78b4137de475dd7","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\kimbie.light.styl","hash":"e901738455ec9a1bddde7b62bbd8595de6033e1e","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\index.styl","hash":"36c44375229613a5bb9ee84a8e90214978070439","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\magula.styl","hash":"ab179306c12a1cf2949482beaca328e379ef034a","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\monokai-sublime.styl","hash":"84a27bd29d939105d65f4164c219d6cc2e09ae60","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\mono-blue.styl","hash":"14fb8678739b77f35771b6d63101ddbf1e7a9fbc","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\kimbie.styl","hash":"13113af220dfed09cb49d85102babb352c3eff97","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\obsidian.styl","hash":"efba069860181d2b709e1548dd16cf102ca267fa","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\monokai.styl","hash":"c3a3bfae1eb864505fbc8748db734600057af1af","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\grayscale.styl","hash":"c83804abe39faebd80f8f4ff64fbd7137674cb1c","modified":1717915697043},{"_id":"themes\\cactus\\source\\css\\_highlight\\paraiso-dark.styl","hash":"50f1cee8a5b3b165b4184ead0a99dc564b62ef4f","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\paraiso.styl","hash":"846a06a57fa0b3db7f83ec7ac2bf34911f32cf66","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\rainbow.styl","hash":"95246afef181bd96f9adb1a2e84fb3ef302d4598","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\railscasts.styl","hash":"5dc9ce33cecee87fe9ca8f2ed9342602194484ec","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\paraiso-light.styl","hash":"e428e8202b01e83b0f018a96058d806e7f4c76bf","modified":1717915697059},{"_id":"themes\\cactus\\source\\css\\_highlight\\solarized-dark.styl","hash":"9fc9400d3a8cae97eb5761c284140acb0f847538","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\sunburst.styl","hash":"e6e4c009b10b9805f0c593446bf013edec47d146","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\pojoaque.styl","hash":"4d4a9360c35f3c5a0c5b9b49a1f2284e7e21317b","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\school-book.styl","hash":"186c37e9c39e65aa291cce3317e35904693598d1","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\tomorrow-night-bright.styl","hash":"e6b025b247e4027fb3c1b7833588f5a5b04a549c","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\solarized-light.styl","hash":"bb04944fc06c12ecd7b56ad933dbedde60c2259a","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\tomorrow-night.styl","hash":"eb8441364bb1664ecebde77b965dc36c91133aa0","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\tomorrow-night-eighties.styl","hash":"8b16876cf205111d5d5454100de712bc3ea8f477","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\vs.styl","hash":"14fbb0c43af440a290280b26968c8a5c0786b27f","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\tomorrow-night-blue.styl","hash":"92f4423d4964fcfe34ff7ca6cb21012b5738c697","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_partial\\categories.styl","hash":"92fffe2baacb9d19021b3d120d2038417ca466df","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\footer.styl","hash":"5bc59fd8cadd7cff06d989c9c7e8e4eb0d0872d8","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\comments.styl","hash":"6e839bae0ddc11447579c34541e79b50d3670bbd","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\archive.styl","hash":"301bf71b6878c965b3ea49dc19aba3f1c111cd3a","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\article.styl","hash":"abdbf82d71c7ec89c2f3ebaf8cc0606ab4ec1e03","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\index.styl","hash":"4a0da5d7052204b23d390a7f76cdc903b9eef52b","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\header.styl","hash":"f08c8bd685ddced854cdf2183684013c0644527c","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\pagination.styl","hash":"4ff9755163aae6039bb72eac8360bc1c50fa26b6","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\tags.styl","hash":"7a2f9051b21bce525ecb71799d37c4b65a4f9171","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\search.styl","hash":"680ea535e5a20c01a31bee4d3eb680b86267a281","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\tooltip.styl","hash":"6cb13a9f4a7c01aa7ab8f73739a7d385377c5465","modified":1717915697090},{"_id":"themes\\cactus\\source\\lib\\justified-gallery\\css\\justifiedGallery.min.css","hash":"4a8d364c99df8471c6a0c7192710631e605af635","modified":1717915697196},{"_id":"themes\\cactus\\source\\css\\_highlight\\zenburn.styl","hash":"f63534764dd6598e81177d64714a184f98153b11","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_highlight\\tomorrow.styl","hash":"502335f0fac07ed74ca78207bcf3ef8dd2252cf6","modified":1717915697075},{"_id":"themes\\cactus\\source\\css\\_highlight\\xcode.styl","hash":"5fa8999c7f807c1aae29c7a1cdf681678576fb69","modified":1717915697075},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-v4compatibility.ttf","hash":"a9d072aca9e0fadc2a7167671ce3d6b18d9cd2cc","modified":1717915697178},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-regular-400.woff2","hash":"fb363d27cfdfe71a243fa2ac3dab2815232b9b7e","modified":1717915697154},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-regular-400.ttf","hash":"67afa6237670ab99125056f2899129f22912dcf3","modified":1717915697150},{"_id":"themes\\cactus\\source\\lib\\justified-gallery\\js\\jquery.justifiedGallery.min.js","hash":"8d7e041394387fd523991bf827d417ade2747e35","modified":1717915697196},{"_id":"themes\\cactus\\source\\css\\_partial\\post\\actions_desktop.styl","hash":"c25ccdd505ca1b7c74a7fb2365ad2c262f8025ba","modified":1717915697090},{"_id":"themes\\cactus\\source\\css\\_partial\\post\\actions_mobile.styl","hash":"b06410ed34b5ecbcac11357aa359149e1f827aa6","modified":1717915697090},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-v4compatibility.woff2","hash":"8f80d0bbe995f7fe92320fdaec10cd5ccd710a51","modified":1717915697180},{"_id":"themes\\cactus\\source\\lib\\jquery\\jquery.min.js","hash":"edf8a6a066f201b1ffad32c585bd79c9982d4433","modified":1717915697188},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1717915697346},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1717915697363},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1717915697355},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1717915697371},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1717915697386},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1717915697396},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1717915697396},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1717915697405},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1717915697422},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1717915697436},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1717915697413},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1717915697380},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1717915697422},{"_id":"themes\\cactus\\source\\lib\\vazir-font\\Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1717915697438},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\css\\all.min.css","hash":"2bf056f1697bf3afdf49e56573d63b114374661e","modified":1717915697128},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-brands-400.woff2","hash":"4350f9ba93384634faf35f41c503c99c767f1069","modified":1717915697142},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-brands-400.ttf","hash":"f0982a77285d53653845b0a78170b4688db972f1","modified":1717915697137},{"_id":"themes\\cactus\\source\\images\\logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1717915697112},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-solid-900.woff2","hash":"6b99aa650bd12a36caa14e0127435d8f4cd3ba73","modified":1717915697172},{"_id":"themes\\cactus\\source\\images\\favicon.ico","hash":"a4679b6756a93f156687d7ed20952021fb1c9824","modified":1717936166784},{"_id":"themes\\cactus\\source\\lib\\font-awesome\\webfonts\\fa-solid-900.ttf","hash":"20bd663830188cbadd2264e1daf9497c3ffc3621","modified":1717915697172},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1717915697246},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1717915697296},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1717915697330},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1717915697229},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1717915697263},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1717915697220},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1717915697271},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1717915697313},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1717915697286},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1717915697324},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1717915697338},{"_id":"themes\\cactus\\source\\lib\\meslo-LG\\MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1717915697305},{"_id":"public/about/index.html","hash":"cdb3ab1da5d6e292884629d222cf067d4345c302","modified":1718555950798},{"_id":"public/2024/06/15/frp_read/index.html","hash":"65970033a68fb447dec6f9b195ef60aa616d9fd2","modified":1718555950798},{"_id":"public/friends/index.html","hash":"0b1f281aac620f0484281a936b78a6ecce98591d","modified":1718555950798},{"_id":"public/categories/index.html","hash":"79b2b488011c9bb48a9df724c3709827700bd7b5","modified":1718555950798},{"_id":"public/2024/06/16/glcm/index.html","hash":"27cbe7904f9909da34a748f61cef5ac685968c65","modified":1718555950798},{"_id":"public/2024/06/12/how_does_clash_work/index.html","hash":"a36eff18d1fd5efc6824bb822391704dbdcbac7c","modified":1718555950798},{"_id":"public/2024/06/11/async_await/index.html","hash":"dbf94a6e01eea1038573e8a263d88f2e3b7607f6","modified":1718555950798},{"_id":"public/2024/06/10/browser_eventloop/index.html","hash":"9404914a97ed1cd730cb5f6638b69b0b18b52e6b","modified":1718555950798},{"_id":"public/2024/05/20/hello_web/index.html","hash":"847d5c2efb1db1973bbba36a5aa78fb7fb50b5db","modified":1718555950798},{"_id":"public/2024/02/20/overview-of-nginx-process-model/index.html","hash":"971203ac2e196b90396ec27fd68b2a554db82095","modified":1718555950798},{"_id":"public/2024/06/09/promise/index.html","hash":"6e694f36dece12c055ba56b7606b44cc479e1868","modified":1718555950798},{"_id":"public/2024/02/14/js-prototype-chain/index.html","hash":"87245bbb75f2ca6e16d521b534fe4d5be2bde859","modified":1718555950798},{"_id":"public/2024/02/16/js-scope-and-hoisting/index.html","hash":"78689ab9cc57e54998ae60dd78105e532b43dfe1","modified":1718555950798},{"_id":"public/2024/02/10/how-js-run/index.html","hash":"33617b884e4f89d789a8d9b6dba90e7a2a72f558","modified":1718555950798},{"_id":"public/2024/02/12/js-obfuscation-deobfuscation/index.html","hash":"83a6584743d3f5ace762d3863e8f29e9c8bf3509","modified":1718555950798},{"_id":"public/2023/11/23/python_in_linux/index.html","hash":"7d9aa3bd8b85be091d7fe0458dbb26127f6110f3","modified":1718555950798},{"_id":"public/2023/12/11/dnssec/index.html","hash":"a18dfb0e327b883a3e36c10f1b8c244ae017ddd1","modified":1718555950798},{"_id":"public/2023/10/22/html_relearn/index.html","hash":"06d48c1b1bb1624a30f2634623a8144df2556c16","modified":1718555950798},{"_id":"public/2023/10/14/linux_for_freshman/index.html","hash":"bd5ec959ec6e8d59bfe5dd85f9e1d37283ede8b0","modified":1718555950798},{"_id":"public/2023/10/02/base_network/index.html","hash":"23c2cfbe2a18093b0eddf1de3704b267239717b9","modified":1718555950798},{"_id":"public/2023/09/14/web-usual-auth/index.html","hash":"103213125ab0151cdac9bbf728e5f09b19daa2cd","modified":1718555950798},{"_id":"public/2023/09/01/how_java_run/index.html","hash":"14d17a813ada1bb920802e6c4e4618b6985bf253","modified":1718555950798},{"_id":"public/2023/06/12/nvm-node/index.html","hash":"74edef10c68925ffc151de00b5fa646b5d8535a2","modified":1718555950798},{"_id":"public/2023/05/02/docker-base/index.html","hash":"4198c7bb10cddf8088acba7f09d1d579cd332b92","modified":1718555950798},{"_id":"public/2023/04/28/koa2-crud-example/index.html","hash":"d5e821c0d3d8ec69e31730a4297a786f3fa7dad7","modified":1718555950798},{"_id":"public/categories/JavaScript/index.html","hash":"7b6b26ef2ea1f84d3d32b331b33e3df64b359e1f","modified":1718555950798},{"_id":"public/2023/01/26/unocss-theme/index.html","hash":"abc6a2032b46b7e96adafee9a01fefcd11ebeebf","modified":1718555950798},{"_id":"public/categories/Network/index.html","hash":"485071c5a166ee3decbbe42302e12bc77354c203","modified":1718555950798},{"_id":"public/2022/01/01/where_is_posts/index.html","hash":"782cddd94bdcbe095a4c19bc966101cd099073cc","modified":1718555950798},{"_id":"public/categories/Docker/index.html","hash":"4db341d886a080c3af4df2af782f1bfce70296c4","modified":1718555950798},{"_id":"public/categories/Source-Code-Read/index.html","hash":"0b0e39bd86ad05ccf5d1451bccb05ece83cf9f40","modified":1718555950798},{"_id":"public/categories/Web/index.html","hash":"2ad023ba1c4b7c083a1d7ea2a6e808fb756d9879","modified":1718555950798},{"_id":"public/categories/Java/index.html","hash":"dabe9539a296ee416d8f1061848ce8ff9f3ea5e6","modified":1718555950798},{"_id":"public/categories/Digital-Image-Processing/index.html","hash":"efd4533d0dfa68a915f3ca5b7b8b082470ed51b2","modified":1718555950798},{"_id":"public/categories/Linux/index.html","hash":"b451cf0856442a4f6b6cd3245da53c1d5d4c7ea7","modified":1718555950798},{"_id":"public/categories/HTML/index.html","hash":"01045988715c858e61eaf5953cc78c170a150b8a","modified":1718555950798},{"_id":"public/categories/Node-js/index.html","hash":"d20132f7fbca102a2358b4e1d502d319eac53480","modified":1718555950798},{"_id":"public/categories/CSS/index.html","hash":"b3e49c69cd5804a391cacd90e8620f5286f4b3b2","modified":1718555950798},{"_id":"public/categories/Life/index.html","hash":"5e6268297f1f680d0b9c01ed892f2424304d3ca4","modified":1718555950798},{"_id":"public/categories/Nginx/index.html","hash":"63a48552c3582fc96d148e2c44895cc4be2e8105","modified":1718555950798},{"_id":"public/archives/index.html","hash":"eac15b9783d12bf0574e57f28d16801623b3776e","modified":1718555950798},{"_id":"public/categories/Python/index.html","hash":"c8b9eb64618f04eaa024dee7ce6a72b709183d99","modified":1718555950798},{"_id":"public/archives/page/2/index.html","hash":"d5943898f9ee102246680f420187f7c352daa706","modified":1718555950798},{"_id":"public/archives/page/3/index.html","hash":"972281be15f6c91e27f7a11e6f521fa9196e5631","modified":1718555950798},{"_id":"public/archives/2022/index.html","hash":"554cd3173c0b275e1b3eb728da8874964ff70da4","modified":1718555950798},{"_id":"public/archives/2022/01/index.html","hash":"0f54e8b80459f2550e2d8978f8eb52a6eebefdd2","modified":1718555950798},{"_id":"public/archives/2023/index.html","hash":"3e38e45bca71edc0ca25191afa35e3896bf7b404","modified":1718555950798},{"_id":"public/archives/2023/page/2/index.html","hash":"55cf4bb51a7e7f5db75e9a8ad95abf3c87efcd95","modified":1718555950798},{"_id":"public/archives/2023/01/index.html","hash":"f940be981fe0a4280ba4c6641c84b11197a897b7","modified":1718555950798},{"_id":"public/archives/2023/04/index.html","hash":"b21b7c10afa2aac7dd9007e914c808618e64db07","modified":1718555950798},{"_id":"public/archives/2023/05/index.html","hash":"ed5640c23559483b264613998fc37c7d5bc2f11b","modified":1718555950798},{"_id":"public/archives/2023/09/index.html","hash":"0886147b6f0e6bc02b6bbfbeec816d17e542c42c","modified":1718555950798},{"_id":"public/archives/2023/06/index.html","hash":"d33f3c0658f6aa4b77c102a78f39767147253971","modified":1718555950798},{"_id":"public/archives/2023/11/index.html","hash":"229d5b343559c738a1f84f4c994e47a5cbd5a81c","modified":1718555950798},{"_id":"public/archives/2023/12/index.html","hash":"7d5c98a1199bb7bf6ae332a2ca8da1322a09bdc1","modified":1718555950798},{"_id":"public/archives/2023/10/index.html","hash":"179c1a6440dc26e32b8fea338f930ccc7a759cde","modified":1718555950798},{"_id":"public/archives/2024/page/2/index.html","hash":"791f562654e4b221936aa2e240d0d2d1bed069fc","modified":1718555950798},{"_id":"public/archives/2024/02/index.html","hash":"6476ee88943c4da34b8ee815aae5ae9d3dbd2587","modified":1718555950798},{"_id":"public/archives/2024/index.html","hash":"89a901997e1a2ee4010214ae2a18d4af37b53ab0","modified":1718555950798},{"_id":"public/index.html","hash":"4af2a667995d2848a460d496774873ccc6618087","modified":1718555950798},{"_id":"public/archives/2024/05/index.html","hash":"6ae4fe4b5a80d001e3cd908ddd3fa0f1a4be21f5","modified":1718555950798},{"_id":"public/archives/2024/06/index.html","hash":"d5d9733d108b6a80d270561156208fe5d3ca4fe7","modified":1718555950798},{"_id":"public/404.html","hash":"e74bdc83b944053601d05d88964ceee95ce546a2","modified":1718555950798},{"_id":"public/page/2/index.html","hash":"a3d193cdf8d5cf42e20445bb2cc860ba82d70841","modified":1718555950798},{"_id":"public/page/3/index.html","hash":"bc0f678a2407dbcce4ce617174b9ddd06bb85df8","modified":1718555950798},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1718555950798},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1718555950798},{"_id":"public/images/favicon.svg","hash":"5270db43a400eebd286cbc8e72e7ec9b030c7f50","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1718555950798},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"fb363d27cfdfe71a243fa2ac3dab2815232b9b7e","modified":1718555950798},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"67afa6237670ab99125056f2899129f22912dcf3","modified":1718555950798},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.ttf","hash":"a9d072aca9e0fadc2a7167671ce3d6b18d9cd2cc","modified":1718555950798},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.woff2","hash":"8f80d0bbe995f7fe92320fdaec10cd5ccd710a51","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1718555950798},{"_id":"public/css/style.css","hash":"775c8fa6860f020f1bd5ebdc2d8346998602138a","modified":1718555950798},{"_id":"public/js/main.js","hash":"619ac6529d140711e3b14f739a192bb31c4824ff","modified":1718555950798},{"_id":"public/js/search.js","hash":"914a2ce72fb325106c61600200be823b72bfb39f","modified":1718555950798},{"_id":"public/css/rtl.css","hash":"9589fac02a34fd9084f805f801889028756bbb65","modified":1718555950798},{"_id":"public/lib/clipboard/clipboard.min.js","hash":"9a7cb405f9beed005891587d41f76a0720893ffc","modified":1718555950798},{"_id":"public/lib/jquery/jquery.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1718555950798},{"_id":"public/lib/vazir-font/font-face.css","hash":"ba0030e1cd28a8caa7a5bb74b98da7c7bb185c90","modified":1718555950798},{"_id":"public/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"ad8f48b4022498078b089fcdd1e8b47faf496931","modified":1718555950798},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"8c06d82739d14b094ff6d9036021a252bd1d985d","modified":1718555950798},{"_id":"public/lib/justified-gallery/css/justifiedGallery.min.css","hash":"dd3052149d3054f35efb823c68dd78e78aad5875","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1718555950798},{"_id":"public/lib/vazir-font/Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1718555950798},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"4350f9ba93384634faf35f41c503c99c767f1069","modified":1718555950798},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"6b99aa650bd12a36caa14e0127435d8f4cd3ba73","modified":1718555950798},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"f0982a77285d53653845b0a78170b4688db972f1","modified":1718555950798},{"_id":"public/images/favicon.ico","hash":"a4679b6756a93f156687d7ed20952021fb1c9824","modified":1718555950798},{"_id":"public/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1718555950798},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"20bd663830188cbadd2264e1daf9497c3ffc3621","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1718555950798},{"_id":"public/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1718555950798}],"Category":[{"name":"JavaScript","_id":"clxhruaow0004f4lyg9d916ih"},{"name":"Network","_id":"clxhruap1000cf4ly95u6988i"},{"name":"Docker","_id":"clxhruap4000lf4ly26uo4b7o"},{"name":"Source Code Read","_id":"clxhruap7000rf4ly7fdm5j1s"},{"name":"Web","_id":"clxhruap8000vf4ly6lgd9gzo"},{"name":"Digital Image Processing","_id":"clxhruap90011f4lybxhfbb24"},{"name":"Java","_id":"clxhruapa0016f4ly8hiqgmrc"},{"name":"HTML","_id":"clxhruapb001bf4lyabed68vn"},{"name":"Linux","_id":"clxhruapc001ef4ly4cpc3bxd"},{"name":"Node.js","_id":"clxhruapc001if4ly93qg323r"},{"name":"Nginx","_id":"clxhruapc001lf4lybnfucwza"},{"name":"CSS","_id":"clxhruapd001of4ly97vldi1z"},{"name":"Life","_id":"clxhruapd001qf4lyer9k8056"},{"name":"Python","_id":"clxhruapg001uf4lyggmwgfyc"}],"Data":[],"Page":[{"title":"about","date":"2024-06-09T06:48:32.000Z","_content":"\n# 👋Hello，这里是 Ma5hr00m\n\n现就读于杭州电子科技大学，网络工程专业。Vidar-Team 22 级 Web 手（兼职美工），HDUHelper 第十二届前端部分管主席。\n\n博客是向别人展示自己的窗口，内容相对较杂，但会进行有序的分类。平日里以研究技术为主，偶尔会发散一下创造力，搞一些设计与绘画。\n\n学习计算机时很喜欢反复折腾，拓宽了知识面但也导致有时学习效率较低。会尽快解决掉自己需要做的事情，把时间留给自己感兴趣的东西。\n\n## 技术栈\n\n- Linux 主力系统，Majaro/Fedora | ★★★★★\n- JavaScript/TypeScript 前端开发主力工具 | ★★★★★\n- Sass/SCSS/Less 魔杖 | ★★★★★\n- Golang 后端主力开发工具 | ★★★★★\n- Node.js 后端开发工具 | ★★★★\n- Python 胶水，哪里有需要就糊在哪里 | ★★★★\n- PHP 过气工具，安全用 | ★★★\n\n## 现有设备\n\n- Dell g15 5520 💻\n- Xiaomi12 pro 📱\n- OnePlus Ace 2V 📱\n- NanoPi R2S 📶\n- Tencent Linux 2C2G 🕹️\n- ~~Huawei Wach 2 ⌚~~ （已损坏）\n- Xiaomi Watch 8 ⌚\n- Gaomon 1060Pro 🎨\n\n## 兴趣爱好\n\n- Coding，希望用代码创造一些东西\n- Pixel Art [-> toPixiv](https://www.pixiv.net/users/86286425)\n- 看动漫，漫画为主\n- 偶尔写文章/小说，将自己的幻想变成文字","source":"about/index.md","raw":"---\ntitle: about\ndate: 2024-06-09 14:48:32\n---\n\n# 👋Hello，这里是 Ma5hr00m\n\n现就读于杭州电子科技大学，网络工程专业。Vidar-Team 22 级 Web 手（兼职美工），HDUHelper 第十二届前端部分管主席。\n\n博客是向别人展示自己的窗口，内容相对较杂，但会进行有序的分类。平日里以研究技术为主，偶尔会发散一下创造力，搞一些设计与绘画。\n\n学习计算机时很喜欢反复折腾，拓宽了知识面但也导致有时学习效率较低。会尽快解决掉自己需要做的事情，把时间留给自己感兴趣的东西。\n\n## 技术栈\n\n- Linux 主力系统，Majaro/Fedora | ★★★★★\n- JavaScript/TypeScript 前端开发主力工具 | ★★★★★\n- Sass/SCSS/Less 魔杖 | ★★★★★\n- Golang 后端主力开发工具 | ★★★★★\n- Node.js 后端开发工具 | ★★★★\n- Python 胶水，哪里有需要就糊在哪里 | ★★★★\n- PHP 过气工具，安全用 | ★★★\n\n## 现有设备\n\n- Dell g15 5520 💻\n- Xiaomi12 pro 📱\n- OnePlus Ace 2V 📱\n- NanoPi R2S 📶\n- Tencent Linux 2C2G 🕹️\n- ~~Huawei Wach 2 ⌚~~ （已损坏）\n- Xiaomi Watch 8 ⌚\n- Gaomon 1060Pro 🎨\n\n## 兴趣爱好\n\n- Coding，希望用代码创造一些东西\n- Pixel Art [-> toPixiv](https://www.pixiv.net/users/86286425)\n- 看动漫，漫画为主\n- 偶尔写文章/小说，将自己的幻想变成文字","updated":"2024-06-09T09:23:42.384Z","path":"about/index.html","comments":1,"layout":"page","_id":"clxhruaoq0000f4ly9cub8fuy","content":"<h1 id=\"👋Hello，这里是-Ma5hr00m\"><a href=\"#👋Hello，这里是-Ma5hr00m\" class=\"headerlink\" title=\"👋Hello，这里是 Ma5hr00m\"></a>👋Hello，这里是 Ma5hr00m</h1><p>现就读于杭州电子科技大学，网络工程专业。Vidar-Team 22 级 Web 手（兼职美工），HDUHelper 第十二届前端部分管主席。</p>\n<p>博客是向别人展示自己的窗口，内容相对较杂，但会进行有序的分类。平日里以研究技术为主，偶尔会发散一下创造力，搞一些设计与绘画。</p>\n<p>学习计算机时很喜欢反复折腾，拓宽了知识面但也导致有时学习效率较低。会尽快解决掉自己需要做的事情，把时间留给自己感兴趣的东西。</p>\n<h2 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h2><ul>\n<li>Linux 主力系统，Majaro&#x2F;Fedora | ★★★★★</li>\n<li>JavaScript&#x2F;TypeScript 前端开发主力工具 | ★★★★★</li>\n<li>Sass&#x2F;SCSS&#x2F;Less 魔杖 | ★★★★★</li>\n<li>Golang 后端主力开发工具 | ★★★★★</li>\n<li>Node.js 后端开发工具 | ★★★★</li>\n<li>Python 胶水，哪里有需要就糊在哪里 | ★★★★</li>\n<li>PHP 过气工具，安全用 | ★★★</li>\n</ul>\n<h2 id=\"现有设备\"><a href=\"#现有设备\" class=\"headerlink\" title=\"现有设备\"></a>现有设备</h2><ul>\n<li>Dell g15 5520 💻</li>\n<li>Xiaomi12 pro 📱</li>\n<li>OnePlus Ace 2V 📱</li>\n<li>NanoPi R2S 📶</li>\n<li>Tencent Linux 2C2G 🕹️</li>\n<li><del>Huawei Wach 2 ⌚</del> （已损坏）</li>\n<li>Xiaomi Watch 8 ⌚</li>\n<li>Gaomon 1060Pro 🎨</li>\n</ul>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>Coding，希望用代码创造一些东西</li>\n<li>Pixel Art <a href=\"https://www.pixiv.net/users/86286425\">-&gt; toPixiv</a></li>\n<li>看动漫，漫画为主</li>\n<li>偶尔写文章&#x2F;小说，将自己的幻想变成文字</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"👋Hello，这里是-Ma5hr00m\"><a href=\"#👋Hello，这里是-Ma5hr00m\" class=\"headerlink\" title=\"👋Hello，这里是 Ma5hr00m\"></a>👋Hello，这里是 Ma5hr00m</h1><p>现就读于杭州电子科技大学，网络工程专业。Vidar-Team 22 级 Web 手（兼职美工），HDUHelper 第十二届前端部分管主席。</p>\n<p>博客是向别人展示自己的窗口，内容相对较杂，但会进行有序的分类。平日里以研究技术为主，偶尔会发散一下创造力，搞一些设计与绘画。</p>\n<p>学习计算机时很喜欢反复折腾，拓宽了知识面但也导致有时学习效率较低。会尽快解决掉自己需要做的事情，把时间留给自己感兴趣的东西。</p>\n<h2 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h2><ul>\n<li>Linux 主力系统，Majaro&#x2F;Fedora | ★★★★★</li>\n<li>JavaScript&#x2F;TypeScript 前端开发主力工具 | ★★★★★</li>\n<li>Sass&#x2F;SCSS&#x2F;Less 魔杖 | ★★★★★</li>\n<li>Golang 后端主力开发工具 | ★★★★★</li>\n<li>Node.js 后端开发工具 | ★★★★</li>\n<li>Python 胶水，哪里有需要就糊在哪里 | ★★★★</li>\n<li>PHP 过气工具，安全用 | ★★★</li>\n</ul>\n<h2 id=\"现有设备\"><a href=\"#现有设备\" class=\"headerlink\" title=\"现有设备\"></a>现有设备</h2><ul>\n<li>Dell g15 5520 💻</li>\n<li>Xiaomi12 pro 📱</li>\n<li>OnePlus Ace 2V 📱</li>\n<li>NanoPi R2S 📶</li>\n<li>Tencent Linux 2C2G 🕹️</li>\n<li><del>Huawei Wach 2 ⌚</del> （已损坏）</li>\n<li>Xiaomi Watch 8 ⌚</li>\n<li>Gaomon 1060Pro 🎨</li>\n</ul>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>Coding，希望用代码创造一些东西</li>\n<li>Pixel Art <a href=\"https://www.pixiv.net/users/86286425\">-&gt; toPixiv</a></li>\n<li>看动漫，漫画为主</li>\n<li>偶尔写文章&#x2F;小说，将自己的幻想变成文字</li>\n</ul>\n"},{"title":"categories","date":"2024-06-09T08:34:08.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2024-06-09 16:34:08\ntype: categories\n---\n","updated":"2024-06-09T08:38:50.483Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clxhruaou0002f4ly4yd31ktn","content":"","excerpt":"","more":""},{"title":"friends","date":"2024-06-08T16:00:00.000Z","_content":"\n## 学习计算机知识时遇到的同好\n\n- [ek1ng](https://ek1ng.com/)\n- [ripple](https://rippleqaq.top/)\n- [ch405](https://ch405.live/)\n- [zbwer](https://blog.zbwer.work/)\n- [ec3o](https://ec3o.fun/)\n\n定期清除无法访问的链接，如果误杀非常抱歉，请在仓库 issue 留言，会及时恢复友链。\n\n## 欢迎交换友链\n\n| KEY   | VALUE |\n| ----- | ------------------------------------------------ |\n| 名称   | Ma5hr00m                                         |\n| 头像   | https://img.ma5hr00m.top/blog/20240216014457.png |\n| 描述   | 在摇摆与徘徊中前行                                  |\n| 站点   | 菇物语                                            |\n| 链接   | https://ma5hr00m.top/                            |\n","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2024-06-09\n---\n\n## 学习计算机知识时遇到的同好\n\n- [ek1ng](https://ek1ng.com/)\n- [ripple](https://rippleqaq.top/)\n- [ch405](https://ch405.live/)\n- [zbwer](https://blog.zbwer.work/)\n- [ec3o](https://ec3o.fun/)\n\n定期清除无法访问的链接，如果误杀非常抱歉，请在仓库 issue 留言，会及时恢复友链。\n\n## 欢迎交换友链\n\n| KEY   | VALUE |\n| ----- | ------------------------------------------------ |\n| 名称   | Ma5hr00m                                         |\n| 头像   | https://img.ma5hr00m.top/blog/20240216014457.png |\n| 描述   | 在摇摆与徘徊中前行                                  |\n| 站点   | 菇物语                                            |\n| 链接   | https://ma5hr00m.top/                            |\n","updated":"2024-06-09T12:20:40.278Z","path":"friends/index.html","comments":1,"layout":"page","_id":"clxhruaox0005f4lyddvua9m6","content":"<h2 id=\"学习计算机知识时遇到的同好\"><a href=\"#学习计算机知识时遇到的同好\" class=\"headerlink\" title=\"学习计算机知识时遇到的同好\"></a>学习计算机知识时遇到的同好</h2><ul>\n<li><a href=\"https://ek1ng.com/\">ek1ng</a></li>\n<li><a href=\"https://rippleqaq.top/\">ripple</a></li>\n<li><a href=\"https://ch405.live/\">ch405</a></li>\n<li><a href=\"https://blog.zbwer.work/\">zbwer</a></li>\n<li><a href=\"https://ec3o.fun/\">ec3o</a></li>\n</ul>\n<p>定期清除无法访问的链接，如果误杀非常抱歉，请在仓库 issue 留言，会及时恢复友链。</p>\n<h2 id=\"欢迎交换友链\"><a href=\"#欢迎交换友链\" class=\"headerlink\" title=\"欢迎交换友链\"></a>欢迎交换友链</h2><table>\n<thead>\n<tr>\n<th>KEY</th>\n<th>VALUE</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>名称</td>\n<td>Ma5hr00m</td>\n</tr>\n<tr>\n<td>头像</td>\n<td><a href=\"https://img.ma5hr00m.top/blog/20240216014457.png\">https://img.ma5hr00m.top/blog/20240216014457.png</a></td>\n</tr>\n<tr>\n<td>描述</td>\n<td>在摇摆与徘徊中前行</td>\n</tr>\n<tr>\n<td>站点</td>\n<td>菇物语</td>\n</tr>\n<tr>\n<td>链接</td>\n<td><a href=\"https://ma5hr00m.top/\">https://ma5hr00m.top/</a></td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<h2 id=\"学习计算机知识时遇到的同好\"><a href=\"#学习计算机知识时遇到的同好\" class=\"headerlink\" title=\"学习计算机知识时遇到的同好\"></a>学习计算机知识时遇到的同好</h2><ul>\n<li><a href=\"https://ek1ng.com/\">ek1ng</a></li>\n<li><a href=\"https://rippleqaq.top/\">ripple</a></li>\n<li><a href=\"https://ch405.live/\">ch405</a></li>\n<li><a href=\"https://blog.zbwer.work/\">zbwer</a></li>\n<li><a href=\"https://ec3o.fun/\">ec3o</a></li>\n</ul>\n<p>定期清除无法访问的链接，如果误杀非常抱歉，请在仓库 issue 留言，会及时恢复友链。</p>\n<h2 id=\"欢迎交换友链\"><a href=\"#欢迎交换友链\" class=\"headerlink\" title=\"欢迎交换友链\"></a>欢迎交换友链</h2><table>\n<thead>\n<tr>\n<th>KEY</th>\n<th>VALUE</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>名称</td>\n<td>Ma5hr00m</td>\n</tr>\n<tr>\n<td>头像</td>\n<td><a href=\"https://img.ma5hr00m.top/blog/20240216014457.png\">https://img.ma5hr00m.top/blog/20240216014457.png</a></td>\n</tr>\n<tr>\n<td>描述</td>\n<td>在摇摆与徘徊中前行</td>\n</tr>\n<tr>\n<td>站点</td>\n<td>菇物语</td>\n</tr>\n<tr>\n<td>链接</td>\n<td><a href=\"https://ma5hr00m.top/\">https://ma5hr00m.top/</a></td>\n</tr>\n</tbody></table>\n"}],"Post":[{"title":"流畅地使用 async/await","date":"2024-06-10T16:00:00.000Z","author":"ma5hr00m","_content":"\n`async/await` 是 JavaScript 用来处理异步操作的语法。它们建立在 Promise 的基础上，提供了一种简洁直观的方式来编写和管理异步代码，现在也已经成为了 JavaScript 实际上的最佳异步编程方案。\n\n## Generator\n\n`async` 实质上就是早期的 `generator` 函数的语法糖。\n\nJavaScript 中的生成器（Generator）函数是 ES6 引入（与 Promise 一起）的一种特殊类型的函数。生成器这个概念最初来自于其他编程语言，如 Python，把这东西引入到 JavaScript 中，主要是为了简化异步编程和迭代操作。\n\n### 语法\n\n`generator` 函数的本质是一种可以暂停执行和恢复执行的函数，它返回一个遵循迭代器协议的生成器对象（即 `Iterator` 对象）。这个对象通过 `next()` 方法进行迭代，每次调用 `next()` 都会执行到下一个 `yield` 表达式，并返回一个包含 `value` 和 `done` 属性的对象，其中 `value` 表示返回的值，`done` 表示是否完成所有迭代。\n\n`yield` ****表达式是暂停、恢复执行的关键。在生成器函数体内，使用 `yield` 表达式来暂停函数的执行，并返回一个值到生成器外部。当外部代码再次调用生成器的 `next()` 方法时，生成器函数会从上次暂停的地方继续执行。\n\n语法也比较简单，可以看看以下示范：\n\n```jsx\nfunction* numberGen3erator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst gen = numberGenerator(); // 调用生成器函数创建生成器对象\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // 3\n```\n\n看到这语法结构，你可能会感到熟悉，稍后再说。\n\n### co\n\n既然介绍 `generator` 和 `async` 的关系，那就要说到 `co`。\n\n`co` 库是一个用于 Node.js 和浏览器的 JavaScript 库，由 TJ Holowaychuk 开发。它基于 `generator` 来控制异步流程，允许开发者以一种看起来几乎像同步代码的方式来编写非阻塞的异步代码。`co` 库的核心功能是自动执行生成器函数，处理 `yield` 关键字后面跟随的任何 `Promise` 对象，并在 `Promise` 解决后继续执行生成器函数。\n\n- **`co`** 库可以将生成器函数转换为返回 **`Promise`** 对象的函数。\n- 它支持 **`yield`** 关键字后面跟随的 **`Promise`** 对象、Thunk 函数、数组（并行执行）、对象（并行执行）、生成器和生成器函数（委托）。\n- **`co`** 库的使用前提是生成器函数的 **`yield`** 命令后面只能是 Thunk 函数或 **`Promise`** 对象。\n\n```jsx\nconst co = require('co');\n\nco(function* () {\n  var result = yield Promise.resolve(true);\n  return result;\n}).then(function (value) {\n  console.log(value); // true\n});\n```\n\n在这个示例中，`co` 函数接受一个 `generator` 作为参数，并返回一个 `Promise` 对象。生成器函数内部通过 `yield` 暂停执行，等待 `Promise` 解决，然后 `co` 库会自动恢复执行。\n\n### 对比\n\n有了前面的铺垫，这里做个对比：\n\n```jsx\n// async/await\nasync function fetchData() {\n  const data = await fetch('some-url');\n  console.log(data);\n}\n\n// generator + co\nfunction fetchData() {\n  return co(function* () {\n    const data = yield fetch('some-url');\n    console.log(data);\n  });\n}\n```\n\n一目了然，在语法结构层面，你只需要去除 `co`，然后将 `*` 替换为 `async`，`yield` 替换为 `await` 即可。既然 `async` 是对 `generator` 的封装，那肯定做了一些优化，主要体现在以下四点：\n\n1. 内置执行器，无需使用额外的 `co` 库，也不需要手动指定 `.next()`；\n2.  语义性好，代码更简洁；\n3. 适用性广泛，`await`命令后面，可以是 Promise 对象和原始类型的值，没有了 `yield` 的限制；\n4. 返回值为 Promise，可以使用 `.then` 等语法，更方便。\n\n> `async` 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 `await` 命令就是内部 `then` 命令的语法糖。\n> \n\n## 使用\n\n### async 语法\n\n使用 `async` 关键字可以声明一个异步函数（async function），这种函数会返回一个 `Promise` 对象。如果函数体内有返回值，那么这个值会被 `Promise.resolve()` 包装。如果函数抛出错误，则会被 `Promise.reject()` 包装。\n\n```jsx\nasync function f() {\n  return \"Hello, World!\";\n}\n\nf().then(alert); // \"Hello, World!\"\n```\n\n### await 语法\n\n`await` 关键字用于等待一个 `Promise` 完成（fulfilled）或拒绝（rejected）。它只能在异步函数内部使用。当 `await` 表达式暂停执行异步函数时，它会等待 `Promise` 解决，然后恢复异步函数的执行并返回解决的值。\n\n```jsx\nasync function f3() {\n  let promise = new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"完成!\"), 1000)\n  });\n\n  let result = await promise; // 等待直到 promise 解决 (*)\n\n  alert(result); // \"完成!\"\n}\n```\n\n### 错误处理\n\n`async` 异步编程错误处理的姿势比较多，比较推荐的是老老实实使用 `try...catch...`，虽然这可能造成有些情况下难以找到具体错误代码（比如 `await` 被嵌套在其他操作中）。\n\n另一种方案是在 `await` 之后使用 `catch()` 块捕获错误，也可以，但会造成代码风格上的冲突。\n\n此外，还有一种有趣的 Golang 代码风格的错误处理方式。我们可以通过创建一个包装函数来模拟这种行为，这个函数接受一个 **`Promise`** 并返回一个包含两个值的数组：一个错误和一个结果，这样我们就可以使用数组解构来同时获取错误和结果，而不需要使用 **`try...catch...`** 块。这种方法使得错误处理更加显式。\n\n下面是一个实现这种错误处理的示范：\n\n```jsx\n// 'to' 函数用于转换 Promise，以便它返回一个包含错误和结果的数组\nfunction to(promise) {\n  return promise\n    .then(data => [null, data])\n    .catch(err => [err]);\n}\n\n// 异步函数使用 'to' 函数和 'await' 来处理 fetch 请求\nasync function fetchUrl(url) {\n  const [err, response] = await to(fetch(url));\n  if (err) {\n    console.error('Fetch error:', err);\n    return;\n  }\n  const [parseErr, data] = await to(response.json());\n  if (parseErr) {\n    console.error('JSON parsing error:', parseErr);\n    return;\n  }\n  console.log('Fetched data:', data);\n}\n```\n\n### 示范\n\n模拟用户登录流程，流程看注释：\n\n```jsx\n// 假设我们有一个用于请求用户数据的函数\nfunction getUser(username) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (username === 'Alice') {\n        resolve({ id: 1, username: 'Alice', verified: true });\n      } else {\n        reject(new Error('用户不存在'));\n      }\n    }, 1000);\n  });\n}\n\n// 假设我们有另一个函数用于验证用户\nfunction verifyUser(user) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (user.verified) {\n        resolve('用户验证成功');\n      } else {\n        reject(new Error('用户验证失败'));\n      }\n    }, 1000);\n  });\n}\n\n// 使用 async/await 和 .then().catch() 结合处理登录流程\nasync function loginUser(username) {\n  try {\n    // 使用 await 等待 getUser 函数解决\n    const user = await getUser(username);\n    // 使用 await 等待 verifyUser 函数解决\n    const verificationStatus = await verifyUser(user);\n    console.log(verificationStatus);\n  } catch (error) {\n    // 处理任何在 getUser 或 verifyUser 中抛出的错误\n    console.error(error.message);\n  }\n}\n\n// 调用 loginUser 函数，并使用 .then().catch() 处理最终结果\nloginUser('Alice')\n  .then(() => {\n    console.log('登录流程完成');\n  })\n  .catch((error) => {\n    console.error('登录流程中发生错误:', error.message);\n  })\n```\n\n实际处理异步操作就套用这个 combo。此外还有一些使用时的注意点，这里也做补充：\n\n1. 多个 `await` 之间如果不存在继发关系，用 `Promise.all()` 统一处理，避免额外耗时；\n2. `async` 函数保留运行栈。\n\n最后一条特性需要个小例子来解释：\n\n```jsx\n// b() 执行时 a() 同步执行，若 b() or c() 报错，错误堆栈可能不包括 a()\nconst a = () => {\n  b().then(() => c());\n};\n\n// b() 执行时 a() 暂停执行，上下文保留，b() or c() 报错，错误堆栈一定包括 a()\nconst a = async () => {\n  await b();\n  c();\n};\n```\n\n### 实例：顺序完成异步加载\n\n`async` 内部的多个 `await` 使继发执行的，如果这些异步操作没有相互依赖，这种特性会降低运行效率，所以我们可以使用以下代码并发发出请求，然后顺序获得结果：\n\n> 代码案例来自阅读文档1\n> \n\n```jsx\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```\n\n## 顶层 await\n\n除了在 `async` 代码块中，我们也可以在模块的顶层代码中使用 **`await`** 关键字。\n\n当模块需要在执行任何其他代码之前完成某些异步操作，如数据加载、资源配置等，或者当一个模块依赖于另一个异步解析的模块时，可以使用顶层 **`await`** 确保所有依赖都已正确加载。\n\n```jsx\n// config.js\nexport async function loadConfig() {\n  const response = await fetch('/config.json');\n  if (!response.ok) {\n    throw new Error('配置加载失败');\n  }\n  return response.json();\n}\n```\n\n```jsx\n// main.js\nimport { loadConfig } from './config.js';\n\nlet config;\n\ntry {\n\t// 使用顶层 await 确保配置在继续之前被加载\n  config = await loadConfig();\n} catch (error) {\n  console.error('无法加载配置:', error);\n}\n\napplyConfig(config);\n```\n\n这种写法有个显而易见的好处——我们不需要在主程序中再额外包裹一层 `async`，而且虽然操作是异步的，但顶层 **`await`** 使得代码的读写更像是同步操作，易于理解和维护。\n\n同时，这种写法也确保了服务的可靠性。如果开发者单纯写一个脚本，然后在主模块中同步加载这个脚本，则很难控制异步操作的结果，因为主模块没法控制异步操作是否完成，以下面的代码为例，usage.js 无法确保自己获得了一个合理的 output 还是一个 `undefined`。\n\n> 代码案例来自阅读文档1\n> \n\n```jsx\n// awaiting.js\nlet output;\nasync function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n}\nmain();\nexport { output };\n```\n\n```jsx\n// usage.js\nimport { output } from \"./awaiting.js\";\n\nfunction outputPlusValue(value) { return output + value }\n\nconsole.log(outputPlusValue(100));\nsetTimeout(() => console.log(outputPlusValue(100)), 1000);\n```\n\n旧版的解决方法是让 awaiting.js 返回一个 Promise 对象，通过这个 Promise 对象判断异步操作是否结束。\n\n> 代码案例来自阅读文档1\n> \n\n```jsx\n// awaiting.js\nlet output;\nexport default (async function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n})();\nexport { output };\n```\n\n```jsx\n// usage.js\nimport promise, { output } from \"./awaiting.js\";\n\nfunction outputPlusValue(value) { return output + value }\n\npromise.then(() => {\n  console.log(outputPlusValue(100));\n  setTimeout(() => console.log(outputPlusValue(100)), 1000);\n});\n```\n\n这种写法虽然保证了数据的可靠性，但使代码变得臃肿，开发者必需时刻记得在调用这个子模块时要使用 Promise 加载，并且所有依赖这个子模块的模块都需要使用 Promise 加载，一层层地套回去了。而顶层 await 就直接解决了这个问题。\n\n## 小坑\n\n### 混用 `await` 和 `.then()`\n\n这是一种不被推荐的做法。\n\n如果你在一个 **`async`** 函数中使用 **`await`**，然后在同一个 **`await`** 调用后面紧接着使用 **`.then()`**，这可能会让人困惑，因为它混合了两种不同的风格，使代码的意图不够清晰。\n\n```jsx\nasync function fetchData() {\n  const data = await fetch('some-api-url')\n    .then(response => response.json())\n    .catch(error => console.error('Error:', error));\n  return data;\n}\n\n```\n\n业务逻辑明确的话，代码不会给你一拳，但其他开发者会给你一拳。\n\n## 阅读文档\n\n1. https://es6.ruanyifeng.com/#docs/async\n2. https://www.cnblogs.com/porter/p/13343524.html","source":"_posts/async_await.md","raw":"---\ntitle: 流畅地使用 async/await\ndate: 2024/6/11\nauthor: ma5hr00m\ncategories:\n- JavaScript\n---\n\n`async/await` 是 JavaScript 用来处理异步操作的语法。它们建立在 Promise 的基础上，提供了一种简洁直观的方式来编写和管理异步代码，现在也已经成为了 JavaScript 实际上的最佳异步编程方案。\n\n## Generator\n\n`async` 实质上就是早期的 `generator` 函数的语法糖。\n\nJavaScript 中的生成器（Generator）函数是 ES6 引入（与 Promise 一起）的一种特殊类型的函数。生成器这个概念最初来自于其他编程语言，如 Python，把这东西引入到 JavaScript 中，主要是为了简化异步编程和迭代操作。\n\n### 语法\n\n`generator` 函数的本质是一种可以暂停执行和恢复执行的函数，它返回一个遵循迭代器协议的生成器对象（即 `Iterator` 对象）。这个对象通过 `next()` 方法进行迭代，每次调用 `next()` 都会执行到下一个 `yield` 表达式，并返回一个包含 `value` 和 `done` 属性的对象，其中 `value` 表示返回的值，`done` 表示是否完成所有迭代。\n\n`yield` ****表达式是暂停、恢复执行的关键。在生成器函数体内，使用 `yield` 表达式来暂停函数的执行，并返回一个值到生成器外部。当外部代码再次调用生成器的 `next()` 方法时，生成器函数会从上次暂停的地方继续执行。\n\n语法也比较简单，可以看看以下示范：\n\n```jsx\nfunction* numberGen3erator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst gen = numberGenerator(); // 调用生成器函数创建生成器对象\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // 3\n```\n\n看到这语法结构，你可能会感到熟悉，稍后再说。\n\n### co\n\n既然介绍 `generator` 和 `async` 的关系，那就要说到 `co`。\n\n`co` 库是一个用于 Node.js 和浏览器的 JavaScript 库，由 TJ Holowaychuk 开发。它基于 `generator` 来控制异步流程，允许开发者以一种看起来几乎像同步代码的方式来编写非阻塞的异步代码。`co` 库的核心功能是自动执行生成器函数，处理 `yield` 关键字后面跟随的任何 `Promise` 对象，并在 `Promise` 解决后继续执行生成器函数。\n\n- **`co`** 库可以将生成器函数转换为返回 **`Promise`** 对象的函数。\n- 它支持 **`yield`** 关键字后面跟随的 **`Promise`** 对象、Thunk 函数、数组（并行执行）、对象（并行执行）、生成器和生成器函数（委托）。\n- **`co`** 库的使用前提是生成器函数的 **`yield`** 命令后面只能是 Thunk 函数或 **`Promise`** 对象。\n\n```jsx\nconst co = require('co');\n\nco(function* () {\n  var result = yield Promise.resolve(true);\n  return result;\n}).then(function (value) {\n  console.log(value); // true\n});\n```\n\n在这个示例中，`co` 函数接受一个 `generator` 作为参数，并返回一个 `Promise` 对象。生成器函数内部通过 `yield` 暂停执行，等待 `Promise` 解决，然后 `co` 库会自动恢复执行。\n\n### 对比\n\n有了前面的铺垫，这里做个对比：\n\n```jsx\n// async/await\nasync function fetchData() {\n  const data = await fetch('some-url');\n  console.log(data);\n}\n\n// generator + co\nfunction fetchData() {\n  return co(function* () {\n    const data = yield fetch('some-url');\n    console.log(data);\n  });\n}\n```\n\n一目了然，在语法结构层面，你只需要去除 `co`，然后将 `*` 替换为 `async`，`yield` 替换为 `await` 即可。既然 `async` 是对 `generator` 的封装，那肯定做了一些优化，主要体现在以下四点：\n\n1. 内置执行器，无需使用额外的 `co` 库，也不需要手动指定 `.next()`；\n2.  语义性好，代码更简洁；\n3. 适用性广泛，`await`命令后面，可以是 Promise 对象和原始类型的值，没有了 `yield` 的限制；\n4. 返回值为 Promise，可以使用 `.then` 等语法，更方便。\n\n> `async` 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 `await` 命令就是内部 `then` 命令的语法糖。\n> \n\n## 使用\n\n### async 语法\n\n使用 `async` 关键字可以声明一个异步函数（async function），这种函数会返回一个 `Promise` 对象。如果函数体内有返回值，那么这个值会被 `Promise.resolve()` 包装。如果函数抛出错误，则会被 `Promise.reject()` 包装。\n\n```jsx\nasync function f() {\n  return \"Hello, World!\";\n}\n\nf().then(alert); // \"Hello, World!\"\n```\n\n### await 语法\n\n`await` 关键字用于等待一个 `Promise` 完成（fulfilled）或拒绝（rejected）。它只能在异步函数内部使用。当 `await` 表达式暂停执行异步函数时，它会等待 `Promise` 解决，然后恢复异步函数的执行并返回解决的值。\n\n```jsx\nasync function f3() {\n  let promise = new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"完成!\"), 1000)\n  });\n\n  let result = await promise; // 等待直到 promise 解决 (*)\n\n  alert(result); // \"完成!\"\n}\n```\n\n### 错误处理\n\n`async` 异步编程错误处理的姿势比较多，比较推荐的是老老实实使用 `try...catch...`，虽然这可能造成有些情况下难以找到具体错误代码（比如 `await` 被嵌套在其他操作中）。\n\n另一种方案是在 `await` 之后使用 `catch()` 块捕获错误，也可以，但会造成代码风格上的冲突。\n\n此外，还有一种有趣的 Golang 代码风格的错误处理方式。我们可以通过创建一个包装函数来模拟这种行为，这个函数接受一个 **`Promise`** 并返回一个包含两个值的数组：一个错误和一个结果，这样我们就可以使用数组解构来同时获取错误和结果，而不需要使用 **`try...catch...`** 块。这种方法使得错误处理更加显式。\n\n下面是一个实现这种错误处理的示范：\n\n```jsx\n// 'to' 函数用于转换 Promise，以便它返回一个包含错误和结果的数组\nfunction to(promise) {\n  return promise\n    .then(data => [null, data])\n    .catch(err => [err]);\n}\n\n// 异步函数使用 'to' 函数和 'await' 来处理 fetch 请求\nasync function fetchUrl(url) {\n  const [err, response] = await to(fetch(url));\n  if (err) {\n    console.error('Fetch error:', err);\n    return;\n  }\n  const [parseErr, data] = await to(response.json());\n  if (parseErr) {\n    console.error('JSON parsing error:', parseErr);\n    return;\n  }\n  console.log('Fetched data:', data);\n}\n```\n\n### 示范\n\n模拟用户登录流程，流程看注释：\n\n```jsx\n// 假设我们有一个用于请求用户数据的函数\nfunction getUser(username) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (username === 'Alice') {\n        resolve({ id: 1, username: 'Alice', verified: true });\n      } else {\n        reject(new Error('用户不存在'));\n      }\n    }, 1000);\n  });\n}\n\n// 假设我们有另一个函数用于验证用户\nfunction verifyUser(user) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (user.verified) {\n        resolve('用户验证成功');\n      } else {\n        reject(new Error('用户验证失败'));\n      }\n    }, 1000);\n  });\n}\n\n// 使用 async/await 和 .then().catch() 结合处理登录流程\nasync function loginUser(username) {\n  try {\n    // 使用 await 等待 getUser 函数解决\n    const user = await getUser(username);\n    // 使用 await 等待 verifyUser 函数解决\n    const verificationStatus = await verifyUser(user);\n    console.log(verificationStatus);\n  } catch (error) {\n    // 处理任何在 getUser 或 verifyUser 中抛出的错误\n    console.error(error.message);\n  }\n}\n\n// 调用 loginUser 函数，并使用 .then().catch() 处理最终结果\nloginUser('Alice')\n  .then(() => {\n    console.log('登录流程完成');\n  })\n  .catch((error) => {\n    console.error('登录流程中发生错误:', error.message);\n  })\n```\n\n实际处理异步操作就套用这个 combo。此外还有一些使用时的注意点，这里也做补充：\n\n1. 多个 `await` 之间如果不存在继发关系，用 `Promise.all()` 统一处理，避免额外耗时；\n2. `async` 函数保留运行栈。\n\n最后一条特性需要个小例子来解释：\n\n```jsx\n// b() 执行时 a() 同步执行，若 b() or c() 报错，错误堆栈可能不包括 a()\nconst a = () => {\n  b().then(() => c());\n};\n\n// b() 执行时 a() 暂停执行，上下文保留，b() or c() 报错，错误堆栈一定包括 a()\nconst a = async () => {\n  await b();\n  c();\n};\n```\n\n### 实例：顺序完成异步加载\n\n`async` 内部的多个 `await` 使继发执行的，如果这些异步操作没有相互依赖，这种特性会降低运行效率，所以我们可以使用以下代码并发发出请求，然后顺序获得结果：\n\n> 代码案例来自阅读文档1\n> \n\n```jsx\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```\n\n## 顶层 await\n\n除了在 `async` 代码块中，我们也可以在模块的顶层代码中使用 **`await`** 关键字。\n\n当模块需要在执行任何其他代码之前完成某些异步操作，如数据加载、资源配置等，或者当一个模块依赖于另一个异步解析的模块时，可以使用顶层 **`await`** 确保所有依赖都已正确加载。\n\n```jsx\n// config.js\nexport async function loadConfig() {\n  const response = await fetch('/config.json');\n  if (!response.ok) {\n    throw new Error('配置加载失败');\n  }\n  return response.json();\n}\n```\n\n```jsx\n// main.js\nimport { loadConfig } from './config.js';\n\nlet config;\n\ntry {\n\t// 使用顶层 await 确保配置在继续之前被加载\n  config = await loadConfig();\n} catch (error) {\n  console.error('无法加载配置:', error);\n}\n\napplyConfig(config);\n```\n\n这种写法有个显而易见的好处——我们不需要在主程序中再额外包裹一层 `async`，而且虽然操作是异步的，但顶层 **`await`** 使得代码的读写更像是同步操作，易于理解和维护。\n\n同时，这种写法也确保了服务的可靠性。如果开发者单纯写一个脚本，然后在主模块中同步加载这个脚本，则很难控制异步操作的结果，因为主模块没法控制异步操作是否完成，以下面的代码为例，usage.js 无法确保自己获得了一个合理的 output 还是一个 `undefined`。\n\n> 代码案例来自阅读文档1\n> \n\n```jsx\n// awaiting.js\nlet output;\nasync function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n}\nmain();\nexport { output };\n```\n\n```jsx\n// usage.js\nimport { output } from \"./awaiting.js\";\n\nfunction outputPlusValue(value) { return output + value }\n\nconsole.log(outputPlusValue(100));\nsetTimeout(() => console.log(outputPlusValue(100)), 1000);\n```\n\n旧版的解决方法是让 awaiting.js 返回一个 Promise 对象，通过这个 Promise 对象判断异步操作是否结束。\n\n> 代码案例来自阅读文档1\n> \n\n```jsx\n// awaiting.js\nlet output;\nexport default (async function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n})();\nexport { output };\n```\n\n```jsx\n// usage.js\nimport promise, { output } from \"./awaiting.js\";\n\nfunction outputPlusValue(value) { return output + value }\n\npromise.then(() => {\n  console.log(outputPlusValue(100));\n  setTimeout(() => console.log(outputPlusValue(100)), 1000);\n});\n```\n\n这种写法虽然保证了数据的可靠性，但使代码变得臃肿，开发者必需时刻记得在调用这个子模块时要使用 Promise 加载，并且所有依赖这个子模块的模块都需要使用 Promise 加载，一层层地套回去了。而顶层 await 就直接解决了这个问题。\n\n## 小坑\n\n### 混用 `await` 和 `.then()`\n\n这是一种不被推荐的做法。\n\n如果你在一个 **`async`** 函数中使用 **`await`**，然后在同一个 **`await`** 调用后面紧接着使用 **`.then()`**，这可能会让人困惑，因为它混合了两种不同的风格，使代码的意图不够清晰。\n\n```jsx\nasync function fetchData() {\n  const data = await fetch('some-api-url')\n    .then(response => response.json())\n    .catch(error => console.error('Error:', error));\n  return data;\n}\n\n```\n\n业务逻辑明确的话，代码不会给你一拳，但其他开发者会给你一拳。\n\n## 阅读文档\n\n1. https://es6.ruanyifeng.com/#docs/async\n2. https://www.cnblogs.com/porter/p/13343524.html","slug":"async_await","published":1,"updated":"2024-06-11T13:01:49.300Z","comments":1,"layout":"post","photos":[],"_id":"clxhruaot0001f4ly6lskhpxg","content":"<p><code>async/await</code> 是 JavaScript 用来处理异步操作的语法。它们建立在 Promise 的基础上，提供了一种简洁直观的方式来编写和管理异步代码，现在也已经成为了 JavaScript 实际上的最佳异步编程方案。</p>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><p><code>async</code> 实质上就是早期的 <code>generator</code> 函数的语法糖。</p>\n<p>JavaScript 中的生成器（Generator）函数是 ES6 引入（与 Promise 一起）的一种特殊类型的函数。生成器这个概念最初来自于其他编程语言，如 Python，把这东西引入到 JavaScript 中，主要是为了简化异步编程和迭代操作。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>generator</code> 函数的本质是一种可以暂停执行和恢复执行的函数，它返回一个遵循迭代器协议的生成器对象（即 <code>Iterator</code> 对象）。这个对象通过 <code>next()</code> 方法进行迭代，每次调用 <code>next()</code> 都会执行到下一个 <code>yield</code> 表达式，并返回一个包含 <code>value</code> 和 <code>done</code> 属性的对象，其中 <code>value</code> 表示返回的值，<code>done</code> 表示是否完成所有迭代。</p>\n<p><code>yield</code> ****表达式是暂停、恢复执行的关键。在生成器函数体内，使用 <code>yield</code> 表达式来暂停函数的执行，并返回一个值到生成器外部。当外部代码再次调用生成器的 <code>next()</code> 方法时，生成器函数会从上次暂停的地方继续执行。</p>\n<p>语法也比较简单，可以看看以下示范：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">numberGen3erator</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"title function_\">numberGenerator</span>(); <span class=\"comment\">// 调用生成器函数创建生成器对象</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>看到这语法结构，你可能会感到熟悉，稍后再说。</p>\n<h3 id=\"co\"><a href=\"#co\" class=\"headerlink\" title=\"co\"></a>co</h3><p>既然介绍 <code>generator</code> 和 <code>async</code> 的关系，那就要说到 <code>co</code>。</p>\n<p><code>co</code> 库是一个用于 Node.js 和浏览器的 JavaScript 库，由 TJ Holowaychuk 开发。它基于 <code>generator</code> 来控制异步流程，允许开发者以一种看起来几乎像同步代码的方式来编写非阻塞的异步代码。<code>co</code> 库的核心功能是自动执行生成器函数，处理 <code>yield</code> 关键字后面跟随的任何 <code>Promise</code> 对象，并在 <code>Promise</code> 解决后继续执行生成器函数。</p>\n<ul>\n<li><strong><code>co</code></strong> 库可以将生成器函数转换为返回 <strong><code>Promise</code></strong> 对象的函数。</li>\n<li>它支持 <strong><code>yield</code></strong> 关键字后面跟随的 <strong><code>Promise</code></strong> 对象、Thunk 函数、数组（并行执行）、对象（并行执行）、生成器和生成器函数（委托）。</li>\n<li><strong><code>co</code></strong> 库的使用前提是生成器函数的 <strong><code>yield</code></strong> 命令后面只能是 Thunk 函数或 <strong><code>Promise</code></strong> 对象。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;co&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">co</span>(<span class=\"keyword\">function</span>* () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，<code>co</code> 函数接受一个 <code>generator</code> 作为参数，并返回一个 <code>Promise</code> 对象。生成器函数内部通过 <code>yield</code> 暂停执行，等待 <code>Promise</code> 解决，然后 <code>co</code> 库会自动恢复执行。</p>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><p>有了前面的铺垫，这里做个对比：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async/await</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;some-url&#x27;</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// generator + co</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">co</span>(<span class=\"keyword\">function</span>* () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;some-url&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一目了然，在语法结构层面，你只需要去除 <code>co</code>，然后将 <code>*</code> 替换为 <code>async</code>，<code>yield</code> 替换为 <code>await</code> 即可。既然 <code>async</code> 是对 <code>generator</code> 的封装，那肯定做了一些优化，主要体现在以下四点：</p>\n<ol>\n<li>内置执行器，无需使用额外的 <code>co</code> 库，也不需要手动指定 <code>.next()</code>；</li>\n<li>语义性好，代码更简洁；</li>\n<li>适用性广泛，<code>await</code>命令后面，可以是 Promise 对象和原始类型的值，没有了 <code>yield</code> 的限制；</li>\n<li>返回值为 Promise，可以使用 <code>.then</code> 等语法，更方便。</li>\n</ol>\n<blockquote>\n<p><code>async</code> 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 <code>await</code> 命令就是内部 <code>then</code> 命令的语法糖。</p>\n</blockquote>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"async-语法\"><a href=\"#async-语法\" class=\"headerlink\" title=\"async 语法\"></a>async 语法</h3><p>使用 <code>async</code> 关键字可以声明一个异步函数（async function），这种函数会返回一个 <code>Promise</code> 对象。如果函数体内有返回值，那么这个值会被 <code>Promise.resolve()</code> 包装。如果函数抛出错误，则会被 <code>Promise.reject()</code> 包装。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, World!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>().<span class=\"title function_\">then</span>(alert); <span class=\"comment\">// &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"await-语法\"><a href=\"#await-语法\" class=\"headerlink\" title=\"await 语法\"></a>await 语法</h3><p><code>await</code> 关键字用于等待一个 <code>Promise</code> 完成（fulfilled）或拒绝（rejected）。它只能在异步函数内部使用。当 <code>await</code> 表达式暂停执行异步函数时，它会等待 <code>Promise</code> 解决，然后恢复异步函数的执行并返回解决的值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f3</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;完成!&quot;</span>), <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> promise; <span class=\"comment\">// 等待直到 promise 解决 (*)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">alert</span>(result); <span class=\"comment\">// &quot;完成!&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p><code>async</code> 异步编程错误处理的姿势比较多，比较推荐的是老老实实使用 <code>try...catch...</code>，虽然这可能造成有些情况下难以找到具体错误代码（比如 <code>await</code> 被嵌套在其他操作中）。</p>\n<p>另一种方案是在 <code>await</code> 之后使用 <code>catch()</code> 块捕获错误，也可以，但会造成代码风格上的冲突。</p>\n<p>此外，还有一种有趣的 Golang 代码风格的错误处理方式。我们可以通过创建一个包装函数来模拟这种行为，这个函数接受一个 <strong><code>Promise</code></strong> 并返回一个包含两个值的数组：一个错误和一个结果，这样我们就可以使用数组解构来同时获取错误和结果，而不需要使用 <strong><code>try...catch...</code></strong> 块。这种方法使得错误处理更加显式。</p>\n<p>下面是一个实现这种错误处理的示范：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#x27;to&#x27; 函数用于转换 Promise，以便它返回一个包含错误和结果的数组</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">to</span>(<span class=\"params\">promise</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> [<span class=\"literal\">null</span>, data])</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> [err]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步函数使用 &#x27;to&#x27; 函数和 &#x27;await&#x27; 来处理 fetch 请求</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchUrl</span>(<span class=\"params\">url</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [err, response] = <span class=\"keyword\">await</span> <span class=\"title function_\">to</span>(<span class=\"title function_\">fetch</span>(url));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Fetch error:&#x27;</span>, err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [parseErr, data] = <span class=\"keyword\">await</span> <span class=\"title function_\">to</span>(response.<span class=\"title function_\">json</span>());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parseErr) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;JSON parsing error:&#x27;</span>, parseErr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Fetched data:&#x27;</span>, data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"示范\"><a href=\"#示范\" class=\"headerlink\" title=\"示范\"></a>示范</h3><p>模拟用户登录流程，流程看注释：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设我们有一个用于请求用户数据的函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getUser</span>(<span class=\"params\">username</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (username === <span class=\"string\">&#x27;Alice&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">username</span>: <span class=\"string\">&#x27;Alice&#x27;</span>, <span class=\"attr\">verified</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;用户不存在&#x27;</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设我们有另一个函数用于验证用户</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">verifyUser</span>(<span class=\"params\">user</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (user.<span class=\"property\">verified</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(<span class=\"string\">&#x27;用户验证成功&#x27;</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;用户验证失败&#x27;</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 async/await 和 .then().catch() 结合处理登录流程</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">loginUser</span>(<span class=\"params\">username</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 await 等待 getUser 函数解决</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> <span class=\"title function_\">getUser</span>(username);</span><br><span class=\"line\">    <span class=\"comment\">// 使用 await 等待 verifyUser 函数解决</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> verificationStatus = <span class=\"keyword\">await</span> <span class=\"title function_\">verifyUser</span>(user);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(verificationStatus);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理任何在 getUser 或 verifyUser 中抛出的错误</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error.<span class=\"property\">message</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 loginUser 函数，并使用 .then().catch() 处理最终结果</span></span><br><span class=\"line\"><span class=\"title function_\">loginUser</span>(<span class=\"string\">&#x27;Alice&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;登录流程完成&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;登录流程中发生错误:&#x27;</span>, error.<span class=\"property\">message</span>);</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>实际处理异步操作就套用这个 combo。此外还有一些使用时的注意点，这里也做补充：</p>\n<ol>\n<li>多个 <code>await</code> 之间如果不存在继发关系，用 <code>Promise.all()</code> 统一处理，避免额外耗时；</li>\n<li><code>async</code> 函数保留运行栈。</li>\n</ol>\n<p>最后一条特性需要个小例子来解释：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// b() 执行时 a() 同步执行，若 b() or c() 报错，错误堆栈可能不包括 a()</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">a</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title function_\">b</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">c</span>());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b() 执行时 a() 暂停执行，上下文保留，b() or c() 报错，错误堆栈一定包括 a()</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">a</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">b</span>();</span><br><span class=\"line\">  <span class=\"title function_\">c</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例：顺序完成异步加载\"><a href=\"#实例：顺序完成异步加载\" class=\"headerlink\" title=\"实例：顺序完成异步加载\"></a>实例：顺序完成异步加载</h3><p><code>async</code> 内部的多个 <code>await</code> 使继发执行的，如果这些异步操作没有相互依赖，这种特性会降低运行效率，所以我们可以使用以下代码并发发出请求，然后顺序获得结果：</p>\n<blockquote>\n<p>代码案例来自阅读文档1</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">logInOrder</span>(<span class=\"params\">urls</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.<span class=\"title function_\">map</span>(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.<span class=\"title function_\">text</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"顶层-await\"><a href=\"#顶层-await\" class=\"headerlink\" title=\"顶层 await\"></a>顶层 await</h2><p>除了在 <code>async</code> 代码块中，我们也可以在模块的顶层代码中使用 <strong><code>await</code></strong> 关键字。</p>\n<p>当模块需要在执行任何其他代码之前完成某些异步操作，如数据加载、资源配置等，或者当一个模块依赖于另一个异步解析的模块时，可以使用顶层 <strong><code>await</code></strong> 确保所有依赖都已正确加载。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">loadConfig</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/config.json&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!response.<span class=\"property\">ok</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;配置加载失败&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; loadConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./config.js&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 使用顶层 await 确保配置在继续之前被加载</span></span><br><span class=\"line\">  config = <span class=\"keyword\">await</span> <span class=\"title function_\">loadConfig</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;无法加载配置:&#x27;</span>, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">applyConfig</span>(config);</span><br></pre></td></tr></table></figure>\n\n<p>这种写法有个显而易见的好处——我们不需要在主程序中再额外包裹一层 <code>async</code>，而且虽然操作是异步的，但顶层 <strong><code>await</code></strong> 使得代码的读写更像是同步操作，易于理解和维护。</p>\n<p>同时，这种写法也确保了服务的可靠性。如果开发者单纯写一个脚本，然后在主模块中同步加载这个脚本，则很难控制异步操作的结果，因为主模块没法控制异步操作是否完成，以下面的代码为例，usage.js 无法确保自己获得了一个合理的 output 还是一个 <code>undefined</code>。</p>\n<blockquote>\n<p>代码案例来自阅读文档1</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  output = <span class=\"title function_\">someProcess</span>(dynamic.<span class=\"property\">default</span>, data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">main</span>();</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./awaiting.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outputPlusValue</span>(<span class=\"params\">value</span>) &#123; <span class=\"keyword\">return</span> output + value &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">outputPlusValue</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">outputPlusValue</span>(<span class=\"number\">100</span>)), <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>旧版的解决方法是让 awaiting.js 返回一个 Promise 对象，通过这个 Promise 对象判断异步操作是否结束。</p>\n<blockquote>\n<p>代码案例来自阅读文档1</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (<span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  output = <span class=\"title function_\">someProcess</span>(dynamic.<span class=\"property\">default</span>, data);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> promise, &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./awaiting.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outputPlusValue</span>(<span class=\"params\">value</span>) &#123; <span class=\"keyword\">return</span> output + value &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">outputPlusValue</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">outputPlusValue</span>(<span class=\"number\">100</span>)), <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这种写法虽然保证了数据的可靠性，但使代码变得臃肿，开发者必需时刻记得在调用这个子模块时要使用 Promise 加载，并且所有依赖这个子模块的模块都需要使用 Promise 加载，一层层地套回去了。而顶层 await 就直接解决了这个问题。</p>\n<h2 id=\"小坑\"><a href=\"#小坑\" class=\"headerlink\" title=\"小坑\"></a>小坑</h2><h3 id=\"混用-await-和-then\"><a href=\"#混用-await-和-then\" class=\"headerlink\" title=\"混用 await 和 .then()\"></a>混用 <code>await</code> 和 <code>.then()</code></h3><p>这是一种不被推荐的做法。</p>\n<p>如果你在一个 <strong><code>async</code></strong> 函数中使用 **<code>await</code>**，然后在同一个 <strong><code>await</code></strong> 调用后面紧接着使用 **<code>.then()</code>**，这可能会让人困惑，因为它混合了两种不同的风格，使代码的意图不够清晰。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;some-api-url&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Error:&#x27;</span>, error));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>业务逻辑明确的话，代码不会给你一拳，但其他开发者会给你一拳。</p>\n<h2 id=\"阅读文档\"><a href=\"#阅读文档\" class=\"headerlink\" title=\"阅读文档\"></a>阅读文档</h2><ol>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/async\">https://es6.ruanyifeng.com/#docs/async</a></li>\n<li><a href=\"https://www.cnblogs.com/porter/p/13343524.html\">https://www.cnblogs.com/porter/p/13343524.html</a></li>\n</ol>\n","excerpt":"","more":"<p><code>async/await</code> 是 JavaScript 用来处理异步操作的语法。它们建立在 Promise 的基础上，提供了一种简洁直观的方式来编写和管理异步代码，现在也已经成为了 JavaScript 实际上的最佳异步编程方案。</p>\n<h2 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h2><p><code>async</code> 实质上就是早期的 <code>generator</code> 函数的语法糖。</p>\n<p>JavaScript 中的生成器（Generator）函数是 ES6 引入（与 Promise 一起）的一种特殊类型的函数。生成器这个概念最初来自于其他编程语言，如 Python，把这东西引入到 JavaScript 中，主要是为了简化异步编程和迭代操作。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>generator</code> 函数的本质是一种可以暂停执行和恢复执行的函数，它返回一个遵循迭代器协议的生成器对象（即 <code>Iterator</code> 对象）。这个对象通过 <code>next()</code> 方法进行迭代，每次调用 <code>next()</code> 都会执行到下一个 <code>yield</code> 表达式，并返回一个包含 <code>value</code> 和 <code>done</code> 属性的对象，其中 <code>value</code> 表示返回的值，<code>done</code> 表示是否完成所有迭代。</p>\n<p><code>yield</code> ****表达式是暂停、恢复执行的关键。在生成器函数体内，使用 <code>yield</code> 表达式来暂停函数的执行，并返回一个值到生成器外部。当外部代码再次调用生成器的 <code>next()</code> 方法时，生成器函数会从上次暂停的地方继续执行。</p>\n<p>语法也比较简单，可以看看以下示范：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span>* <span class=\"title function_\">numberGen3erator</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"title function_\">numberGenerator</span>(); <span class=\"comment\">// 调用生成器函数创建生成器对象</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(gen.<span class=\"title function_\">next</span>().<span class=\"property\">value</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<p>看到这语法结构，你可能会感到熟悉，稍后再说。</p>\n<h3 id=\"co\"><a href=\"#co\" class=\"headerlink\" title=\"co\"></a>co</h3><p>既然介绍 <code>generator</code> 和 <code>async</code> 的关系，那就要说到 <code>co</code>。</p>\n<p><code>co</code> 库是一个用于 Node.js 和浏览器的 JavaScript 库，由 TJ Holowaychuk 开发。它基于 <code>generator</code> 来控制异步流程，允许开发者以一种看起来几乎像同步代码的方式来编写非阻塞的异步代码。<code>co</code> 库的核心功能是自动执行生成器函数，处理 <code>yield</code> 关键字后面跟随的任何 <code>Promise</code> 对象，并在 <code>Promise</code> 解决后继续执行生成器函数。</p>\n<ul>\n<li><strong><code>co</code></strong> 库可以将生成器函数转换为返回 <strong><code>Promise</code></strong> 对象的函数。</li>\n<li>它支持 <strong><code>yield</code></strong> 关键字后面跟随的 <strong><code>Promise</code></strong> 对象、Thunk 函数、数组（并行执行）、对象（并行执行）、生成器和生成器函数（委托）。</li>\n<li><strong><code>co</code></strong> 库的使用前提是生成器函数的 <strong><code>yield</code></strong> 命令后面只能是 Thunk 函数或 <strong><code>Promise</code></strong> 对象。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;co&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">co</span>(<span class=\"keyword\">function</span>* () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，<code>co</code> 函数接受一个 <code>generator</code> 作为参数，并返回一个 <code>Promise</code> 对象。生成器函数内部通过 <code>yield</code> 暂停执行，等待 <code>Promise</code> 解决，然后 <code>co</code> 库会自动恢复执行。</p>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><p>有了前面的铺垫，这里做个对比：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async/await</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;some-url&#x27;</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// generator + co</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">co</span>(<span class=\"keyword\">function</span>* () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">yield</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;some-url&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一目了然，在语法结构层面，你只需要去除 <code>co</code>，然后将 <code>*</code> 替换为 <code>async</code>，<code>yield</code> 替换为 <code>await</code> 即可。既然 <code>async</code> 是对 <code>generator</code> 的封装，那肯定做了一些优化，主要体现在以下四点：</p>\n<ol>\n<li>内置执行器，无需使用额外的 <code>co</code> 库，也不需要手动指定 <code>.next()</code>；</li>\n<li>语义性好，代码更简洁；</li>\n<li>适用性广泛，<code>await</code>命令后面，可以是 Promise 对象和原始类型的值，没有了 <code>yield</code> 的限制；</li>\n<li>返回值为 Promise，可以使用 <code>.then</code> 等语法，更方便。</li>\n</ol>\n<blockquote>\n<p><code>async</code> 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 <code>await</code> 命令就是内部 <code>then</code> 命令的语法糖。</p>\n</blockquote>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"async-语法\"><a href=\"#async-语法\" class=\"headerlink\" title=\"async 语法\"></a>async 语法</h3><p>使用 <code>async</code> 关键字可以声明一个异步函数（async function），这种函数会返回一个 <code>Promise</code> 对象。如果函数体内有返回值，那么这个值会被 <code>Promise.resolve()</code> 包装。如果函数抛出错误，则会被 <code>Promise.reject()</code> 包装。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, World!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>().<span class=\"title function_\">then</span>(alert); <span class=\"comment\">// &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"await-语法\"><a href=\"#await-语法\" class=\"headerlink\" title=\"await 语法\"></a>await 语法</h3><p><code>await</code> 关键字用于等待一个 <code>Promise</code> 完成（fulfilled）或拒绝（rejected）。它只能在异步函数内部使用。当 <code>await</code> 表达式暂停执行异步函数时，它会等待 <code>Promise</code> 解决，然后恢复异步函数的执行并返回解决的值。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f3</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;完成!&quot;</span>), <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> promise; <span class=\"comment\">// 等待直到 promise 解决 (*)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">alert</span>(result); <span class=\"comment\">// &quot;完成!&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p><code>async</code> 异步编程错误处理的姿势比较多，比较推荐的是老老实实使用 <code>try...catch...</code>，虽然这可能造成有些情况下难以找到具体错误代码（比如 <code>await</code> 被嵌套在其他操作中）。</p>\n<p>另一种方案是在 <code>await</code> 之后使用 <code>catch()</code> 块捕获错误，也可以，但会造成代码风格上的冲突。</p>\n<p>此外，还有一种有趣的 Golang 代码风格的错误处理方式。我们可以通过创建一个包装函数来模拟这种行为，这个函数接受一个 <strong><code>Promise</code></strong> 并返回一个包含两个值的数组：一个错误和一个结果，这样我们就可以使用数组解构来同时获取错误和结果，而不需要使用 <strong><code>try...catch...</code></strong> 块。这种方法使得错误处理更加显式。</p>\n<p>下面是一个实现这种错误处理的示范：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#x27;to&#x27; 函数用于转换 Promise，以便它返回一个包含错误和结果的数组</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">to</span>(<span class=\"params\">promise</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> [<span class=\"literal\">null</span>, data])</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> [err]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步函数使用 &#x27;to&#x27; 函数和 &#x27;await&#x27; 来处理 fetch 请求</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchUrl</span>(<span class=\"params\">url</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [err, response] = <span class=\"keyword\">await</span> <span class=\"title function_\">to</span>(<span class=\"title function_\">fetch</span>(url));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Fetch error:&#x27;</span>, err);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [parseErr, data] = <span class=\"keyword\">await</span> <span class=\"title function_\">to</span>(response.<span class=\"title function_\">json</span>());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parseErr) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;JSON parsing error:&#x27;</span>, parseErr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Fetched data:&#x27;</span>, data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"示范\"><a href=\"#示范\" class=\"headerlink\" title=\"示范\"></a>示范</h3><p>模拟用户登录流程，流程看注释：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设我们有一个用于请求用户数据的函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getUser</span>(<span class=\"params\">username</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (username === <span class=\"string\">&#x27;Alice&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">username</span>: <span class=\"string\">&#x27;Alice&#x27;</span>, <span class=\"attr\">verified</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;用户不存在&#x27;</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设我们有另一个函数用于验证用户</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">verifyUser</span>(<span class=\"params\">user</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (user.<span class=\"property\">verified</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">resolve</span>(<span class=\"string\">&#x27;用户验证成功&#x27;</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"title function_\">reject</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;用户验证失败&#x27;</span>));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 async/await 和 .then().catch() 结合处理登录流程</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">loginUser</span>(<span class=\"params\">username</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 await 等待 getUser 函数解决</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> <span class=\"title function_\">getUser</span>(username);</span><br><span class=\"line\">    <span class=\"comment\">// 使用 await 等待 verifyUser 函数解决</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> verificationStatus = <span class=\"keyword\">await</span> <span class=\"title function_\">verifyUser</span>(user);</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(verificationStatus);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理任何在 getUser 或 verifyUser 中抛出的错误</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error.<span class=\"property\">message</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 loginUser 函数，并使用 .then().catch() 处理最终结果</span></span><br><span class=\"line\"><span class=\"title function_\">loginUser</span>(<span class=\"string\">&#x27;Alice&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;登录流程完成&#x27;</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;登录流程中发生错误:&#x27;</span>, error.<span class=\"property\">message</span>);</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>实际处理异步操作就套用这个 combo。此外还有一些使用时的注意点，这里也做补充：</p>\n<ol>\n<li>多个 <code>await</code> 之间如果不存在继发关系，用 <code>Promise.all()</code> 统一处理，避免额外耗时；</li>\n<li><code>async</code> 函数保留运行栈。</li>\n</ol>\n<p>最后一条特性需要个小例子来解释：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// b() 执行时 a() 同步执行，若 b() or c() 报错，错误堆栈可能不包括 a()</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">a</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title function_\">b</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">c</span>());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b() 执行时 a() 暂停执行，上下文保留，b() or c() 报错，错误堆栈一定包括 a()</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">a</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">b</span>();</span><br><span class=\"line\">  <span class=\"title function_\">c</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例：顺序完成异步加载\"><a href=\"#实例：顺序完成异步加载\" class=\"headerlink\" title=\"实例：顺序完成异步加载\"></a>实例：顺序完成异步加载</h3><p><code>async</code> 内部的多个 <code>await</code> 使继发执行的，如果这些异步操作没有相互依赖，这种特性会降低运行效率，所以我们可以使用以下代码并发发出请求，然后顺序获得结果：</p>\n<blockquote>\n<p>代码案例来自阅读文档1</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">logInOrder</span>(<span class=\"params\">urls</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.<span class=\"title function_\">map</span>(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.<span class=\"title function_\">text</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"顶层-await\"><a href=\"#顶层-await\" class=\"headerlink\" title=\"顶层 await\"></a>顶层 await</h2><p>除了在 <code>async</code> 代码块中，我们也可以在模块的顶层代码中使用 <strong><code>await</code></strong> 关键字。</p>\n<p>当模块需要在执行任何其他代码之前完成某些异步操作，如数据加载、资源配置等，或者当一个模块依赖于另一个异步解析的模块时，可以使用顶层 <strong><code>await</code></strong> 确保所有依赖都已正确加载。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// config.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">loadConfig</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/config.json&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!response.<span class=\"property\">ok</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;配置加载失败&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; loadConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./config.js&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> config;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 使用顶层 await 确保配置在继续之前被加载</span></span><br><span class=\"line\">  config = <span class=\"keyword\">await</span> <span class=\"title function_\">loadConfig</span>();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;无法加载配置:&#x27;</span>, error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">applyConfig</span>(config);</span><br></pre></td></tr></table></figure>\n\n<p>这种写法有个显而易见的好处——我们不需要在主程序中再额外包裹一层 <code>async</code>，而且虽然操作是异步的，但顶层 <strong><code>await</code></strong> 使得代码的读写更像是同步操作，易于理解和维护。</p>\n<p>同时，这种写法也确保了服务的可靠性。如果开发者单纯写一个脚本，然后在主模块中同步加载这个脚本，则很难控制异步操作的结果，因为主模块没法控制异步操作是否完成，以下面的代码为例，usage.js 无法确保自己获得了一个合理的 output 还是一个 <code>undefined</code>。</p>\n<blockquote>\n<p>代码案例来自阅读文档1</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output;</span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  output = <span class=\"title function_\">someProcess</span>(dynamic.<span class=\"property\">default</span>, data);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">main</span>();</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./awaiting.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outputPlusValue</span>(<span class=\"params\">value</span>) &#123; <span class=\"keyword\">return</span> output + value &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">outputPlusValue</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">outputPlusValue</span>(<span class=\"number\">100</span>)), <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>旧版的解决方法是让 awaiting.js 返回一个 Promise 对象，通过这个 Promise 对象判断异步操作是否结束。</p>\n<blockquote>\n<p>代码案例来自阅读文档1</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// awaiting.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> output;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (<span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dynamic = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(someMission);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  output = <span class=\"title function_\">someProcess</span>(dynamic.<span class=\"property\">default</span>, data);</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// usage.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> promise, &#123; output &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./awaiting.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">outputPlusValue</span>(<span class=\"params\">value</span>) &#123; <span class=\"keyword\">return</span> output + value &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">outputPlusValue</span>(<span class=\"number\">100</span>));</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">outputPlusValue</span>(<span class=\"number\">100</span>)), <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这种写法虽然保证了数据的可靠性，但使代码变得臃肿，开发者必需时刻记得在调用这个子模块时要使用 Promise 加载，并且所有依赖这个子模块的模块都需要使用 Promise 加载，一层层地套回去了。而顶层 await 就直接解决了这个问题。</p>\n<h2 id=\"小坑\"><a href=\"#小坑\" class=\"headerlink\" title=\"小坑\"></a>小坑</h2><h3 id=\"混用-await-和-then\"><a href=\"#混用-await-和-then\" class=\"headerlink\" title=\"混用 await 和 .then()\"></a>混用 <code>await</code> 和 <code>.then()</code></h3><p>这是一种不被推荐的做法。</p>\n<p>如果你在一个 <strong><code>async</code></strong> 函数中使用 **<code>await</code>**，然后在同一个 <strong><code>await</code></strong> 调用后面紧接着使用 **<code>.then()</code>**，这可能会让人困惑，因为它混合了两种不同的风格，使代码的意图不够清晰。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;some-api-url&#x27;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Error:&#x27;</span>, error));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>业务逻辑明确的话，代码不会给你一拳，但其他开发者会给你一拳。</p>\n<h2 id=\"阅读文档\"><a href=\"#阅读文档\" class=\"headerlink\" title=\"阅读文档\"></a>阅读文档</h2><ol>\n<li><a href=\"https://es6.ruanyifeng.com/#docs/async\">https://es6.ruanyifeng.com/#docs/async</a></li>\n<li><a href=\"https://www.cnblogs.com/porter/p/13343524.html\">https://www.cnblogs.com/porter/p/13343524.html</a></li>\n</ol>\n"},{"title":"浏览器中的 Event Loop","date":"2024-06-09T16:00:00.000Z","author":"ma5hr00m","_content":"\n事件循环是 JavaScript 管理事件执行顺序的流程，具体实现与运行环境有关。本篇文章主要讲述浏览器环境中的事件循环，Node.js 中的事件循环就简单说说分哪几个阶段。\n\n## 同步异步\n\n同步（Synchronous）执行指的是代码按顺序一行接一行地执行。每个操作必须等待前一个操作完成后才能开始。这种模式简单易懂，但它有一个缺点：如果一个操作需要很长时间来完成（例如，从服务器获取数据），它会阻塞后续代码的执行，导致整个程序暂停，直到该操作完成。这对于 Web 应用来说是无法忍受的，总不发出请求后一直等待所有数据全到手之后再渲染页面，这样搞用户的心情想必不会很美丽。\n\n异步（Asynchronous）执行允许代码在等待一个耗时任务（如数据请求）完成时继续执行其他任务。这是通过回调函数、Promises 或 async/await 等机制实现的。异步编程使得 JavaScript 可以同时处理多个操作，提高了程序的效率和用户体验。\n\n## 事件循环\n\n![20240610160305](https://img.ma5hr00m.top/blog/20240610160305.png)\n\n事件循环（Event Loop）是 JavaScript 中处理异步操作的核心机制。它确保即使在单线程环境中，JavaScript 也能够执行非阻塞操作。以下是事件循环的详细流程说明，看完这个就基本清晰异步操作的实现过程了：\n\n1. **执行栈（Execution Stack）：**所有同步任务都在主线程上的执行栈中运行。执行栈是一个按顺序存储函数调用的结构。当一个函数执行完毕，它就会从栈中弹出。\n2. **Web API：**当遇到异步任务（如 `setTimeout` 或网络请求）时，浏览器提供的 Web API 会接管这些任务，并在后台运行。\n3. **任务队列（Task Queue）：**异步任务完成后，回调函数会被放入任务队列。如果有多个回调，它们会按照它们被添加到队列的顺序排队。\n4. **事件循环（Event Loop—）：**事件循环持续检查执行栈是否为空。如果执行栈为空，事件循环会从任务队列中取出第一个回调函数，并将其推入执行栈中执行。\n5. **微任务队列（Microtask Queue）：**微任务（如 `Promise` 的回调）会被添加到微任务队列。微任务队列的特点是在当前执行栈清空后，事件循环会在执行下一个宏任务（如 `setTimeout` 的回调）之前，先执行所有微任务。\n6. **渲染 (Rendering)**: 在某些情况下，如页面渲染或用户交互，浏览器会在适当的时候执行渲染任务。\n\n这个过程不断重复，形成了一个循环，确保 JavaScript 可以连续处理任务，而不会阻塞主线程。这就是事件循环的工作原理，它使得即使是单线程的 JavaScript 也能够支持复杂的异步操作和高效的用户交互。\n\n## 宏任务微任务\n\n介绍事件循环时有提到宏任务和微任务，解宏任务（Macro Task）和微任务（Micro Task）对于掌握事件循环至关重要。这两种任务决定了代码的执行顺序和时机。\n\n### 本质区别\n\n**宏任务**是由宿主环境（如浏览器或 Node.js）发起的任务。它们通常包括：\n\n- **`setTimeout`**\n- **`setInterval`**\n- **`I/O`**\n- UI渲染\n- **`postMessage`**\n- **`MessageChannel`**\n\n**而微任务**则是由 JavaScript 引擎发起的任务，它们通常用于处理一些不需要长时间运行或等待的操作，如：\n\n- **`Promise.then`**\n- **`MutationObserver`**\n- **`process.nextTick`** （Node.js）\n\n宏任务和微任务的执行时机不同。在每次事件循环中，一个宏任务会被执行，然后所有的微任务会被执行。这意味着微任务总是在当前宏任务结束后立即执行，而不是等待下一个宏任务。\n\n这种区分允许 JavaScript 引擎优化异步操作的处理。通过微任务，JavaScript 可以快速响应并处理短暂的异步操作，而宏任务则用于可能需要更多时间来完成的操作。这种机制确保了即使在单线程环境中，JavaScript 也能够有效地处理复杂的异步场景。\n\n### 产生原因\n\n从前文事件循环的实现流程可以看出，宏任务和微任务的概念与其密切相关。事件循环是 JavaScript 早期就存在的机制，但微任务的概念是随着 ES6 规范的引入才明确的，特别是在引入`Promise`之后。`Promise`是在 ES6 中正式成为标准的，它允许 JavaScrip t引擎自身发起异步任务，而不仅仅依赖于宿主环境。\n\n这俩概念的提出是为了解决 JavaScript 在处理异步操作时的效率问题。在早期的 JavaScript 中，所有的异步操作都被视为宏任务，这导致了效率低下和响应性差的问题。通过引入微任务，JavaScript 能够更快地处理那些不需要等待的异步操作，从而提高了程序的整体性能。\n\n### 示范代码\n\n前文说得已经比较清楚了，这里再给个代码示范：\n\n```jsx\nconsole.log('宏任务开始');  \n\nsetTimeout(function() {\n  console.log('宏任务');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('微任务 1');\n}).then(function() {\n  console.log('微任务 2');\n});\n\nconsole.log('宏任务结束');\n```\n\n以上代码的输出如下，初学者可以思考下输出为什么是这个顺序：\n\n```bash\n宏任务开始\n宏任务结束\n微任务 1\n微任务 2\n宏任务\n```\n\n以下是这段代码运行时发生的事件顺序：\n\n1. 因为`console.log`是同步操作，所以首先会在控制台打印出`'宏任务开始'`；\n2. `setTimeout`是一个宏任务。尽管它设置了`0`毫秒的延迟，但它不会立即执行。它会被添加到宏任务队列中，在当前执行上下文清空并且所有微任务都被处理后执行；\n3. `Promise.resolve()`创建了一个已解决的promise，这是一个微任务。`.then`方法被链式调用来处理微任务。这些将被添加到微任务队列中，并且会在当前调用栈为空时立即执行，但在下一个宏任务之前；\n4. 接下来，因为是下一行同步代码，所以会在控制台打印出`'宏任务结束'`；\n5. 在当前宏任务（即整个脚本）执行完毕后，JavaScript引擎会检查是否有微任务在队列中。它找到了promise的`.then`方法中的回调，并按顺序执行它们。这导致控制台依次打印出`'微任务 1'`和`'微任务 2'`；\n6. 所有微任务完成后，引擎会检查宏任务队列。现在执行`setTimeout`的回调，控制台打印出`'宏任务'`。\n\n## 定时器不准确\n\n学到东西就要拿来解决问题，定时器不准确就算是一个经典问题。在 JavaScript 中，定时器的不准确性主要是由于事件循环的工作方式造成的。`setTimeout` 和 `setInterval` 这样的定时器函数并不保证回调函数会在指定的时间精确执行。**定时器只是在指定的延迟后将回调函数放入事件队列**，但实际上它何时被执行取决于主线程上当前正在执行的任务。\n\n当你设置一个定时器时，例如 `setTimeout(callback, 2000)`，你告诉 JavaScript 引擎在大约 2 秒后将 `callback` 放入事件队列。但是，如果主线程在执行长时间运行的同步任务，如你的 `syncFunc` 函数，它会阻塞线程，直到该任务完成。在这段时间内，即使定时器的时间已经过去，回调函数也不会执行，因为事件循环必须等待主线程变为空闲才能从事件队列中取出回调函数并执行它。\n\n下面是一个简化的事件循环流程，以帮助理解：\n\n1. **执行同步代码**：主线程首先执行所有同步代码。\n2. **设置定时器**：遇到 `setTimeout`，将其回调函数和计时请求交给定时器线程。\n3. **计时结束**：定时器线程计时结束后，通知事件触发线程。\n4. **排队等待**：事件触发线程将定时器回调放入事件队列。\n5. **检查主线程**：如果主线程空闲，事件循环将从事件队列中取出回调函数执行；如果主线程忙，回调函数必须等待。\n\n为了避免定时器不准确，开发者应该尽量避免在主线程上执行长时间的同步任务。如果必须执行这样的任务，可以考虑使用 Web Workers 或者将任务分解为更小的部分，使用 `requestAnimationFrame` 或 `requestIdleCallback` 来安排非紧急任务的执行。\n\n```jsx\n// 示例代码\nconst syncFunc = (startTime) => {\n  const time = new Date().getTime();\n  while (new Date().getTime() - time < 5000) { /* 长时间同步阻塞 */ }\n  const offset = new Date().getTime() - startTime;\n  console.log(`同步函数执行完毕，时间偏差：${offset}毫秒`);\n};\n\nconst asyncFunc = (startTime) => {\n  setTimeout(() => {\n    const offset = new Date().getTime() - startTime;\n    console.log(`异步函数执行完毕，时间偏差：${offset}毫秒`);\n  }, 2000);\n};\n\nconst startTime = new Date().getTime();\nasyncFunc(startTime);\nsyncFunc(startTime);\n\n```\n\n在上述代码中，`syncFunc` 会阻塞主线程5秒钟，即使 `asyncFunc` 的定时器在2秒后到期，它的回调也必须等待 `syncFunc` 完成。这就是为什么定时器的执行时间可能不准确。为了提高定时器的准确性，应当尽量减少同步代码的执行时间，或者使用其他机制来处理长时间运行的任务。\n\n## requestAnimationFrame & requestIdleCallback\n\n`requestAnimationFrame()` 和 `requestIdleCallback()` 是两个与浏览器事件循环和渲染过程紧密相关的 Web API。它们在不同的时间点被调用，以优化性能和响应性。`requestAnimationFrame()` 适合需要与屏幕刷新率同步的任务，如动画，而 `requestIdleCallback()` 适合可以推迟执行的任务，如统计和数据处理。\n\n### **requestAnimationFrame()**\n\n`requestAnimationFrame()` 主要用于动画和页面重绘之前的更新操作，它告诉浏览器你希望执行动画，并请求浏览器在下次重绘之前调用指定的函数来更新动画。函数通常在每次屏幕刷新之前执行，大约是每秒 60 次，但这会根据浏览器和设备的性能而变化。使用 `requestAnimationFrame()` 可以保证动画的流畅性，因为它是在浏览器准备好绘制新帧时执行。\n\n```jsx\n// 使用 requestAnimationFrame 请求动画帧\nfunction updateAnimation() {\n  // 更新动画的代码\n  // ...\n  requestAnimationFrame(updateAnimation);\n}\n\n// 开始动画\nrequestAnimationFrame(updateAnimation);\n```\n\n我之后准备出一些关于前端动效实现的文章，到时候细说这个 API，现在先给一个尽可能简单的示范。\n\n### **requestIdleCallback()**\n\n`requestIdleCallback()` 用于在主线程空闲时执行低优先级的任务，当事件循环空闲，并且没有其他脚本或渲染任务需要执行时，浏览器会调用通过 `requestIdleCallback()` 注册的回调函数。这个 API 的目的是在不影响性能和响应性的情况下，利用空闲时间执行后台和低优先级的工作，回调函数会接收一个 `IdleDeadline` 对象，提供了一个 `timeRemaining()` 方法，该方法可以告诉你当前帧中剩余多少时间可以用于执行代码。\n\n举一个相对贴近实际的例子，即如何在一个假想的大型电商网站中使用 **`requestIdleCallback()`** 来优化图片懒加载功能：\n\n```jsx\n// 假设有一个函数用于懒加载图片\nfunction lazyLoadImages(images) {\n  images.forEach(image => {\n    if (isInViewport(image)) {\n      loadImage(image);\n    }\n  });\n}\n\n// 使用 requestIdleCallback 来调度懒加载任务\nfunction scheduleLazyLoad(images) {\n  // 如果浏览器支持 requestIdleCallback，则使用它\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(deadline => {\n      while (deadline.timeRemaining() > 0 && images.length > 0) {\n        lazyLoadImages(images.splice(0, 2)); // 每次处理两个图片\n      }\n\n      // 如果还有图片未处理，继续调度\n      if (images.length > 0) {\n        scheduleLazyLoad(images);\n      }\n    });\n  } else {\n    // 如果浏览器不支持 requestIdleCallback，则回退到 setTimeout\n    setTimeout(() => lazyLoadImages(images), 0);\n  }\n}\n\n// 假设页面上有很多图片需要懒加载\nconst allImages = document.querySelectorAll('.lazy-load-image');\nscheduleLazyLoad(Array.from(allImages));\n```\n\n在这个示例中，`scheduleLazyLoad` 函数使用 `requestIdleCallback` 来安排图片的懒加载。它会检查浏览器是否支持 `requestIdleCallback`，如果支持，就使用它来在浏览器空闲时加载图片。每次回调函数被调用时，它会处理一小批图片，确保不会占用太多的主线程时间，从而不影响用户的交互体验。\n\n如果浏览器不支持 `requestIdleCallback`，则使用 `setTimeout` 作为回退方案。这样可以确保在所有浏览器中都能实现懒加载功能，同时在支持的浏览器中提供更好的性能。\n\n## Node.js 中的事件循环\n\n虽然用的都是 V8 引擎（暂且这么说），但因为使用场景和任务的不同，Node.js 的事件循环与浏览器中 JavaScript 原生的事件循环存在差异。\n\n从整体上来看，最显著的差异就是 Node.js 的事件循环分阶段，每个阶段都有一个 FIFO 队列，只有当队列的事件执行完或达到该阶段的上限时，才会进入下一个阶段。Node.js 会在每次事件循环之间检查是否在等待任何 I/O 或定时器，如果没有，则程序关闭退出，一次完整的 Node.js 事件循环包括以下几个阶段：\n\n- **timers 阶段**: 执行 `setTimeout()` 和 `setInterval()` 定时器的回调函数。\n- **pending callbacks 阶段**: 执行延迟到下一个循环迭代的 I/O 回调。\n- **idle, prepare 阶段**: 仅系统内部使用。\n- **poll 阶段**: 检索新的 I/O 事件; 执行与 I/O 相关的回调，几乎所有的异步操作都在这个阶段处理。\n- **check 阶段**: `setImmediate()` 的回调在这里执行。\n- **close callbacks 阶段**: 执行一些关闭的回调函数，如 `socket.on('close', ...)`。\n\n其中的 poll 阶段需要注意，如果 poll 队列执行完没有`setImmediate`但是有定时器到期，就会绕回去执行 timers 阶段。\n\n![20240610160523](https://img.ma5hr00m.top/blog/20240610160523.png)\n\n## 阅读文章\n\n- [請說明瀏覽器中的事件循環 (Event Loop)｜ExplainThis](https://www.explainthis.io/zh-hant/swe/what-is-event-loop)\n- [异步和EventLoop · 前端进阶](https://dennisgo.cn/Articles/JavaScript/AsyncAndEventLoop.html)","source":"_posts/browser_eventloop.md","raw":"---\ntitle: 浏览器中的 Event Loop\ndate: 2024/6/10\nauthor: ma5hr00m\ncategories:\n- JavaScript\n---\n\n事件循环是 JavaScript 管理事件执行顺序的流程，具体实现与运行环境有关。本篇文章主要讲述浏览器环境中的事件循环，Node.js 中的事件循环就简单说说分哪几个阶段。\n\n## 同步异步\n\n同步（Synchronous）执行指的是代码按顺序一行接一行地执行。每个操作必须等待前一个操作完成后才能开始。这种模式简单易懂，但它有一个缺点：如果一个操作需要很长时间来完成（例如，从服务器获取数据），它会阻塞后续代码的执行，导致整个程序暂停，直到该操作完成。这对于 Web 应用来说是无法忍受的，总不发出请求后一直等待所有数据全到手之后再渲染页面，这样搞用户的心情想必不会很美丽。\n\n异步（Asynchronous）执行允许代码在等待一个耗时任务（如数据请求）完成时继续执行其他任务。这是通过回调函数、Promises 或 async/await 等机制实现的。异步编程使得 JavaScript 可以同时处理多个操作，提高了程序的效率和用户体验。\n\n## 事件循环\n\n![20240610160305](https://img.ma5hr00m.top/blog/20240610160305.png)\n\n事件循环（Event Loop）是 JavaScript 中处理异步操作的核心机制。它确保即使在单线程环境中，JavaScript 也能够执行非阻塞操作。以下是事件循环的详细流程说明，看完这个就基本清晰异步操作的实现过程了：\n\n1. **执行栈（Execution Stack）：**所有同步任务都在主线程上的执行栈中运行。执行栈是一个按顺序存储函数调用的结构。当一个函数执行完毕，它就会从栈中弹出。\n2. **Web API：**当遇到异步任务（如 `setTimeout` 或网络请求）时，浏览器提供的 Web API 会接管这些任务，并在后台运行。\n3. **任务队列（Task Queue）：**异步任务完成后，回调函数会被放入任务队列。如果有多个回调，它们会按照它们被添加到队列的顺序排队。\n4. **事件循环（Event Loop—）：**事件循环持续检查执行栈是否为空。如果执行栈为空，事件循环会从任务队列中取出第一个回调函数，并将其推入执行栈中执行。\n5. **微任务队列（Microtask Queue）：**微任务（如 `Promise` 的回调）会被添加到微任务队列。微任务队列的特点是在当前执行栈清空后，事件循环会在执行下一个宏任务（如 `setTimeout` 的回调）之前，先执行所有微任务。\n6. **渲染 (Rendering)**: 在某些情况下，如页面渲染或用户交互，浏览器会在适当的时候执行渲染任务。\n\n这个过程不断重复，形成了一个循环，确保 JavaScript 可以连续处理任务，而不会阻塞主线程。这就是事件循环的工作原理，它使得即使是单线程的 JavaScript 也能够支持复杂的异步操作和高效的用户交互。\n\n## 宏任务微任务\n\n介绍事件循环时有提到宏任务和微任务，解宏任务（Macro Task）和微任务（Micro Task）对于掌握事件循环至关重要。这两种任务决定了代码的执行顺序和时机。\n\n### 本质区别\n\n**宏任务**是由宿主环境（如浏览器或 Node.js）发起的任务。它们通常包括：\n\n- **`setTimeout`**\n- **`setInterval`**\n- **`I/O`**\n- UI渲染\n- **`postMessage`**\n- **`MessageChannel`**\n\n**而微任务**则是由 JavaScript 引擎发起的任务，它们通常用于处理一些不需要长时间运行或等待的操作，如：\n\n- **`Promise.then`**\n- **`MutationObserver`**\n- **`process.nextTick`** （Node.js）\n\n宏任务和微任务的执行时机不同。在每次事件循环中，一个宏任务会被执行，然后所有的微任务会被执行。这意味着微任务总是在当前宏任务结束后立即执行，而不是等待下一个宏任务。\n\n这种区分允许 JavaScript 引擎优化异步操作的处理。通过微任务，JavaScript 可以快速响应并处理短暂的异步操作，而宏任务则用于可能需要更多时间来完成的操作。这种机制确保了即使在单线程环境中，JavaScript 也能够有效地处理复杂的异步场景。\n\n### 产生原因\n\n从前文事件循环的实现流程可以看出，宏任务和微任务的概念与其密切相关。事件循环是 JavaScript 早期就存在的机制，但微任务的概念是随着 ES6 规范的引入才明确的，特别是在引入`Promise`之后。`Promise`是在 ES6 中正式成为标准的，它允许 JavaScrip t引擎自身发起异步任务，而不仅仅依赖于宿主环境。\n\n这俩概念的提出是为了解决 JavaScript 在处理异步操作时的效率问题。在早期的 JavaScript 中，所有的异步操作都被视为宏任务，这导致了效率低下和响应性差的问题。通过引入微任务，JavaScript 能够更快地处理那些不需要等待的异步操作，从而提高了程序的整体性能。\n\n### 示范代码\n\n前文说得已经比较清楚了，这里再给个代码示范：\n\n```jsx\nconsole.log('宏任务开始');  \n\nsetTimeout(function() {\n  console.log('宏任务');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('微任务 1');\n}).then(function() {\n  console.log('微任务 2');\n});\n\nconsole.log('宏任务结束');\n```\n\n以上代码的输出如下，初学者可以思考下输出为什么是这个顺序：\n\n```bash\n宏任务开始\n宏任务结束\n微任务 1\n微任务 2\n宏任务\n```\n\n以下是这段代码运行时发生的事件顺序：\n\n1. 因为`console.log`是同步操作，所以首先会在控制台打印出`'宏任务开始'`；\n2. `setTimeout`是一个宏任务。尽管它设置了`0`毫秒的延迟，但它不会立即执行。它会被添加到宏任务队列中，在当前执行上下文清空并且所有微任务都被处理后执行；\n3. `Promise.resolve()`创建了一个已解决的promise，这是一个微任务。`.then`方法被链式调用来处理微任务。这些将被添加到微任务队列中，并且会在当前调用栈为空时立即执行，但在下一个宏任务之前；\n4. 接下来，因为是下一行同步代码，所以会在控制台打印出`'宏任务结束'`；\n5. 在当前宏任务（即整个脚本）执行完毕后，JavaScript引擎会检查是否有微任务在队列中。它找到了promise的`.then`方法中的回调，并按顺序执行它们。这导致控制台依次打印出`'微任务 1'`和`'微任务 2'`；\n6. 所有微任务完成后，引擎会检查宏任务队列。现在执行`setTimeout`的回调，控制台打印出`'宏任务'`。\n\n## 定时器不准确\n\n学到东西就要拿来解决问题，定时器不准确就算是一个经典问题。在 JavaScript 中，定时器的不准确性主要是由于事件循环的工作方式造成的。`setTimeout` 和 `setInterval` 这样的定时器函数并不保证回调函数会在指定的时间精确执行。**定时器只是在指定的延迟后将回调函数放入事件队列**，但实际上它何时被执行取决于主线程上当前正在执行的任务。\n\n当你设置一个定时器时，例如 `setTimeout(callback, 2000)`，你告诉 JavaScript 引擎在大约 2 秒后将 `callback` 放入事件队列。但是，如果主线程在执行长时间运行的同步任务，如你的 `syncFunc` 函数，它会阻塞线程，直到该任务完成。在这段时间内，即使定时器的时间已经过去，回调函数也不会执行，因为事件循环必须等待主线程变为空闲才能从事件队列中取出回调函数并执行它。\n\n下面是一个简化的事件循环流程，以帮助理解：\n\n1. **执行同步代码**：主线程首先执行所有同步代码。\n2. **设置定时器**：遇到 `setTimeout`，将其回调函数和计时请求交给定时器线程。\n3. **计时结束**：定时器线程计时结束后，通知事件触发线程。\n4. **排队等待**：事件触发线程将定时器回调放入事件队列。\n5. **检查主线程**：如果主线程空闲，事件循环将从事件队列中取出回调函数执行；如果主线程忙，回调函数必须等待。\n\n为了避免定时器不准确，开发者应该尽量避免在主线程上执行长时间的同步任务。如果必须执行这样的任务，可以考虑使用 Web Workers 或者将任务分解为更小的部分，使用 `requestAnimationFrame` 或 `requestIdleCallback` 来安排非紧急任务的执行。\n\n```jsx\n// 示例代码\nconst syncFunc = (startTime) => {\n  const time = new Date().getTime();\n  while (new Date().getTime() - time < 5000) { /* 长时间同步阻塞 */ }\n  const offset = new Date().getTime() - startTime;\n  console.log(`同步函数执行完毕，时间偏差：${offset}毫秒`);\n};\n\nconst asyncFunc = (startTime) => {\n  setTimeout(() => {\n    const offset = new Date().getTime() - startTime;\n    console.log(`异步函数执行完毕，时间偏差：${offset}毫秒`);\n  }, 2000);\n};\n\nconst startTime = new Date().getTime();\nasyncFunc(startTime);\nsyncFunc(startTime);\n\n```\n\n在上述代码中，`syncFunc` 会阻塞主线程5秒钟，即使 `asyncFunc` 的定时器在2秒后到期，它的回调也必须等待 `syncFunc` 完成。这就是为什么定时器的执行时间可能不准确。为了提高定时器的准确性，应当尽量减少同步代码的执行时间，或者使用其他机制来处理长时间运行的任务。\n\n## requestAnimationFrame & requestIdleCallback\n\n`requestAnimationFrame()` 和 `requestIdleCallback()` 是两个与浏览器事件循环和渲染过程紧密相关的 Web API。它们在不同的时间点被调用，以优化性能和响应性。`requestAnimationFrame()` 适合需要与屏幕刷新率同步的任务，如动画，而 `requestIdleCallback()` 适合可以推迟执行的任务，如统计和数据处理。\n\n### **requestAnimationFrame()**\n\n`requestAnimationFrame()` 主要用于动画和页面重绘之前的更新操作，它告诉浏览器你希望执行动画，并请求浏览器在下次重绘之前调用指定的函数来更新动画。函数通常在每次屏幕刷新之前执行，大约是每秒 60 次，但这会根据浏览器和设备的性能而变化。使用 `requestAnimationFrame()` 可以保证动画的流畅性，因为它是在浏览器准备好绘制新帧时执行。\n\n```jsx\n// 使用 requestAnimationFrame 请求动画帧\nfunction updateAnimation() {\n  // 更新动画的代码\n  // ...\n  requestAnimationFrame(updateAnimation);\n}\n\n// 开始动画\nrequestAnimationFrame(updateAnimation);\n```\n\n我之后准备出一些关于前端动效实现的文章，到时候细说这个 API，现在先给一个尽可能简单的示范。\n\n### **requestIdleCallback()**\n\n`requestIdleCallback()` 用于在主线程空闲时执行低优先级的任务，当事件循环空闲，并且没有其他脚本或渲染任务需要执行时，浏览器会调用通过 `requestIdleCallback()` 注册的回调函数。这个 API 的目的是在不影响性能和响应性的情况下，利用空闲时间执行后台和低优先级的工作，回调函数会接收一个 `IdleDeadline` 对象，提供了一个 `timeRemaining()` 方法，该方法可以告诉你当前帧中剩余多少时间可以用于执行代码。\n\n举一个相对贴近实际的例子，即如何在一个假想的大型电商网站中使用 **`requestIdleCallback()`** 来优化图片懒加载功能：\n\n```jsx\n// 假设有一个函数用于懒加载图片\nfunction lazyLoadImages(images) {\n  images.forEach(image => {\n    if (isInViewport(image)) {\n      loadImage(image);\n    }\n  });\n}\n\n// 使用 requestIdleCallback 来调度懒加载任务\nfunction scheduleLazyLoad(images) {\n  // 如果浏览器支持 requestIdleCallback，则使用它\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(deadline => {\n      while (deadline.timeRemaining() > 0 && images.length > 0) {\n        lazyLoadImages(images.splice(0, 2)); // 每次处理两个图片\n      }\n\n      // 如果还有图片未处理，继续调度\n      if (images.length > 0) {\n        scheduleLazyLoad(images);\n      }\n    });\n  } else {\n    // 如果浏览器不支持 requestIdleCallback，则回退到 setTimeout\n    setTimeout(() => lazyLoadImages(images), 0);\n  }\n}\n\n// 假设页面上有很多图片需要懒加载\nconst allImages = document.querySelectorAll('.lazy-load-image');\nscheduleLazyLoad(Array.from(allImages));\n```\n\n在这个示例中，`scheduleLazyLoad` 函数使用 `requestIdleCallback` 来安排图片的懒加载。它会检查浏览器是否支持 `requestIdleCallback`，如果支持，就使用它来在浏览器空闲时加载图片。每次回调函数被调用时，它会处理一小批图片，确保不会占用太多的主线程时间，从而不影响用户的交互体验。\n\n如果浏览器不支持 `requestIdleCallback`，则使用 `setTimeout` 作为回退方案。这样可以确保在所有浏览器中都能实现懒加载功能，同时在支持的浏览器中提供更好的性能。\n\n## Node.js 中的事件循环\n\n虽然用的都是 V8 引擎（暂且这么说），但因为使用场景和任务的不同，Node.js 的事件循环与浏览器中 JavaScript 原生的事件循环存在差异。\n\n从整体上来看，最显著的差异就是 Node.js 的事件循环分阶段，每个阶段都有一个 FIFO 队列，只有当队列的事件执行完或达到该阶段的上限时，才会进入下一个阶段。Node.js 会在每次事件循环之间检查是否在等待任何 I/O 或定时器，如果没有，则程序关闭退出，一次完整的 Node.js 事件循环包括以下几个阶段：\n\n- **timers 阶段**: 执行 `setTimeout()` 和 `setInterval()` 定时器的回调函数。\n- **pending callbacks 阶段**: 执行延迟到下一个循环迭代的 I/O 回调。\n- **idle, prepare 阶段**: 仅系统内部使用。\n- **poll 阶段**: 检索新的 I/O 事件; 执行与 I/O 相关的回调，几乎所有的异步操作都在这个阶段处理。\n- **check 阶段**: `setImmediate()` 的回调在这里执行。\n- **close callbacks 阶段**: 执行一些关闭的回调函数，如 `socket.on('close', ...)`。\n\n其中的 poll 阶段需要注意，如果 poll 队列执行完没有`setImmediate`但是有定时器到期，就会绕回去执行 timers 阶段。\n\n![20240610160523](https://img.ma5hr00m.top/blog/20240610160523.png)\n\n## 阅读文章\n\n- [請說明瀏覽器中的事件循環 (Event Loop)｜ExplainThis](https://www.explainthis.io/zh-hant/swe/what-is-event-loop)\n- [异步和EventLoop · 前端进阶](https://dennisgo.cn/Articles/JavaScript/AsyncAndEventLoop.html)","slug":"browser_eventloop","published":1,"updated":"2024-06-11T06:59:16.497Z","comments":1,"layout":"post","photos":[],"_id":"clxhruaov0003f4ly8zmgal7q","content":"<p>事件循环是 JavaScript 管理事件执行顺序的流程，具体实现与运行环境有关。本篇文章主要讲述浏览器环境中的事件循环，Node.js 中的事件循环就简单说说分哪几个阶段。</p>\n<h2 id=\"同步异步\"><a href=\"#同步异步\" class=\"headerlink\" title=\"同步异步\"></a>同步异步</h2><p>同步（Synchronous）执行指的是代码按顺序一行接一行地执行。每个操作必须等待前一个操作完成后才能开始。这种模式简单易懂，但它有一个缺点：如果一个操作需要很长时间来完成（例如，从服务器获取数据），它会阻塞后续代码的执行，导致整个程序暂停，直到该操作完成。这对于 Web 应用来说是无法忍受的，总不发出请求后一直等待所有数据全到手之后再渲染页面，这样搞用户的心情想必不会很美丽。</p>\n<p>异步（Asynchronous）执行允许代码在等待一个耗时任务（如数据请求）完成时继续执行其他任务。这是通过回调函数、Promises 或 async&#x2F;await 等机制实现的。异步编程使得 JavaScript 可以同时处理多个操作，提高了程序的效率和用户体验。</p>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p><img src=\"https://img.ma5hr00m.top/blog/20240610160305.png\" alt=\"20240610160305\"></p>\n<p>事件循环（Event Loop）是 JavaScript 中处理异步操作的核心机制。它确保即使在单线程环境中，JavaScript 也能够执行非阻塞操作。以下是事件循环的详细流程说明，看完这个就基本清晰异步操作的实现过程了：</p>\n<ol>\n<li><strong>执行栈（Execution Stack）：</strong>所有同步任务都在主线程上的执行栈中运行。执行栈是一个按顺序存储函数调用的结构。当一个函数执行完毕，它就会从栈中弹出。</li>\n<li><strong>Web API：</strong>当遇到异步任务（如 <code>setTimeout</code> 或网络请求）时，浏览器提供的 Web API 会接管这些任务，并在后台运行。</li>\n<li><strong>任务队列（Task Queue）：</strong>异步任务完成后，回调函数会被放入任务队列。如果有多个回调，它们会按照它们被添加到队列的顺序排队。</li>\n<li><strong>事件循环（Event Loop—）：</strong>事件循环持续检查执行栈是否为空。如果执行栈为空，事件循环会从任务队列中取出第一个回调函数，并将其推入执行栈中执行。</li>\n<li><strong>微任务队列（Microtask Queue）：</strong>微任务（如 <code>Promise</code> 的回调）会被添加到微任务队列。微任务队列的特点是在当前执行栈清空后，事件循环会在执行下一个宏任务（如 <code>setTimeout</code> 的回调）之前，先执行所有微任务。</li>\n<li><strong>渲染 (Rendering)</strong>: 在某些情况下，如页面渲染或用户交互，浏览器会在适当的时候执行渲染任务。</li>\n</ol>\n<p>这个过程不断重复，形成了一个循环，确保 JavaScript 可以连续处理任务，而不会阻塞主线程。这就是事件循环的工作原理，它使得即使是单线程的 JavaScript 也能够支持复杂的异步操作和高效的用户交互。</p>\n<h2 id=\"宏任务微任务\"><a href=\"#宏任务微任务\" class=\"headerlink\" title=\"宏任务微任务\"></a>宏任务微任务</h2><p>介绍事件循环时有提到宏任务和微任务，解宏任务（Macro Task）和微任务（Micro Task）对于掌握事件循环至关重要。这两种任务决定了代码的执行顺序和时机。</p>\n<h3 id=\"本质区别\"><a href=\"#本质区别\" class=\"headerlink\" title=\"本质区别\"></a>本质区别</h3><p><strong>宏任务</strong>是由宿主环境（如浏览器或 Node.js）发起的任务。它们通常包括：</p>\n<ul>\n<li><strong><code>setTimeout</code></strong></li>\n<li><strong><code>setInterval</code></strong></li>\n<li><strong><code>I/O</code></strong></li>\n<li>UI渲染</li>\n<li><strong><code>postMessage</code></strong></li>\n<li><strong><code>MessageChannel</code></strong></li>\n</ul>\n<p><strong>而微任务</strong>则是由 JavaScript 引擎发起的任务，它们通常用于处理一些不需要长时间运行或等待的操作，如：</p>\n<ul>\n<li><strong><code>Promise.then</code></strong></li>\n<li><strong><code>MutationObserver</code></strong></li>\n<li><strong><code>process.nextTick</code></strong> （Node.js）</li>\n</ul>\n<p>宏任务和微任务的执行时机不同。在每次事件循环中，一个宏任务会被执行，然后所有的微任务会被执行。这意味着微任务总是在当前宏任务结束后立即执行，而不是等待下一个宏任务。</p>\n<p>这种区分允许 JavaScript 引擎优化异步操作的处理。通过微任务，JavaScript 可以快速响应并处理短暂的异步操作，而宏任务则用于可能需要更多时间来完成的操作。这种机制确保了即使在单线程环境中，JavaScript 也能够有效地处理复杂的异步场景。</p>\n<h3 id=\"产生原因\"><a href=\"#产生原因\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h3><p>从前文事件循环的实现流程可以看出，宏任务和微任务的概念与其密切相关。事件循环是 JavaScript 早期就存在的机制，但微任务的概念是随着 ES6 规范的引入才明确的，特别是在引入<code>Promise</code>之后。<code>Promise</code>是在 ES6 中正式成为标准的，它允许 JavaScrip t引擎自身发起异步任务，而不仅仅依赖于宿主环境。</p>\n<p>这俩概念的提出是为了解决 JavaScript 在处理异步操作时的效率问题。在早期的 JavaScript 中，所有的异步操作都被视为宏任务，这导致了效率低下和响应性差的问题。通过引入微任务，JavaScript 能够更快地处理那些不需要等待的异步操作，从而提高了程序的整体性能。</p>\n<h3 id=\"示范代码\"><a href=\"#示范代码\" class=\"headerlink\" title=\"示范代码\"></a>示范代码</h3><p>前文说得已经比较清楚了，这里再给个代码示范：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;宏任务开始&#x27;</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;宏任务&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微任务 1&#x27;</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微任务 2&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;宏任务结束&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>以上代码的输出如下，初学者可以思考下输出为什么是这个顺序：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">宏任务开始</span><br><span class=\"line\">宏任务结束</span><br><span class=\"line\">微任务 1</span><br><span class=\"line\">微任务 2</span><br><span class=\"line\">宏任务</span><br></pre></td></tr></table></figure>\n\n<p>以下是这段代码运行时发生的事件顺序：</p>\n<ol>\n<li>因为<code>console.log</code>是同步操作，所以首先会在控制台打印出<code>&#39;宏任务开始&#39;</code>；</li>\n<li><code>setTimeout</code>是一个宏任务。尽管它设置了<code>0</code>毫秒的延迟，但它不会立即执行。它会被添加到宏任务队列中，在当前执行上下文清空并且所有微任务都被处理后执行；</li>\n<li><code>Promise.resolve()</code>创建了一个已解决的promise，这是一个微任务。<code>.then</code>方法被链式调用来处理微任务。这些将被添加到微任务队列中，并且会在当前调用栈为空时立即执行，但在下一个宏任务之前；</li>\n<li>接下来，因为是下一行同步代码，所以会在控制台打印出<code>&#39;宏任务结束&#39;</code>；</li>\n<li>在当前宏任务（即整个脚本）执行完毕后，JavaScript引擎会检查是否有微任务在队列中。它找到了promise的<code>.then</code>方法中的回调，并按顺序执行它们。这导致控制台依次打印出<code>&#39;微任务 1&#39;</code>和<code>&#39;微任务 2&#39;</code>；</li>\n<li>所有微任务完成后，引擎会检查宏任务队列。现在执行<code>setTimeout</code>的回调，控制台打印出<code>&#39;宏任务&#39;</code>。</li>\n</ol>\n<h2 id=\"定时器不准确\"><a href=\"#定时器不准确\" class=\"headerlink\" title=\"定时器不准确\"></a>定时器不准确</h2><p>学到东西就要拿来解决问题，定时器不准确就算是一个经典问题。在 JavaScript 中，定时器的不准确性主要是由于事件循环的工作方式造成的。<code>setTimeout</code> 和 <code>setInterval</code> 这样的定时器函数并不保证回调函数会在指定的时间精确执行。<strong>定时器只是在指定的延迟后将回调函数放入事件队列</strong>，但实际上它何时被执行取决于主线程上当前正在执行的任务。</p>\n<p>当你设置一个定时器时，例如 <code>setTimeout(callback, 2000)</code>，你告诉 JavaScript 引擎在大约 2 秒后将 <code>callback</code> 放入事件队列。但是，如果主线程在执行长时间运行的同步任务，如你的 <code>syncFunc</code> 函数，它会阻塞线程，直到该任务完成。在这段时间内，即使定时器的时间已经过去，回调函数也不会执行，因为事件循环必须等待主线程变为空闲才能从事件队列中取出回调函数并执行它。</p>\n<p>下面是一个简化的事件循环流程，以帮助理解：</p>\n<ol>\n<li><strong>执行同步代码</strong>：主线程首先执行所有同步代码。</li>\n<li><strong>设置定时器</strong>：遇到 <code>setTimeout</code>，将其回调函数和计时请求交给定时器线程。</li>\n<li><strong>计时结束</strong>：定时器线程计时结束后，通知事件触发线程。</li>\n<li><strong>排队等待</strong>：事件触发线程将定时器回调放入事件队列。</li>\n<li><strong>检查主线程</strong>：如果主线程空闲，事件循环将从事件队列中取出回调函数执行；如果主线程忙，回调函数必须等待。</li>\n</ol>\n<p>为了避免定时器不准确，开发者应该尽量避免在主线程上执行长时间的同步任务。如果必须执行这样的任务，可以考虑使用 Web Workers 或者将任务分解为更小的部分，使用 <code>requestAnimationFrame</code> 或 <code>requestIdleCallback</code> 来安排非紧急任务的执行。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">syncFunc</span> = (<span class=\"params\">startTime</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>() - time &lt; <span class=\"number\">5000</span>) &#123; <span class=\"comment\">/* 长时间同步阻塞 */</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> offset = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>() - startTime;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`同步函数执行完毕，时间偏差：<span class=\"subst\">$&#123;offset&#125;</span>毫秒`</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">asyncFunc</span> = (<span class=\"params\">startTime</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> offset = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>() - startTime;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`异步函数执行完毕，时间偏差：<span class=\"subst\">$&#123;offset&#125;</span>毫秒`</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> startTime = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>();</span><br><span class=\"line\"><span class=\"title function_\">asyncFunc</span>(startTime);</span><br><span class=\"line\"><span class=\"title function_\">syncFunc</span>(startTime);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上述代码中，<code>syncFunc</code> 会阻塞主线程5秒钟，即使 <code>asyncFunc</code> 的定时器在2秒后到期，它的回调也必须等待 <code>syncFunc</code> 完成。这就是为什么定时器的执行时间可能不准确。为了提高定时器的准确性，应当尽量减少同步代码的执行时间，或者使用其他机制来处理长时间运行的任务。</p>\n<h2 id=\"requestAnimationFrame-requestIdleCallback\"><a href=\"#requestAnimationFrame-requestIdleCallback\" class=\"headerlink\" title=\"requestAnimationFrame &amp; requestIdleCallback\"></a>requestAnimationFrame &amp; requestIdleCallback</h2><p><code>requestAnimationFrame()</code> 和 <code>requestIdleCallback()</code> 是两个与浏览器事件循环和渲染过程紧密相关的 Web API。它们在不同的时间点被调用，以优化性能和响应性。<code>requestAnimationFrame()</code> 适合需要与屏幕刷新率同步的任务，如动画，而 <code>requestIdleCallback()</code> 适合可以推迟执行的任务，如统计和数据处理。</p>\n<h3 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame()\"></a><strong>requestAnimationFrame()</strong></h3><p><code>requestAnimationFrame()</code> 主要用于动画和页面重绘之前的更新操作，它告诉浏览器你希望执行动画，并请求浏览器在下次重绘之前调用指定的函数来更新动画。函数通常在每次屏幕刷新之前执行，大约是每秒 60 次，但这会根据浏览器和设备的性能而变化。使用 <code>requestAnimationFrame()</code> 可以保证动画的流畅性，因为它是在浏览器准备好绘制新帧时执行。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 requestAnimationFrame 请求动画帧</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateAnimation</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 更新动画的代码</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"title function_\">requestAnimationFrame</span>(updateAnimation);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始动画</span></span><br><span class=\"line\"><span class=\"title function_\">requestAnimationFrame</span>(updateAnimation);</span><br></pre></td></tr></table></figure>\n\n<p>我之后准备出一些关于前端动效实现的文章，到时候细说这个 API，现在先给一个尽可能简单的示范。</p>\n<h3 id=\"requestIdleCallback\"><a href=\"#requestIdleCallback\" class=\"headerlink\" title=\"requestIdleCallback()\"></a><strong>requestIdleCallback()</strong></h3><p><code>requestIdleCallback()</code> 用于在主线程空闲时执行低优先级的任务，当事件循环空闲，并且没有其他脚本或渲染任务需要执行时，浏览器会调用通过 <code>requestIdleCallback()</code> 注册的回调函数。这个 API 的目的是在不影响性能和响应性的情况下，利用空闲时间执行后台和低优先级的工作，回调函数会接收一个 <code>IdleDeadline</code> 对象，提供了一个 <code>timeRemaining()</code> 方法，该方法可以告诉你当前帧中剩余多少时间可以用于执行代码。</p>\n<p>举一个相对贴近实际的例子，即如何在一个假想的大型电商网站中使用 <strong><code>requestIdleCallback()</code></strong> 来优化图片懒加载功能：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有一个函数用于懒加载图片</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">lazyLoadImages</span>(<span class=\"params\">images</span>) &#123;</span><br><span class=\"line\">  images.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">image</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isInViewport</span>(image)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">loadImage</span>(image);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 requestIdleCallback 来调度懒加载任务</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">scheduleLazyLoad</span>(<span class=\"params\">images</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果浏览器支持 requestIdleCallback，则使用它</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;requestIdleCallback&#x27;</span> <span class=\"keyword\">in</span> <span class=\"variable language_\">window</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">requestIdleCallback</span>(<span class=\"function\"><span class=\"params\">deadline</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (deadline.<span class=\"title function_\">timeRemaining</span>() &gt; <span class=\"number\">0</span> &amp;&amp; images.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">lazyLoadImages</span>(images.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 每次处理两个图片</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果还有图片未处理，继续调度</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (images.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">scheduleLazyLoad</span>(images);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果浏览器不支持 requestIdleCallback，则回退到 setTimeout</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">lazyLoadImages</span>(images), <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设页面上有很多图片需要懒加载</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> allImages = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">&#x27;.lazy-load-image&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">scheduleLazyLoad</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(allImages));</span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，<code>scheduleLazyLoad</code> 函数使用 <code>requestIdleCallback</code> 来安排图片的懒加载。它会检查浏览器是否支持 <code>requestIdleCallback</code>，如果支持，就使用它来在浏览器空闲时加载图片。每次回调函数被调用时，它会处理一小批图片，确保不会占用太多的主线程时间，从而不影响用户的交互体验。</p>\n<p>如果浏览器不支持 <code>requestIdleCallback</code>，则使用 <code>setTimeout</code> 作为回退方案。这样可以确保在所有浏览器中都能实现懒加载功能，同时在支持的浏览器中提供更好的性能。</p>\n<h2 id=\"Node-js-中的事件循环\"><a href=\"#Node-js-中的事件循环\" class=\"headerlink\" title=\"Node.js 中的事件循环\"></a>Node.js 中的事件循环</h2><p>虽然用的都是 V8 引擎（暂且这么说），但因为使用场景和任务的不同，Node.js 的事件循环与浏览器中 JavaScript 原生的事件循环存在差异。</p>\n<p>从整体上来看，最显著的差异就是 Node.js 的事件循环分阶段，每个阶段都有一个 FIFO 队列，只有当队列的事件执行完或达到该阶段的上限时，才会进入下一个阶段。Node.js 会在每次事件循环之间检查是否在等待任何 I&#x2F;O 或定时器，如果没有，则程序关闭退出，一次完整的 Node.js 事件循环包括以下几个阶段：</p>\n<ul>\n<li><strong>timers 阶段</strong>: 执行 <code>setTimeout()</code> 和 <code>setInterval()</code> 定时器的回调函数。</li>\n<li><strong>pending callbacks 阶段</strong>: 执行延迟到下一个循环迭代的 I&#x2F;O 回调。</li>\n<li><strong>idle, prepare 阶段</strong>: 仅系统内部使用。</li>\n<li><strong>poll 阶段</strong>: 检索新的 I&#x2F;O 事件; 执行与 I&#x2F;O 相关的回调，几乎所有的异步操作都在这个阶段处理。</li>\n<li><strong>check 阶段</strong>: <code>setImmediate()</code> 的回调在这里执行。</li>\n<li><strong>close callbacks 阶段</strong>: 执行一些关闭的回调函数，如 <code>socket.on(&#39;close&#39;, ...)</code>。</li>\n</ul>\n<p>其中的 poll 阶段需要注意，如果 poll 队列执行完没有<code>setImmediate</code>但是有定时器到期，就会绕回去执行 timers 阶段。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240610160523.png\" alt=\"20240610160523\"></p>\n<h2 id=\"阅读文章\"><a href=\"#阅读文章\" class=\"headerlink\" title=\"阅读文章\"></a>阅读文章</h2><ul>\n<li><a href=\"https://www.explainthis.io/zh-hant/swe/what-is-event-loop\">請說明瀏覽器中的事件循環 (Event Loop)｜ExplainThis</a></li>\n<li><a href=\"https://dennisgo.cn/Articles/JavaScript/AsyncAndEventLoop.html\">异步和EventLoop · 前端进阶</a></li>\n</ul>\n","excerpt":"","more":"<p>事件循环是 JavaScript 管理事件执行顺序的流程，具体实现与运行环境有关。本篇文章主要讲述浏览器环境中的事件循环，Node.js 中的事件循环就简单说说分哪几个阶段。</p>\n<h2 id=\"同步异步\"><a href=\"#同步异步\" class=\"headerlink\" title=\"同步异步\"></a>同步异步</h2><p>同步（Synchronous）执行指的是代码按顺序一行接一行地执行。每个操作必须等待前一个操作完成后才能开始。这种模式简单易懂，但它有一个缺点：如果一个操作需要很长时间来完成（例如，从服务器获取数据），它会阻塞后续代码的执行，导致整个程序暂停，直到该操作完成。这对于 Web 应用来说是无法忍受的，总不发出请求后一直等待所有数据全到手之后再渲染页面，这样搞用户的心情想必不会很美丽。</p>\n<p>异步（Asynchronous）执行允许代码在等待一个耗时任务（如数据请求）完成时继续执行其他任务。这是通过回调函数、Promises 或 async&#x2F;await 等机制实现的。异步编程使得 JavaScript 可以同时处理多个操作，提高了程序的效率和用户体验。</p>\n<h2 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h2><p><img src=\"https://img.ma5hr00m.top/blog/20240610160305.png\" alt=\"20240610160305\"></p>\n<p>事件循环（Event Loop）是 JavaScript 中处理异步操作的核心机制。它确保即使在单线程环境中，JavaScript 也能够执行非阻塞操作。以下是事件循环的详细流程说明，看完这个就基本清晰异步操作的实现过程了：</p>\n<ol>\n<li><strong>执行栈（Execution Stack）：</strong>所有同步任务都在主线程上的执行栈中运行。执行栈是一个按顺序存储函数调用的结构。当一个函数执行完毕，它就会从栈中弹出。</li>\n<li><strong>Web API：</strong>当遇到异步任务（如 <code>setTimeout</code> 或网络请求）时，浏览器提供的 Web API 会接管这些任务，并在后台运行。</li>\n<li><strong>任务队列（Task Queue）：</strong>异步任务完成后，回调函数会被放入任务队列。如果有多个回调，它们会按照它们被添加到队列的顺序排队。</li>\n<li><strong>事件循环（Event Loop—）：</strong>事件循环持续检查执行栈是否为空。如果执行栈为空，事件循环会从任务队列中取出第一个回调函数，并将其推入执行栈中执行。</li>\n<li><strong>微任务队列（Microtask Queue）：</strong>微任务（如 <code>Promise</code> 的回调）会被添加到微任务队列。微任务队列的特点是在当前执行栈清空后，事件循环会在执行下一个宏任务（如 <code>setTimeout</code> 的回调）之前，先执行所有微任务。</li>\n<li><strong>渲染 (Rendering)</strong>: 在某些情况下，如页面渲染或用户交互，浏览器会在适当的时候执行渲染任务。</li>\n</ol>\n<p>这个过程不断重复，形成了一个循环，确保 JavaScript 可以连续处理任务，而不会阻塞主线程。这就是事件循环的工作原理，它使得即使是单线程的 JavaScript 也能够支持复杂的异步操作和高效的用户交互。</p>\n<h2 id=\"宏任务微任务\"><a href=\"#宏任务微任务\" class=\"headerlink\" title=\"宏任务微任务\"></a>宏任务微任务</h2><p>介绍事件循环时有提到宏任务和微任务，解宏任务（Macro Task）和微任务（Micro Task）对于掌握事件循环至关重要。这两种任务决定了代码的执行顺序和时机。</p>\n<h3 id=\"本质区别\"><a href=\"#本质区别\" class=\"headerlink\" title=\"本质区别\"></a>本质区别</h3><p><strong>宏任务</strong>是由宿主环境（如浏览器或 Node.js）发起的任务。它们通常包括：</p>\n<ul>\n<li><strong><code>setTimeout</code></strong></li>\n<li><strong><code>setInterval</code></strong></li>\n<li><strong><code>I/O</code></strong></li>\n<li>UI渲染</li>\n<li><strong><code>postMessage</code></strong></li>\n<li><strong><code>MessageChannel</code></strong></li>\n</ul>\n<p><strong>而微任务</strong>则是由 JavaScript 引擎发起的任务，它们通常用于处理一些不需要长时间运行或等待的操作，如：</p>\n<ul>\n<li><strong><code>Promise.then</code></strong></li>\n<li><strong><code>MutationObserver</code></strong></li>\n<li><strong><code>process.nextTick</code></strong> （Node.js）</li>\n</ul>\n<p>宏任务和微任务的执行时机不同。在每次事件循环中，一个宏任务会被执行，然后所有的微任务会被执行。这意味着微任务总是在当前宏任务结束后立即执行，而不是等待下一个宏任务。</p>\n<p>这种区分允许 JavaScript 引擎优化异步操作的处理。通过微任务，JavaScript 可以快速响应并处理短暂的异步操作，而宏任务则用于可能需要更多时间来完成的操作。这种机制确保了即使在单线程环境中，JavaScript 也能够有效地处理复杂的异步场景。</p>\n<h3 id=\"产生原因\"><a href=\"#产生原因\" class=\"headerlink\" title=\"产生原因\"></a>产生原因</h3><p>从前文事件循环的实现流程可以看出，宏任务和微任务的概念与其密切相关。事件循环是 JavaScript 早期就存在的机制，但微任务的概念是随着 ES6 规范的引入才明确的，特别是在引入<code>Promise</code>之后。<code>Promise</code>是在 ES6 中正式成为标准的，它允许 JavaScrip t引擎自身发起异步任务，而不仅仅依赖于宿主环境。</p>\n<p>这俩概念的提出是为了解决 JavaScript 在处理异步操作时的效率问题。在早期的 JavaScript 中，所有的异步操作都被视为宏任务，这导致了效率低下和响应性差的问题。通过引入微任务，JavaScript 能够更快地处理那些不需要等待的异步操作，从而提高了程序的整体性能。</p>\n<h3 id=\"示范代码\"><a href=\"#示范代码\" class=\"headerlink\" title=\"示范代码\"></a>示范代码</h3><p>前文说得已经比较清楚了，这里再给个代码示范：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;宏任务开始&#x27;</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;宏任务&#x27;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微任务 1&#x27;</span>);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微任务 2&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;宏任务结束&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>以上代码的输出如下，初学者可以思考下输出为什么是这个顺序：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">宏任务开始</span><br><span class=\"line\">宏任务结束</span><br><span class=\"line\">微任务 1</span><br><span class=\"line\">微任务 2</span><br><span class=\"line\">宏任务</span><br></pre></td></tr></table></figure>\n\n<p>以下是这段代码运行时发生的事件顺序：</p>\n<ol>\n<li>因为<code>console.log</code>是同步操作，所以首先会在控制台打印出<code>&#39;宏任务开始&#39;</code>；</li>\n<li><code>setTimeout</code>是一个宏任务。尽管它设置了<code>0</code>毫秒的延迟，但它不会立即执行。它会被添加到宏任务队列中，在当前执行上下文清空并且所有微任务都被处理后执行；</li>\n<li><code>Promise.resolve()</code>创建了一个已解决的promise，这是一个微任务。<code>.then</code>方法被链式调用来处理微任务。这些将被添加到微任务队列中，并且会在当前调用栈为空时立即执行，但在下一个宏任务之前；</li>\n<li>接下来，因为是下一行同步代码，所以会在控制台打印出<code>&#39;宏任务结束&#39;</code>；</li>\n<li>在当前宏任务（即整个脚本）执行完毕后，JavaScript引擎会检查是否有微任务在队列中。它找到了promise的<code>.then</code>方法中的回调，并按顺序执行它们。这导致控制台依次打印出<code>&#39;微任务 1&#39;</code>和<code>&#39;微任务 2&#39;</code>；</li>\n<li>所有微任务完成后，引擎会检查宏任务队列。现在执行<code>setTimeout</code>的回调，控制台打印出<code>&#39;宏任务&#39;</code>。</li>\n</ol>\n<h2 id=\"定时器不准确\"><a href=\"#定时器不准确\" class=\"headerlink\" title=\"定时器不准确\"></a>定时器不准确</h2><p>学到东西就要拿来解决问题，定时器不准确就算是一个经典问题。在 JavaScript 中，定时器的不准确性主要是由于事件循环的工作方式造成的。<code>setTimeout</code> 和 <code>setInterval</code> 这样的定时器函数并不保证回调函数会在指定的时间精确执行。<strong>定时器只是在指定的延迟后将回调函数放入事件队列</strong>，但实际上它何时被执行取决于主线程上当前正在执行的任务。</p>\n<p>当你设置一个定时器时，例如 <code>setTimeout(callback, 2000)</code>，你告诉 JavaScript 引擎在大约 2 秒后将 <code>callback</code> 放入事件队列。但是，如果主线程在执行长时间运行的同步任务，如你的 <code>syncFunc</code> 函数，它会阻塞线程，直到该任务完成。在这段时间内，即使定时器的时间已经过去，回调函数也不会执行，因为事件循环必须等待主线程变为空闲才能从事件队列中取出回调函数并执行它。</p>\n<p>下面是一个简化的事件循环流程，以帮助理解：</p>\n<ol>\n<li><strong>执行同步代码</strong>：主线程首先执行所有同步代码。</li>\n<li><strong>设置定时器</strong>：遇到 <code>setTimeout</code>，将其回调函数和计时请求交给定时器线程。</li>\n<li><strong>计时结束</strong>：定时器线程计时结束后，通知事件触发线程。</li>\n<li><strong>排队等待</strong>：事件触发线程将定时器回调放入事件队列。</li>\n<li><strong>检查主线程</strong>：如果主线程空闲，事件循环将从事件队列中取出回调函数执行；如果主线程忙，回调函数必须等待。</li>\n</ol>\n<p>为了避免定时器不准确，开发者应该尽量避免在主线程上执行长时间的同步任务。如果必须执行这样的任务，可以考虑使用 Web Workers 或者将任务分解为更小的部分，使用 <code>requestAnimationFrame</code> 或 <code>requestIdleCallback</code> 来安排非紧急任务的执行。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">syncFunc</span> = (<span class=\"params\">startTime</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> time = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>();</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>() - time &lt; <span class=\"number\">5000</span>) &#123; <span class=\"comment\">/* 长时间同步阻塞 */</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> offset = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>() - startTime;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`同步函数执行完毕，时间偏差：<span class=\"subst\">$&#123;offset&#125;</span>毫秒`</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">asyncFunc</span> = (<span class=\"params\">startTime</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> offset = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>() - startTime;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`异步函数执行完毕，时间偏差：<span class=\"subst\">$&#123;offset&#125;</span>毫秒`</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> startTime = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>();</span><br><span class=\"line\"><span class=\"title function_\">asyncFunc</span>(startTime);</span><br><span class=\"line\"><span class=\"title function_\">syncFunc</span>(startTime);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上述代码中，<code>syncFunc</code> 会阻塞主线程5秒钟，即使 <code>asyncFunc</code> 的定时器在2秒后到期，它的回调也必须等待 <code>syncFunc</code> 完成。这就是为什么定时器的执行时间可能不准确。为了提高定时器的准确性，应当尽量减少同步代码的执行时间，或者使用其他机制来处理长时间运行的任务。</p>\n<h2 id=\"requestAnimationFrame-requestIdleCallback\"><a href=\"#requestAnimationFrame-requestIdleCallback\" class=\"headerlink\" title=\"requestAnimationFrame &amp; requestIdleCallback\"></a>requestAnimationFrame &amp; requestIdleCallback</h2><p><code>requestAnimationFrame()</code> 和 <code>requestIdleCallback()</code> 是两个与浏览器事件循环和渲染过程紧密相关的 Web API。它们在不同的时间点被调用，以优化性能和响应性。<code>requestAnimationFrame()</code> 适合需要与屏幕刷新率同步的任务，如动画，而 <code>requestIdleCallback()</code> 适合可以推迟执行的任务，如统计和数据处理。</p>\n<h3 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame()\"></a><strong>requestAnimationFrame()</strong></h3><p><code>requestAnimationFrame()</code> 主要用于动画和页面重绘之前的更新操作，它告诉浏览器你希望执行动画，并请求浏览器在下次重绘之前调用指定的函数来更新动画。函数通常在每次屏幕刷新之前执行，大约是每秒 60 次，但这会根据浏览器和设备的性能而变化。使用 <code>requestAnimationFrame()</code> 可以保证动画的流畅性，因为它是在浏览器准备好绘制新帧时执行。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 requestAnimationFrame 请求动画帧</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">updateAnimation</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 更新动画的代码</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"title function_\">requestAnimationFrame</span>(updateAnimation);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始动画</span></span><br><span class=\"line\"><span class=\"title function_\">requestAnimationFrame</span>(updateAnimation);</span><br></pre></td></tr></table></figure>\n\n<p>我之后准备出一些关于前端动效实现的文章，到时候细说这个 API，现在先给一个尽可能简单的示范。</p>\n<h3 id=\"requestIdleCallback\"><a href=\"#requestIdleCallback\" class=\"headerlink\" title=\"requestIdleCallback()\"></a><strong>requestIdleCallback()</strong></h3><p><code>requestIdleCallback()</code> 用于在主线程空闲时执行低优先级的任务，当事件循环空闲，并且没有其他脚本或渲染任务需要执行时，浏览器会调用通过 <code>requestIdleCallback()</code> 注册的回调函数。这个 API 的目的是在不影响性能和响应性的情况下，利用空闲时间执行后台和低优先级的工作，回调函数会接收一个 <code>IdleDeadline</code> 对象，提供了一个 <code>timeRemaining()</code> 方法，该方法可以告诉你当前帧中剩余多少时间可以用于执行代码。</p>\n<p>举一个相对贴近实际的例子，即如何在一个假想的大型电商网站中使用 <strong><code>requestIdleCallback()</code></strong> 来优化图片懒加载功能：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有一个函数用于懒加载图片</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">lazyLoadImages</span>(<span class=\"params\">images</span>) &#123;</span><br><span class=\"line\">  images.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">image</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"title function_\">isInViewport</span>(image)) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">loadImage</span>(image);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 requestIdleCallback 来调度懒加载任务</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">scheduleLazyLoad</span>(<span class=\"params\">images</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果浏览器支持 requestIdleCallback，则使用它</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"string\">&#x27;requestIdleCallback&#x27;</span> <span class=\"keyword\">in</span> <span class=\"variable language_\">window</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">requestIdleCallback</span>(<span class=\"function\"><span class=\"params\">deadline</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (deadline.<span class=\"title function_\">timeRemaining</span>() &gt; <span class=\"number\">0</span> &amp;&amp; images.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">lazyLoadImages</span>(images.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 每次处理两个图片</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 如果还有图片未处理，继续调度</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (images.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">scheduleLazyLoad</span>(images);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果浏览器不支持 requestIdleCallback，则回退到 setTimeout</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">lazyLoadImages</span>(images), <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设页面上有很多图片需要懒加载</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> allImages = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelectorAll</span>(<span class=\"string\">&#x27;.lazy-load-image&#x27;</span>);</span><br><span class=\"line\"><span class=\"title function_\">scheduleLazyLoad</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(allImages));</span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，<code>scheduleLazyLoad</code> 函数使用 <code>requestIdleCallback</code> 来安排图片的懒加载。它会检查浏览器是否支持 <code>requestIdleCallback</code>，如果支持，就使用它来在浏览器空闲时加载图片。每次回调函数被调用时，它会处理一小批图片，确保不会占用太多的主线程时间，从而不影响用户的交互体验。</p>\n<p>如果浏览器不支持 <code>requestIdleCallback</code>，则使用 <code>setTimeout</code> 作为回退方案。这样可以确保在所有浏览器中都能实现懒加载功能，同时在支持的浏览器中提供更好的性能。</p>\n<h2 id=\"Node-js-中的事件循环\"><a href=\"#Node-js-中的事件循环\" class=\"headerlink\" title=\"Node.js 中的事件循环\"></a>Node.js 中的事件循环</h2><p>虽然用的都是 V8 引擎（暂且这么说），但因为使用场景和任务的不同，Node.js 的事件循环与浏览器中 JavaScript 原生的事件循环存在差异。</p>\n<p>从整体上来看，最显著的差异就是 Node.js 的事件循环分阶段，每个阶段都有一个 FIFO 队列，只有当队列的事件执行完或达到该阶段的上限时，才会进入下一个阶段。Node.js 会在每次事件循环之间检查是否在等待任何 I&#x2F;O 或定时器，如果没有，则程序关闭退出，一次完整的 Node.js 事件循环包括以下几个阶段：</p>\n<ul>\n<li><strong>timers 阶段</strong>: 执行 <code>setTimeout()</code> 和 <code>setInterval()</code> 定时器的回调函数。</li>\n<li><strong>pending callbacks 阶段</strong>: 执行延迟到下一个循环迭代的 I&#x2F;O 回调。</li>\n<li><strong>idle, prepare 阶段</strong>: 仅系统内部使用。</li>\n<li><strong>poll 阶段</strong>: 检索新的 I&#x2F;O 事件; 执行与 I&#x2F;O 相关的回调，几乎所有的异步操作都在这个阶段处理。</li>\n<li><strong>check 阶段</strong>: <code>setImmediate()</code> 的回调在这里执行。</li>\n<li><strong>close callbacks 阶段</strong>: 执行一些关闭的回调函数，如 <code>socket.on(&#39;close&#39;, ...)</code>。</li>\n</ul>\n<p>其中的 poll 阶段需要注意，如果 poll 队列执行完没有<code>setImmediate</code>但是有定时器到期，就会绕回去执行 timers 阶段。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240610160523.png\" alt=\"20240610160523\"></p>\n<h2 id=\"阅读文章\"><a href=\"#阅读文章\" class=\"headerlink\" title=\"阅读文章\"></a>阅读文章</h2><ul>\n<li><a href=\"https://www.explainthis.io/zh-hant/swe/what-is-event-loop\">請說明瀏覽器中的事件循環 (Event Loop)｜ExplainThis</a></li>\n<li><a href=\"https://dennisgo.cn/Articles/JavaScript/AsyncAndEventLoop.html\">异步和EventLoop · 前端进阶</a></li>\n</ul>\n"},{"title":"计算机网络基本概念速通","date":"2023-10-01T16:00:00.000Z","author":"ma5hr00m","_content":"\n## 常见概念\n网络由 *节点*、*节点之间的链路* 和 *管理节点间数据传输的协议* 组成。\n\n### *节点 node*\n节点指连接到网络的物理电子设备，比如电脑、打印机、路由器等，在网络上进行信息的收发，彼此连级。通常，路由器将网络连接到因特网，交换机运行在网络内部，促进内网通信。\n\n### *链路 link*\n链路连接网络中的节点，可以是有线的（比如以太网），也可以是无线的（比如 WiFi），可以是一对一的（A-B），也可以是一对多的(A-B且A-C)。\n\n### *协议 protocol*\n协议是一组互相商定的规则，规定了数据应该按照什么形式进行转换，以允许网络中的两个节点交换数据。\n\n协议定义了管理通信过程中语法（可通信的内容）、语义（如何通信）以及同步（何时通信以及通信的速度）的规则。协议可以由硬件、软件或二者的组合实现。协议可以由任何人创建，但是最被广泛采纳的协议都是基于标准的。   \n\n### *拓扑 topology*\n拓扑（topology）描述的是节点和链路如何在网络配置中组合在一起，通常用图描述。\n\n### *双工 duplex*\n大家都知道“双向”传输，及 A、B 之间的数据可以互相传递，但这不意味着两个过程可以同时进行。\n“双工”是对双向的一个更具体的描述，进一步区分了双向传输的方式。主要分为以下两类：\n- 半双工：允许在两个方向上进行传输，但不能同时进行\n- 全双工：允许同时在两个方向上进行数据传输\n\n## 网络层次划分\n国际标准化组织（ISO）在1978年提出了\"开放系统互联参考模型\"，即著名的 *OSI/RM模型*（Open System Interconnection/Reference Model）。\n它将计算机网络体系结构的通信协议划分为七层，目的是为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络\n\n下面这张图可以简明地表示常见的三种网络层次划分之间的关系：\n\n![三种网络层次划分](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005143909.png)\n\n## OSI七层模型\n全称 `Opne System Interconnection`，及开放式系统互联参考模型，是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互联为网络的标准框架。\n\nOSI 是一种理论下的模型，引入了服务、接口、协议、分层的概念，这为 TCP/IP 协议的建立提供了参考。\n\n自上而下分为以下七层，简单说说每一层的功能：\n\n1. 应用层 *Application* 🟦  \n    为应用程序提供网络服务。它是计算机用户、以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。  \n    协议：*HTTP、TFTP、FTP、NFS、WAIS、SMTP……*\n2. 表示层 *Presentation* 🟦  \n    数据编码、转换、加密解密。它负责将应用处理的信息格式与适合网络传输的格式互相转换，同时消除不同设备之间固有数据格式的差异。\n    协议：*Telent、Rlogin、SNMP、Gopher……*\n3. 会话层 *Session* 🟦  \n    创建、维护、管理会话连接。它负责建立和管理应用程序之间的通信。\n    协议：*SMTP、DNS……*\n4. 传输层 *Transport* 🟩  \n    数据通信。它负责创建、维护、管理段到端的连接，监控数据传输服务的质量，保证报文的正确传输。\n    协议：*TCP、UDP……*\n5. 网络层 *Network* 🟩  \n    IP 寻址和路由选择。通过路由选择算法，为报文或通信自王选择最适当的路径。\n    协议：*IP、ICMP、ARP、RARP、AKP、UUCP……*\n6. 数据链路层 *Data Link* 🟨  \n    控制网络层与物理层之间的通信。它负责接受来自物理层的位流式数据，将其封装成帧，传输到网络层；或者将来自网络层的数据帧，拆装为位流式数据转发到物理层。\n    协议：*FFDI、PDN、Arpanet……*\n7. 物理层 *Physical* 🟥  \n    比特流数据传输。\n    协议：*IEEE 802.1A、IEEE 802.2……*\n\n以上七层，每一层都实现各自的功能和协议，并与相邻层的接口通信。\n\n## IP 地址\n*IP地址*（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。\n\n每个 IP 地址包括两部分：\n- *网络号*  \n  用于在互联网中定位用户的网络，同一个物理网络上的所有主机都使用同一个网络号。对于网络号相同的设备，无论实际所处的物理位置如何，它们都处在同意网络中。\n- *主机号*  \n  用于标识具体设备，网络中每一个主机号都对应一个主机（包括服务器、路由器等），同一网络上的设备都具有唯一的 IP 地址，只有 IP 地址唯一才能正常通信。\n\n为什么要使用 IP 地址？\n单个局域网网段中，我们可以使用 MAC 地址进行通信。但在路由式网络中，计算机之间不能使用 MAC 地址通信，这是因为 MAC 地址不能跨路由接口运行。\n\n### IP 地址分类\nIP 地址根据 *网络号* 的不同分为 5 种类型：A 类地址、B 类地址、C 类地址、D 类地址和 E 类地址。A、B、C 三类常用于一般主机，D、E 两类有特殊用途。\n\n- *A 类地址*  \n  一个 A 类 IP 地址由 1 字节的网络地址和 3 字节主机地址组成。网络地址的最高位必须是 `0`，即第一段数字范围为 1~127。\n  每个 A 类地址理论上可连接 16777214 台主机，互联网中有 126 个可用的 A 类地址，用于政府机构、大型企业等。\n- *B 类地址*  \n  一个 B 类 IP 地址由 2 字节的网络地址和 2 个字节的主机地址组成。网络地址的最高位必须是 `10`，即第一段数字范围为 128~191。\n  每个 B 类网络可以容纳 65534 台主机，用于中等规模的网络，如学校、公司、机构等。\n- *C 类地址*  \n  一个 C 类 IP 地址由 3 字节的网络地址和 1 字节的主机地址组成，网络地址的最高位必须是 `110`，即第一段数字范围为 192~223。\n  每个 C 类网络最多只能包含 254 台计算机，用于小规模网络，如家庭、办公室、局域网等。\n- *D 类地址*  \n  D 类 IP 地址第一个字节以 `1110` 开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。\n- *E 类地址*  \n  以 `11110` 开始，为将来使用保留。`240.0.0.0` 到 `255.255.255.254`，`255.255.255.255` 用于广播地址。\n\n### IPv4 & IPv6\n`IPv4` 和 `IPv6` 都是互联网协议，用于在网络中传输数据。它们之间主要的区别在于地址长度和可用地址数量。\n\n`IPv4`（Internet Protocol Version 4）是网络层协议的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。IPv4 地址由 32 位（4字节）地址组成，因此地址空间中只有约四十亿（4,294,967,296，2^32）个地址。\nIPv4 是一种无连接的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。\n这些方面是由上层的传输协议（如传输控制协议）处理的¹。\n\n*IPv6*（Internet Protocol Version 6），也被称为 *IPng*（IP Next Generation），是网络层协议的第二代标准协议。\nIPv6 可以看作 IPv4 的升级版，它们之间最显著的区别是：IP 地址的长度从 32 比特增加到 128 比特，这意味着 IPv6 具有比 IPv4 大得多的编码地址空间。因此新增的地址空间支持 2^128 （约3.4×10^38）个位址。\n\n有句话怎么说来着：IPv6 允许人们给地球上每粒沙子都分配一个 IP 地址。这也能体现出 IPv6 编码地址空间的庞大。\n\n### MAC地址\n`MAC地址`（Media Access Control）是网络设备的唯一标识，也被称为物理地址或硬件地址。它是由网卡生产厂家烧入网卡的 EPROM（一种闪存芯片），用来定义网络设备的位置。\n\n### 广播地址\n`广播地址`（Broadcast Address）是一种特殊的 IP 地址，用于在网络中发送信息到所有设备。\n\n广播地址专门用于同时向网络中（通常指同一子网）所有工作站发送数据的一个地址。\n在使用 TCP/IP 协议的网络中，主机号为 255 的 IP 地址为广播地址，广播的分组传送给同一个子网的所有计算机。\n\n例如，对于 `10.1.1.0`（即 255.255.255.0）网段，其广播地址为 `10.1.1.255`，当发出一个目的地址为 `10.1.1.255` 的数据包时，它将被分发给该网段上的所有计算机。\n\n![广播地址示范](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005150331.png)\n\n广播地址主要有两类：\n- *受限广播*  \n  路由器不会转发受限广播的数据包，但同一个子网的所有主机都会接收到受限广播的数据包。IP 地址的网络号和主机号均为 255 就是受限广播地址 `255.255.255.255`。\n- *直接广播/定向广播*  \n  直接广播可以被路由转发，发送到目标网络的所有主机。例如，IP 地址为 `192.168.2.1` 的主机也可以发送广播到 `192.168.1.0` 网络。IP 地址的网络字段定义这个网络，主机号通常为 255，如 `192.168.10.0/24` 的直接广播地址为：`192.168.10.255`。\n\n### 组播地址\n组播地址（Multicast Address）是用于一对多通信的一种特殊IP地址。它允许一个主机发送数据包到加入了特定组播组的所有主机。\n\n### 环回地址\n环回地址是一个特殊的 IP 地址，用于网络中的设备向自身发送通信。在 IPv4 中，回环地址的范围是 `127.0.0.1` 到 `127.255.255.254`。\n\n环回地址有以下几个主要用途：\n1. *测试网络配置*\n   如果你能够成功地 ping 通 `127.0.0.1`，那就说明你的网络配置没有问题。\n2. *运行本地服务*  \n   有些服务器/客户端应用程序在运行时需要调用服务器上的资源。当这些程序需要在同一台机器上运行而没有其他服务器时，可以将服务器的资源装在本机，将服务器的IP地址设为 `127.0.0.1`。\n3. *路由器管理*  \n   在配置路由器时，通常会将环回地址作为管理地址。例如，我们可以通过 telnet IP 到你所要管理的那个路由器，这个 IP 就是你所设置的环回地址。\n\n开发人员经常使用环回地址来测试网络应用。例如，如果你正在开发一个 Web 服务器，并且想要在本地测试它，你可以启动服务器并让它监听127.0.0.1 上的某个端口。然后，你可以打开浏览器并导航到`http://127.0.0.1:port`（其中 `port` 是你的服务器正在监听的端口），以查看服务器的响应。\n\n关于我们常用的`localhost`和`127.0.0.1`，二者可以互换使用，实际上我们在使用时也是这么做的。但二者还是存在区别的：\n- `127.0.0.1` 不需要解析，`localhost` 需要解析查找其对应的 IP 地址。\n- 依据上一条，`localhost` 并不一定解析为 `127.0.0.1`，也可能解析为地址环回块中的其它地址。\n\n### 私有地址\n私有地址是指在互联网上不公开使用，而只在局域网内部使用的IP地址。私有地址的作用是节省公网IP地址的资源，同时也提高了网络安全性。私有地址有以下三个范围：\n- A 类私有地址：`10.0.0.0` ~ `10.255.255.255`，可以容纳约 1.6 亿个主机，适用于大型网络。\n- B 类私有地址：`172.16.0.0` ~ `172.31.255.255`，可以容纳约 100 万个主机，适用于中等规模的网络。\n- C 类私有地址：`192.168.0.0` ~ `192.168.255.255`，可以容纳约 65000 个主机，适用于小型网络。\n\n私有地址不能直接访问互联网，需要通过网络地址转换（NAT）技术将其转换为公网IP地址才能与外部网络通信。\n\n## 子网掩码\n在了解“子网掩码”之前，你需要先知道 [什么是“子网”](https://www.zhihu.com/question/21064101)\n\n子网掩码（Subnet Mask）是一种用于指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。它是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”，对应到常用的十进制就是 `xxx.xxx.xxx.xxx`。子网掩码不能单独存在，它必须结合 IP 地址一起使用。\n\n子网掩码的唯一作用是将某个 IP 地址划分成网络号和主机号两部分。这样做可以提高 IP 地址的分配效率，有效解决 IP 地址资源紧张的问题。同时，网路管理员也可以利用子网掩码，人为地将一个大型内网划分为更多个小规模的子网，再利用交换机的路由功能实现子网互联，从而有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。\n\n这里举个 Web 开发中使用子网掩码的例子：\n\n假设我们有一个服务器，其 IP 地址为 `192.168.1.1`，并且我们希望该服务器只能与同一子网内的其他设备进行通信。这时，我们可以将子网掩码设置为 `255.255.255.0`，这样就只有 IP 地址在 `192.168.1.0` 到 `192.168.1.255` 范围内的设备才能与该服务器进行通信。\n\n## 常用设备\n### *集线器 hub*\n集线器充当网络中计算机和其他设备的连接点。\n当集线器接收到来自某一端口的数据包后，它无法直接把数据包发送给目标节点，而是会采取“广播”的方式，把数据报发送给其他所有与集线器相连的端口。\n所有与这个集线器相连的计算机都会接收到这个数据包，即使它们不是目标节点。\n\n集线器有些缺点：以广播的方式传送数据不安全；数据包向所有节点同时发送可能造成网络堵塞，降低了网络执行效率；非双工传输的通信效率低……\n\n但因为集线器便宜且易于设置使用，现实生活中集线器依然能够得到应用，比如家庭或小型企业的内部网络。但在注重效率和安全性的场合，会使用交换机代替集线器。\n\n### *交换机 switch*\n交换机同样充当网络中计算机和其他设备的连接点。\n\n交换机工作在模型的物理层和数据链路层，它通过自学习和维护 MAC 地址信息，对以太网帧进行高速而透明的交换转发。当接收到数据帧时，交换机会查找内存中的地址对照表以确定目的 MAC（网卡的硬件地址）的 NIC（网卡）挂接在哪个端口上。然后，通过内部交换矩阵迅速将数据包传送到目标端口，这种工作方式使得交换机具有更高的性能和安全性。\n\n除此之外，相比于集线器，交换机有一些优点：\n只有目标设备能看到数据包，这有效控制了网络流量，提高网络执行效率；\n交换机能够实现全双工操作，这意味着交换机可以同时接收和发送数据，这种特性使得交换机在处理大量网络流量时具有很高的效率；\n交换机可以使用 VLAN（虚拟局域网）技术来隔离广播，见效广播范围，进一步提高安全性和网络性能……\n\n### *路由器 router*\n路由器是一种智能的网络设备，通常是一个专门设计用来理解、操作和指导流量的小型计算设备，提供了路由和转送两种机制。\n它工作在 OSI 模型的网络层，通过运行路由协议（如 RIP、OSPF、BGP）来维护一张路由表。路由表记录了不同目的地网络的最佳路径。\n\n路由器决定数据包从来源端到目的端所经过的路径，这个过程称为 *路由*；路由器将输入端的数据包移送至适当的路由器输出端，这称为 *转送*。\n\n当接收到数据包时，路由器会查看数据包的目标 IP 地址，并根据路由表选择合适的出口接口转发数据包。\n如果目标 IP 地址不在路由表中，路由器会将数据包发送到默认网关。\n\n这种工作方式使得路由器具有以下优点：\n- 路由器可以连接不同类型和规模的网络，如 LAN、WAN、MAN 等。\n- 路由器可以根据网络拓扑和流量状况动态地调整最佳路径。\n- 路由器可以过滤广播信息，减少网络拥塞。\n- 路由器可以提供高级的安全功能，如防火墙、VPN、NAT 等。\n\n路由器，也被称为三层网络设备。\n\n### *网桥 bridge*\n网桥，也被称为桥接器，是一种用于连接两个局域网的存储/转发设备。它能将一个大的局域网分割为多个网段，或将两个以上的局域网互联为一个逻辑局域网，使局域网上的所有用户都可以访问服务器。\n\n网桥工作在数据链路层，在不同或相同类型的 LAN 之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。\n\n### *网关 gateway*\n网关，又叫网间连接器、协议转换器，作用是在传输层以上实现网络互连，但仅用于两个高层协议不同的网络互连。\n\n在传统 TCP/IP 术语中，网络设备只分成两种：一种为网关，另一种为主机。网关能在网络间转递数据包，但主机不能转送数据包。在主机中，数据包需经过四层协议处理，但是在网关中只需要到达网络层，决定路径之后就可以转送。在当时，网关与路由器还没有区别。但在现代网络术语中，网关与路由器的定义不同：网关能在不同协议间移动资料，而路由器是在不同网络间移动资料。\n\n网关既可以用于广域网互连，也可以用于局域网互连。\n在使用不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。\n与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求，并提供一定的过滤以及安全防护功能。\n\n\n## 常见协议\n太常见的就不做记录了，比如 TCP/IP 和 HTTP，这种协议接触 Web 的时候就应该已经看了……\n\n### ARP/RARP\n`ARP 协议`（Address Resolution Protocol）是一个用于将 IP 地址解析为 MAC 地址的协议。\n\n当主机或路由器有数据要发送给另一台主机或路由器时，需要知道对方的网络层地址（即 IP 地址）。\n主机发送信息时将包含目标 IP 地址的 ARP 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；\n收到返回消息后，将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。\n\n在实际开发中，ARP 协议主要用于在同一局域网内进行通信。\n当一个设备需要向另一个设备发送数据时，它会首先查看自己的 ARP 缓存，看是否已经有了目标设备的 MAC 地址。如果没有，它就会发送一个 ARP 请求，询问目标设备的MAC 地址。\n然后，目标设备会回应这个请求，提供它的 MAC 地址，发送设备则将这个 MAC 地址保存在它的ARP缓存中，以便将来使用。\n\n`RARP 协议`（Reverse Address Resolution Protocol）则是根据 MAC 地址来获取 IP 地址。\n\nRARP 允许局域网的物理机器从网关服务器的 ARP 表或缓存上请求 IP 地址。\n例如，局域网中有一台主机只知道自己的物理地址而不知道自己的 IP 地址，那么可以通过 RARP 协议发出征求自身 IP 地址的广播请求，然后由 RARP 服务器负责回答。\n\n在实际开发中，RARP 协议已经被 DHCP 协议所取代。\n\n### DHCP\n`DHCP 协议`（Dynamic Host Configuration Protocol）是一种用于动态分配和配置网络参数（如 IP 地址、子网掩码、默认网关等）的协议。它可以简化网络管理，提高 IP 地址的利用率，避免 IP 地址冲突等问题。\n\nDHCP 协议的工作原理主要包括四个步骤¹：\n1. *发现阶段*  \n   DHCP 客户端广播发送一个 `DHCP Discover` 报文，以发现网络中的 DHCP 服务器。\n2. *提供阶段*  \n   所有收到 Discover 报文的 DHCP 服务器都会发送一个 `DHCP Offer` 报文，告知用户本服务器可以为其提供IP地址。\n3. *请求阶段*  \n   DHCP 客户端选择一个 Offer 应答报文，并向该服务器发送一个广播的 `DHCP Request` 请求报文，通告选择的服务器，希望获得所分配的 IP 地址。\n4. *确认阶段*  \n   当 DHCP 服务器收到 Request 请求报文后，发送一个 `DHCP ACK` 应答报文，通知用户可以使用分配的 IP 地址。\n\n在实际开发中，DHCP 协议主要用于在局域网内动态分配 IP 地址。当一个设备需要获取网络参数时，它会向 DHCP 服务器发送请求，然后服务器会从预定义的地址池中分配一个 IP 地址，并将这个 IP 地址和其他相关信息（如子网掩码、默认网关等）返回给设备。\n这样，设备就可以自动获取并配置网络参数，无需手动设置。\n\n至于前文为什么说 RARP 协议已经被 DHCP 协议所取代，主要是因为 RARP 协议只能提供 IP 地址，而不能提供其他网络参数（如子网掩码、默认网关等）。\n而且，RARP 协议需要在每台主机上都设置一个 RARP 服务器，这在大型网络中是不现实的。\n相比之下，DHCP 协议可以提供完整的网络配置信息，并且只需要在网络中设置一个或几个 DHCP 服务器即可。\n\n你可以使用 `dig` 命令在 Linux 下使用 DHCP 协议获取指定域名所在主机的公网 IP 地址：\n```bash\ndig +short ma5hr00m.top @resolver1.opendns.com\n# 如果你想查询更详细的信息，去除 +short 参数即可\n```\n\n这条命令会向 `OpenDNS` 的解析器发送一个 DNS 查询请求，查询 `ma5hr00m.top` 域名的记录。\nOpenDNS 的解析器会返回发送请求的公网 IP 。\n\n### 路由选择协议\n路由选择协议是一种网络协议，它决定了数据包在网络中的传输路径。这些协议基于不同的网络性能参数（如带宽、延迟、跳数等）来确定最优路径。\n\n#### RIP\n`RIP`（Routing Information Protocol）是一种基于距离向量的路由选择协议，最大的优点是简单。\nRIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（距离向量）。\nRIP 认为一个好的路由就是它通过的路由器的数目少，即 *距离短*，它要求一条路径最多只能包含 15 个路由器。\n\n由于存在路由环路、可拓展性差等问题，RIP 逐渐被 OSPF 替代。\n\n#### OSPF\n`OSPF `（Open Shortest Path First）是一种基于链路状态的路由协议，它从设计上就保证了无路由环路。\nOSPF 支持区域的划分，区域内部的路由器使用 SPF 最短路径算法保证了区域内部的无环路。OSPF还利用区域间的连接规则保证了区域之间无路由环路。\n\n在实际开发中，开发者通常需要配置网络设备（如路由器）以使用 OSPF 协议。\n\n如果你想玩玩 OSPF 协议，可以参考这篇文章：[Ubuntu20.04 利用 FRR 配置 OSPF 路由协议](https://blog.csdn.net/weixin_46505636/article/details/128629176)\n\n### DNS\n关于 DNS 协议和 DNSSEC，可以看看这篇文章，写得更详细一些：[DNSSEC协议](/posts/network/dnssec)\n\n\n## 参考\n- [计算机网络基础知识总结 - 菜鸟教程](https://www.runoob.com/w3cnote/summary-of-network.html)\n- [计算机网络教程](https://www.jc2182.com/cn/cn-jiaocheng.html)\n- [Hubs, Switches And Routers Explained](https://themillergroup.com/differences-hubs-switches-routers/)\n- [计算机网络漫谈：OSI七层模型与TCP/IP四层（参考）模型](https://www.jianshu.com/p/c793a279f698)\n- [白话 OSI 七层网络模型](https://www.freecodecamp.org/chinese/news/osi-model-networking-layers/)\n- [什么是网关，网关的作用是什么](https://zhuanlan.zhihu.com/p/165142303)\n- [TCP/IP Model](https://www.geeksforgeeks.org/tcp-ip-model/?ref=lbp)\n- [广播地址介绍 - CSDN](https://blog.csdn.net/tennysonsky/article/details/45564479)\n- [IP地址的分类及范围详解 - 知乎](https://zhuanlan.zhihu.com/p/353821843)\n- [一文解析IP地址 - 知乎](https://zhuanlan.zhihu.com/p/498255136)\n- [什么是环回地址127.0.0.1](https://cloud.tencent.com/developer/article/2149791)\n- [子网掩码是什么？有什么作用？](https://zhuanlan.zhihu.com/p/371400090)\n- [什么是 ARP - 华为](https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html)\n- [DHCP 详解 - 知乎](https://zhuanlan.zhihu.com/p/265293856)\n- [RIP 协议详解](https://blog.csdn.net/TheCarol/article/details/112106308)\n- [什么是OSPF？为什么要用OSPF？附OSPF配置实例](https://zhuanlan.zhihu.com/p/616791347)","source":"_posts/base_network.md","raw":"---\ntitle: 计算机网络基本概念速通\ndate: 2023/10/02\nauthor: ma5hr00m\ncategories:\n- Network\n---\n\n## 常见概念\n网络由 *节点*、*节点之间的链路* 和 *管理节点间数据传输的协议* 组成。\n\n### *节点 node*\n节点指连接到网络的物理电子设备，比如电脑、打印机、路由器等，在网络上进行信息的收发，彼此连级。通常，路由器将网络连接到因特网，交换机运行在网络内部，促进内网通信。\n\n### *链路 link*\n链路连接网络中的节点，可以是有线的（比如以太网），也可以是无线的（比如 WiFi），可以是一对一的（A-B），也可以是一对多的(A-B且A-C)。\n\n### *协议 protocol*\n协议是一组互相商定的规则，规定了数据应该按照什么形式进行转换，以允许网络中的两个节点交换数据。\n\n协议定义了管理通信过程中语法（可通信的内容）、语义（如何通信）以及同步（何时通信以及通信的速度）的规则。协议可以由硬件、软件或二者的组合实现。协议可以由任何人创建，但是最被广泛采纳的协议都是基于标准的。   \n\n### *拓扑 topology*\n拓扑（topology）描述的是节点和链路如何在网络配置中组合在一起，通常用图描述。\n\n### *双工 duplex*\n大家都知道“双向”传输，及 A、B 之间的数据可以互相传递，但这不意味着两个过程可以同时进行。\n“双工”是对双向的一个更具体的描述，进一步区分了双向传输的方式。主要分为以下两类：\n- 半双工：允许在两个方向上进行传输，但不能同时进行\n- 全双工：允许同时在两个方向上进行数据传输\n\n## 网络层次划分\n国际标准化组织（ISO）在1978年提出了\"开放系统互联参考模型\"，即著名的 *OSI/RM模型*（Open System Interconnection/Reference Model）。\n它将计算机网络体系结构的通信协议划分为七层，目的是为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络\n\n下面这张图可以简明地表示常见的三种网络层次划分之间的关系：\n\n![三种网络层次划分](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005143909.png)\n\n## OSI七层模型\n全称 `Opne System Interconnection`，及开放式系统互联参考模型，是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互联为网络的标准框架。\n\nOSI 是一种理论下的模型，引入了服务、接口、协议、分层的概念，这为 TCP/IP 协议的建立提供了参考。\n\n自上而下分为以下七层，简单说说每一层的功能：\n\n1. 应用层 *Application* 🟦  \n    为应用程序提供网络服务。它是计算机用户、以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。  \n    协议：*HTTP、TFTP、FTP、NFS、WAIS、SMTP……*\n2. 表示层 *Presentation* 🟦  \n    数据编码、转换、加密解密。它负责将应用处理的信息格式与适合网络传输的格式互相转换，同时消除不同设备之间固有数据格式的差异。\n    协议：*Telent、Rlogin、SNMP、Gopher……*\n3. 会话层 *Session* 🟦  \n    创建、维护、管理会话连接。它负责建立和管理应用程序之间的通信。\n    协议：*SMTP、DNS……*\n4. 传输层 *Transport* 🟩  \n    数据通信。它负责创建、维护、管理段到端的连接，监控数据传输服务的质量，保证报文的正确传输。\n    协议：*TCP、UDP……*\n5. 网络层 *Network* 🟩  \n    IP 寻址和路由选择。通过路由选择算法，为报文或通信自王选择最适当的路径。\n    协议：*IP、ICMP、ARP、RARP、AKP、UUCP……*\n6. 数据链路层 *Data Link* 🟨  \n    控制网络层与物理层之间的通信。它负责接受来自物理层的位流式数据，将其封装成帧，传输到网络层；或者将来自网络层的数据帧，拆装为位流式数据转发到物理层。\n    协议：*FFDI、PDN、Arpanet……*\n7. 物理层 *Physical* 🟥  \n    比特流数据传输。\n    协议：*IEEE 802.1A、IEEE 802.2……*\n\n以上七层，每一层都实现各自的功能和协议，并与相邻层的接口通信。\n\n## IP 地址\n*IP地址*（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。\n\n每个 IP 地址包括两部分：\n- *网络号*  \n  用于在互联网中定位用户的网络，同一个物理网络上的所有主机都使用同一个网络号。对于网络号相同的设备，无论实际所处的物理位置如何，它们都处在同意网络中。\n- *主机号*  \n  用于标识具体设备，网络中每一个主机号都对应一个主机（包括服务器、路由器等），同一网络上的设备都具有唯一的 IP 地址，只有 IP 地址唯一才能正常通信。\n\n为什么要使用 IP 地址？\n单个局域网网段中，我们可以使用 MAC 地址进行通信。但在路由式网络中，计算机之间不能使用 MAC 地址通信，这是因为 MAC 地址不能跨路由接口运行。\n\n### IP 地址分类\nIP 地址根据 *网络号* 的不同分为 5 种类型：A 类地址、B 类地址、C 类地址、D 类地址和 E 类地址。A、B、C 三类常用于一般主机，D、E 两类有特殊用途。\n\n- *A 类地址*  \n  一个 A 类 IP 地址由 1 字节的网络地址和 3 字节主机地址组成。网络地址的最高位必须是 `0`，即第一段数字范围为 1~127。\n  每个 A 类地址理论上可连接 16777214 台主机，互联网中有 126 个可用的 A 类地址，用于政府机构、大型企业等。\n- *B 类地址*  \n  一个 B 类 IP 地址由 2 字节的网络地址和 2 个字节的主机地址组成。网络地址的最高位必须是 `10`，即第一段数字范围为 128~191。\n  每个 B 类网络可以容纳 65534 台主机，用于中等规模的网络，如学校、公司、机构等。\n- *C 类地址*  \n  一个 C 类 IP 地址由 3 字节的网络地址和 1 字节的主机地址组成，网络地址的最高位必须是 `110`，即第一段数字范围为 192~223。\n  每个 C 类网络最多只能包含 254 台计算机，用于小规模网络，如家庭、办公室、局域网等。\n- *D 类地址*  \n  D 类 IP 地址第一个字节以 `1110` 开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。\n- *E 类地址*  \n  以 `11110` 开始，为将来使用保留。`240.0.0.0` 到 `255.255.255.254`，`255.255.255.255` 用于广播地址。\n\n### IPv4 & IPv6\n`IPv4` 和 `IPv6` 都是互联网协议，用于在网络中传输数据。它们之间主要的区别在于地址长度和可用地址数量。\n\n`IPv4`（Internet Protocol Version 4）是网络层协议的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。IPv4 地址由 32 位（4字节）地址组成，因此地址空间中只有约四十亿（4,294,967,296，2^32）个地址。\nIPv4 是一种无连接的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。\n这些方面是由上层的传输协议（如传输控制协议）处理的¹。\n\n*IPv6*（Internet Protocol Version 6），也被称为 *IPng*（IP Next Generation），是网络层协议的第二代标准协议。\nIPv6 可以看作 IPv4 的升级版，它们之间最显著的区别是：IP 地址的长度从 32 比特增加到 128 比特，这意味着 IPv6 具有比 IPv4 大得多的编码地址空间。因此新增的地址空间支持 2^128 （约3.4×10^38）个位址。\n\n有句话怎么说来着：IPv6 允许人们给地球上每粒沙子都分配一个 IP 地址。这也能体现出 IPv6 编码地址空间的庞大。\n\n### MAC地址\n`MAC地址`（Media Access Control）是网络设备的唯一标识，也被称为物理地址或硬件地址。它是由网卡生产厂家烧入网卡的 EPROM（一种闪存芯片），用来定义网络设备的位置。\n\n### 广播地址\n`广播地址`（Broadcast Address）是一种特殊的 IP 地址，用于在网络中发送信息到所有设备。\n\n广播地址专门用于同时向网络中（通常指同一子网）所有工作站发送数据的一个地址。\n在使用 TCP/IP 协议的网络中，主机号为 255 的 IP 地址为广播地址，广播的分组传送给同一个子网的所有计算机。\n\n例如，对于 `10.1.1.0`（即 255.255.255.0）网段，其广播地址为 `10.1.1.255`，当发出一个目的地址为 `10.1.1.255` 的数据包时，它将被分发给该网段上的所有计算机。\n\n![广播地址示范](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005150331.png)\n\n广播地址主要有两类：\n- *受限广播*  \n  路由器不会转发受限广播的数据包，但同一个子网的所有主机都会接收到受限广播的数据包。IP 地址的网络号和主机号均为 255 就是受限广播地址 `255.255.255.255`。\n- *直接广播/定向广播*  \n  直接广播可以被路由转发，发送到目标网络的所有主机。例如，IP 地址为 `192.168.2.1` 的主机也可以发送广播到 `192.168.1.0` 网络。IP 地址的网络字段定义这个网络，主机号通常为 255，如 `192.168.10.0/24` 的直接广播地址为：`192.168.10.255`。\n\n### 组播地址\n组播地址（Multicast Address）是用于一对多通信的一种特殊IP地址。它允许一个主机发送数据包到加入了特定组播组的所有主机。\n\n### 环回地址\n环回地址是一个特殊的 IP 地址，用于网络中的设备向自身发送通信。在 IPv4 中，回环地址的范围是 `127.0.0.1` 到 `127.255.255.254`。\n\n环回地址有以下几个主要用途：\n1. *测试网络配置*\n   如果你能够成功地 ping 通 `127.0.0.1`，那就说明你的网络配置没有问题。\n2. *运行本地服务*  \n   有些服务器/客户端应用程序在运行时需要调用服务器上的资源。当这些程序需要在同一台机器上运行而没有其他服务器时，可以将服务器的资源装在本机，将服务器的IP地址设为 `127.0.0.1`。\n3. *路由器管理*  \n   在配置路由器时，通常会将环回地址作为管理地址。例如，我们可以通过 telnet IP 到你所要管理的那个路由器，这个 IP 就是你所设置的环回地址。\n\n开发人员经常使用环回地址来测试网络应用。例如，如果你正在开发一个 Web 服务器，并且想要在本地测试它，你可以启动服务器并让它监听127.0.0.1 上的某个端口。然后，你可以打开浏览器并导航到`http://127.0.0.1:port`（其中 `port` 是你的服务器正在监听的端口），以查看服务器的响应。\n\n关于我们常用的`localhost`和`127.0.0.1`，二者可以互换使用，实际上我们在使用时也是这么做的。但二者还是存在区别的：\n- `127.0.0.1` 不需要解析，`localhost` 需要解析查找其对应的 IP 地址。\n- 依据上一条，`localhost` 并不一定解析为 `127.0.0.1`，也可能解析为地址环回块中的其它地址。\n\n### 私有地址\n私有地址是指在互联网上不公开使用，而只在局域网内部使用的IP地址。私有地址的作用是节省公网IP地址的资源，同时也提高了网络安全性。私有地址有以下三个范围：\n- A 类私有地址：`10.0.0.0` ~ `10.255.255.255`，可以容纳约 1.6 亿个主机，适用于大型网络。\n- B 类私有地址：`172.16.0.0` ~ `172.31.255.255`，可以容纳约 100 万个主机，适用于中等规模的网络。\n- C 类私有地址：`192.168.0.0` ~ `192.168.255.255`，可以容纳约 65000 个主机，适用于小型网络。\n\n私有地址不能直接访问互联网，需要通过网络地址转换（NAT）技术将其转换为公网IP地址才能与外部网络通信。\n\n## 子网掩码\n在了解“子网掩码”之前，你需要先知道 [什么是“子网”](https://www.zhihu.com/question/21064101)\n\n子网掩码（Subnet Mask）是一种用于指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。它是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”，对应到常用的十进制就是 `xxx.xxx.xxx.xxx`。子网掩码不能单独存在，它必须结合 IP 地址一起使用。\n\n子网掩码的唯一作用是将某个 IP 地址划分成网络号和主机号两部分。这样做可以提高 IP 地址的分配效率，有效解决 IP 地址资源紧张的问题。同时，网路管理员也可以利用子网掩码，人为地将一个大型内网划分为更多个小规模的子网，再利用交换机的路由功能实现子网互联，从而有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。\n\n这里举个 Web 开发中使用子网掩码的例子：\n\n假设我们有一个服务器，其 IP 地址为 `192.168.1.1`，并且我们希望该服务器只能与同一子网内的其他设备进行通信。这时，我们可以将子网掩码设置为 `255.255.255.0`，这样就只有 IP 地址在 `192.168.1.0` 到 `192.168.1.255` 范围内的设备才能与该服务器进行通信。\n\n## 常用设备\n### *集线器 hub*\n集线器充当网络中计算机和其他设备的连接点。\n当集线器接收到来自某一端口的数据包后，它无法直接把数据包发送给目标节点，而是会采取“广播”的方式，把数据报发送给其他所有与集线器相连的端口。\n所有与这个集线器相连的计算机都会接收到这个数据包，即使它们不是目标节点。\n\n集线器有些缺点：以广播的方式传送数据不安全；数据包向所有节点同时发送可能造成网络堵塞，降低了网络执行效率；非双工传输的通信效率低……\n\n但因为集线器便宜且易于设置使用，现实生活中集线器依然能够得到应用，比如家庭或小型企业的内部网络。但在注重效率和安全性的场合，会使用交换机代替集线器。\n\n### *交换机 switch*\n交换机同样充当网络中计算机和其他设备的连接点。\n\n交换机工作在模型的物理层和数据链路层，它通过自学习和维护 MAC 地址信息，对以太网帧进行高速而透明的交换转发。当接收到数据帧时，交换机会查找内存中的地址对照表以确定目的 MAC（网卡的硬件地址）的 NIC（网卡）挂接在哪个端口上。然后，通过内部交换矩阵迅速将数据包传送到目标端口，这种工作方式使得交换机具有更高的性能和安全性。\n\n除此之外，相比于集线器，交换机有一些优点：\n只有目标设备能看到数据包，这有效控制了网络流量，提高网络执行效率；\n交换机能够实现全双工操作，这意味着交换机可以同时接收和发送数据，这种特性使得交换机在处理大量网络流量时具有很高的效率；\n交换机可以使用 VLAN（虚拟局域网）技术来隔离广播，见效广播范围，进一步提高安全性和网络性能……\n\n### *路由器 router*\n路由器是一种智能的网络设备，通常是一个专门设计用来理解、操作和指导流量的小型计算设备，提供了路由和转送两种机制。\n它工作在 OSI 模型的网络层，通过运行路由协议（如 RIP、OSPF、BGP）来维护一张路由表。路由表记录了不同目的地网络的最佳路径。\n\n路由器决定数据包从来源端到目的端所经过的路径，这个过程称为 *路由*；路由器将输入端的数据包移送至适当的路由器输出端，这称为 *转送*。\n\n当接收到数据包时，路由器会查看数据包的目标 IP 地址，并根据路由表选择合适的出口接口转发数据包。\n如果目标 IP 地址不在路由表中，路由器会将数据包发送到默认网关。\n\n这种工作方式使得路由器具有以下优点：\n- 路由器可以连接不同类型和规模的网络，如 LAN、WAN、MAN 等。\n- 路由器可以根据网络拓扑和流量状况动态地调整最佳路径。\n- 路由器可以过滤广播信息，减少网络拥塞。\n- 路由器可以提供高级的安全功能，如防火墙、VPN、NAT 等。\n\n路由器，也被称为三层网络设备。\n\n### *网桥 bridge*\n网桥，也被称为桥接器，是一种用于连接两个局域网的存储/转发设备。它能将一个大的局域网分割为多个网段，或将两个以上的局域网互联为一个逻辑局域网，使局域网上的所有用户都可以访问服务器。\n\n网桥工作在数据链路层，在不同或相同类型的 LAN 之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。\n\n### *网关 gateway*\n网关，又叫网间连接器、协议转换器，作用是在传输层以上实现网络互连，但仅用于两个高层协议不同的网络互连。\n\n在传统 TCP/IP 术语中，网络设备只分成两种：一种为网关，另一种为主机。网关能在网络间转递数据包，但主机不能转送数据包。在主机中，数据包需经过四层协议处理，但是在网关中只需要到达网络层，决定路径之后就可以转送。在当时，网关与路由器还没有区别。但在现代网络术语中，网关与路由器的定义不同：网关能在不同协议间移动资料，而路由器是在不同网络间移动资料。\n\n网关既可以用于广域网互连，也可以用于局域网互连。\n在使用不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。\n与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求，并提供一定的过滤以及安全防护功能。\n\n\n## 常见协议\n太常见的就不做记录了，比如 TCP/IP 和 HTTP，这种协议接触 Web 的时候就应该已经看了……\n\n### ARP/RARP\n`ARP 协议`（Address Resolution Protocol）是一个用于将 IP 地址解析为 MAC 地址的协议。\n\n当主机或路由器有数据要发送给另一台主机或路由器时，需要知道对方的网络层地址（即 IP 地址）。\n主机发送信息时将包含目标 IP 地址的 ARP 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；\n收到返回消息后，将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。\n\n在实际开发中，ARP 协议主要用于在同一局域网内进行通信。\n当一个设备需要向另一个设备发送数据时，它会首先查看自己的 ARP 缓存，看是否已经有了目标设备的 MAC 地址。如果没有，它就会发送一个 ARP 请求，询问目标设备的MAC 地址。\n然后，目标设备会回应这个请求，提供它的 MAC 地址，发送设备则将这个 MAC 地址保存在它的ARP缓存中，以便将来使用。\n\n`RARP 协议`（Reverse Address Resolution Protocol）则是根据 MAC 地址来获取 IP 地址。\n\nRARP 允许局域网的物理机器从网关服务器的 ARP 表或缓存上请求 IP 地址。\n例如，局域网中有一台主机只知道自己的物理地址而不知道自己的 IP 地址，那么可以通过 RARP 协议发出征求自身 IP 地址的广播请求，然后由 RARP 服务器负责回答。\n\n在实际开发中，RARP 协议已经被 DHCP 协议所取代。\n\n### DHCP\n`DHCP 协议`（Dynamic Host Configuration Protocol）是一种用于动态分配和配置网络参数（如 IP 地址、子网掩码、默认网关等）的协议。它可以简化网络管理，提高 IP 地址的利用率，避免 IP 地址冲突等问题。\n\nDHCP 协议的工作原理主要包括四个步骤¹：\n1. *发现阶段*  \n   DHCP 客户端广播发送一个 `DHCP Discover` 报文，以发现网络中的 DHCP 服务器。\n2. *提供阶段*  \n   所有收到 Discover 报文的 DHCP 服务器都会发送一个 `DHCP Offer` 报文，告知用户本服务器可以为其提供IP地址。\n3. *请求阶段*  \n   DHCP 客户端选择一个 Offer 应答报文，并向该服务器发送一个广播的 `DHCP Request` 请求报文，通告选择的服务器，希望获得所分配的 IP 地址。\n4. *确认阶段*  \n   当 DHCP 服务器收到 Request 请求报文后，发送一个 `DHCP ACK` 应答报文，通知用户可以使用分配的 IP 地址。\n\n在实际开发中，DHCP 协议主要用于在局域网内动态分配 IP 地址。当一个设备需要获取网络参数时，它会向 DHCP 服务器发送请求，然后服务器会从预定义的地址池中分配一个 IP 地址，并将这个 IP 地址和其他相关信息（如子网掩码、默认网关等）返回给设备。\n这样，设备就可以自动获取并配置网络参数，无需手动设置。\n\n至于前文为什么说 RARP 协议已经被 DHCP 协议所取代，主要是因为 RARP 协议只能提供 IP 地址，而不能提供其他网络参数（如子网掩码、默认网关等）。\n而且，RARP 协议需要在每台主机上都设置一个 RARP 服务器，这在大型网络中是不现实的。\n相比之下，DHCP 协议可以提供完整的网络配置信息，并且只需要在网络中设置一个或几个 DHCP 服务器即可。\n\n你可以使用 `dig` 命令在 Linux 下使用 DHCP 协议获取指定域名所在主机的公网 IP 地址：\n```bash\ndig +short ma5hr00m.top @resolver1.opendns.com\n# 如果你想查询更详细的信息，去除 +short 参数即可\n```\n\n这条命令会向 `OpenDNS` 的解析器发送一个 DNS 查询请求，查询 `ma5hr00m.top` 域名的记录。\nOpenDNS 的解析器会返回发送请求的公网 IP 。\n\n### 路由选择协议\n路由选择协议是一种网络协议，它决定了数据包在网络中的传输路径。这些协议基于不同的网络性能参数（如带宽、延迟、跳数等）来确定最优路径。\n\n#### RIP\n`RIP`（Routing Information Protocol）是一种基于距离向量的路由选择协议，最大的优点是简单。\nRIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（距离向量）。\nRIP 认为一个好的路由就是它通过的路由器的数目少，即 *距离短*，它要求一条路径最多只能包含 15 个路由器。\n\n由于存在路由环路、可拓展性差等问题，RIP 逐渐被 OSPF 替代。\n\n#### OSPF\n`OSPF `（Open Shortest Path First）是一种基于链路状态的路由协议，它从设计上就保证了无路由环路。\nOSPF 支持区域的划分，区域内部的路由器使用 SPF 最短路径算法保证了区域内部的无环路。OSPF还利用区域间的连接规则保证了区域之间无路由环路。\n\n在实际开发中，开发者通常需要配置网络设备（如路由器）以使用 OSPF 协议。\n\n如果你想玩玩 OSPF 协议，可以参考这篇文章：[Ubuntu20.04 利用 FRR 配置 OSPF 路由协议](https://blog.csdn.net/weixin_46505636/article/details/128629176)\n\n### DNS\n关于 DNS 协议和 DNSSEC，可以看看这篇文章，写得更详细一些：[DNSSEC协议](/posts/network/dnssec)\n\n\n## 参考\n- [计算机网络基础知识总结 - 菜鸟教程](https://www.runoob.com/w3cnote/summary-of-network.html)\n- [计算机网络教程](https://www.jc2182.com/cn/cn-jiaocheng.html)\n- [Hubs, Switches And Routers Explained](https://themillergroup.com/differences-hubs-switches-routers/)\n- [计算机网络漫谈：OSI七层模型与TCP/IP四层（参考）模型](https://www.jianshu.com/p/c793a279f698)\n- [白话 OSI 七层网络模型](https://www.freecodecamp.org/chinese/news/osi-model-networking-layers/)\n- [什么是网关，网关的作用是什么](https://zhuanlan.zhihu.com/p/165142303)\n- [TCP/IP Model](https://www.geeksforgeeks.org/tcp-ip-model/?ref=lbp)\n- [广播地址介绍 - CSDN](https://blog.csdn.net/tennysonsky/article/details/45564479)\n- [IP地址的分类及范围详解 - 知乎](https://zhuanlan.zhihu.com/p/353821843)\n- [一文解析IP地址 - 知乎](https://zhuanlan.zhihu.com/p/498255136)\n- [什么是环回地址127.0.0.1](https://cloud.tencent.com/developer/article/2149791)\n- [子网掩码是什么？有什么作用？](https://zhuanlan.zhihu.com/p/371400090)\n- [什么是 ARP - 华为](https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html)\n- [DHCP 详解 - 知乎](https://zhuanlan.zhihu.com/p/265293856)\n- [RIP 协议详解](https://blog.csdn.net/TheCarol/article/details/112106308)\n- [什么是OSPF？为什么要用OSPF？附OSPF配置实例](https://zhuanlan.zhihu.com/p/616791347)","slug":"base_network","published":1,"updated":"2024-06-09T12:55:55.188Z","comments":1,"layout":"post","photos":[],"_id":"clxhruaox0006f4ly9ea00fve","content":"<h2 id=\"常见概念\"><a href=\"#常见概念\" class=\"headerlink\" title=\"常见概念\"></a>常见概念</h2><p>网络由 <em>节点</em>、<em>节点之间的链路</em> 和 <em>管理节点间数据传输的协议</em> 组成。</p>\n<h3 id=\"节点-node\"><a href=\"#节点-node\" class=\"headerlink\" title=\"节点 node\"></a><em>节点 node</em></h3><p>节点指连接到网络的物理电子设备，比如电脑、打印机、路由器等，在网络上进行信息的收发，彼此连级。通常，路由器将网络连接到因特网，交换机运行在网络内部，促进内网通信。</p>\n<h3 id=\"链路-link\"><a href=\"#链路-link\" class=\"headerlink\" title=\"链路 link\"></a><em>链路 link</em></h3><p>链路连接网络中的节点，可以是有线的（比如以太网），也可以是无线的（比如 WiFi），可以是一对一的（A-B），也可以是一对多的(A-B且A-C)。</p>\n<h3 id=\"协议-protocol\"><a href=\"#协议-protocol\" class=\"headerlink\" title=\"协议 protocol\"></a><em>协议 protocol</em></h3><p>协议是一组互相商定的规则，规定了数据应该按照什么形式进行转换，以允许网络中的两个节点交换数据。</p>\n<p>协议定义了管理通信过程中语法（可通信的内容）、语义（如何通信）以及同步（何时通信以及通信的速度）的规则。协议可以由硬件、软件或二者的组合实现。协议可以由任何人创建，但是最被广泛采纳的协议都是基于标准的。   </p>\n<h3 id=\"拓扑-topology\"><a href=\"#拓扑-topology\" class=\"headerlink\" title=\"拓扑 topology\"></a><em>拓扑 topology</em></h3><p>拓扑（topology）描述的是节点和链路如何在网络配置中组合在一起，通常用图描述。</p>\n<h3 id=\"双工-duplex\"><a href=\"#双工-duplex\" class=\"headerlink\" title=\"双工 duplex\"></a><em>双工 duplex</em></h3><p>大家都知道“双向”传输，及 A、B 之间的数据可以互相传递，但这不意味着两个过程可以同时进行。<br>“双工”是对双向的一个更具体的描述，进一步区分了双向传输的方式。主要分为以下两类：</p>\n<ul>\n<li>半双工：允许在两个方向上进行传输，但不能同时进行</li>\n<li>全双工：允许同时在两个方向上进行数据传输</li>\n</ul>\n<h2 id=\"网络层次划分\"><a href=\"#网络层次划分\" class=\"headerlink\" title=\"网络层次划分\"></a>网络层次划分</h2><p>国际标准化组织（ISO）在1978年提出了”开放系统互联参考模型”，即著名的 <em>OSI&#x2F;RM模型</em>（Open System Interconnection&#x2F;Reference Model）。<br>它将计算机网络体系结构的通信协议划分为七层，目的是为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络</p>\n<p>下面这张图可以简明地表示常见的三种网络层次划分之间的关系：</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005143909.png\" alt=\"三种网络层次划分\"></p>\n<h2 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h2><p>全称 <code>Opne System Interconnection</code>，及开放式系统互联参考模型，是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互联为网络的标准框架。</p>\n<p>OSI 是一种理论下的模型，引入了服务、接口、协议、分层的概念，这为 TCP&#x2F;IP 协议的建立提供了参考。</p>\n<p>自上而下分为以下七层，简单说说每一层的功能：</p>\n<ol>\n<li>应用层 <em>Application</em> 🟦<br> 为应用程序提供网络服务。它是计算机用户、以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。<br> 协议：<em>HTTP、TFTP、FTP、NFS、WAIS、SMTP……</em></li>\n<li>表示层 <em>Presentation</em> 🟦<br> 数据编码、转换、加密解密。它负责将应用处理的信息格式与适合网络传输的格式互相转换，同时消除不同设备之间固有数据格式的差异。<br> 协议：<em>Telent、Rlogin、SNMP、Gopher……</em></li>\n<li>会话层 <em>Session</em> 🟦<br> 创建、维护、管理会话连接。它负责建立和管理应用程序之间的通信。<br> 协议：<em>SMTP、DNS……</em></li>\n<li>传输层 <em>Transport</em> 🟩<br> 数据通信。它负责创建、维护、管理段到端的连接，监控数据传输服务的质量，保证报文的正确传输。<br> 协议：<em>TCP、UDP……</em></li>\n<li>网络层 <em>Network</em> 🟩<br> IP 寻址和路由选择。通过路由选择算法，为报文或通信自王选择最适当的路径。<br> 协议：<em>IP、ICMP、ARP、RARP、AKP、UUCP……</em></li>\n<li>数据链路层 <em>Data Link</em> 🟨<br> 控制网络层与物理层之间的通信。它负责接受来自物理层的位流式数据，将其封装成帧，传输到网络层；或者将来自网络层的数据帧，拆装为位流式数据转发到物理层。<br> 协议：<em>FFDI、PDN、Arpanet……</em></li>\n<li>物理层 <em>Physical</em> 🟥<br> 比特流数据传输。<br> 协议：<em>IEEE 802.1A、IEEE 802.2……</em></li>\n</ol>\n<p>以上七层，每一层都实现各自的功能和协议，并与相邻层的接口通信。</p>\n<h2 id=\"IP-地址\"><a href=\"#IP-地址\" class=\"headerlink\" title=\"IP 地址\"></a>IP 地址</h2><p><em>IP地址</em>（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>\n<p>每个 IP 地址包括两部分：</p>\n<ul>\n<li><em>网络号</em><br>用于在互联网中定位用户的网络，同一个物理网络上的所有主机都使用同一个网络号。对于网络号相同的设备，无论实际所处的物理位置如何，它们都处在同意网络中。</li>\n<li><em>主机号</em><br>用于标识具体设备，网络中每一个主机号都对应一个主机（包括服务器、路由器等），同一网络上的设备都具有唯一的 IP 地址，只有 IP 地址唯一才能正常通信。</li>\n</ul>\n<p>为什么要使用 IP 地址？<br>单个局域网网段中，我们可以使用 MAC 地址进行通信。但在路由式网络中，计算机之间不能使用 MAC 地址通信，这是因为 MAC 地址不能跨路由接口运行。</p>\n<h3 id=\"IP-地址分类\"><a href=\"#IP-地址分类\" class=\"headerlink\" title=\"IP 地址分类\"></a>IP 地址分类</h3><p>IP 地址根据 <em>网络号</em> 的不同分为 5 种类型：A 类地址、B 类地址、C 类地址、D 类地址和 E 类地址。A、B、C 三类常用于一般主机，D、E 两类有特殊用途。</p>\n<ul>\n<li><em>A 类地址</em><br>一个 A 类 IP 地址由 1 字节的网络地址和 3 字节主机地址组成。网络地址的最高位必须是 <code>0</code>，即第一段数字范围为 1~127。<br>每个 A 类地址理论上可连接 16777214 台主机，互联网中有 126 个可用的 A 类地址，用于政府机构、大型企业等。</li>\n<li><em>B 类地址</em><br>一个 B 类 IP 地址由 2 字节的网络地址和 2 个字节的主机地址组成。网络地址的最高位必须是 <code>10</code>，即第一段数字范围为 128~191。<br>每个 B 类网络可以容纳 65534 台主机，用于中等规模的网络，如学校、公司、机构等。</li>\n<li><em>C 类地址</em><br>一个 C 类 IP 地址由 3 字节的网络地址和 1 字节的主机地址组成，网络地址的最高位必须是 <code>110</code>，即第一段数字范围为 192~223。<br>每个 C 类网络最多只能包含 254 台计算机，用于小规模网络，如家庭、办公室、局域网等。</li>\n<li><em>D 类地址</em><br>D 类 IP 地址第一个字节以 <code>1110</code> 开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。</li>\n<li><em>E 类地址</em><br>以 <code>11110</code> 开始，为将来使用保留。<code>240.0.0.0</code> 到 <code>255.255.255.254</code>，<code>255.255.255.255</code> 用于广播地址。</li>\n</ul>\n<h3 id=\"IPv4-IPv6\"><a href=\"#IPv4-IPv6\" class=\"headerlink\" title=\"IPv4 &amp; IPv6\"></a>IPv4 &amp; IPv6</h3><p><code>IPv4</code> 和 <code>IPv6</code> 都是互联网协议，用于在网络中传输数据。它们之间主要的区别在于地址长度和可用地址数量。</p>\n<p><code>IPv4</code>（Internet Protocol Version 4）是网络层协议的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。IPv4 地址由 32 位（4字节）地址组成，因此地址空间中只有约四十亿（4,294,967,296，2^32）个地址。<br>IPv4 是一种无连接的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。<br>这些方面是由上层的传输协议（如传输控制协议）处理的¹。</p>\n<p><em>IPv6</em>（Internet Protocol Version 6），也被称为 <em>IPng</em>（IP Next Generation），是网络层协议的第二代标准协议。<br>IPv6 可以看作 IPv4 的升级版，它们之间最显著的区别是：IP 地址的长度从 32 比特增加到 128 比特，这意味着 IPv6 具有比 IPv4 大得多的编码地址空间。因此新增的地址空间支持 2^128 （约3.4×10^38）个位址。</p>\n<p>有句话怎么说来着：IPv6 允许人们给地球上每粒沙子都分配一个 IP 地址。这也能体现出 IPv6 编码地址空间的庞大。</p>\n<h3 id=\"MAC地址\"><a href=\"#MAC地址\" class=\"headerlink\" title=\"MAC地址\"></a>MAC地址</h3><p><code>MAC地址</code>（Media Access Control）是网络设备的唯一标识，也被称为物理地址或硬件地址。它是由网卡生产厂家烧入网卡的 EPROM（一种闪存芯片），用来定义网络设备的位置。</p>\n<h3 id=\"广播地址\"><a href=\"#广播地址\" class=\"headerlink\" title=\"广播地址\"></a>广播地址</h3><p><code>广播地址</code>（Broadcast Address）是一种特殊的 IP 地址，用于在网络中发送信息到所有设备。</p>\n<p>广播地址专门用于同时向网络中（通常指同一子网）所有工作站发送数据的一个地址。<br>在使用 TCP&#x2F;IP 协议的网络中，主机号为 255 的 IP 地址为广播地址，广播的分组传送给同一个子网的所有计算机。</p>\n<p>例如，对于 <code>10.1.1.0</code>（即 255.255.255.0）网段，其广播地址为 <code>10.1.1.255</code>，当发出一个目的地址为 <code>10.1.1.255</code> 的数据包时，它将被分发给该网段上的所有计算机。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005150331.png\" alt=\"广播地址示范\"></p>\n<p>广播地址主要有两类：</p>\n<ul>\n<li><em>受限广播</em><br>路由器不会转发受限广播的数据包，但同一个子网的所有主机都会接收到受限广播的数据包。IP 地址的网络号和主机号均为 255 就是受限广播地址 <code>255.255.255.255</code>。</li>\n<li><em>直接广播&#x2F;定向广播</em><br>直接广播可以被路由转发，发送到目标网络的所有主机。例如，IP 地址为 <code>192.168.2.1</code> 的主机也可以发送广播到 <code>192.168.1.0</code> 网络。IP 地址的网络字段定义这个网络，主机号通常为 255，如 <code>192.168.10.0/24</code> 的直接广播地址为：<code>192.168.10.255</code>。</li>\n</ul>\n<h3 id=\"组播地址\"><a href=\"#组播地址\" class=\"headerlink\" title=\"组播地址\"></a>组播地址</h3><p>组播地址（Multicast Address）是用于一对多通信的一种特殊IP地址。它允许一个主机发送数据包到加入了特定组播组的所有主机。</p>\n<h3 id=\"环回地址\"><a href=\"#环回地址\" class=\"headerlink\" title=\"环回地址\"></a>环回地址</h3><p>环回地址是一个特殊的 IP 地址，用于网络中的设备向自身发送通信。在 IPv4 中，回环地址的范围是 <code>127.0.0.1</code> 到 <code>127.255.255.254</code>。</p>\n<p>环回地址有以下几个主要用途：</p>\n<ol>\n<li><em>测试网络配置</em><br>如果你能够成功地 ping 通 <code>127.0.0.1</code>，那就说明你的网络配置没有问题。</li>\n<li><em>运行本地服务</em><br>有些服务器&#x2F;客户端应用程序在运行时需要调用服务器上的资源。当这些程序需要在同一台机器上运行而没有其他服务器时，可以将服务器的资源装在本机，将服务器的IP地址设为 <code>127.0.0.1</code>。</li>\n<li><em>路由器管理</em><br>在配置路由器时，通常会将环回地址作为管理地址。例如，我们可以通过 telnet IP 到你所要管理的那个路由器，这个 IP 就是你所设置的环回地址。</li>\n</ol>\n<p>开发人员经常使用环回地址来测试网络应用。例如，如果你正在开发一个 Web 服务器，并且想要在本地测试它，你可以启动服务器并让它监听127.0.0.1 上的某个端口。然后，你可以打开浏览器并导航到<code>http://127.0.0.1:port</code>（其中 <code>port</code> 是你的服务器正在监听的端口），以查看服务器的响应。</p>\n<p>关于我们常用的<code>localhost</code>和<code>127.0.0.1</code>，二者可以互换使用，实际上我们在使用时也是这么做的。但二者还是存在区别的：</p>\n<ul>\n<li><code>127.0.0.1</code> 不需要解析，<code>localhost</code> 需要解析查找其对应的 IP 地址。</li>\n<li>依据上一条，<code>localhost</code> 并不一定解析为 <code>127.0.0.1</code>，也可能解析为地址环回块中的其它地址。</li>\n</ul>\n<h3 id=\"私有地址\"><a href=\"#私有地址\" class=\"headerlink\" title=\"私有地址\"></a>私有地址</h3><p>私有地址是指在互联网上不公开使用，而只在局域网内部使用的IP地址。私有地址的作用是节省公网IP地址的资源，同时也提高了网络安全性。私有地址有以下三个范围：</p>\n<ul>\n<li>A 类私有地址：<code>10.0.0.0</code> ~ <code>10.255.255.255</code>，可以容纳约 1.6 亿个主机，适用于大型网络。</li>\n<li>B 类私有地址：<code>172.16.0.0</code> ~ <code>172.31.255.255</code>，可以容纳约 100 万个主机，适用于中等规模的网络。</li>\n<li>C 类私有地址：<code>192.168.0.0</code> ~ <code>192.168.255.255</code>，可以容纳约 65000 个主机，适用于小型网络。</li>\n</ul>\n<p>私有地址不能直接访问互联网，需要通过网络地址转换（NAT）技术将其转换为公网IP地址才能与外部网络通信。</p>\n<h2 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h2><p>在了解“子网掩码”之前，你需要先知道 <a href=\"https://www.zhihu.com/question/21064101\">什么是“子网”</a></p>\n<p>子网掩码（Subnet Mask）是一种用于指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。它是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”，对应到常用的十进制就是 <code>xxx.xxx.xxx.xxx</code>。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</p>\n<p>子网掩码的唯一作用是将某个 IP 地址划分成网络号和主机号两部分。这样做可以提高 IP 地址的分配效率，有效解决 IP 地址资源紧张的问题。同时，网路管理员也可以利用子网掩码，人为地将一个大型内网划分为更多个小规模的子网，再利用交换机的路由功能实现子网互联，从而有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。</p>\n<p>这里举个 Web 开发中使用子网掩码的例子：</p>\n<p>假设我们有一个服务器，其 IP 地址为 <code>192.168.1.1</code>，并且我们希望该服务器只能与同一子网内的其他设备进行通信。这时，我们可以将子网掩码设置为 <code>255.255.255.0</code>，这样就只有 IP 地址在 <code>192.168.1.0</code> 到 <code>192.168.1.255</code> 范围内的设备才能与该服务器进行通信。</p>\n<h2 id=\"常用设备\"><a href=\"#常用设备\" class=\"headerlink\" title=\"常用设备\"></a>常用设备</h2><h3 id=\"集线器-hub\"><a href=\"#集线器-hub\" class=\"headerlink\" title=\"集线器 hub\"></a><em>集线器 hub</em></h3><p>集线器充当网络中计算机和其他设备的连接点。<br>当集线器接收到来自某一端口的数据包后，它无法直接把数据包发送给目标节点，而是会采取“广播”的方式，把数据报发送给其他所有与集线器相连的端口。<br>所有与这个集线器相连的计算机都会接收到这个数据包，即使它们不是目标节点。</p>\n<p>集线器有些缺点：以广播的方式传送数据不安全；数据包向所有节点同时发送可能造成网络堵塞，降低了网络执行效率；非双工传输的通信效率低……</p>\n<p>但因为集线器便宜且易于设置使用，现实生活中集线器依然能够得到应用，比如家庭或小型企业的内部网络。但在注重效率和安全性的场合，会使用交换机代替集线器。</p>\n<h3 id=\"交换机-switch\"><a href=\"#交换机-switch\" class=\"headerlink\" title=\"交换机 switch\"></a><em>交换机 switch</em></h3><p>交换机同样充当网络中计算机和其他设备的连接点。</p>\n<p>交换机工作在模型的物理层和数据链路层，它通过自学习和维护 MAC 地址信息，对以太网帧进行高速而透明的交换转发。当接收到数据帧时，交换机会查找内存中的地址对照表以确定目的 MAC（网卡的硬件地址）的 NIC（网卡）挂接在哪个端口上。然后，通过内部交换矩阵迅速将数据包传送到目标端口，这种工作方式使得交换机具有更高的性能和安全性。</p>\n<p>除此之外，相比于集线器，交换机有一些优点：<br>只有目标设备能看到数据包，这有效控制了网络流量，提高网络执行效率；<br>交换机能够实现全双工操作，这意味着交换机可以同时接收和发送数据，这种特性使得交换机在处理大量网络流量时具有很高的效率；<br>交换机可以使用 VLAN（虚拟局域网）技术来隔离广播，见效广播范围，进一步提高安全性和网络性能……</p>\n<h3 id=\"路由器-router\"><a href=\"#路由器-router\" class=\"headerlink\" title=\"路由器 router\"></a><em>路由器 router</em></h3><p>路由器是一种智能的网络设备，通常是一个专门设计用来理解、操作和指导流量的小型计算设备，提供了路由和转送两种机制。<br>它工作在 OSI 模型的网络层，通过运行路由协议（如 RIP、OSPF、BGP）来维护一张路由表。路由表记录了不同目的地网络的最佳路径。</p>\n<p>路由器决定数据包从来源端到目的端所经过的路径，这个过程称为 <em>路由</em>；路由器将输入端的数据包移送至适当的路由器输出端，这称为 <em>转送</em>。</p>\n<p>当接收到数据包时，路由器会查看数据包的目标 IP 地址，并根据路由表选择合适的出口接口转发数据包。<br>如果目标 IP 地址不在路由表中，路由器会将数据包发送到默认网关。</p>\n<p>这种工作方式使得路由器具有以下优点：</p>\n<ul>\n<li>路由器可以连接不同类型和规模的网络，如 LAN、WAN、MAN 等。</li>\n<li>路由器可以根据网络拓扑和流量状况动态地调整最佳路径。</li>\n<li>路由器可以过滤广播信息，减少网络拥塞。</li>\n<li>路由器可以提供高级的安全功能，如防火墙、VPN、NAT 等。</li>\n</ul>\n<p>路由器，也被称为三层网络设备。</p>\n<h3 id=\"网桥-bridge\"><a href=\"#网桥-bridge\" class=\"headerlink\" title=\"网桥 bridge\"></a><em>网桥 bridge</em></h3><p>网桥，也被称为桥接器，是一种用于连接两个局域网的存储&#x2F;转发设备。它能将一个大的局域网分割为多个网段，或将两个以上的局域网互联为一个逻辑局域网，使局域网上的所有用户都可以访问服务器。</p>\n<p>网桥工作在数据链路层，在不同或相同类型的 LAN 之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。</p>\n<h3 id=\"网关-gateway\"><a href=\"#网关-gateway\" class=\"headerlink\" title=\"网关 gateway\"></a><em>网关 gateway</em></h3><p>网关，又叫网间连接器、协议转换器，作用是在传输层以上实现网络互连，但仅用于两个高层协议不同的网络互连。</p>\n<p>在传统 TCP&#x2F;IP 术语中，网络设备只分成两种：一种为网关，另一种为主机。网关能在网络间转递数据包，但主机不能转送数据包。在主机中，数据包需经过四层协议处理，但是在网关中只需要到达网络层，决定路径之后就可以转送。在当时，网关与路由器还没有区别。但在现代网络术语中，网关与路由器的定义不同：网关能在不同协议间移动资料，而路由器是在不同网络间移动资料。</p>\n<p>网关既可以用于广域网互连，也可以用于局域网互连。<br>在使用不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。<br>与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求，并提供一定的过滤以及安全防护功能。</p>\n<h2 id=\"常见协议\"><a href=\"#常见协议\" class=\"headerlink\" title=\"常见协议\"></a>常见协议</h2><p>太常见的就不做记录了，比如 TCP&#x2F;IP 和 HTTP，这种协议接触 Web 的时候就应该已经看了……</p>\n<h3 id=\"ARP-RARP\"><a href=\"#ARP-RARP\" class=\"headerlink\" title=\"ARP&#x2F;RARP\"></a>ARP&#x2F;RARP</h3><p><code>ARP 协议</code>（Address Resolution Protocol）是一个用于将 IP 地址解析为 MAC 地址的协议。</p>\n<p>当主机或路由器有数据要发送给另一台主机或路由器时，需要知道对方的网络层地址（即 IP 地址）。<br>主机发送信息时将包含目标 IP 地址的 ARP 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；<br>收到返回消息后，将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。</p>\n<p>在实际开发中，ARP 协议主要用于在同一局域网内进行通信。<br>当一个设备需要向另一个设备发送数据时，它会首先查看自己的 ARP 缓存，看是否已经有了目标设备的 MAC 地址。如果没有，它就会发送一个 ARP 请求，询问目标设备的MAC 地址。<br>然后，目标设备会回应这个请求，提供它的 MAC 地址，发送设备则将这个 MAC 地址保存在它的ARP缓存中，以便将来使用。</p>\n<p><code>RARP 协议</code>（Reverse Address Resolution Protocol）则是根据 MAC 地址来获取 IP 地址。</p>\n<p>RARP 允许局域网的物理机器从网关服务器的 ARP 表或缓存上请求 IP 地址。<br>例如，局域网中有一台主机只知道自己的物理地址而不知道自己的 IP 地址，那么可以通过 RARP 协议发出征求自身 IP 地址的广播请求，然后由 RARP 服务器负责回答。</p>\n<p>在实际开发中，RARP 协议已经被 DHCP 协议所取代。</p>\n<h3 id=\"DHCP\"><a href=\"#DHCP\" class=\"headerlink\" title=\"DHCP\"></a>DHCP</h3><p><code>DHCP 协议</code>（Dynamic Host Configuration Protocol）是一种用于动态分配和配置网络参数（如 IP 地址、子网掩码、默认网关等）的协议。它可以简化网络管理，提高 IP 地址的利用率，避免 IP 地址冲突等问题。</p>\n<p>DHCP 协议的工作原理主要包括四个步骤¹：</p>\n<ol>\n<li><em>发现阶段</em><br>DHCP 客户端广播发送一个 <code>DHCP Discover</code> 报文，以发现网络中的 DHCP 服务器。</li>\n<li><em>提供阶段</em><br>所有收到 Discover 报文的 DHCP 服务器都会发送一个 <code>DHCP Offer</code> 报文，告知用户本服务器可以为其提供IP地址。</li>\n<li><em>请求阶段</em><br>DHCP 客户端选择一个 Offer 应答报文，并向该服务器发送一个广播的 <code>DHCP Request</code> 请求报文，通告选择的服务器，希望获得所分配的 IP 地址。</li>\n<li><em>确认阶段</em><br>当 DHCP 服务器收到 Request 请求报文后，发送一个 <code>DHCP ACK</code> 应答报文，通知用户可以使用分配的 IP 地址。</li>\n</ol>\n<p>在实际开发中，DHCP 协议主要用于在局域网内动态分配 IP 地址。当一个设备需要获取网络参数时，它会向 DHCP 服务器发送请求，然后服务器会从预定义的地址池中分配一个 IP 地址，并将这个 IP 地址和其他相关信息（如子网掩码、默认网关等）返回给设备。<br>这样，设备就可以自动获取并配置网络参数，无需手动设置。</p>\n<p>至于前文为什么说 RARP 协议已经被 DHCP 协议所取代，主要是因为 RARP 协议只能提供 IP 地址，而不能提供其他网络参数（如子网掩码、默认网关等）。<br>而且，RARP 协议需要在每台主机上都设置一个 RARP 服务器，这在大型网络中是不现实的。<br>相比之下，DHCP 协议可以提供完整的网络配置信息，并且只需要在网络中设置一个或几个 DHCP 服务器即可。</p>\n<p>你可以使用 <code>dig</code> 命令在 Linux 下使用 DHCP 协议获取指定域名所在主机的公网 IP 地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dig +short ma5hr00m.top @resolver1.opendns.com</span><br><span class=\"line\"><span class=\"comment\"># 如果你想查询更详细的信息，去除 +short 参数即可</span></span><br></pre></td></tr></table></figure>\n\n<p>这条命令会向 <code>OpenDNS</code> 的解析器发送一个 DNS 查询请求，查询 <code>ma5hr00m.top</code> 域名的记录。<br>OpenDNS 的解析器会返回发送请求的公网 IP 。</p>\n<h3 id=\"路由选择协议\"><a href=\"#路由选择协议\" class=\"headerlink\" title=\"路由选择协议\"></a>路由选择协议</h3><p>路由选择协议是一种网络协议，它决定了数据包在网络中的传输路径。这些协议基于不同的网络性能参数（如带宽、延迟、跳数等）来确定最优路径。</p>\n<h4 id=\"RIP\"><a href=\"#RIP\" class=\"headerlink\" title=\"RIP\"></a>RIP</h4><p><code>RIP</code>（Routing Information Protocol）是一种基于距离向量的路由选择协议，最大的优点是简单。<br>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（距离向量）。<br>RIP 认为一个好的路由就是它通过的路由器的数目少，即 <em>距离短</em>，它要求一条路径最多只能包含 15 个路由器。</p>\n<p>由于存在路由环路、可拓展性差等问题，RIP 逐渐被 OSPF 替代。</p>\n<h4 id=\"OSPF\"><a href=\"#OSPF\" class=\"headerlink\" title=\"OSPF\"></a>OSPF</h4><p><code>OSPF </code>（Open Shortest Path First）是一种基于链路状态的路由协议，它从设计上就保证了无路由环路。<br>OSPF 支持区域的划分，区域内部的路由器使用 SPF 最短路径算法保证了区域内部的无环路。OSPF还利用区域间的连接规则保证了区域之间无路由环路。</p>\n<p>在实际开发中，开发者通常需要配置网络设备（如路由器）以使用 OSPF 协议。</p>\n<p>如果你想玩玩 OSPF 协议，可以参考这篇文章：<a href=\"https://blog.csdn.net/weixin_46505636/article/details/128629176\">Ubuntu20.04 利用 FRR 配置 OSPF 路由协议</a></p>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>关于 DNS 协议和 DNSSEC，可以看看这篇文章，写得更详细一些：<a href=\"/posts/network/dnssec\">DNSSEC协议</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.runoob.com/w3cnote/summary-of-network.html\">计算机网络基础知识总结 - 菜鸟教程</a></li>\n<li><a href=\"https://www.jc2182.com/cn/cn-jiaocheng.html\">计算机网络教程</a></li>\n<li><a href=\"https://themillergroup.com/differences-hubs-switches-routers/\">Hubs, Switches And Routers Explained</a></li>\n<li><a href=\"https://www.jianshu.com/p/c793a279f698\">计算机网络漫谈：OSI七层模型与TCP&#x2F;IP四层（参考）模型</a></li>\n<li><a href=\"https://www.freecodecamp.org/chinese/news/osi-model-networking-layers/\">白话 OSI 七层网络模型</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/165142303\">什么是网关，网关的作用是什么</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/tcp-ip-model/?ref=lbp\">TCP&#x2F;IP Model</a></li>\n<li><a href=\"https://blog.csdn.net/tennysonsky/article/details/45564479\">广播地址介绍 - CSDN</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/353821843\">IP地址的分类及范围详解 - 知乎</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/498255136\">一文解析IP地址 - 知乎</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2149791\">什么是环回地址127.0.0.1</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/371400090\">子网掩码是什么？有什么作用？</a></li>\n<li><a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html\">什么是 ARP - 华为</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/265293856\">DHCP 详解 - 知乎</a></li>\n<li><a href=\"https://blog.csdn.net/TheCarol/article/details/112106308\">RIP 协议详解</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/616791347\">什么是OSPF？为什么要用OSPF？附OSPF配置实例</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"常见概念\"><a href=\"#常见概念\" class=\"headerlink\" title=\"常见概念\"></a>常见概念</h2><p>网络由 <em>节点</em>、<em>节点之间的链路</em> 和 <em>管理节点间数据传输的协议</em> 组成。</p>\n<h3 id=\"节点-node\"><a href=\"#节点-node\" class=\"headerlink\" title=\"节点 node\"></a><em>节点 node</em></h3><p>节点指连接到网络的物理电子设备，比如电脑、打印机、路由器等，在网络上进行信息的收发，彼此连级。通常，路由器将网络连接到因特网，交换机运行在网络内部，促进内网通信。</p>\n<h3 id=\"链路-link\"><a href=\"#链路-link\" class=\"headerlink\" title=\"链路 link\"></a><em>链路 link</em></h3><p>链路连接网络中的节点，可以是有线的（比如以太网），也可以是无线的（比如 WiFi），可以是一对一的（A-B），也可以是一对多的(A-B且A-C)。</p>\n<h3 id=\"协议-protocol\"><a href=\"#协议-protocol\" class=\"headerlink\" title=\"协议 protocol\"></a><em>协议 protocol</em></h3><p>协议是一组互相商定的规则，规定了数据应该按照什么形式进行转换，以允许网络中的两个节点交换数据。</p>\n<p>协议定义了管理通信过程中语法（可通信的内容）、语义（如何通信）以及同步（何时通信以及通信的速度）的规则。协议可以由硬件、软件或二者的组合实现。协议可以由任何人创建，但是最被广泛采纳的协议都是基于标准的。   </p>\n<h3 id=\"拓扑-topology\"><a href=\"#拓扑-topology\" class=\"headerlink\" title=\"拓扑 topology\"></a><em>拓扑 topology</em></h3><p>拓扑（topology）描述的是节点和链路如何在网络配置中组合在一起，通常用图描述。</p>\n<h3 id=\"双工-duplex\"><a href=\"#双工-duplex\" class=\"headerlink\" title=\"双工 duplex\"></a><em>双工 duplex</em></h3><p>大家都知道“双向”传输，及 A、B 之间的数据可以互相传递，但这不意味着两个过程可以同时进行。<br>“双工”是对双向的一个更具体的描述，进一步区分了双向传输的方式。主要分为以下两类：</p>\n<ul>\n<li>半双工：允许在两个方向上进行传输，但不能同时进行</li>\n<li>全双工：允许同时在两个方向上进行数据传输</li>\n</ul>\n<h2 id=\"网络层次划分\"><a href=\"#网络层次划分\" class=\"headerlink\" title=\"网络层次划分\"></a>网络层次划分</h2><p>国际标准化组织（ISO）在1978年提出了”开放系统互联参考模型”，即著名的 <em>OSI&#x2F;RM模型</em>（Open System Interconnection&#x2F;Reference Model）。<br>它将计算机网络体系结构的通信协议划分为七层，目的是为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络</p>\n<p>下面这张图可以简明地表示常见的三种网络层次划分之间的关系：</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005143909.png\" alt=\"三种网络层次划分\"></p>\n<h2 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h2><p>全称 <code>Opne System Interconnection</code>，及开放式系统互联参考模型，是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互联为网络的标准框架。</p>\n<p>OSI 是一种理论下的模型，引入了服务、接口、协议、分层的概念，这为 TCP&#x2F;IP 协议的建立提供了参考。</p>\n<p>自上而下分为以下七层，简单说说每一层的功能：</p>\n<ol>\n<li>应用层 <em>Application</em> 🟦<br> 为应用程序提供网络服务。它是计算机用户、以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。<br> 协议：<em>HTTP、TFTP、FTP、NFS、WAIS、SMTP……</em></li>\n<li>表示层 <em>Presentation</em> 🟦<br> 数据编码、转换、加密解密。它负责将应用处理的信息格式与适合网络传输的格式互相转换，同时消除不同设备之间固有数据格式的差异。<br> 协议：<em>Telent、Rlogin、SNMP、Gopher……</em></li>\n<li>会话层 <em>Session</em> 🟦<br> 创建、维护、管理会话连接。它负责建立和管理应用程序之间的通信。<br> 协议：<em>SMTP、DNS……</em></li>\n<li>传输层 <em>Transport</em> 🟩<br> 数据通信。它负责创建、维护、管理段到端的连接，监控数据传输服务的质量，保证报文的正确传输。<br> 协议：<em>TCP、UDP……</em></li>\n<li>网络层 <em>Network</em> 🟩<br> IP 寻址和路由选择。通过路由选择算法，为报文或通信自王选择最适当的路径。<br> 协议：<em>IP、ICMP、ARP、RARP、AKP、UUCP……</em></li>\n<li>数据链路层 <em>Data Link</em> 🟨<br> 控制网络层与物理层之间的通信。它负责接受来自物理层的位流式数据，将其封装成帧，传输到网络层；或者将来自网络层的数据帧，拆装为位流式数据转发到物理层。<br> 协议：<em>FFDI、PDN、Arpanet……</em></li>\n<li>物理层 <em>Physical</em> 🟥<br> 比特流数据传输。<br> 协议：<em>IEEE 802.1A、IEEE 802.2……</em></li>\n</ol>\n<p>以上七层，每一层都实现各自的功能和协议，并与相邻层的接口通信。</p>\n<h2 id=\"IP-地址\"><a href=\"#IP-地址\" class=\"headerlink\" title=\"IP 地址\"></a>IP 地址</h2><p><em>IP地址</em>（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>\n<p>每个 IP 地址包括两部分：</p>\n<ul>\n<li><em>网络号</em><br>用于在互联网中定位用户的网络，同一个物理网络上的所有主机都使用同一个网络号。对于网络号相同的设备，无论实际所处的物理位置如何，它们都处在同意网络中。</li>\n<li><em>主机号</em><br>用于标识具体设备，网络中每一个主机号都对应一个主机（包括服务器、路由器等），同一网络上的设备都具有唯一的 IP 地址，只有 IP 地址唯一才能正常通信。</li>\n</ul>\n<p>为什么要使用 IP 地址？<br>单个局域网网段中，我们可以使用 MAC 地址进行通信。但在路由式网络中，计算机之间不能使用 MAC 地址通信，这是因为 MAC 地址不能跨路由接口运行。</p>\n<h3 id=\"IP-地址分类\"><a href=\"#IP-地址分类\" class=\"headerlink\" title=\"IP 地址分类\"></a>IP 地址分类</h3><p>IP 地址根据 <em>网络号</em> 的不同分为 5 种类型：A 类地址、B 类地址、C 类地址、D 类地址和 E 类地址。A、B、C 三类常用于一般主机，D、E 两类有特殊用途。</p>\n<ul>\n<li><em>A 类地址</em><br>一个 A 类 IP 地址由 1 字节的网络地址和 3 字节主机地址组成。网络地址的最高位必须是 <code>0</code>，即第一段数字范围为 1~127。<br>每个 A 类地址理论上可连接 16777214 台主机，互联网中有 126 个可用的 A 类地址，用于政府机构、大型企业等。</li>\n<li><em>B 类地址</em><br>一个 B 类 IP 地址由 2 字节的网络地址和 2 个字节的主机地址组成。网络地址的最高位必须是 <code>10</code>，即第一段数字范围为 128~191。<br>每个 B 类网络可以容纳 65534 台主机，用于中等规模的网络，如学校、公司、机构等。</li>\n<li><em>C 类地址</em><br>一个 C 类 IP 地址由 3 字节的网络地址和 1 字节的主机地址组成，网络地址的最高位必须是 <code>110</code>，即第一段数字范围为 192~223。<br>每个 C 类网络最多只能包含 254 台计算机，用于小规模网络，如家庭、办公室、局域网等。</li>\n<li><em>D 类地址</em><br>D 类 IP 地址第一个字节以 <code>1110</code> 开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。</li>\n<li><em>E 类地址</em><br>以 <code>11110</code> 开始，为将来使用保留。<code>240.0.0.0</code> 到 <code>255.255.255.254</code>，<code>255.255.255.255</code> 用于广播地址。</li>\n</ul>\n<h3 id=\"IPv4-IPv6\"><a href=\"#IPv4-IPv6\" class=\"headerlink\" title=\"IPv4 &amp; IPv6\"></a>IPv4 &amp; IPv6</h3><p><code>IPv4</code> 和 <code>IPv6</code> 都是互联网协议，用于在网络中传输数据。它们之间主要的区别在于地址长度和可用地址数量。</p>\n<p><code>IPv4</code>（Internet Protocol Version 4）是网络层协议的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。IPv4 地址由 32 位（4字节）地址组成，因此地址空间中只有约四十亿（4,294,967,296，2^32）个地址。<br>IPv4 是一种无连接的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。<br>这些方面是由上层的传输协议（如传输控制协议）处理的¹。</p>\n<p><em>IPv6</em>（Internet Protocol Version 6），也被称为 <em>IPng</em>（IP Next Generation），是网络层协议的第二代标准协议。<br>IPv6 可以看作 IPv4 的升级版，它们之间最显著的区别是：IP 地址的长度从 32 比特增加到 128 比特，这意味着 IPv6 具有比 IPv4 大得多的编码地址空间。因此新增的地址空间支持 2^128 （约3.4×10^38）个位址。</p>\n<p>有句话怎么说来着：IPv6 允许人们给地球上每粒沙子都分配一个 IP 地址。这也能体现出 IPv6 编码地址空间的庞大。</p>\n<h3 id=\"MAC地址\"><a href=\"#MAC地址\" class=\"headerlink\" title=\"MAC地址\"></a>MAC地址</h3><p><code>MAC地址</code>（Media Access Control）是网络设备的唯一标识，也被称为物理地址或硬件地址。它是由网卡生产厂家烧入网卡的 EPROM（一种闪存芯片），用来定义网络设备的位置。</p>\n<h3 id=\"广播地址\"><a href=\"#广播地址\" class=\"headerlink\" title=\"广播地址\"></a>广播地址</h3><p><code>广播地址</code>（Broadcast Address）是一种特殊的 IP 地址，用于在网络中发送信息到所有设备。</p>\n<p>广播地址专门用于同时向网络中（通常指同一子网）所有工作站发送数据的一个地址。<br>在使用 TCP&#x2F;IP 协议的网络中，主机号为 255 的 IP 地址为广播地址，广播的分组传送给同一个子网的所有计算机。</p>\n<p>例如，对于 <code>10.1.1.0</code>（即 255.255.255.0）网段，其广播地址为 <code>10.1.1.255</code>，当发出一个目的地址为 <code>10.1.1.255</code> 的数据包时，它将被分发给该网段上的所有计算机。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231005150331.png\" alt=\"广播地址示范\"></p>\n<p>广播地址主要有两类：</p>\n<ul>\n<li><em>受限广播</em><br>路由器不会转发受限广播的数据包，但同一个子网的所有主机都会接收到受限广播的数据包。IP 地址的网络号和主机号均为 255 就是受限广播地址 <code>255.255.255.255</code>。</li>\n<li><em>直接广播&#x2F;定向广播</em><br>直接广播可以被路由转发，发送到目标网络的所有主机。例如，IP 地址为 <code>192.168.2.1</code> 的主机也可以发送广播到 <code>192.168.1.0</code> 网络。IP 地址的网络字段定义这个网络，主机号通常为 255，如 <code>192.168.10.0/24</code> 的直接广播地址为：<code>192.168.10.255</code>。</li>\n</ul>\n<h3 id=\"组播地址\"><a href=\"#组播地址\" class=\"headerlink\" title=\"组播地址\"></a>组播地址</h3><p>组播地址（Multicast Address）是用于一对多通信的一种特殊IP地址。它允许一个主机发送数据包到加入了特定组播组的所有主机。</p>\n<h3 id=\"环回地址\"><a href=\"#环回地址\" class=\"headerlink\" title=\"环回地址\"></a>环回地址</h3><p>环回地址是一个特殊的 IP 地址，用于网络中的设备向自身发送通信。在 IPv4 中，回环地址的范围是 <code>127.0.0.1</code> 到 <code>127.255.255.254</code>。</p>\n<p>环回地址有以下几个主要用途：</p>\n<ol>\n<li><em>测试网络配置</em><br>如果你能够成功地 ping 通 <code>127.0.0.1</code>，那就说明你的网络配置没有问题。</li>\n<li><em>运行本地服务</em><br>有些服务器&#x2F;客户端应用程序在运行时需要调用服务器上的资源。当这些程序需要在同一台机器上运行而没有其他服务器时，可以将服务器的资源装在本机，将服务器的IP地址设为 <code>127.0.0.1</code>。</li>\n<li><em>路由器管理</em><br>在配置路由器时，通常会将环回地址作为管理地址。例如，我们可以通过 telnet IP 到你所要管理的那个路由器，这个 IP 就是你所设置的环回地址。</li>\n</ol>\n<p>开发人员经常使用环回地址来测试网络应用。例如，如果你正在开发一个 Web 服务器，并且想要在本地测试它，你可以启动服务器并让它监听127.0.0.1 上的某个端口。然后，你可以打开浏览器并导航到<code>http://127.0.0.1:port</code>（其中 <code>port</code> 是你的服务器正在监听的端口），以查看服务器的响应。</p>\n<p>关于我们常用的<code>localhost</code>和<code>127.0.0.1</code>，二者可以互换使用，实际上我们在使用时也是这么做的。但二者还是存在区别的：</p>\n<ul>\n<li><code>127.0.0.1</code> 不需要解析，<code>localhost</code> 需要解析查找其对应的 IP 地址。</li>\n<li>依据上一条，<code>localhost</code> 并不一定解析为 <code>127.0.0.1</code>，也可能解析为地址环回块中的其它地址。</li>\n</ul>\n<h3 id=\"私有地址\"><a href=\"#私有地址\" class=\"headerlink\" title=\"私有地址\"></a>私有地址</h3><p>私有地址是指在互联网上不公开使用，而只在局域网内部使用的IP地址。私有地址的作用是节省公网IP地址的资源，同时也提高了网络安全性。私有地址有以下三个范围：</p>\n<ul>\n<li>A 类私有地址：<code>10.0.0.0</code> ~ <code>10.255.255.255</code>，可以容纳约 1.6 亿个主机，适用于大型网络。</li>\n<li>B 类私有地址：<code>172.16.0.0</code> ~ <code>172.31.255.255</code>，可以容纳约 100 万个主机，适用于中等规模的网络。</li>\n<li>C 类私有地址：<code>192.168.0.0</code> ~ <code>192.168.255.255</code>，可以容纳约 65000 个主机，适用于小型网络。</li>\n</ul>\n<p>私有地址不能直接访问互联网，需要通过网络地址转换（NAT）技术将其转换为公网IP地址才能与外部网络通信。</p>\n<h2 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h2><p>在了解“子网掩码”之前，你需要先知道 <a href=\"https://www.zhihu.com/question/21064101\">什么是“子网”</a></p>\n<p>子网掩码（Subnet Mask）是一种用于指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。它是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”，对应到常用的十进制就是 <code>xxx.xxx.xxx.xxx</code>。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</p>\n<p>子网掩码的唯一作用是将某个 IP 地址划分成网络号和主机号两部分。这样做可以提高 IP 地址的分配效率，有效解决 IP 地址资源紧张的问题。同时，网路管理员也可以利用子网掩码，人为地将一个大型内网划分为更多个小规模的子网，再利用交换机的路由功能实现子网互联，从而有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。</p>\n<p>这里举个 Web 开发中使用子网掩码的例子：</p>\n<p>假设我们有一个服务器，其 IP 地址为 <code>192.168.1.1</code>，并且我们希望该服务器只能与同一子网内的其他设备进行通信。这时，我们可以将子网掩码设置为 <code>255.255.255.0</code>，这样就只有 IP 地址在 <code>192.168.1.0</code> 到 <code>192.168.1.255</code> 范围内的设备才能与该服务器进行通信。</p>\n<h2 id=\"常用设备\"><a href=\"#常用设备\" class=\"headerlink\" title=\"常用设备\"></a>常用设备</h2><h3 id=\"集线器-hub\"><a href=\"#集线器-hub\" class=\"headerlink\" title=\"集线器 hub\"></a><em>集线器 hub</em></h3><p>集线器充当网络中计算机和其他设备的连接点。<br>当集线器接收到来自某一端口的数据包后，它无法直接把数据包发送给目标节点，而是会采取“广播”的方式，把数据报发送给其他所有与集线器相连的端口。<br>所有与这个集线器相连的计算机都会接收到这个数据包，即使它们不是目标节点。</p>\n<p>集线器有些缺点：以广播的方式传送数据不安全；数据包向所有节点同时发送可能造成网络堵塞，降低了网络执行效率；非双工传输的通信效率低……</p>\n<p>但因为集线器便宜且易于设置使用，现实生活中集线器依然能够得到应用，比如家庭或小型企业的内部网络。但在注重效率和安全性的场合，会使用交换机代替集线器。</p>\n<h3 id=\"交换机-switch\"><a href=\"#交换机-switch\" class=\"headerlink\" title=\"交换机 switch\"></a><em>交换机 switch</em></h3><p>交换机同样充当网络中计算机和其他设备的连接点。</p>\n<p>交换机工作在模型的物理层和数据链路层，它通过自学习和维护 MAC 地址信息，对以太网帧进行高速而透明的交换转发。当接收到数据帧时，交换机会查找内存中的地址对照表以确定目的 MAC（网卡的硬件地址）的 NIC（网卡）挂接在哪个端口上。然后，通过内部交换矩阵迅速将数据包传送到目标端口，这种工作方式使得交换机具有更高的性能和安全性。</p>\n<p>除此之外，相比于集线器，交换机有一些优点：<br>只有目标设备能看到数据包，这有效控制了网络流量，提高网络执行效率；<br>交换机能够实现全双工操作，这意味着交换机可以同时接收和发送数据，这种特性使得交换机在处理大量网络流量时具有很高的效率；<br>交换机可以使用 VLAN（虚拟局域网）技术来隔离广播，见效广播范围，进一步提高安全性和网络性能……</p>\n<h3 id=\"路由器-router\"><a href=\"#路由器-router\" class=\"headerlink\" title=\"路由器 router\"></a><em>路由器 router</em></h3><p>路由器是一种智能的网络设备，通常是一个专门设计用来理解、操作和指导流量的小型计算设备，提供了路由和转送两种机制。<br>它工作在 OSI 模型的网络层，通过运行路由协议（如 RIP、OSPF、BGP）来维护一张路由表。路由表记录了不同目的地网络的最佳路径。</p>\n<p>路由器决定数据包从来源端到目的端所经过的路径，这个过程称为 <em>路由</em>；路由器将输入端的数据包移送至适当的路由器输出端，这称为 <em>转送</em>。</p>\n<p>当接收到数据包时，路由器会查看数据包的目标 IP 地址，并根据路由表选择合适的出口接口转发数据包。<br>如果目标 IP 地址不在路由表中，路由器会将数据包发送到默认网关。</p>\n<p>这种工作方式使得路由器具有以下优点：</p>\n<ul>\n<li>路由器可以连接不同类型和规模的网络，如 LAN、WAN、MAN 等。</li>\n<li>路由器可以根据网络拓扑和流量状况动态地调整最佳路径。</li>\n<li>路由器可以过滤广播信息，减少网络拥塞。</li>\n<li>路由器可以提供高级的安全功能，如防火墙、VPN、NAT 等。</li>\n</ul>\n<p>路由器，也被称为三层网络设备。</p>\n<h3 id=\"网桥-bridge\"><a href=\"#网桥-bridge\" class=\"headerlink\" title=\"网桥 bridge\"></a><em>网桥 bridge</em></h3><p>网桥，也被称为桥接器，是一种用于连接两个局域网的存储&#x2F;转发设备。它能将一个大的局域网分割为多个网段，或将两个以上的局域网互联为一个逻辑局域网，使局域网上的所有用户都可以访问服务器。</p>\n<p>网桥工作在数据链路层，在不同或相同类型的 LAN 之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。</p>\n<h3 id=\"网关-gateway\"><a href=\"#网关-gateway\" class=\"headerlink\" title=\"网关 gateway\"></a><em>网关 gateway</em></h3><p>网关，又叫网间连接器、协议转换器，作用是在传输层以上实现网络互连，但仅用于两个高层协议不同的网络互连。</p>\n<p>在传统 TCP&#x2F;IP 术语中，网络设备只分成两种：一种为网关，另一种为主机。网关能在网络间转递数据包，但主机不能转送数据包。在主机中，数据包需经过四层协议处理，但是在网关中只需要到达网络层，决定路径之后就可以转送。在当时，网关与路由器还没有区别。但在现代网络术语中，网关与路由器的定义不同：网关能在不同协议间移动资料，而路由器是在不同网络间移动资料。</p>\n<p>网关既可以用于广域网互连，也可以用于局域网互连。<br>在使用不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。<br>与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求，并提供一定的过滤以及安全防护功能。</p>\n<h2 id=\"常见协议\"><a href=\"#常见协议\" class=\"headerlink\" title=\"常见协议\"></a>常见协议</h2><p>太常见的就不做记录了，比如 TCP&#x2F;IP 和 HTTP，这种协议接触 Web 的时候就应该已经看了……</p>\n<h3 id=\"ARP-RARP\"><a href=\"#ARP-RARP\" class=\"headerlink\" title=\"ARP&#x2F;RARP\"></a>ARP&#x2F;RARP</h3><p><code>ARP 协议</code>（Address Resolution Protocol）是一个用于将 IP 地址解析为 MAC 地址的协议。</p>\n<p>当主机或路由器有数据要发送给另一台主机或路由器时，需要知道对方的网络层地址（即 IP 地址）。<br>主机发送信息时将包含目标 IP 地址的 ARP 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；<br>收到返回消息后，将该 IP 地址和物理地址存入本机 ARP 缓存中并保留一定时间，下次请求时直接查询 ARP 缓存以节约资源。</p>\n<p>在实际开发中，ARP 协议主要用于在同一局域网内进行通信。<br>当一个设备需要向另一个设备发送数据时，它会首先查看自己的 ARP 缓存，看是否已经有了目标设备的 MAC 地址。如果没有，它就会发送一个 ARP 请求，询问目标设备的MAC 地址。<br>然后，目标设备会回应这个请求，提供它的 MAC 地址，发送设备则将这个 MAC 地址保存在它的ARP缓存中，以便将来使用。</p>\n<p><code>RARP 协议</code>（Reverse Address Resolution Protocol）则是根据 MAC 地址来获取 IP 地址。</p>\n<p>RARP 允许局域网的物理机器从网关服务器的 ARP 表或缓存上请求 IP 地址。<br>例如，局域网中有一台主机只知道自己的物理地址而不知道自己的 IP 地址，那么可以通过 RARP 协议发出征求自身 IP 地址的广播请求，然后由 RARP 服务器负责回答。</p>\n<p>在实际开发中，RARP 协议已经被 DHCP 协议所取代。</p>\n<h3 id=\"DHCP\"><a href=\"#DHCP\" class=\"headerlink\" title=\"DHCP\"></a>DHCP</h3><p><code>DHCP 协议</code>（Dynamic Host Configuration Protocol）是一种用于动态分配和配置网络参数（如 IP 地址、子网掩码、默认网关等）的协议。它可以简化网络管理，提高 IP 地址的利用率，避免 IP 地址冲突等问题。</p>\n<p>DHCP 协议的工作原理主要包括四个步骤¹：</p>\n<ol>\n<li><em>发现阶段</em><br>DHCP 客户端广播发送一个 <code>DHCP Discover</code> 报文，以发现网络中的 DHCP 服务器。</li>\n<li><em>提供阶段</em><br>所有收到 Discover 报文的 DHCP 服务器都会发送一个 <code>DHCP Offer</code> 报文，告知用户本服务器可以为其提供IP地址。</li>\n<li><em>请求阶段</em><br>DHCP 客户端选择一个 Offer 应答报文，并向该服务器发送一个广播的 <code>DHCP Request</code> 请求报文，通告选择的服务器，希望获得所分配的 IP 地址。</li>\n<li><em>确认阶段</em><br>当 DHCP 服务器收到 Request 请求报文后，发送一个 <code>DHCP ACK</code> 应答报文，通知用户可以使用分配的 IP 地址。</li>\n</ol>\n<p>在实际开发中，DHCP 协议主要用于在局域网内动态分配 IP 地址。当一个设备需要获取网络参数时，它会向 DHCP 服务器发送请求，然后服务器会从预定义的地址池中分配一个 IP 地址，并将这个 IP 地址和其他相关信息（如子网掩码、默认网关等）返回给设备。<br>这样，设备就可以自动获取并配置网络参数，无需手动设置。</p>\n<p>至于前文为什么说 RARP 协议已经被 DHCP 协议所取代，主要是因为 RARP 协议只能提供 IP 地址，而不能提供其他网络参数（如子网掩码、默认网关等）。<br>而且，RARP 协议需要在每台主机上都设置一个 RARP 服务器，这在大型网络中是不现实的。<br>相比之下，DHCP 协议可以提供完整的网络配置信息，并且只需要在网络中设置一个或几个 DHCP 服务器即可。</p>\n<p>你可以使用 <code>dig</code> 命令在 Linux 下使用 DHCP 协议获取指定域名所在主机的公网 IP 地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dig +short ma5hr00m.top @resolver1.opendns.com</span><br><span class=\"line\"><span class=\"comment\"># 如果你想查询更详细的信息，去除 +short 参数即可</span></span><br></pre></td></tr></table></figure>\n\n<p>这条命令会向 <code>OpenDNS</code> 的解析器发送一个 DNS 查询请求，查询 <code>ma5hr00m.top</code> 域名的记录。<br>OpenDNS 的解析器会返回发送请求的公网 IP 。</p>\n<h3 id=\"路由选择协议\"><a href=\"#路由选择协议\" class=\"headerlink\" title=\"路由选择协议\"></a>路由选择协议</h3><p>路由选择协议是一种网络协议，它决定了数据包在网络中的传输路径。这些协议基于不同的网络性能参数（如带宽、延迟、跳数等）来确定最优路径。</p>\n<h4 id=\"RIP\"><a href=\"#RIP\" class=\"headerlink\" title=\"RIP\"></a>RIP</h4><p><code>RIP</code>（Routing Information Protocol）是一种基于距离向量的路由选择协议，最大的优点是简单。<br>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（距离向量）。<br>RIP 认为一个好的路由就是它通过的路由器的数目少，即 <em>距离短</em>，它要求一条路径最多只能包含 15 个路由器。</p>\n<p>由于存在路由环路、可拓展性差等问题，RIP 逐渐被 OSPF 替代。</p>\n<h4 id=\"OSPF\"><a href=\"#OSPF\" class=\"headerlink\" title=\"OSPF\"></a>OSPF</h4><p><code>OSPF </code>（Open Shortest Path First）是一种基于链路状态的路由协议，它从设计上就保证了无路由环路。<br>OSPF 支持区域的划分，区域内部的路由器使用 SPF 最短路径算法保证了区域内部的无环路。OSPF还利用区域间的连接规则保证了区域之间无路由环路。</p>\n<p>在实际开发中，开发者通常需要配置网络设备（如路由器）以使用 OSPF 协议。</p>\n<p>如果你想玩玩 OSPF 协议，可以参考这篇文章：<a href=\"https://blog.csdn.net/weixin_46505636/article/details/128629176\">Ubuntu20.04 利用 FRR 配置 OSPF 路由协议</a></p>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>关于 DNS 协议和 DNSSEC，可以看看这篇文章，写得更详细一些：<a href=\"/posts/network/dnssec\">DNSSEC协议</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.runoob.com/w3cnote/summary-of-network.html\">计算机网络基础知识总结 - 菜鸟教程</a></li>\n<li><a href=\"https://www.jc2182.com/cn/cn-jiaocheng.html\">计算机网络教程</a></li>\n<li><a href=\"https://themillergroup.com/differences-hubs-switches-routers/\">Hubs, Switches And Routers Explained</a></li>\n<li><a href=\"https://www.jianshu.com/p/c793a279f698\">计算机网络漫谈：OSI七层模型与TCP&#x2F;IP四层（参考）模型</a></li>\n<li><a href=\"https://www.freecodecamp.org/chinese/news/osi-model-networking-layers/\">白话 OSI 七层网络模型</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/165142303\">什么是网关，网关的作用是什么</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/tcp-ip-model/?ref=lbp\">TCP&#x2F;IP Model</a></li>\n<li><a href=\"https://blog.csdn.net/tennysonsky/article/details/45564479\">广播地址介绍 - CSDN</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/353821843\">IP地址的分类及范围详解 - 知乎</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/498255136\">一文解析IP地址 - 知乎</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2149791\">什么是环回地址127.0.0.1</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/371400090\">子网掩码是什么？有什么作用？</a></li>\n<li><a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html\">什么是 ARP - 华为</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/265293856\">DHCP 详解 - 知乎</a></li>\n<li><a href=\"https://blog.csdn.net/TheCarol/article/details/112106308\">RIP 协议详解</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/616791347\">什么是OSPF？为什么要用OSPF？附OSPF配置实例</a></li>\n</ul>\n"},{"title":"DNSSEC 安全拓展","date":"2023-12-10T16:00:00.000Z","author":"ma5hr00m","_content":"\n网络安全技术理论课程的Topic主题，倒也是很有意思。\n\n## 脆弱的DNS\nDNS（Domain Name System）是一种用于将易于理解的域名转换为计算机可读的IP地址的系统。\n从其功能来说，它就像互联网中的“电话簿”，通过管理域名和IP地址之间的映射关系，使得计算机和其他网络设备能够相互通信。\n\n举个例子：用户在浏览器中访问一个域名，比如`ma5hr00m.top`，需要先知道这个域名对应的IP地址，计算机通过DNS查询到域名对应的IP地址是`101.35.240.239`，它就会与这个IP对应的机器通信。\n\n更详细地说“通过DNS查询到域名对应的IP”这个过程：DNS系统由多个层级的域名服务器组成，这些服务器相互协作来处理DNS查询。当用户在浏览器中输入域名并请求访问网站时，操作系统会向*本地DNS解析器*发出查询请求。如果本地解析器缓存了相应的IP地址，它会直接返回结果；否则，它会向互联网上的*根域名服务器*发出请求。根域名服务器会指导本地解析器到达*顶级域名服务器*，然后再到达*次级域名服务器*，直到找到负责特定域名的*权威域名服务器*。最终，权威域名服务器会返回所请求域名对应的IP地址，使得用户的设备能够连接到相应的服务器。\n\n该流程可以总结成这张图，更好理解：\n\n![DNS流程图](https://img.ma5hr00m.top/blog/20231208062310.png)\n\n现在我们知道什么是DNS了，那我们为什么需要DNS？因为直接记忆IP地址比较麻烦（尤其是IPV6出现之后），而有意义的字符串更方便记忆。`20.205.243.166`和`github.com`，我们愿意记哪一个呢？\n\n我们可以使用`nslookup xxx.xxx`指令来查询域名对应的IP地址。该工具包含在`dnsutils`（Debian/Arch）和`bind-utils`（CentOS/RHEL）中。\n\nDNS最早在1983年的[RFC 882](https://datatracker.ietf.org/doc/html/rfc882)中定义，并提供了技术实现，现今已成为互联网的基础设施之一。但经过多年发展，互联网环境日趋复杂，远不像那个时代那般“单纯”，DNS的脆弱就体现出来了。\n\n理由无他，DNS在设计之初就没有提供任何安全措施：基于UDP的明文数据传输、无身份验证、无数据完整性验证……如果我们仅使用传统的DNS协议，这无异于只穿条裤衩就上街。对于有心者，我们的数据一览无遗。\n\n后世的人们自然也发现了这个问题，毕竟谁都不想让自己的数据裸奔。然后就出现了很多种解决方案，比如为DNS服务器添加入侵检测系统、设置DNS过滤器、对应的加密协议`DNS on TLS`……这其中，就包括DNS安全拓展，也就是DNSSEC。\n\n## 可靠的DNSSEC\nDNSSEC（Domain Name System Security Extensions）是一种用于增强域名系统（DNS）安全性的协议扩展，也就是由 IETF 提供的一套DNS安全认证机制（可参考[RFC 2535](https://tools.ietf.org/html/rfc2535)）。它通过添加加密验证机制，防止DNS查询过程中的欺骗和篡改，确保用户访问的网站和服务器是合法和可信的。\n\n## 相关概念\n### 新的DNS记录类型\nDNSSEC通过向现有DNS记录添加加密签名，确保域名系统的安全性，这些数字签名与`A、AAAA、MX、CNAME`等常见记录类型一起存储在DNS名称服务器中。计算机可以通过检查相关签名，去验证请求的DNS记录是否来自权威名称服务器，以及有没有被篡改过。\n\n- RRSIG：包含加密签名\n- DNSKEY：包含公共签名密钥\n- DS：包含DNSKEY记录的Hash\n- NSEC和NSEC3：用于明确否认DNS记录的存在\n- CDNSKEY和CDS：用于请求对父区域中的DS记录进行更新的子区域。\n\n先有个印象，下文细说，\n\n### Resource Record Set\n资源记录集，即RRSets。使用 DNSSEC 保护某个区域的第一步，是将所有相同类型的记录分组到一个RRSets中，也就是进行分组。\n\n比如，example.com域下有三条AAAA类型的记录，分别为：\n\n- `a.example.com 300 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7334`\n- `b.example.com 600 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7335`\n- `c.example.com 900 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7336`\n\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208073028.png\" alt=\"KSK&ZSK\">\n</div>\n\n我们可以将其捆绑到同一组中，这就是一个RRset。\n\n### Zone-Singing Key\n区域签名密钥，即ZSK。\n\nDNSSEC中的每个区域都有一个ZSK。ZSK通常是RSA密钥对，包括公钥（公用）和私钥（专用）两部分，其中专用部分对区域中的每个RRset进行数字签名，而公共部分则验证签名。\n\n为了启用DNSSEC，区域操作员需要使用ZSK专用部分为每个RRset创建数字签名，并将其作为`RRSIG`记录存储在名称服务器中，并将公用共用部分添加到`DNSKEY`记录中的名称服务器，使其可用。\n\n当DNSSEC解析器请求特定的记录类型（例如 AAAA）时，名称服务器就返回相应的`RRSIG`。然后，解析器可以从名称服务器中提取包含ZSK共用部分的`DNSKEY`记录。就这样，RRset、RRSIG和公共ZSK将一同用于验证响应。\n\n### Key-Singing Key\n密钥签名密钥，即KSK。\n\nKSK验证`DNSKEY`记录的方式与上文ZSK保护RRset的方式相同：\n使用KSK的私钥签署ZSK公钥（存储在 DNSKEY 记录中），并为其`DNSKEY`创建`RRSIG`；然后，计算机将KSK放入DNSKEY记录中。\n\n就像公共ZSK一样，名称服务器将公共KSK发布在另一个`DNSKEY`记录中，而这就给计算机提供了上面显示的`DNSKEY`RRset。\n公共KSK和公共ZSK均由私有KSK签名。然后，解析器就可以使用公共KSK来验证公共ZSK。\n\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208115854.png\" alt=\"KSK&ZSK\">\n</div>\n\n简单地说，KSK就是用于保护密钥的密钥。\nZSK负责保护RRset的安全，KSK负责保护ZSK的安全。\n而KSK的主要作用是建立信任链，将父区域的信任传递给子区域。\n\n### Delegation Signer\n委派签名者，即DS。\n\nDNSSEC引入了DS记录，用于在父区域和子区域之间建立*信任链*。区域操作员将子区域的公共KSK的Hash作为DS记录发布到父区域。当解析器引用子区域时，父区域提供DS记录，解析器通过比较子区域公共KSK的哈希值和父区域的DS记录来验证公共KSK的有效性。如果匹配成功，解析器就可以信任子区域的所有记录。\n\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208123822.png\" alt=\"KSK&ZSK\">\n</div>\n\n### 信任链\n这一套操作下来，我们使用RRset+ZSK+KSK的认证机制保证了区域内的安全，又通过DS保证了子区域到父区域的安全。那问题来了：我们应该如何信任DS记录呢，换句话说，我们该如何得知父区域是否安全可信？\n\n那自然是去找父区域的父区域啦～\n\nDS记录本身就像其他任何RRset一样签署，这意味着它在父级中也具有相应的RRSIG。我们所要做的就是不断重复上面的过程，区域内的ZSK+KSK验证做完就去找父区域的公共KSK，父区域的KSK+ZSK验证完成就继续往上找……这样的验证方式就会自底而上形成一条链子，称为*信任链*。\n\n链子总归是有个头的。我们向链子的根源不断摸索，最后看到的是——\n\n![DNSSEC根签名仪式人员在ICANN的合影](https://www.cloudflare.com/img/products/official-ceremony-photo.jpg)\n\n### 根域签名仪式\n像前文所说，我们不断重复验证，最终来到信任链的终点（或者说起点）——*根DNS区域*。那现在问题来了：根区域没有父区域。我们可以在根DNS区域获取一个`RRSIG`记录，通过这个记录验证根名称服务器的公共KSK和ZSK。但我们没有所需的DS来验证这个`RRSIG`记录的安全性。\n\n怎么办呢？\n即使是聪明的大脑也没有合适的解决方法，所以，我们采取了朴实无华的方法……\n\n每隔一段时间，相关负责机构会召集一群人，以公开且经严格审核的方式签署*根DNSKEY RRset*，继而产生一条`RRSIG`记录用于验证根名称服务器的公共KSK和ZSK。也就是说，根区域的公共KSK是没有DS记录来保证安全性的，我们只是假定它足够安全有效。\n\n当然啦，事实上也足够安全。我无意去介绍这个仪式的流程，总之就是十分的严谨繁琐冗长——都是为了互联网的安全。仪式最后得到的就是那条`RSSIG`数据。\n\n前面说到过，整个仪式的过程是公开的，这个[视频](https://www.youtube.com/watch?v=EOb0Zu3hy2U)是距本篇博客写作最近的一次根域签名仪式录播，长达4.5h。这篇[文章](https://www.cloudflare.com/zh-cn/dns/dnssec/root-signing-ceremony/)则是对根域签名仪式全过程的记述。\n\n### 为什么需要KSK\nDNS是一个分层系统，各区域很少独立运行。\n像上文说的DS记录，就是为了将父区域的信任传递给子区域，DS记录本身就是公共KSK的Hash。\n只要更换KSK就需要更改父区域的DS记录。\n而更改DS记录是一个多步骤的过程，如果执行不正确，最终可能会破坏该区域。\n\n这意味着，更换KSK的成本很高。如果我们把ZSK和KSK合二为一，使其既承担信任传递功能又承担加密RRset功能，那我们每次想要对子区域内密钥进行更换都会变得繁琐。而更换ZSK只需要在特定区域内进行操作，不会涉及到父区域的DS记录的修改。将二者独立开来，就可以在保证信任链的前提下，提供更好的灵活性，使区域操作员更容易更换ZSK，以保证RRset的安全。\n\nKSK用于建立信任链，确保子区域的公钥的有效性；而ZSK用于签名特定区域的数据，保证数据的完整性和身份验证。d\n\n## 完整流程\n前面讲得比较零散，可能你仍不清楚一次`DNS with DNSSEC`查询到底要怎么将以上所有点结合起来。我下面以`ma5hr00m.top`为例，走一遍完整的流程：\n\n1. 解析器向根域名服务器发送查询请求，询问顶级域名服务器(.域)的NS记录。\n2. 根域名服务器回复解析器，提供顶级域名服务器(.域)的NS记录。\n3. 解析器向顶级域名服务器(.域)发送查询请求，询问`.ma5hr00m.top`域的NS记录。\n4. 顶级域名服务器(.域)回复解析器，提供`ma5hr00m.top`域的NS记录。\n5. 解析器向`ma5hr00m.top`域的权威域名服务器发送查询请求，询问`ma5hr00m.top`域的A记录。\n6. 权威域名服务器回复解析器，提供`ma5hr00m.top`域的A记录为`101.35.240.239`。\n7. 解析器同时获取到`ma5hr00m.top`域的A记录的`RRSet`的签名`RRSIG`，并使用该签名的`ZSK`进行验证，确保数据的完整性和身份验证。\n8. 解析器向`ma5hr00m.top`域的权威域名服务器发送查询请求，询问`ma5hr00m.top`域的`DNSKEY`记录。\n9. 权威域名服务器回复解析器，提供`ma5hr00m.top`域的`ZSK`和`KSK`公钥，并同时提供`DNSKEY RRSet`的签名`RRSIG`。\n10. 解析器使用获取到的`KSK`验证上一步得到的`DNSKEY`记录，确保数据的完整性和身份验证。\n11. 解析器使用获取到的`ZSK`验证第五步得到的A记录，确保数据的完整性和身份验证。\n12. 为了保证`DNSKEY RRSIG`中的KSK不被伪造，解析器请求`.ma5hr00m.top`域与`ma5hr00m.top`相关的DS记录，并获取到DS记录的`RRSIG`。\n13. 解析器计算`KSK`的哈希值，并使用获取到的DS记录的`RRSIG`进行验证，确保数据的完整性和身份验证。\n14. 解析器重复步骤12和步骤13，向顶级域名服务器(.域)请求`.ma5hr00m.top`域的DS记录，并获取到DS记录的`RRSIG`。\n15. 解析器重复步骤12和步骤13，向根域名服务器请求`.ma5hr00m.top`域的DS记录，并获取到DS记录的`RRSIG`。\n16. 解析器使用根域名服务器提供的DS记录的`RRSIG`进行验证，确保数据的完整性和身份验证。\n17. 验证通过后，解析器将最终的结果`101.35.240.239`返回给用户。\n\n然后，我们就安全地获取到了`ma5hr00m.top`对应的IP地址：`101.35.240.239`！\n\n## DNSSEC的优劣\n原理讲完了，说说为什么要使用DNSSEC。\n\n作为一个安全拓展，使用DNSSEC最重要的好处就是保护DNS提供的数据，确保互联网上的路标（DNS记录）指向正确的内容或服务，以防止攻击者篡改DNS数据，导致用户被引导到错误的网站或不安全的地方。从根本上来讲，就是保护用户的安全。具体点说，就是可以在一定程度上防止DNS投毒、DNS劫持、DNS重放等攻击手段。\n\n数据变得可信之后，相继地，这份可信的数据也会促进全球DNS的应用。我们利用这些数据创建了一个*安全的域名/值数据库*，这个安全的数据库可以提供多种创新机会，支持新的技术、服务和设施。互联网研究人员就可以利用这些“干净”的数据来做一些有趣的实验，研发一些新技术。比如DANE（DNS-based Authentication of Named Entitie）就是在利用DNS中受DNSSEC保护的数据，期望解决当前互联网安全连接方法中存在的一些漏洞。\n\n此外呢，从广义上来讲，DNS 涉及两个方面：发布，由注册人或其代理执行；以及解析，通常由网络运营商（例如，互联网服务提供商）来完成。\n也就是说，使用DNSSEC需要两端同时发力。\n\n而DNSSEC很早就大规模部署了。所有根域名服务器在2010年就部署了DNSSEC，若干顶级域名（`.org`、`.com`、`.net`和`.edu`等）服务器也在2011年部署了DNSSEC。\n相比其他DNS保护措施，DNSSEC的普及度可以说是遥遥领先了，多数公共的域名服务器都支持它。\n\n> DNSSEC支持情况：[Notable public DNS servicde operators](https://en.wikipedia.org/wiki/Public_recursive_name_server#Notable_public_DNS_service_operators)\n\nDNSSEC也是最早大规模部署的。在 2010 年的时候，所有根域名服务器都已经部署了 DNSSEC。到了 2011 年，若干顶级域名（.org 和 .com 和 .net 和 .edu）也部署了 DNSSEC。\n\n但是，DNSSEC也并不完美。DNSSEC仅仅是对传输的数据做了数字签名，但未进行加密。如果你的网络流量被别人监视，他依然可以得知你在访问什么域名。可是是出于这个原因，Chrome曾支持过DNSSEC但随后移除，Firefox则从未支持过DNSSEC。\n\n另外，DNSSEC的使用显著增加了DNS查询响应的数量（需要额外的字段和加密信息来正确验证记录），这就增加了计算机增加遭受分布式拒绝服务 (DDoS) 攻击的风险。\n\n## 后话\n可能是出于对部署DNSSEC收益的考量，DNS出现于1980年，相关安全问题在08-11年大规模爆发，直到2013年，DNSSEC才开始快速普及。截至2021年，尽管DNSSEC解析服务器只占总量的 17.4%，但其请求量已经超过七成。按照国家来看，平均使用率为14%，而中国的DNSSEC使用率仅6%左右。\n\n## 参考 \n- [什么是 DNS | DNS 的工作方式](https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/)，by CloudFlare\n- [DNSSEC 如何运作](https://www.cloudflare.com/zh-cn/dns/dnssec/how-dnssec-works/)，by CloudFlare\n- [4种DNS安全协议对比](https://www.wosign.com/News/news_2019032201.htm)，by WoTrust\n- [重启DNS根密钥服务器的七个人](https://www.cernet.com/hlwjsyj/202009/4606.html)，by 赛尔网络\n- [DNSSEC：保护DNS的安全](https://www.icann.org/zh/system/files/files/octo-006-24jul20-zh.pdf)，by ICANN首席技术官办公室\n- [对比4种强化域名安全的协议](https://herbertgao.com/15/#DNSSEC)，by HerbertGao0\n- [DNSSEC的选择：Yes还是No？](https://www.edu.cn/xxh/zt/tj/202305/t20230518_2408472.shtml)，by 中国教育网络 ","source":"_posts/dnssec.md","raw":"---\ntitle: DNSSEC 安全拓展\ndate: 2023/12/11\nauthor: ma5hr00m\ncategories:\n- Network\n---\n\n网络安全技术理论课程的Topic主题，倒也是很有意思。\n\n## 脆弱的DNS\nDNS（Domain Name System）是一种用于将易于理解的域名转换为计算机可读的IP地址的系统。\n从其功能来说，它就像互联网中的“电话簿”，通过管理域名和IP地址之间的映射关系，使得计算机和其他网络设备能够相互通信。\n\n举个例子：用户在浏览器中访问一个域名，比如`ma5hr00m.top`，需要先知道这个域名对应的IP地址，计算机通过DNS查询到域名对应的IP地址是`101.35.240.239`，它就会与这个IP对应的机器通信。\n\n更详细地说“通过DNS查询到域名对应的IP”这个过程：DNS系统由多个层级的域名服务器组成，这些服务器相互协作来处理DNS查询。当用户在浏览器中输入域名并请求访问网站时，操作系统会向*本地DNS解析器*发出查询请求。如果本地解析器缓存了相应的IP地址，它会直接返回结果；否则，它会向互联网上的*根域名服务器*发出请求。根域名服务器会指导本地解析器到达*顶级域名服务器*，然后再到达*次级域名服务器*，直到找到负责特定域名的*权威域名服务器*。最终，权威域名服务器会返回所请求域名对应的IP地址，使得用户的设备能够连接到相应的服务器。\n\n该流程可以总结成这张图，更好理解：\n\n![DNS流程图](https://img.ma5hr00m.top/blog/20231208062310.png)\n\n现在我们知道什么是DNS了，那我们为什么需要DNS？因为直接记忆IP地址比较麻烦（尤其是IPV6出现之后），而有意义的字符串更方便记忆。`20.205.243.166`和`github.com`，我们愿意记哪一个呢？\n\n我们可以使用`nslookup xxx.xxx`指令来查询域名对应的IP地址。该工具包含在`dnsutils`（Debian/Arch）和`bind-utils`（CentOS/RHEL）中。\n\nDNS最早在1983年的[RFC 882](https://datatracker.ietf.org/doc/html/rfc882)中定义，并提供了技术实现，现今已成为互联网的基础设施之一。但经过多年发展，互联网环境日趋复杂，远不像那个时代那般“单纯”，DNS的脆弱就体现出来了。\n\n理由无他，DNS在设计之初就没有提供任何安全措施：基于UDP的明文数据传输、无身份验证、无数据完整性验证……如果我们仅使用传统的DNS协议，这无异于只穿条裤衩就上街。对于有心者，我们的数据一览无遗。\n\n后世的人们自然也发现了这个问题，毕竟谁都不想让自己的数据裸奔。然后就出现了很多种解决方案，比如为DNS服务器添加入侵检测系统、设置DNS过滤器、对应的加密协议`DNS on TLS`……这其中，就包括DNS安全拓展，也就是DNSSEC。\n\n## 可靠的DNSSEC\nDNSSEC（Domain Name System Security Extensions）是一种用于增强域名系统（DNS）安全性的协议扩展，也就是由 IETF 提供的一套DNS安全认证机制（可参考[RFC 2535](https://tools.ietf.org/html/rfc2535)）。它通过添加加密验证机制，防止DNS查询过程中的欺骗和篡改，确保用户访问的网站和服务器是合法和可信的。\n\n## 相关概念\n### 新的DNS记录类型\nDNSSEC通过向现有DNS记录添加加密签名，确保域名系统的安全性，这些数字签名与`A、AAAA、MX、CNAME`等常见记录类型一起存储在DNS名称服务器中。计算机可以通过检查相关签名，去验证请求的DNS记录是否来自权威名称服务器，以及有没有被篡改过。\n\n- RRSIG：包含加密签名\n- DNSKEY：包含公共签名密钥\n- DS：包含DNSKEY记录的Hash\n- NSEC和NSEC3：用于明确否认DNS记录的存在\n- CDNSKEY和CDS：用于请求对父区域中的DS记录进行更新的子区域。\n\n先有个印象，下文细说，\n\n### Resource Record Set\n资源记录集，即RRSets。使用 DNSSEC 保护某个区域的第一步，是将所有相同类型的记录分组到一个RRSets中，也就是进行分组。\n\n比如，example.com域下有三条AAAA类型的记录，分别为：\n\n- `a.example.com 300 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7334`\n- `b.example.com 600 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7335`\n- `c.example.com 900 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7336`\n\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208073028.png\" alt=\"KSK&ZSK\">\n</div>\n\n我们可以将其捆绑到同一组中，这就是一个RRset。\n\n### Zone-Singing Key\n区域签名密钥，即ZSK。\n\nDNSSEC中的每个区域都有一个ZSK。ZSK通常是RSA密钥对，包括公钥（公用）和私钥（专用）两部分，其中专用部分对区域中的每个RRset进行数字签名，而公共部分则验证签名。\n\n为了启用DNSSEC，区域操作员需要使用ZSK专用部分为每个RRset创建数字签名，并将其作为`RRSIG`记录存储在名称服务器中，并将公用共用部分添加到`DNSKEY`记录中的名称服务器，使其可用。\n\n当DNSSEC解析器请求特定的记录类型（例如 AAAA）时，名称服务器就返回相应的`RRSIG`。然后，解析器可以从名称服务器中提取包含ZSK共用部分的`DNSKEY`记录。就这样，RRset、RRSIG和公共ZSK将一同用于验证响应。\n\n### Key-Singing Key\n密钥签名密钥，即KSK。\n\nKSK验证`DNSKEY`记录的方式与上文ZSK保护RRset的方式相同：\n使用KSK的私钥签署ZSK公钥（存储在 DNSKEY 记录中），并为其`DNSKEY`创建`RRSIG`；然后，计算机将KSK放入DNSKEY记录中。\n\n就像公共ZSK一样，名称服务器将公共KSK发布在另一个`DNSKEY`记录中，而这就给计算机提供了上面显示的`DNSKEY`RRset。\n公共KSK和公共ZSK均由私有KSK签名。然后，解析器就可以使用公共KSK来验证公共ZSK。\n\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208115854.png\" alt=\"KSK&ZSK\">\n</div>\n\n简单地说，KSK就是用于保护密钥的密钥。\nZSK负责保护RRset的安全，KSK负责保护ZSK的安全。\n而KSK的主要作用是建立信任链，将父区域的信任传递给子区域。\n\n### Delegation Signer\n委派签名者，即DS。\n\nDNSSEC引入了DS记录，用于在父区域和子区域之间建立*信任链*。区域操作员将子区域的公共KSK的Hash作为DS记录发布到父区域。当解析器引用子区域时，父区域提供DS记录，解析器通过比较子区域公共KSK的哈希值和父区域的DS记录来验证公共KSK的有效性。如果匹配成功，解析器就可以信任子区域的所有记录。\n\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208123822.png\" alt=\"KSK&ZSK\">\n</div>\n\n### 信任链\n这一套操作下来，我们使用RRset+ZSK+KSK的认证机制保证了区域内的安全，又通过DS保证了子区域到父区域的安全。那问题来了：我们应该如何信任DS记录呢，换句话说，我们该如何得知父区域是否安全可信？\n\n那自然是去找父区域的父区域啦～\n\nDS记录本身就像其他任何RRset一样签署，这意味着它在父级中也具有相应的RRSIG。我们所要做的就是不断重复上面的过程，区域内的ZSK+KSK验证做完就去找父区域的公共KSK，父区域的KSK+ZSK验证完成就继续往上找……这样的验证方式就会自底而上形成一条链子，称为*信任链*。\n\n链子总归是有个头的。我们向链子的根源不断摸索，最后看到的是——\n\n![DNSSEC根签名仪式人员在ICANN的合影](https://www.cloudflare.com/img/products/official-ceremony-photo.jpg)\n\n### 根域签名仪式\n像前文所说，我们不断重复验证，最终来到信任链的终点（或者说起点）——*根DNS区域*。那现在问题来了：根区域没有父区域。我们可以在根DNS区域获取一个`RRSIG`记录，通过这个记录验证根名称服务器的公共KSK和ZSK。但我们没有所需的DS来验证这个`RRSIG`记录的安全性。\n\n怎么办呢？\n即使是聪明的大脑也没有合适的解决方法，所以，我们采取了朴实无华的方法……\n\n每隔一段时间，相关负责机构会召集一群人，以公开且经严格审核的方式签署*根DNSKEY RRset*，继而产生一条`RRSIG`记录用于验证根名称服务器的公共KSK和ZSK。也就是说，根区域的公共KSK是没有DS记录来保证安全性的，我们只是假定它足够安全有效。\n\n当然啦，事实上也足够安全。我无意去介绍这个仪式的流程，总之就是十分的严谨繁琐冗长——都是为了互联网的安全。仪式最后得到的就是那条`RSSIG`数据。\n\n前面说到过，整个仪式的过程是公开的，这个[视频](https://www.youtube.com/watch?v=EOb0Zu3hy2U)是距本篇博客写作最近的一次根域签名仪式录播，长达4.5h。这篇[文章](https://www.cloudflare.com/zh-cn/dns/dnssec/root-signing-ceremony/)则是对根域签名仪式全过程的记述。\n\n### 为什么需要KSK\nDNS是一个分层系统，各区域很少独立运行。\n像上文说的DS记录，就是为了将父区域的信任传递给子区域，DS记录本身就是公共KSK的Hash。\n只要更换KSK就需要更改父区域的DS记录。\n而更改DS记录是一个多步骤的过程，如果执行不正确，最终可能会破坏该区域。\n\n这意味着，更换KSK的成本很高。如果我们把ZSK和KSK合二为一，使其既承担信任传递功能又承担加密RRset功能，那我们每次想要对子区域内密钥进行更换都会变得繁琐。而更换ZSK只需要在特定区域内进行操作，不会涉及到父区域的DS记录的修改。将二者独立开来，就可以在保证信任链的前提下，提供更好的灵活性，使区域操作员更容易更换ZSK，以保证RRset的安全。\n\nKSK用于建立信任链，确保子区域的公钥的有效性；而ZSK用于签名特定区域的数据，保证数据的完整性和身份验证。d\n\n## 完整流程\n前面讲得比较零散，可能你仍不清楚一次`DNS with DNSSEC`查询到底要怎么将以上所有点结合起来。我下面以`ma5hr00m.top`为例，走一遍完整的流程：\n\n1. 解析器向根域名服务器发送查询请求，询问顶级域名服务器(.域)的NS记录。\n2. 根域名服务器回复解析器，提供顶级域名服务器(.域)的NS记录。\n3. 解析器向顶级域名服务器(.域)发送查询请求，询问`.ma5hr00m.top`域的NS记录。\n4. 顶级域名服务器(.域)回复解析器，提供`ma5hr00m.top`域的NS记录。\n5. 解析器向`ma5hr00m.top`域的权威域名服务器发送查询请求，询问`ma5hr00m.top`域的A记录。\n6. 权威域名服务器回复解析器，提供`ma5hr00m.top`域的A记录为`101.35.240.239`。\n7. 解析器同时获取到`ma5hr00m.top`域的A记录的`RRSet`的签名`RRSIG`，并使用该签名的`ZSK`进行验证，确保数据的完整性和身份验证。\n8. 解析器向`ma5hr00m.top`域的权威域名服务器发送查询请求，询问`ma5hr00m.top`域的`DNSKEY`记录。\n9. 权威域名服务器回复解析器，提供`ma5hr00m.top`域的`ZSK`和`KSK`公钥，并同时提供`DNSKEY RRSet`的签名`RRSIG`。\n10. 解析器使用获取到的`KSK`验证上一步得到的`DNSKEY`记录，确保数据的完整性和身份验证。\n11. 解析器使用获取到的`ZSK`验证第五步得到的A记录，确保数据的完整性和身份验证。\n12. 为了保证`DNSKEY RRSIG`中的KSK不被伪造，解析器请求`.ma5hr00m.top`域与`ma5hr00m.top`相关的DS记录，并获取到DS记录的`RRSIG`。\n13. 解析器计算`KSK`的哈希值，并使用获取到的DS记录的`RRSIG`进行验证，确保数据的完整性和身份验证。\n14. 解析器重复步骤12和步骤13，向顶级域名服务器(.域)请求`.ma5hr00m.top`域的DS记录，并获取到DS记录的`RRSIG`。\n15. 解析器重复步骤12和步骤13，向根域名服务器请求`.ma5hr00m.top`域的DS记录，并获取到DS记录的`RRSIG`。\n16. 解析器使用根域名服务器提供的DS记录的`RRSIG`进行验证，确保数据的完整性和身份验证。\n17. 验证通过后，解析器将最终的结果`101.35.240.239`返回给用户。\n\n然后，我们就安全地获取到了`ma5hr00m.top`对应的IP地址：`101.35.240.239`！\n\n## DNSSEC的优劣\n原理讲完了，说说为什么要使用DNSSEC。\n\n作为一个安全拓展，使用DNSSEC最重要的好处就是保护DNS提供的数据，确保互联网上的路标（DNS记录）指向正确的内容或服务，以防止攻击者篡改DNS数据，导致用户被引导到错误的网站或不安全的地方。从根本上来讲，就是保护用户的安全。具体点说，就是可以在一定程度上防止DNS投毒、DNS劫持、DNS重放等攻击手段。\n\n数据变得可信之后，相继地，这份可信的数据也会促进全球DNS的应用。我们利用这些数据创建了一个*安全的域名/值数据库*，这个安全的数据库可以提供多种创新机会，支持新的技术、服务和设施。互联网研究人员就可以利用这些“干净”的数据来做一些有趣的实验，研发一些新技术。比如DANE（DNS-based Authentication of Named Entitie）就是在利用DNS中受DNSSEC保护的数据，期望解决当前互联网安全连接方法中存在的一些漏洞。\n\n此外呢，从广义上来讲，DNS 涉及两个方面：发布，由注册人或其代理执行；以及解析，通常由网络运营商（例如，互联网服务提供商）来完成。\n也就是说，使用DNSSEC需要两端同时发力。\n\n而DNSSEC很早就大规模部署了。所有根域名服务器在2010年就部署了DNSSEC，若干顶级域名（`.org`、`.com`、`.net`和`.edu`等）服务器也在2011年部署了DNSSEC。\n相比其他DNS保护措施，DNSSEC的普及度可以说是遥遥领先了，多数公共的域名服务器都支持它。\n\n> DNSSEC支持情况：[Notable public DNS servicde operators](https://en.wikipedia.org/wiki/Public_recursive_name_server#Notable_public_DNS_service_operators)\n\nDNSSEC也是最早大规模部署的。在 2010 年的时候，所有根域名服务器都已经部署了 DNSSEC。到了 2011 年，若干顶级域名（.org 和 .com 和 .net 和 .edu）也部署了 DNSSEC。\n\n但是，DNSSEC也并不完美。DNSSEC仅仅是对传输的数据做了数字签名，但未进行加密。如果你的网络流量被别人监视，他依然可以得知你在访问什么域名。可是是出于这个原因，Chrome曾支持过DNSSEC但随后移除，Firefox则从未支持过DNSSEC。\n\n另外，DNSSEC的使用显著增加了DNS查询响应的数量（需要额外的字段和加密信息来正确验证记录），这就增加了计算机增加遭受分布式拒绝服务 (DDoS) 攻击的风险。\n\n## 后话\n可能是出于对部署DNSSEC收益的考量，DNS出现于1980年，相关安全问题在08-11年大规模爆发，直到2013年，DNSSEC才开始快速普及。截至2021年，尽管DNSSEC解析服务器只占总量的 17.4%，但其请求量已经超过七成。按照国家来看，平均使用率为14%，而中国的DNSSEC使用率仅6%左右。\n\n## 参考 \n- [什么是 DNS | DNS 的工作方式](https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/)，by CloudFlare\n- [DNSSEC 如何运作](https://www.cloudflare.com/zh-cn/dns/dnssec/how-dnssec-works/)，by CloudFlare\n- [4种DNS安全协议对比](https://www.wosign.com/News/news_2019032201.htm)，by WoTrust\n- [重启DNS根密钥服务器的七个人](https://www.cernet.com/hlwjsyj/202009/4606.html)，by 赛尔网络\n- [DNSSEC：保护DNS的安全](https://www.icann.org/zh/system/files/files/octo-006-24jul20-zh.pdf)，by ICANN首席技术官办公室\n- [对比4种强化域名安全的协议](https://herbertgao.com/15/#DNSSEC)，by HerbertGao0\n- [DNSSEC的选择：Yes还是No？](https://www.edu.cn/xxh/zt/tj/202305/t20230518_2408472.shtml)，by 中国教育网络 ","slug":"dnssec","published":1,"updated":"2024-06-09T12:55:30.968Z","comments":1,"layout":"post","photos":[],"_id":"clxhruaoy0007f4ly3u18dhkk","content":"<p>网络安全技术理论课程的Topic主题，倒也是很有意思。</p>\n<h2 id=\"脆弱的DNS\"><a href=\"#脆弱的DNS\" class=\"headerlink\" title=\"脆弱的DNS\"></a>脆弱的DNS</h2><p>DNS（Domain Name System）是一种用于将易于理解的域名转换为计算机可读的IP地址的系统。<br>从其功能来说，它就像互联网中的“电话簿”，通过管理域名和IP地址之间的映射关系，使得计算机和其他网络设备能够相互通信。</p>\n<p>举个例子：用户在浏览器中访问一个域名，比如<code>ma5hr00m.top</code>，需要先知道这个域名对应的IP地址，计算机通过DNS查询到域名对应的IP地址是<code>101.35.240.239</code>，它就会与这个IP对应的机器通信。</p>\n<p>更详细地说“通过DNS查询到域名对应的IP”这个过程：DNS系统由多个层级的域名服务器组成，这些服务器相互协作来处理DNS查询。当用户在浏览器中输入域名并请求访问网站时，操作系统会向<em>本地DNS解析器</em>发出查询请求。如果本地解析器缓存了相应的IP地址，它会直接返回结果；否则，它会向互联网上的<em>根域名服务器</em>发出请求。根域名服务器会指导本地解析器到达<em>顶级域名服务器</em>，然后再到达<em>次级域名服务器</em>，直到找到负责特定域名的<em>权威域名服务器</em>。最终，权威域名服务器会返回所请求域名对应的IP地址，使得用户的设备能够连接到相应的服务器。</p>\n<p>该流程可以总结成这张图，更好理解：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20231208062310.png\" alt=\"DNS流程图\"></p>\n<p>现在我们知道什么是DNS了，那我们为什么需要DNS？因为直接记忆IP地址比较麻烦（尤其是IPV6出现之后），而有意义的字符串更方便记忆。<code>20.205.243.166</code>和<code>github.com</code>，我们愿意记哪一个呢？</p>\n<p>我们可以使用<code>nslookup xxx.xxx</code>指令来查询域名对应的IP地址。该工具包含在<code>dnsutils</code>（Debian&#x2F;Arch）和<code>bind-utils</code>（CentOS&#x2F;RHEL）中。</p>\n<p>DNS最早在1983年的<a href=\"https://datatracker.ietf.org/doc/html/rfc882\">RFC 882</a>中定义，并提供了技术实现，现今已成为互联网的基础设施之一。但经过多年发展，互联网环境日趋复杂，远不像那个时代那般“单纯”，DNS的脆弱就体现出来了。</p>\n<p>理由无他，DNS在设计之初就没有提供任何安全措施：基于UDP的明文数据传输、无身份验证、无数据完整性验证……如果我们仅使用传统的DNS协议，这无异于只穿条裤衩就上街。对于有心者，我们的数据一览无遗。</p>\n<p>后世的人们自然也发现了这个问题，毕竟谁都不想让自己的数据裸奔。然后就出现了很多种解决方案，比如为DNS服务器添加入侵检测系统、设置DNS过滤器、对应的加密协议<code>DNS on TLS</code>……这其中，就包括DNS安全拓展，也就是DNSSEC。</p>\n<h2 id=\"可靠的DNSSEC\"><a href=\"#可靠的DNSSEC\" class=\"headerlink\" title=\"可靠的DNSSEC\"></a>可靠的DNSSEC</h2><p>DNSSEC（Domain Name System Security Extensions）是一种用于增强域名系统（DNS）安全性的协议扩展，也就是由 IETF 提供的一套DNS安全认证机制（可参考<a href=\"https://tools.ietf.org/html/rfc2535\">RFC 2535</a>）。它通过添加加密验证机制，防止DNS查询过程中的欺骗和篡改，确保用户访问的网站和服务器是合法和可信的。</p>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><h3 id=\"新的DNS记录类型\"><a href=\"#新的DNS记录类型\" class=\"headerlink\" title=\"新的DNS记录类型\"></a>新的DNS记录类型</h3><p>DNSSEC通过向现有DNS记录添加加密签名，确保域名系统的安全性，这些数字签名与<code>A、AAAA、MX、CNAME</code>等常见记录类型一起存储在DNS名称服务器中。计算机可以通过检查相关签名，去验证请求的DNS记录是否来自权威名称服务器，以及有没有被篡改过。</p>\n<ul>\n<li>RRSIG：包含加密签名</li>\n<li>DNSKEY：包含公共签名密钥</li>\n<li>DS：包含DNSKEY记录的Hash</li>\n<li>NSEC和NSEC3：用于明确否认DNS记录的存在</li>\n<li>CDNSKEY和CDS：用于请求对父区域中的DS记录进行更新的子区域。</li>\n</ul>\n<p>先有个印象，下文细说，</p>\n<h3 id=\"Resource-Record-Set\"><a href=\"#Resource-Record-Set\" class=\"headerlink\" title=\"Resource Record Set\"></a>Resource Record Set</h3><p>资源记录集，即RRSets。使用 DNSSEC 保护某个区域的第一步，是将所有相同类型的记录分组到一个RRSets中，也就是进行分组。</p>\n<p>比如，example.com域下有三条AAAA类型的记录，分别为：</p>\n<ul>\n<li><code>a.example.com 300 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7334</code></li>\n<li><code>b.example.com 600 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7335</code></li>\n<li><code>c.example.com 900 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7336</code></li>\n</ul>\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208073028.png\" alt=\"KSK&ZSK\">\n</div>\n\n<p>我们可以将其捆绑到同一组中，这就是一个RRset。</p>\n<h3 id=\"Zone-Singing-Key\"><a href=\"#Zone-Singing-Key\" class=\"headerlink\" title=\"Zone-Singing Key\"></a>Zone-Singing Key</h3><p>区域签名密钥，即ZSK。</p>\n<p>DNSSEC中的每个区域都有一个ZSK。ZSK通常是RSA密钥对，包括公钥（公用）和私钥（专用）两部分，其中专用部分对区域中的每个RRset进行数字签名，而公共部分则验证签名。</p>\n<p>为了启用DNSSEC，区域操作员需要使用ZSK专用部分为每个RRset创建数字签名，并将其作为<code>RRSIG</code>记录存储在名称服务器中，并将公用共用部分添加到<code>DNSKEY</code>记录中的名称服务器，使其可用。</p>\n<p>当DNSSEC解析器请求特定的记录类型（例如 AAAA）时，名称服务器就返回相应的<code>RRSIG</code>。然后，解析器可以从名称服务器中提取包含ZSK共用部分的<code>DNSKEY</code>记录。就这样，RRset、RRSIG和公共ZSK将一同用于验证响应。</p>\n<h3 id=\"Key-Singing-Key\"><a href=\"#Key-Singing-Key\" class=\"headerlink\" title=\"Key-Singing Key\"></a>Key-Singing Key</h3><p>密钥签名密钥，即KSK。</p>\n<p>KSK验证<code>DNSKEY</code>记录的方式与上文ZSK保护RRset的方式相同：<br>使用KSK的私钥签署ZSK公钥（存储在 DNSKEY 记录中），并为其<code>DNSKEY</code>创建<code>RRSIG</code>；然后，计算机将KSK放入DNSKEY记录中。</p>\n<p>就像公共ZSK一样，名称服务器将公共KSK发布在另一个<code>DNSKEY</code>记录中，而这就给计算机提供了上面显示的<code>DNSKEY</code>RRset。<br>公共KSK和公共ZSK均由私有KSK签名。然后，解析器就可以使用公共KSK来验证公共ZSK。</p>\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208115854.png\" alt=\"KSK&ZSK\">\n</div>\n\n<p>简单地说，KSK就是用于保护密钥的密钥。<br>ZSK负责保护RRset的安全，KSK负责保护ZSK的安全。<br>而KSK的主要作用是建立信任链，将父区域的信任传递给子区域。</p>\n<h3 id=\"Delegation-Signer\"><a href=\"#Delegation-Signer\" class=\"headerlink\" title=\"Delegation Signer\"></a>Delegation Signer</h3><p>委派签名者，即DS。</p>\n<p>DNSSEC引入了DS记录，用于在父区域和子区域之间建立<em>信任链</em>。区域操作员将子区域的公共KSK的Hash作为DS记录发布到父区域。当解析器引用子区域时，父区域提供DS记录，解析器通过比较子区域公共KSK的哈希值和父区域的DS记录来验证公共KSK的有效性。如果匹配成功，解析器就可以信任子区域的所有记录。</p>\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208123822.png\" alt=\"KSK&ZSK\">\n</div>\n\n<h3 id=\"信任链\"><a href=\"#信任链\" class=\"headerlink\" title=\"信任链\"></a>信任链</h3><p>这一套操作下来，我们使用RRset+ZSK+KSK的认证机制保证了区域内的安全，又通过DS保证了子区域到父区域的安全。那问题来了：我们应该如何信任DS记录呢，换句话说，我们该如何得知父区域是否安全可信？</p>\n<p>那自然是去找父区域的父区域啦～</p>\n<p>DS记录本身就像其他任何RRset一样签署，这意味着它在父级中也具有相应的RRSIG。我们所要做的就是不断重复上面的过程，区域内的ZSK+KSK验证做完就去找父区域的公共KSK，父区域的KSK+ZSK验证完成就继续往上找……这样的验证方式就会自底而上形成一条链子，称为<em>信任链</em>。</p>\n<p>链子总归是有个头的。我们向链子的根源不断摸索，最后看到的是——</p>\n<p><img src=\"https://www.cloudflare.com/img/products/official-ceremony-photo.jpg\" alt=\"DNSSEC根签名仪式人员在ICANN的合影\"></p>\n<h3 id=\"根域签名仪式\"><a href=\"#根域签名仪式\" class=\"headerlink\" title=\"根域签名仪式\"></a>根域签名仪式</h3><p>像前文所说，我们不断重复验证，最终来到信任链的终点（或者说起点）——<em>根DNS区域</em>。那现在问题来了：根区域没有父区域。我们可以在根DNS区域获取一个<code>RRSIG</code>记录，通过这个记录验证根名称服务器的公共KSK和ZSK。但我们没有所需的DS来验证这个<code>RRSIG</code>记录的安全性。</p>\n<p>怎么办呢？<br>即使是聪明的大脑也没有合适的解决方法，所以，我们采取了朴实无华的方法……</p>\n<p>每隔一段时间，相关负责机构会召集一群人，以公开且经严格审核的方式签署<em>根DNSKEY RRset</em>，继而产生一条<code>RRSIG</code>记录用于验证根名称服务器的公共KSK和ZSK。也就是说，根区域的公共KSK是没有DS记录来保证安全性的，我们只是假定它足够安全有效。</p>\n<p>当然啦，事实上也足够安全。我无意去介绍这个仪式的流程，总之就是十分的严谨繁琐冗长——都是为了互联网的安全。仪式最后得到的就是那条<code>RSSIG</code>数据。</p>\n<p>前面说到过，整个仪式的过程是公开的，这个<a href=\"https://www.youtube.com/watch?v=EOb0Zu3hy2U\">视频</a>是距本篇博客写作最近的一次根域签名仪式录播，长达4.5h。这篇<a href=\"https://www.cloudflare.com/zh-cn/dns/dnssec/root-signing-ceremony/\">文章</a>则是对根域签名仪式全过程的记述。</p>\n<h3 id=\"为什么需要KSK\"><a href=\"#为什么需要KSK\" class=\"headerlink\" title=\"为什么需要KSK\"></a>为什么需要KSK</h3><p>DNS是一个分层系统，各区域很少独立运行。<br>像上文说的DS记录，就是为了将父区域的信任传递给子区域，DS记录本身就是公共KSK的Hash。<br>只要更换KSK就需要更改父区域的DS记录。<br>而更改DS记录是一个多步骤的过程，如果执行不正确，最终可能会破坏该区域。</p>\n<p>这意味着，更换KSK的成本很高。如果我们把ZSK和KSK合二为一，使其既承担信任传递功能又承担加密RRset功能，那我们每次想要对子区域内密钥进行更换都会变得繁琐。而更换ZSK只需要在特定区域内进行操作，不会涉及到父区域的DS记录的修改。将二者独立开来，就可以在保证信任链的前提下，提供更好的灵活性，使区域操作员更容易更换ZSK，以保证RRset的安全。</p>\n<p>KSK用于建立信任链，确保子区域的公钥的有效性；而ZSK用于签名特定区域的数据，保证数据的完整性和身份验证。d</p>\n<h2 id=\"完整流程\"><a href=\"#完整流程\" class=\"headerlink\" title=\"完整流程\"></a>完整流程</h2><p>前面讲得比较零散，可能你仍不清楚一次<code>DNS with DNSSEC</code>查询到底要怎么将以上所有点结合起来。我下面以<code>ma5hr00m.top</code>为例，走一遍完整的流程：</p>\n<ol>\n<li>解析器向根域名服务器发送查询请求，询问顶级域名服务器(.域)的NS记录。</li>\n<li>根域名服务器回复解析器，提供顶级域名服务器(.域)的NS记录。</li>\n<li>解析器向顶级域名服务器(.域)发送查询请求，询问<code>.ma5hr00m.top</code>域的NS记录。</li>\n<li>顶级域名服务器(.域)回复解析器，提供<code>ma5hr00m.top</code>域的NS记录。</li>\n<li>解析器向<code>ma5hr00m.top</code>域的权威域名服务器发送查询请求，询问<code>ma5hr00m.top</code>域的A记录。</li>\n<li>权威域名服务器回复解析器，提供<code>ma5hr00m.top</code>域的A记录为<code>101.35.240.239</code>。</li>\n<li>解析器同时获取到<code>ma5hr00m.top</code>域的A记录的<code>RRSet</code>的签名<code>RRSIG</code>，并使用该签名的<code>ZSK</code>进行验证，确保数据的完整性和身份验证。</li>\n<li>解析器向<code>ma5hr00m.top</code>域的权威域名服务器发送查询请求，询问<code>ma5hr00m.top</code>域的<code>DNSKEY</code>记录。</li>\n<li>权威域名服务器回复解析器，提供<code>ma5hr00m.top</code>域的<code>ZSK</code>和<code>KSK</code>公钥，并同时提供<code>DNSKEY RRSet</code>的签名<code>RRSIG</code>。</li>\n<li>解析器使用获取到的<code>KSK</code>验证上一步得到的<code>DNSKEY</code>记录，确保数据的完整性和身份验证。</li>\n<li>解析器使用获取到的<code>ZSK</code>验证第五步得到的A记录，确保数据的完整性和身份验证。</li>\n<li>为了保证<code>DNSKEY RRSIG</code>中的KSK不被伪造，解析器请求<code>.ma5hr00m.top</code>域与<code>ma5hr00m.top</code>相关的DS记录，并获取到DS记录的<code>RRSIG</code>。</li>\n<li>解析器计算<code>KSK</code>的哈希值，并使用获取到的DS记录的<code>RRSIG</code>进行验证，确保数据的完整性和身份验证。</li>\n<li>解析器重复步骤12和步骤13，向顶级域名服务器(.域)请求<code>.ma5hr00m.top</code>域的DS记录，并获取到DS记录的<code>RRSIG</code>。</li>\n<li>解析器重复步骤12和步骤13，向根域名服务器请求<code>.ma5hr00m.top</code>域的DS记录，并获取到DS记录的<code>RRSIG</code>。</li>\n<li>解析器使用根域名服务器提供的DS记录的<code>RRSIG</code>进行验证，确保数据的完整性和身份验证。</li>\n<li>验证通过后，解析器将最终的结果<code>101.35.240.239</code>返回给用户。</li>\n</ol>\n<p>然后，我们就安全地获取到了<code>ma5hr00m.top</code>对应的IP地址：<code>101.35.240.239</code>！</p>\n<h2 id=\"DNSSEC的优劣\"><a href=\"#DNSSEC的优劣\" class=\"headerlink\" title=\"DNSSEC的优劣\"></a>DNSSEC的优劣</h2><p>原理讲完了，说说为什么要使用DNSSEC。</p>\n<p>作为一个安全拓展，使用DNSSEC最重要的好处就是保护DNS提供的数据，确保互联网上的路标（DNS记录）指向正确的内容或服务，以防止攻击者篡改DNS数据，导致用户被引导到错误的网站或不安全的地方。从根本上来讲，就是保护用户的安全。具体点说，就是可以在一定程度上防止DNS投毒、DNS劫持、DNS重放等攻击手段。</p>\n<p>数据变得可信之后，相继地，这份可信的数据也会促进全球DNS的应用。我们利用这些数据创建了一个<em>安全的域名&#x2F;值数据库</em>，这个安全的数据库可以提供多种创新机会，支持新的技术、服务和设施。互联网研究人员就可以利用这些“干净”的数据来做一些有趣的实验，研发一些新技术。比如DANE（DNS-based Authentication of Named Entitie）就是在利用DNS中受DNSSEC保护的数据，期望解决当前互联网安全连接方法中存在的一些漏洞。</p>\n<p>此外呢，从广义上来讲，DNS 涉及两个方面：发布，由注册人或其代理执行；以及解析，通常由网络运营商（例如，互联网服务提供商）来完成。<br>也就是说，使用DNSSEC需要两端同时发力。</p>\n<p>而DNSSEC很早就大规模部署了。所有根域名服务器在2010年就部署了DNSSEC，若干顶级域名（<code>.org</code>、<code>.com</code>、<code>.net</code>和<code>.edu</code>等）服务器也在2011年部署了DNSSEC。<br>相比其他DNS保护措施，DNSSEC的普及度可以说是遥遥领先了，多数公共的域名服务器都支持它。</p>\n<blockquote>\n<p>DNSSEC支持情况：<a href=\"https://en.wikipedia.org/wiki/Public_recursive_name_server#Notable_public_DNS_service_operators\">Notable public DNS servicde operators</a></p>\n</blockquote>\n<p>DNSSEC也是最早大规模部署的。在 2010 年的时候，所有根域名服务器都已经部署了 DNSSEC。到了 2011 年，若干顶级域名（.org 和 .com 和 .net 和 .edu）也部署了 DNSSEC。</p>\n<p>但是，DNSSEC也并不完美。DNSSEC仅仅是对传输的数据做了数字签名，但未进行加密。如果你的网络流量被别人监视，他依然可以得知你在访问什么域名。可是是出于这个原因，Chrome曾支持过DNSSEC但随后移除，Firefox则从未支持过DNSSEC。</p>\n<p>另外，DNSSEC的使用显著增加了DNS查询响应的数量（需要额外的字段和加密信息来正确验证记录），这就增加了计算机增加遭受分布式拒绝服务 (DDoS) 攻击的风险。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>可能是出于对部署DNSSEC收益的考量，DNS出现于1980年，相关安全问题在08-11年大规模爆发，直到2013年，DNSSEC才开始快速普及。截至2021年，尽管DNSSEC解析服务器只占总量的 17.4%，但其请求量已经超过七成。按照国家来看，平均使用率为14%，而中国的DNSSEC使用率仅6%左右。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/\">什么是 DNS | DNS 的工作方式</a>，by CloudFlare</li>\n<li><a href=\"https://www.cloudflare.com/zh-cn/dns/dnssec/how-dnssec-works/\">DNSSEC 如何运作</a>，by CloudFlare</li>\n<li><a href=\"https://www.wosign.com/News/news_2019032201.htm\">4种DNS安全协议对比</a>，by WoTrust</li>\n<li><a href=\"https://www.cernet.com/hlwjsyj/202009/4606.html\">重启DNS根密钥服务器的七个人</a>，by 赛尔网络</li>\n<li><a href=\"https://www.icann.org/zh/system/files/files/octo-006-24jul20-zh.pdf\">DNSSEC：保护DNS的安全</a>，by ICANN首席技术官办公室</li>\n<li><a href=\"https://herbertgao.com/15/#DNSSEC\">对比4种强化域名安全的协议</a>，by HerbertGao0</li>\n<li><a href=\"https://www.edu.cn/xxh/zt/tj/202305/t20230518_2408472.shtml\">DNSSEC的选择：Yes还是No？</a>，by 中国教育网络</li>\n</ul>\n","excerpt":"","more":"<p>网络安全技术理论课程的Topic主题，倒也是很有意思。</p>\n<h2 id=\"脆弱的DNS\"><a href=\"#脆弱的DNS\" class=\"headerlink\" title=\"脆弱的DNS\"></a>脆弱的DNS</h2><p>DNS（Domain Name System）是一种用于将易于理解的域名转换为计算机可读的IP地址的系统。<br>从其功能来说，它就像互联网中的“电话簿”，通过管理域名和IP地址之间的映射关系，使得计算机和其他网络设备能够相互通信。</p>\n<p>举个例子：用户在浏览器中访问一个域名，比如<code>ma5hr00m.top</code>，需要先知道这个域名对应的IP地址，计算机通过DNS查询到域名对应的IP地址是<code>101.35.240.239</code>，它就会与这个IP对应的机器通信。</p>\n<p>更详细地说“通过DNS查询到域名对应的IP”这个过程：DNS系统由多个层级的域名服务器组成，这些服务器相互协作来处理DNS查询。当用户在浏览器中输入域名并请求访问网站时，操作系统会向<em>本地DNS解析器</em>发出查询请求。如果本地解析器缓存了相应的IP地址，它会直接返回结果；否则，它会向互联网上的<em>根域名服务器</em>发出请求。根域名服务器会指导本地解析器到达<em>顶级域名服务器</em>，然后再到达<em>次级域名服务器</em>，直到找到负责特定域名的<em>权威域名服务器</em>。最终，权威域名服务器会返回所请求域名对应的IP地址，使得用户的设备能够连接到相应的服务器。</p>\n<p>该流程可以总结成这张图，更好理解：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20231208062310.png\" alt=\"DNS流程图\"></p>\n<p>现在我们知道什么是DNS了，那我们为什么需要DNS？因为直接记忆IP地址比较麻烦（尤其是IPV6出现之后），而有意义的字符串更方便记忆。<code>20.205.243.166</code>和<code>github.com</code>，我们愿意记哪一个呢？</p>\n<p>我们可以使用<code>nslookup xxx.xxx</code>指令来查询域名对应的IP地址。该工具包含在<code>dnsutils</code>（Debian&#x2F;Arch）和<code>bind-utils</code>（CentOS&#x2F;RHEL）中。</p>\n<p>DNS最早在1983年的<a href=\"https://datatracker.ietf.org/doc/html/rfc882\">RFC 882</a>中定义，并提供了技术实现，现今已成为互联网的基础设施之一。但经过多年发展，互联网环境日趋复杂，远不像那个时代那般“单纯”，DNS的脆弱就体现出来了。</p>\n<p>理由无他，DNS在设计之初就没有提供任何安全措施：基于UDP的明文数据传输、无身份验证、无数据完整性验证……如果我们仅使用传统的DNS协议，这无异于只穿条裤衩就上街。对于有心者，我们的数据一览无遗。</p>\n<p>后世的人们自然也发现了这个问题，毕竟谁都不想让自己的数据裸奔。然后就出现了很多种解决方案，比如为DNS服务器添加入侵检测系统、设置DNS过滤器、对应的加密协议<code>DNS on TLS</code>……这其中，就包括DNS安全拓展，也就是DNSSEC。</p>\n<h2 id=\"可靠的DNSSEC\"><a href=\"#可靠的DNSSEC\" class=\"headerlink\" title=\"可靠的DNSSEC\"></a>可靠的DNSSEC</h2><p>DNSSEC（Domain Name System Security Extensions）是一种用于增强域名系统（DNS）安全性的协议扩展，也就是由 IETF 提供的一套DNS安全认证机制（可参考<a href=\"https://tools.ietf.org/html/rfc2535\">RFC 2535</a>）。它通过添加加密验证机制，防止DNS查询过程中的欺骗和篡改，确保用户访问的网站和服务器是合法和可信的。</p>\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><h3 id=\"新的DNS记录类型\"><a href=\"#新的DNS记录类型\" class=\"headerlink\" title=\"新的DNS记录类型\"></a>新的DNS记录类型</h3><p>DNSSEC通过向现有DNS记录添加加密签名，确保域名系统的安全性，这些数字签名与<code>A、AAAA、MX、CNAME</code>等常见记录类型一起存储在DNS名称服务器中。计算机可以通过检查相关签名，去验证请求的DNS记录是否来自权威名称服务器，以及有没有被篡改过。</p>\n<ul>\n<li>RRSIG：包含加密签名</li>\n<li>DNSKEY：包含公共签名密钥</li>\n<li>DS：包含DNSKEY记录的Hash</li>\n<li>NSEC和NSEC3：用于明确否认DNS记录的存在</li>\n<li>CDNSKEY和CDS：用于请求对父区域中的DS记录进行更新的子区域。</li>\n</ul>\n<p>先有个印象，下文细说，</p>\n<h3 id=\"Resource-Record-Set\"><a href=\"#Resource-Record-Set\" class=\"headerlink\" title=\"Resource Record Set\"></a>Resource Record Set</h3><p>资源记录集，即RRSets。使用 DNSSEC 保护某个区域的第一步，是将所有相同类型的记录分组到一个RRSets中，也就是进行分组。</p>\n<p>比如，example.com域下有三条AAAA类型的记录，分别为：</p>\n<ul>\n<li><code>a.example.com 300 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7334</code></li>\n<li><code>b.example.com 600 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7335</code></li>\n<li><code>c.example.com 900 IN AAAA 2001:0db8:85a3:0000:0000:8a2e:0370:7336</code></li>\n</ul>\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208073028.png\" alt=\"KSK&ZSK\">\n</div>\n\n<p>我们可以将其捆绑到同一组中，这就是一个RRset。</p>\n<h3 id=\"Zone-Singing-Key\"><a href=\"#Zone-Singing-Key\" class=\"headerlink\" title=\"Zone-Singing Key\"></a>Zone-Singing Key</h3><p>区域签名密钥，即ZSK。</p>\n<p>DNSSEC中的每个区域都有一个ZSK。ZSK通常是RSA密钥对，包括公钥（公用）和私钥（专用）两部分，其中专用部分对区域中的每个RRset进行数字签名，而公共部分则验证签名。</p>\n<p>为了启用DNSSEC，区域操作员需要使用ZSK专用部分为每个RRset创建数字签名，并将其作为<code>RRSIG</code>记录存储在名称服务器中，并将公用共用部分添加到<code>DNSKEY</code>记录中的名称服务器，使其可用。</p>\n<p>当DNSSEC解析器请求特定的记录类型（例如 AAAA）时，名称服务器就返回相应的<code>RRSIG</code>。然后，解析器可以从名称服务器中提取包含ZSK共用部分的<code>DNSKEY</code>记录。就这样，RRset、RRSIG和公共ZSK将一同用于验证响应。</p>\n<h3 id=\"Key-Singing-Key\"><a href=\"#Key-Singing-Key\" class=\"headerlink\" title=\"Key-Singing Key\"></a>Key-Singing Key</h3><p>密钥签名密钥，即KSK。</p>\n<p>KSK验证<code>DNSKEY</code>记录的方式与上文ZSK保护RRset的方式相同：<br>使用KSK的私钥签署ZSK公钥（存储在 DNSKEY 记录中），并为其<code>DNSKEY</code>创建<code>RRSIG</code>；然后，计算机将KSK放入DNSKEY记录中。</p>\n<p>就像公共ZSK一样，名称服务器将公共KSK发布在另一个<code>DNSKEY</code>记录中，而这就给计算机提供了上面显示的<code>DNSKEY</code>RRset。<br>公共KSK和公共ZSK均由私有KSK签名。然后，解析器就可以使用公共KSK来验证公共ZSK。</p>\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208115854.png\" alt=\"KSK&ZSK\">\n</div>\n\n<p>简单地说，KSK就是用于保护密钥的密钥。<br>ZSK负责保护RRset的安全，KSK负责保护ZSK的安全。<br>而KSK的主要作用是建立信任链，将父区域的信任传递给子区域。</p>\n<h3 id=\"Delegation-Signer\"><a href=\"#Delegation-Signer\" class=\"headerlink\" title=\"Delegation Signer\"></a>Delegation Signer</h3><p>委派签名者，即DS。</p>\n<p>DNSSEC引入了DS记录，用于在父区域和子区域之间建立<em>信任链</em>。区域操作员将子区域的公共KSK的Hash作为DS记录发布到父区域。当解析器引用子区域时，父区域提供DS记录，解析器通过比较子区域公共KSK的哈希值和父区域的DS记录来验证公共KSK的有效性。如果匹配成功，解析器就可以信任子区域的所有记录。</p>\n<div align=\"center\">\n  <img style=\"width:100%;\" src=\"https://img.ma5hr00m.top/blog/20231208123822.png\" alt=\"KSK&ZSK\">\n</div>\n\n<h3 id=\"信任链\"><a href=\"#信任链\" class=\"headerlink\" title=\"信任链\"></a>信任链</h3><p>这一套操作下来，我们使用RRset+ZSK+KSK的认证机制保证了区域内的安全，又通过DS保证了子区域到父区域的安全。那问题来了：我们应该如何信任DS记录呢，换句话说，我们该如何得知父区域是否安全可信？</p>\n<p>那自然是去找父区域的父区域啦～</p>\n<p>DS记录本身就像其他任何RRset一样签署，这意味着它在父级中也具有相应的RRSIG。我们所要做的就是不断重复上面的过程，区域内的ZSK+KSK验证做完就去找父区域的公共KSK，父区域的KSK+ZSK验证完成就继续往上找……这样的验证方式就会自底而上形成一条链子，称为<em>信任链</em>。</p>\n<p>链子总归是有个头的。我们向链子的根源不断摸索，最后看到的是——</p>\n<p><img src=\"https://www.cloudflare.com/img/products/official-ceremony-photo.jpg\" alt=\"DNSSEC根签名仪式人员在ICANN的合影\"></p>\n<h3 id=\"根域签名仪式\"><a href=\"#根域签名仪式\" class=\"headerlink\" title=\"根域签名仪式\"></a>根域签名仪式</h3><p>像前文所说，我们不断重复验证，最终来到信任链的终点（或者说起点）——<em>根DNS区域</em>。那现在问题来了：根区域没有父区域。我们可以在根DNS区域获取一个<code>RRSIG</code>记录，通过这个记录验证根名称服务器的公共KSK和ZSK。但我们没有所需的DS来验证这个<code>RRSIG</code>记录的安全性。</p>\n<p>怎么办呢？<br>即使是聪明的大脑也没有合适的解决方法，所以，我们采取了朴实无华的方法……</p>\n<p>每隔一段时间，相关负责机构会召集一群人，以公开且经严格审核的方式签署<em>根DNSKEY RRset</em>，继而产生一条<code>RRSIG</code>记录用于验证根名称服务器的公共KSK和ZSK。也就是说，根区域的公共KSK是没有DS记录来保证安全性的，我们只是假定它足够安全有效。</p>\n<p>当然啦，事实上也足够安全。我无意去介绍这个仪式的流程，总之就是十分的严谨繁琐冗长——都是为了互联网的安全。仪式最后得到的就是那条<code>RSSIG</code>数据。</p>\n<p>前面说到过，整个仪式的过程是公开的，这个<a href=\"https://www.youtube.com/watch?v=EOb0Zu3hy2U\">视频</a>是距本篇博客写作最近的一次根域签名仪式录播，长达4.5h。这篇<a href=\"https://www.cloudflare.com/zh-cn/dns/dnssec/root-signing-ceremony/\">文章</a>则是对根域签名仪式全过程的记述。</p>\n<h3 id=\"为什么需要KSK\"><a href=\"#为什么需要KSK\" class=\"headerlink\" title=\"为什么需要KSK\"></a>为什么需要KSK</h3><p>DNS是一个分层系统，各区域很少独立运行。<br>像上文说的DS记录，就是为了将父区域的信任传递给子区域，DS记录本身就是公共KSK的Hash。<br>只要更换KSK就需要更改父区域的DS记录。<br>而更改DS记录是一个多步骤的过程，如果执行不正确，最终可能会破坏该区域。</p>\n<p>这意味着，更换KSK的成本很高。如果我们把ZSK和KSK合二为一，使其既承担信任传递功能又承担加密RRset功能，那我们每次想要对子区域内密钥进行更换都会变得繁琐。而更换ZSK只需要在特定区域内进行操作，不会涉及到父区域的DS记录的修改。将二者独立开来，就可以在保证信任链的前提下，提供更好的灵活性，使区域操作员更容易更换ZSK，以保证RRset的安全。</p>\n<p>KSK用于建立信任链，确保子区域的公钥的有效性；而ZSK用于签名特定区域的数据，保证数据的完整性和身份验证。d</p>\n<h2 id=\"完整流程\"><a href=\"#完整流程\" class=\"headerlink\" title=\"完整流程\"></a>完整流程</h2><p>前面讲得比较零散，可能你仍不清楚一次<code>DNS with DNSSEC</code>查询到底要怎么将以上所有点结合起来。我下面以<code>ma5hr00m.top</code>为例，走一遍完整的流程：</p>\n<ol>\n<li>解析器向根域名服务器发送查询请求，询问顶级域名服务器(.域)的NS记录。</li>\n<li>根域名服务器回复解析器，提供顶级域名服务器(.域)的NS记录。</li>\n<li>解析器向顶级域名服务器(.域)发送查询请求，询问<code>.ma5hr00m.top</code>域的NS记录。</li>\n<li>顶级域名服务器(.域)回复解析器，提供<code>ma5hr00m.top</code>域的NS记录。</li>\n<li>解析器向<code>ma5hr00m.top</code>域的权威域名服务器发送查询请求，询问<code>ma5hr00m.top</code>域的A记录。</li>\n<li>权威域名服务器回复解析器，提供<code>ma5hr00m.top</code>域的A记录为<code>101.35.240.239</code>。</li>\n<li>解析器同时获取到<code>ma5hr00m.top</code>域的A记录的<code>RRSet</code>的签名<code>RRSIG</code>，并使用该签名的<code>ZSK</code>进行验证，确保数据的完整性和身份验证。</li>\n<li>解析器向<code>ma5hr00m.top</code>域的权威域名服务器发送查询请求，询问<code>ma5hr00m.top</code>域的<code>DNSKEY</code>记录。</li>\n<li>权威域名服务器回复解析器，提供<code>ma5hr00m.top</code>域的<code>ZSK</code>和<code>KSK</code>公钥，并同时提供<code>DNSKEY RRSet</code>的签名<code>RRSIG</code>。</li>\n<li>解析器使用获取到的<code>KSK</code>验证上一步得到的<code>DNSKEY</code>记录，确保数据的完整性和身份验证。</li>\n<li>解析器使用获取到的<code>ZSK</code>验证第五步得到的A记录，确保数据的完整性和身份验证。</li>\n<li>为了保证<code>DNSKEY RRSIG</code>中的KSK不被伪造，解析器请求<code>.ma5hr00m.top</code>域与<code>ma5hr00m.top</code>相关的DS记录，并获取到DS记录的<code>RRSIG</code>。</li>\n<li>解析器计算<code>KSK</code>的哈希值，并使用获取到的DS记录的<code>RRSIG</code>进行验证，确保数据的完整性和身份验证。</li>\n<li>解析器重复步骤12和步骤13，向顶级域名服务器(.域)请求<code>.ma5hr00m.top</code>域的DS记录，并获取到DS记录的<code>RRSIG</code>。</li>\n<li>解析器重复步骤12和步骤13，向根域名服务器请求<code>.ma5hr00m.top</code>域的DS记录，并获取到DS记录的<code>RRSIG</code>。</li>\n<li>解析器使用根域名服务器提供的DS记录的<code>RRSIG</code>进行验证，确保数据的完整性和身份验证。</li>\n<li>验证通过后，解析器将最终的结果<code>101.35.240.239</code>返回给用户。</li>\n</ol>\n<p>然后，我们就安全地获取到了<code>ma5hr00m.top</code>对应的IP地址：<code>101.35.240.239</code>！</p>\n<h2 id=\"DNSSEC的优劣\"><a href=\"#DNSSEC的优劣\" class=\"headerlink\" title=\"DNSSEC的优劣\"></a>DNSSEC的优劣</h2><p>原理讲完了，说说为什么要使用DNSSEC。</p>\n<p>作为一个安全拓展，使用DNSSEC最重要的好处就是保护DNS提供的数据，确保互联网上的路标（DNS记录）指向正确的内容或服务，以防止攻击者篡改DNS数据，导致用户被引导到错误的网站或不安全的地方。从根本上来讲，就是保护用户的安全。具体点说，就是可以在一定程度上防止DNS投毒、DNS劫持、DNS重放等攻击手段。</p>\n<p>数据变得可信之后，相继地，这份可信的数据也会促进全球DNS的应用。我们利用这些数据创建了一个<em>安全的域名&#x2F;值数据库</em>，这个安全的数据库可以提供多种创新机会，支持新的技术、服务和设施。互联网研究人员就可以利用这些“干净”的数据来做一些有趣的实验，研发一些新技术。比如DANE（DNS-based Authentication of Named Entitie）就是在利用DNS中受DNSSEC保护的数据，期望解决当前互联网安全连接方法中存在的一些漏洞。</p>\n<p>此外呢，从广义上来讲，DNS 涉及两个方面：发布，由注册人或其代理执行；以及解析，通常由网络运营商（例如，互联网服务提供商）来完成。<br>也就是说，使用DNSSEC需要两端同时发力。</p>\n<p>而DNSSEC很早就大规模部署了。所有根域名服务器在2010年就部署了DNSSEC，若干顶级域名（<code>.org</code>、<code>.com</code>、<code>.net</code>和<code>.edu</code>等）服务器也在2011年部署了DNSSEC。<br>相比其他DNS保护措施，DNSSEC的普及度可以说是遥遥领先了，多数公共的域名服务器都支持它。</p>\n<blockquote>\n<p>DNSSEC支持情况：<a href=\"https://en.wikipedia.org/wiki/Public_recursive_name_server#Notable_public_DNS_service_operators\">Notable public DNS servicde operators</a></p>\n</blockquote>\n<p>DNSSEC也是最早大规模部署的。在 2010 年的时候，所有根域名服务器都已经部署了 DNSSEC。到了 2011 年，若干顶级域名（.org 和 .com 和 .net 和 .edu）也部署了 DNSSEC。</p>\n<p>但是，DNSSEC也并不完美。DNSSEC仅仅是对传输的数据做了数字签名，但未进行加密。如果你的网络流量被别人监视，他依然可以得知你在访问什么域名。可是是出于这个原因，Chrome曾支持过DNSSEC但随后移除，Firefox则从未支持过DNSSEC。</p>\n<p>另外，DNSSEC的使用显著增加了DNS查询响应的数量（需要额外的字段和加密信息来正确验证记录），这就增加了计算机增加遭受分布式拒绝服务 (DDoS) 攻击的风险。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>可能是出于对部署DNSSEC收益的考量，DNS出现于1980年，相关安全问题在08-11年大规模爆发，直到2013年，DNSSEC才开始快速普及。截至2021年，尽管DNSSEC解析服务器只占总量的 17.4%，但其请求量已经超过七成。按照国家来看，平均使用率为14%，而中国的DNSSEC使用率仅6%左右。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/\">什么是 DNS | DNS 的工作方式</a>，by CloudFlare</li>\n<li><a href=\"https://www.cloudflare.com/zh-cn/dns/dnssec/how-dnssec-works/\">DNSSEC 如何运作</a>，by CloudFlare</li>\n<li><a href=\"https://www.wosign.com/News/news_2019032201.htm\">4种DNS安全协议对比</a>，by WoTrust</li>\n<li><a href=\"https://www.cernet.com/hlwjsyj/202009/4606.html\">重启DNS根密钥服务器的七个人</a>，by 赛尔网络</li>\n<li><a href=\"https://www.icann.org/zh/system/files/files/octo-006-24jul20-zh.pdf\">DNSSEC：保护DNS的安全</a>，by ICANN首席技术官办公室</li>\n<li><a href=\"https://herbertgao.com/15/#DNSSEC\">对比4种强化域名安全的协议</a>，by HerbertGao0</li>\n<li><a href=\"https://www.edu.cn/xxh/zt/tj/202305/t20230518_2408472.shtml\">DNSSEC的选择：Yes还是No？</a>，by 中国教育网络</li>\n</ul>\n"},{"title":"掌握 Docker 的使用","date":"2023-05-01T16:00:00.000Z","author":"ma5hr00m","_content":"\n## 是什么\n*Docker* 是一个开源的应用容器引擎，它允许用户将他们的应用以及依赖打包到一个轻量级、可移植的容器（*container*）中，然后部署到任何环境中。\n\ndocker 由 dotCloud 公司开发维护，主要项目代码开源与 GitHub。基于 Go 开发实现，并遵循 Apache2.0 协议开源。因为 Docker 的火爆，dotCloud 公司于 2013 年改名为 Docker。\n\n## 与传统虚拟机的比较\n你既然知道 docker，想必也知道虚拟机。你会发现二者的功能看起来很相似。那为什么我们会在某些场景下使用 docker，而不是传统虚拟机呢？\n\n简单说说二者的区别：\n\n传统的虚拟机技术是虚拟出一套硬件，然后在这套虚拟硬件上运行一个完整的操作系统，再在该操作系统上运行所需应用进程；\n而 docker 容器的应用进程则运行于宿主内核，容器没有自己的内核，也没有进行硬件虚拟，这使得容器比传统虚拟机更加轻便。\n\n相比于传统虚拟机技术，docker 主要有以下优点：\n- ✨ docker 不需要进行硬件虚拟以及运行完整操作系统等额外开销，对系统资源的利用率更高，允许你在同一台主机运行更多的应用；\n- 🚀 docker 运行于宿主内核，无需启动完整的操作系统，可以实现更快的启动；\n- 📦 只要安装了 *docker engine*，你的应用镜像可以运行在任何环境中。\n\n## 安装 Docker\n> 以 ubuntu22.04 系统为例\n\n安装一些必要的软件包，这些软件包可以让你使用 HTTPS 协议从互联网上下载软件：\n\n```bash\nsudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common\n```\n\n从 docker 的官方网站下载公钥，并添加到 apt 的信任列表中。这样做可以确保你下载的软件包是原始的，没有被篡改：\n```bash\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n向你的系统的软件源列表中添加 docker 的官方 Ubuntu 仓库：\n```bash\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n首先更新系统的软件包列表，然后从 docker 的官方 ubuntu 仓库中安装Docker CE，Docker CLI 和 containerd.io。\n```bash\nsudo apt update && sudo apt install docker-ce docker-ce-cli containerd.io\n```\n\n检查 docker 服务的状态，确认是否已经成功安装。\n```bash\nsudo systemctl status docker\n```\n\n同时，你可以使用以下指令设置 docker 每次开机自启动：\n```bash\nsudo systemctl enable docker\n```\n\n使用以下指令关闭 docker 开机自启动：\n```bash\nsudo systemctl disable docker\n```\n\n重启 docker 服务：\n```bash\nsudo systemctl restart docker\n```\n\n默认情况下，只有 root 用户有权利执行 docker 指令，这确保了安全，但有些用户可能认为多此一举。执行以下命令将当前用户添加到 docker 用户组，重新登陆后我们即可使用当前用户身份执行 docker 命令：\n```bash\nsudo usermod -aG docker $USER\n```\n\n都搞定后，执行以下命令运行一个测试容器：\n\n```bash\ndocker container run hello-world\n\n# 出现以下输出，代表 docker 功能正常。\n# Hello from Docker!\n# This message shows that your installation appears to be working correctly.\n```\n\n关于如何卸载 docker，其实用的不多，但也可以记录一手。\n\n停止所有正在运行的容器以及所有的 docker 对象：\n```bash\ndocker container stop $(docker container ls -aq)\ndocker system prune -a --volumes\n```\n\n使用 apt 卸载 docker 以及相关依赖：\n```bash\nsudo apt purge docker-ce && sudo apt autoremove\n```\n\n## 安装 Docker Compose\n`docker compose` 是一个用于定义和运行多容器 Docker 应用程序的工具。\n\n从官方仓库拉取最新版本并安装：\n```bash\nsudo curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n```\n\n为 docker-compose 添加执行权限：\n```bash\nsudo chmod +x /usr/local/bin/docker-compose\n```\n\n输出版本信息检查是否安装成功：\n```bash\ndocker-compose --version\n```\n\n## docker 换源\ndocker 默认镜像源在国外，出于某些原因，我们拉取镜像可能会非常慢。这太痛苦了。我们可以修改 `/etc/docker/daemon.json` 文件，以修改镜像源：\n```bash\nsudo vim /etc/docker/daemon.json\n```\n\n添加国内源：\n```json\n{\n  \"registry-mirrors\": [\"https://docker.m.daocloud.io/\"]\n}\n```\n\n保存后退出，重启 docker 服务。换源完成。\n\n> 不同源也是存在区别的，使用前一定要注意。参考这篇教程：[Docker Hub 镜像加速器](https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6)\n\n## 安装 Portainer\n使用命令行管理少数 docker 容器可能挺方便，可要是容器多起来就会变得繁琐，且命令行中的数据也不够直观。\n我们可以使用一些可视化工具提高我们的效率。\n\n`Portainer` 是一款轻量级的 docker 管理工具，我们可以使用它管理我们的docker 镜像容器。\n![Portainer运行页面展示](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230924232212.png)\n\n拉取 portainer 镜像到本地并部署，这样我们就可以在浏览器中访问 portainer 服务，管理本地镜像和容器。\n\n```bash\nsudo docker pull portainer/portainer-ce\n```\n\n使用以下指令，使用 `portainer/portainer-ce` 镜像创建一个运行在本地 9000 端口的镜像。\n\n```bash\nsudo docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /dockerData/portainer:/data --restart=always --name portainer portainer/portainer\n```\n\n创建成功后，访问 [localhost:9000](http://localhost:9000) 的 portainer 服务，按照指引进行一些基本配置，我们就可以方便快捷的管理我们的镜像和容器了。\n\n## 参考\n- [Docker - 从入门到实践](https://yeasy.gitbook.io/docker_practice/introduction/why)\n- [Docker 常用指令](https://www.runoob.com/docker/docker-command-manual.html)\n- [Portainer - github](https://github.com/portainer/portainer)","source":"_posts/docker-base.md","raw":"---\ntitle: 掌握 Docker 的使用\ndate: 2023/05/02\nauthor: ma5hr00m\ncategories:\n- Docker\n---\n\n## 是什么\n*Docker* 是一个开源的应用容器引擎，它允许用户将他们的应用以及依赖打包到一个轻量级、可移植的容器（*container*）中，然后部署到任何环境中。\n\ndocker 由 dotCloud 公司开发维护，主要项目代码开源与 GitHub。基于 Go 开发实现，并遵循 Apache2.0 协议开源。因为 Docker 的火爆，dotCloud 公司于 2013 年改名为 Docker。\n\n## 与传统虚拟机的比较\n你既然知道 docker，想必也知道虚拟机。你会发现二者的功能看起来很相似。那为什么我们会在某些场景下使用 docker，而不是传统虚拟机呢？\n\n简单说说二者的区别：\n\n传统的虚拟机技术是虚拟出一套硬件，然后在这套虚拟硬件上运行一个完整的操作系统，再在该操作系统上运行所需应用进程；\n而 docker 容器的应用进程则运行于宿主内核，容器没有自己的内核，也没有进行硬件虚拟，这使得容器比传统虚拟机更加轻便。\n\n相比于传统虚拟机技术，docker 主要有以下优点：\n- ✨ docker 不需要进行硬件虚拟以及运行完整操作系统等额外开销，对系统资源的利用率更高，允许你在同一台主机运行更多的应用；\n- 🚀 docker 运行于宿主内核，无需启动完整的操作系统，可以实现更快的启动；\n- 📦 只要安装了 *docker engine*，你的应用镜像可以运行在任何环境中。\n\n## 安装 Docker\n> 以 ubuntu22.04 系统为例\n\n安装一些必要的软件包，这些软件包可以让你使用 HTTPS 协议从互联网上下载软件：\n\n```bash\nsudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common\n```\n\n从 docker 的官方网站下载公钥，并添加到 apt 的信任列表中。这样做可以确保你下载的软件包是原始的，没有被篡改：\n```bash\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\n向你的系统的软件源列表中添加 docker 的官方 Ubuntu 仓库：\n```bash\nsudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n首先更新系统的软件包列表，然后从 docker 的官方 ubuntu 仓库中安装Docker CE，Docker CLI 和 containerd.io。\n```bash\nsudo apt update && sudo apt install docker-ce docker-ce-cli containerd.io\n```\n\n检查 docker 服务的状态，确认是否已经成功安装。\n```bash\nsudo systemctl status docker\n```\n\n同时，你可以使用以下指令设置 docker 每次开机自启动：\n```bash\nsudo systemctl enable docker\n```\n\n使用以下指令关闭 docker 开机自启动：\n```bash\nsudo systemctl disable docker\n```\n\n重启 docker 服务：\n```bash\nsudo systemctl restart docker\n```\n\n默认情况下，只有 root 用户有权利执行 docker 指令，这确保了安全，但有些用户可能认为多此一举。执行以下命令将当前用户添加到 docker 用户组，重新登陆后我们即可使用当前用户身份执行 docker 命令：\n```bash\nsudo usermod -aG docker $USER\n```\n\n都搞定后，执行以下命令运行一个测试容器：\n\n```bash\ndocker container run hello-world\n\n# 出现以下输出，代表 docker 功能正常。\n# Hello from Docker!\n# This message shows that your installation appears to be working correctly.\n```\n\n关于如何卸载 docker，其实用的不多，但也可以记录一手。\n\n停止所有正在运行的容器以及所有的 docker 对象：\n```bash\ndocker container stop $(docker container ls -aq)\ndocker system prune -a --volumes\n```\n\n使用 apt 卸载 docker 以及相关依赖：\n```bash\nsudo apt purge docker-ce && sudo apt autoremove\n```\n\n## 安装 Docker Compose\n`docker compose` 是一个用于定义和运行多容器 Docker 应用程序的工具。\n\n从官方仓库拉取最新版本并安装：\n```bash\nsudo curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n```\n\n为 docker-compose 添加执行权限：\n```bash\nsudo chmod +x /usr/local/bin/docker-compose\n```\n\n输出版本信息检查是否安装成功：\n```bash\ndocker-compose --version\n```\n\n## docker 换源\ndocker 默认镜像源在国外，出于某些原因，我们拉取镜像可能会非常慢。这太痛苦了。我们可以修改 `/etc/docker/daemon.json` 文件，以修改镜像源：\n```bash\nsudo vim /etc/docker/daemon.json\n```\n\n添加国内源：\n```json\n{\n  \"registry-mirrors\": [\"https://docker.m.daocloud.io/\"]\n}\n```\n\n保存后退出，重启 docker 服务。换源完成。\n\n> 不同源也是存在区别的，使用前一定要注意。参考这篇教程：[Docker Hub 镜像加速器](https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6)\n\n## 安装 Portainer\n使用命令行管理少数 docker 容器可能挺方便，可要是容器多起来就会变得繁琐，且命令行中的数据也不够直观。\n我们可以使用一些可视化工具提高我们的效率。\n\n`Portainer` 是一款轻量级的 docker 管理工具，我们可以使用它管理我们的docker 镜像容器。\n![Portainer运行页面展示](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230924232212.png)\n\n拉取 portainer 镜像到本地并部署，这样我们就可以在浏览器中访问 portainer 服务，管理本地镜像和容器。\n\n```bash\nsudo docker pull portainer/portainer-ce\n```\n\n使用以下指令，使用 `portainer/portainer-ce` 镜像创建一个运行在本地 9000 端口的镜像。\n\n```bash\nsudo docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /dockerData/portainer:/data --restart=always --name portainer portainer/portainer\n```\n\n创建成功后，访问 [localhost:9000](http://localhost:9000) 的 portainer 服务，按照指引进行一些基本配置，我们就可以方便快捷的管理我们的镜像和容器了。\n\n## 参考\n- [Docker - 从入门到实践](https://yeasy.gitbook.io/docker_practice/introduction/why)\n- [Docker 常用指令](https://www.runoob.com/docker/docker-command-manual.html)\n- [Portainer - github](https://github.com/portainer/portainer)","slug":"docker-base","published":1,"updated":"2024-06-09T12:56:17.808Z","comments":1,"layout":"post","photos":[],"_id":"clxhruaoy0008f4ly09zx4dr8","content":"<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p><em>Docker</em> 是一个开源的应用容器引擎，它允许用户将他们的应用以及依赖打包到一个轻量级、可移植的容器（<em>container</em>）中，然后部署到任何环境中。</p>\n<p>docker 由 dotCloud 公司开发维护，主要项目代码开源与 GitHub。基于 Go 开发实现，并遵循 Apache2.0 协议开源。因为 Docker 的火爆，dotCloud 公司于 2013 年改名为 Docker。</p>\n<h2 id=\"与传统虚拟机的比较\"><a href=\"#与传统虚拟机的比较\" class=\"headerlink\" title=\"与传统虚拟机的比较\"></a>与传统虚拟机的比较</h2><p>你既然知道 docker，想必也知道虚拟机。你会发现二者的功能看起来很相似。那为什么我们会在某些场景下使用 docker，而不是传统虚拟机呢？</p>\n<p>简单说说二者的区别：</p>\n<p>传统的虚拟机技术是虚拟出一套硬件，然后在这套虚拟硬件上运行一个完整的操作系统，再在该操作系统上运行所需应用进程；<br>而 docker 容器的应用进程则运行于宿主内核，容器没有自己的内核，也没有进行硬件虚拟，这使得容器比传统虚拟机更加轻便。</p>\n<p>相比于传统虚拟机技术，docker 主要有以下优点：</p>\n<ul>\n<li>✨ docker 不需要进行硬件虚拟以及运行完整操作系统等额外开销，对系统资源的利用率更高，允许你在同一台主机运行更多的应用；</li>\n<li>🚀 docker 运行于宿主内核，无需启动完整的操作系统，可以实现更快的启动；</li>\n<li>📦 只要安装了 <em>docker engine</em>，你的应用镜像可以运行在任何环境中。</li>\n</ul>\n<h2 id=\"安装-Docker\"><a href=\"#安装-Docker\" class=\"headerlink\" title=\"安装 Docker\"></a>安装 Docker</h2><blockquote>\n<p>以 ubuntu22.04 系统为例</p>\n</blockquote>\n<p>安装一些必要的软件包，这些软件包可以让你使用 HTTPS 协议从互联网上下载软件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure>\n\n<p>从 docker 的官方网站下载公钥，并添加到 apt 的信任列表中。这样做可以确保你下载的软件包是原始的，没有被篡改：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n\n<p>向你的系统的软件源列表中添加 docker 的官方 Ubuntu 仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository <span class=\"string\">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class=\"subst\">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>首先更新系统的软件包列表，然后从 docker 的官方 ubuntu 仓库中安装Docker CE，Docker CLI 和 containerd.io。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update &amp;&amp; sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n\n<p>检查 docker 服务的状态，确认是否已经成功安装。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl status docker</span><br></pre></td></tr></table></figure>\n\n<p>同时，你可以使用以下指令设置 docker 每次开机自启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure>\n\n<p>使用以下指令关闭 docker 开机自启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl <span class=\"built_in\">disable</span> docker</span><br></pre></td></tr></table></figure>\n\n<p>重启 docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，只有 root 用户有权利执行 docker 指令，这确保了安全，但有些用户可能认为多此一举。执行以下命令将当前用户添加到 docker 用户组，重新登陆后我们即可使用当前用户身份执行 docker 命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker <span class=\"variable\">$USER</span></span><br></pre></td></tr></table></figure>\n\n<p>都搞定后，执行以下命令运行一个测试容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run hello-world</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 出现以下输出，代表 docker 功能正常。</span></span><br><span class=\"line\"><span class=\"comment\"># Hello from Docker!</span></span><br><span class=\"line\"><span class=\"comment\"># This message shows that your installation appears to be working correctly.</span></span><br></pre></td></tr></table></figure>\n\n<p>关于如何卸载 docker，其实用的不多，但也可以记录一手。</p>\n<p>停止所有正在运行的容器以及所有的 docker 对象：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container stop $(docker container <span class=\"built_in\">ls</span> -aq)</span><br><span class=\"line\">docker system prune -a --volumes</span><br></pre></td></tr></table></figure>\n\n<p>使用 apt 卸载 docker 以及相关依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt purge docker-ce &amp;&amp; sudo apt autoremove</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装-Docker-Compose\"><a href=\"#安装-Docker-Compose\" class=\"headerlink\" title=\"安装 Docker Compose\"></a>安装 Docker Compose</h2><p><code>docker compose</code> 是一个用于定义和运行多容器 Docker 应用程序的工具。</p>\n<p>从官方仓库拉取最新版本并安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo curl -L <span class=\"string\">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class=\"subst\">$(uname -s)</span>-<span class=\"subst\">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>\n\n<p>为 docker-compose 添加执行权限：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>\n\n<p>输出版本信息检查是否安装成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose --version</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"docker-换源\"><a href=\"#docker-换源\" class=\"headerlink\" title=\"docker 换源\"></a>docker 换源</h2><p>docker 默认镜像源在国外，出于某些原因，我们拉取镜像可能会非常慢。这太痛苦了。我们可以修改 <code>/etc/docker/daemon.json</code> 文件，以修改镜像源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>\n\n<p>添加国内源：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;registry-mirrors&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;https://docker.m.daocloud.io/&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>保存后退出，重启 docker 服务。换源完成。</p>\n<blockquote>\n<p>不同源也是存在区别的，使用前一定要注意。参考这篇教程：<a href=\"https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6\">Docker Hub 镜像加速器</a></p>\n</blockquote>\n<h2 id=\"安装-Portainer\"><a href=\"#安装-Portainer\" class=\"headerlink\" title=\"安装 Portainer\"></a>安装 Portainer</h2><p>使用命令行管理少数 docker 容器可能挺方便，可要是容器多起来就会变得繁琐，且命令行中的数据也不够直观。<br>我们可以使用一些可视化工具提高我们的效率。</p>\n<p><code>Portainer</code> 是一款轻量级的 docker 管理工具，我们可以使用它管理我们的docker 镜像容器。<br><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230924232212.png\" alt=\"Portainer运行页面展示\"></p>\n<p>拉取 portainer 镜像到本地并部署，这样我们就可以在浏览器中访问 portainer 服务，管理本地镜像和容器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker pull portainer/portainer-ce</span><br></pre></td></tr></table></figure>\n\n<p>使用以下指令，使用 <code>portainer/portainer-ce</code> 镜像创建一个运行在本地 9000 端口的镜像。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /dockerData/portainer:/data --restart=always --name portainer portainer/portainer</span><br></pre></td></tr></table></figure>\n\n<p>创建成功后，访问 <a href=\"http://localhost:9000/\">localhost:9000</a> 的 portainer 服务，按照指引进行一些基本配置，我们就可以方便快捷的管理我们的镜像和容器了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://yeasy.gitbook.io/docker_practice/introduction/why\">Docker - 从入门到实践</a></li>\n<li><a href=\"https://www.runoob.com/docker/docker-command-manual.html\">Docker 常用指令</a></li>\n<li><a href=\"https://github.com/portainer/portainer\">Portainer - github</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2><p><em>Docker</em> 是一个开源的应用容器引擎，它允许用户将他们的应用以及依赖打包到一个轻量级、可移植的容器（<em>container</em>）中，然后部署到任何环境中。</p>\n<p>docker 由 dotCloud 公司开发维护，主要项目代码开源与 GitHub。基于 Go 开发实现，并遵循 Apache2.0 协议开源。因为 Docker 的火爆，dotCloud 公司于 2013 年改名为 Docker。</p>\n<h2 id=\"与传统虚拟机的比较\"><a href=\"#与传统虚拟机的比较\" class=\"headerlink\" title=\"与传统虚拟机的比较\"></a>与传统虚拟机的比较</h2><p>你既然知道 docker，想必也知道虚拟机。你会发现二者的功能看起来很相似。那为什么我们会在某些场景下使用 docker，而不是传统虚拟机呢？</p>\n<p>简单说说二者的区别：</p>\n<p>传统的虚拟机技术是虚拟出一套硬件，然后在这套虚拟硬件上运行一个完整的操作系统，再在该操作系统上运行所需应用进程；<br>而 docker 容器的应用进程则运行于宿主内核，容器没有自己的内核，也没有进行硬件虚拟，这使得容器比传统虚拟机更加轻便。</p>\n<p>相比于传统虚拟机技术，docker 主要有以下优点：</p>\n<ul>\n<li>✨ docker 不需要进行硬件虚拟以及运行完整操作系统等额外开销，对系统资源的利用率更高，允许你在同一台主机运行更多的应用；</li>\n<li>🚀 docker 运行于宿主内核，无需启动完整的操作系统，可以实现更快的启动；</li>\n<li>📦 只要安装了 <em>docker engine</em>，你的应用镜像可以运行在任何环境中。</li>\n</ul>\n<h2 id=\"安装-Docker\"><a href=\"#安装-Docker\" class=\"headerlink\" title=\"安装 Docker\"></a>安装 Docker</h2><blockquote>\n<p>以 ubuntu22.04 系统为例</p>\n</blockquote>\n<p>安装一些必要的软件包，这些软件包可以让你使用 HTTPS 协议从互联网上下载软件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure>\n\n<p>从 docker 的官方网站下载公钥，并添加到 apt 的信任列表中。这样做可以确保你下载的软件包是原始的，没有被篡改：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n\n<p>向你的系统的软件源列表中添加 docker 的官方 Ubuntu 仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository <span class=\"string\">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class=\"subst\">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>首先更新系统的软件包列表，然后从 docker 的官方 ubuntu 仓库中安装Docker CE，Docker CLI 和 containerd.io。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update &amp;&amp; sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>\n\n<p>检查 docker 服务的状态，确认是否已经成功安装。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl status docker</span><br></pre></td></tr></table></figure>\n\n<p>同时，你可以使用以下指令设置 docker 每次开机自启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> docker</span><br></pre></td></tr></table></figure>\n\n<p>使用以下指令关闭 docker 开机自启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl <span class=\"built_in\">disable</span> docker</span><br></pre></td></tr></table></figure>\n\n<p>重启 docker 服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，只有 root 用户有权利执行 docker 指令，这确保了安全，但有些用户可能认为多此一举。执行以下命令将当前用户添加到 docker 用户组，重新登陆后我们即可使用当前用户身份执行 docker 命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo usermod -aG docker <span class=\"variable\">$USER</span></span><br></pre></td></tr></table></figure>\n\n<p>都搞定后，执行以下命令运行一个测试容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run hello-world</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 出现以下输出，代表 docker 功能正常。</span></span><br><span class=\"line\"><span class=\"comment\"># Hello from Docker!</span></span><br><span class=\"line\"><span class=\"comment\"># This message shows that your installation appears to be working correctly.</span></span><br></pre></td></tr></table></figure>\n\n<p>关于如何卸载 docker，其实用的不多，但也可以记录一手。</p>\n<p>停止所有正在运行的容器以及所有的 docker 对象：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container stop $(docker container <span class=\"built_in\">ls</span> -aq)</span><br><span class=\"line\">docker system prune -a --volumes</span><br></pre></td></tr></table></figure>\n\n<p>使用 apt 卸载 docker 以及相关依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt purge docker-ce &amp;&amp; sudo apt autoremove</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装-Docker-Compose\"><a href=\"#安装-Docker-Compose\" class=\"headerlink\" title=\"安装 Docker Compose\"></a>安装 Docker Compose</h2><p><code>docker compose</code> 是一个用于定义和运行多容器 Docker 应用程序的工具。</p>\n<p>从官方仓库拉取最新版本并安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo curl -L <span class=\"string\">&quot;https://github.com/docker/compose/releases/latest/download/docker-compose-<span class=\"subst\">$(uname -s)</span>-<span class=\"subst\">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>\n\n<p>为 docker-compose 添加执行权限：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo <span class=\"built_in\">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>\n\n<p>输出版本信息检查是否安装成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose --version</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"docker-换源\"><a href=\"#docker-换源\" class=\"headerlink\" title=\"docker 换源\"></a>docker 换源</h2><p>docker 默认镜像源在国外，出于某些原因，我们拉取镜像可能会非常慢。这太痛苦了。我们可以修改 <code>/etc/docker/daemon.json</code> 文件，以修改镜像源：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>\n\n<p>添加国内源：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;registry-mirrors&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;https://docker.m.daocloud.io/&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>保存后退出，重启 docker 服务。换源完成。</p>\n<blockquote>\n<p>不同源也是存在区别的，使用前一定要注意。参考这篇教程：<a href=\"https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6\">Docker Hub 镜像加速器</a></p>\n</blockquote>\n<h2 id=\"安装-Portainer\"><a href=\"#安装-Portainer\" class=\"headerlink\" title=\"安装 Portainer\"></a>安装 Portainer</h2><p>使用命令行管理少数 docker 容器可能挺方便，可要是容器多起来就会变得繁琐，且命令行中的数据也不够直观。<br>我们可以使用一些可视化工具提高我们的效率。</p>\n<p><code>Portainer</code> 是一款轻量级的 docker 管理工具，我们可以使用它管理我们的docker 镜像容器。<br><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230924232212.png\" alt=\"Portainer运行页面展示\"></p>\n<p>拉取 portainer 镜像到本地并部署，这样我们就可以在浏览器中访问 portainer 服务，管理本地镜像和容器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker pull portainer/portainer-ce</span><br></pre></td></tr></table></figure>\n\n<p>使用以下指令，使用 <code>portainer/portainer-ce</code> 镜像创建一个运行在本地 9000 端口的镜像。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /dockerData/portainer:/data --restart=always --name portainer portainer/portainer</span><br></pre></td></tr></table></figure>\n\n<p>创建成功后，访问 <a href=\"http://localhost:9000/\">localhost:9000</a> 的 portainer 服务，按照指引进行一些基本配置，我们就可以方便快捷的管理我们的镜像和容器了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://yeasy.gitbook.io/docker_practice/introduction/why\">Docker - 从入门到实践</a></li>\n<li><a href=\"https://www.runoob.com/docker/docker-command-manual.html\">Docker 常用指令</a></li>\n<li><a href=\"https://github.com/portainer/portainer\">Portainer - github</a></li>\n</ul>\n"},{"title":"FRP v0.1.0 源码阅读","date":"2024-06-14T16:00:00.000Z","author":"ma5hr00m","_content":"\n\nfrp 是一款专注于内网穿透的、高性能的反向代理工具，做 Web 安全以及网络开发时常用。就算你没接触过这些领域，室友开黑打游戏时，也可能会使用 [Sakura FRP](https://www.natfrp.com/) 做内网穿透实现局域网联机。\n\n## v0.1.0 版本\n\nv0.1.0 版本的代码量很小，核心功能代码就 1079 行，项目结构也很简单，适合上手。\n\n```bash\nPROJECT:\n└─frp\n    ├─conf\n    ├─Godeps       \n    └─src\n        └─frp\n            ├─cmd\n            │  ├─frpc\n            │  └─frps\n            ├─models\n            │  ├─client | 客户端配置信息 & \n            │  ├─consts\n            │  ├─msg | 定义请求/响应信息的结构体\n            │  └─server | 服务端配置信息 & 处理代理服务器的函数\n            └─utils\n                ├─broadcast | \n                ├─conn | 设置本地监听器 & 获取/发起连接的函数\n                ├─log | 日志处理\n                └─pcrypto\n```\n\n在开始之前，先了解 Godeps，一个旧时代的包依赖管理工具，原理是扫描记录版本控制的信息，并在 go 命令前加壳以实现依赖管理。不过后来逐渐被大家更为熟知的 `go mod` 取代了，其 GitHub 仓库也被 archive 了。\n\n项目中使用该工具管理 Go 依赖库时，会在项目中生成 `/Godeps/Godeps.json` 配置文件。这里就不在解释了，自己看看就可以：\n\n```bash\n{\n\t\"ImportPath\": \"frp\",\n\t\"GoVersion\": \"go1.4\",\n\t\"Packages\": [\n\t\t\"./...\"\n\t],\n\t\"Deps\": [\n\t\t{\n\t\t\t\"ImportPath\": \"github.com/astaxie/beego/logs\",\n\t\t\t\"Comment\": \"v1.5.0-9-gfb7314f\",\n\t\t\t\"Rev\": \"fb7314f8ac86b83ccd34386518d97cf2363e2ae5\"\n\t\t},\n\t\t{\n\t\t\t\"ImportPath\": \"github.com/vaughan0/go-ini\",\n\t\t\t\"Rev\": \"a98ad7ee00ec53921f08832bc06ecf7fd600e6a1\"\n\t\t}\n\t]\n}\n```\n\nfrp 分客户端（frpc）和服务端（frps），使用时是先建立服务端再建立客户端，就按照这个顺序。\n\n### frps\n\n对应的配置文件如下：\n\n```ini\n[common]\nbind_addr = 0.0.0.0\nbind_port = 7000\nlog_file = ./frps.log\n# debug, info, warn, error\nlog_level = debug\n# file, console\nlog_way = console \n\n[test1]\npasswd = 123\nbind_addr = 0.0.0.0\nlisten_port = 6000\n```\n\n先看项目入口文件，位置是 `src/frp/cmd/frps/main.go`：\n\n```go\nfunc main() {\n\terr := server.LoadConf(\"./frps.ini\")\n\t// ... ...\n\t\n\tlog.InitLog(server.LogWay, server.LogFile, server.LogLevel)\n\t\n\tl, err := conn.Listen(server.BindAddr, server.BindPort)\n\t// ... ...\n\t\n\tlog.Info(\"Start frps success\")\n\tProcessControlConn(l)\n}\n```\n\n调用 `src/frp/models/server/config.go` 中的 `LoadConf` 方法加载配置文件；初始化日志记录，使用 server 包中定义的日志记录方式、日志文件和日志级别；建立连接；在前面无误的情况下打印 success 信息；最后调用 `ProcessControlConn` 函数，处理控制连接。\n\n然后看 `src/frp/models/server/config.go`。\n\n这个文件的功能就是使用 `github.com/vaughan0/go-ini` 库将配置文件信息映射为结构体，方便后续使用。配置文件可分为两部分，`[common]` 通用信息和代理服务器信息列表，其中 `[common]` 如果没在配置文件中指定，就是用该文件开头指定的默认值。其他配置信息都被当做代理服务器信息循环读取，文件开头初始化了一个 `ProxyServers`  映射，用于存储代理服务器的配置：\n\n```go\nvar ProxyServers map[string]*ProxyServer = make(map[string]*ProxyServer)\n\nfunc LoadConf(confFile string) (err error) {\n\t// ... ...\n\tfor name, section := range conf {\n\t\tif name != \"common\" {\n\t\t\tproxyServer := &ProxyServer{}\n\t\t\tproxyServer.Name = name\n\n\t\t\tproxyServer.Passwd, ok = section[\"passwd\"]\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"Parse ini file error: proxy [%s] no passwd found\", proxyServer.Name)\n\t\t\t}\n\n\t\t\tproxyServer.BindAddr, ok = section[\"bind_addr\"]\n\t\t\tif !ok {\n\t\t\t\tproxyServer.BindAddr = \"0.0.0.0\"\n\t\t\t}\n\n\t\t\tportStr, ok := section[\"listen_port\"]\n\t\t\tif ok {\n\t\t\t\tproxyServer.ListenPort, err = strconv.ParseInt(portStr, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"Parse ini file error: proxy [%s] listen_port error\", proxyServer.Name)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"Parse ini file error: proxy [%s] listen_port not found\", proxyServer.Name)\n\t\t\t}\n\n\t\t\tproxyServer.Init()\n\t\t\tProxyServers[proxyServer.Name] = proxyServer\n\t\t}\n\t}\n\t// 要求至少有一个代理服务器配置选项，如果没有就提示解析错误\n\tif len(ProxyServers) == 0 {\n\t\treturn fmt.Errorf(\"Parse ini file error: no proxy config found\")\n\t}\n\t// ... ...\n}\n```\n\n日志部分使用的是 `github.com/astaxie/beego/logs` 三方库。可以不细看，日志部分所需的配置信息由上面所说的配置文件指定的。\n\n再看 `src/frp/utils/conn/conn.go`，这部分功能是实现服务端与客户端的连接。\n\n文件开头定义了一个 `Listener` 结构体，用于存储 TCP 监听器的地址、监听器对象、连接通道和关闭标志。\n\n```go\ntype Listener struct {\n\taddr      net.Addr\n\tl         *net.TCPListener\n\tconns     chan *Conn\n\tcloseFlag bool\n}\n```\n\n`Listen` 函数用于在指定端口启动一个 TCP 监听器，接受绑定的地址和端口号作为参数（配置文件中指定），并返回一个 `Listener` 对象。\n\n```go\nfunc Listen(bindAddr string, bindPort int64) (l *Listener, err error) {\n\t// 解析TCP地址，指定 tcp4\n\ttcpAddr, err := net.ResolveTCPAddr(\"tcp4\", fmt.Sprintf(\"%s:%d\", bindAddr, bindPort))\n\tif err != nil {\n\t\treturn l, err\n\t}\n\n\t// 在解析的TCP地址上开始监听\n\tlistener, err := net.ListenTCP(\"tcp\", tcpAddr)\n\tif err != nil {\n\t\treturn l, err\n\t}\n\n\t// 使用监听器的地址、监听器对象、连接通道和关闭标志初始化 Listener 结构体\n\tl = &Listener{\n\t\taddr:      listener.Addr(),\n\t\tl:         listener,\n\t\tconns:     make(chan *Conn),\n\t\tcloseFlag: false,\n\t}\n\n\t// 启动一个协程来接受新的连接\n\tgo func() {\n\t\tfor {\n\t\t\t// 接受新的TCP连接\n\t\t\tconn, err := l.l.AcceptTCP()\n\t\t\tif err != nil {\n\t\t\t\t// 如果监听器已经关闭，则返回结束协程\n\t\t\t\tif l.closeFlag {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// 如果是其他错误，则忽略并继续等待新的连接\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// 为每个接受的连接创建一个 Conn 实例，并将其发送到 Listener 的连接通道中\n\t\t\tc := &Conn{\n\t\t\t\tTcpConn:   conn,\n\t\t\t\tcloseFlag: false,\n\t\t\t}\n\t\t\tc.Reader = bufio.NewReader(c.TcpConn)\n\t\t\tl.conns <- c\n\t\t}\n\t}()\n\treturn l, err\n}\n```\n\n返回的 `Listener` 是一个准备好接受连接的结构体。这个结构体包含了一个通道（`conns`），用于接收和存储新的连接。在 `Listen` 函数内部，有一个协程不断地接受新的连接并将它们放入这个通道。\n\n我们的目光再返回主函数。主函数建立好上文说的这个 `l` 后，就认为 frp 已经成功启动了，然后将这个 `l` 传递给控制模块进行管理，控制模块主体在 `src/frp/cmd/frps/control.go` 中。\n\n`ProcessControlConn` 函数启动一个无限循环，调用 `l.GetConn()` 方法尝试从监听器获取一个新的连接对象 `c` ：如果成功获取到新的连接，它将为每个新的连接启动一个新的协程 `controlWorker(c)`，这个协程将独立处理每个连接的控制逻辑；如果 `l.GetConn()` 返回错误，函数将停止运行。\n\n这里的连接对象 `c` 在项目的 `utils/conn` 中定义：\n\n```go\ntype Conn struct {\n\tTcpConn   *net.TCPConn\n\tReader    *bufio.Reader\n\tcloseFlag bool\n}\n```\n\n`Conn` 结构体是一个自定义的数据类型，用于封装 TCP 连接及其相关操作：\n\n- `TcpConn`：指向 `net.TCPConn` 的指针，它代表了底层的 TCP 连接。通过这个字段，可以访问和控制 TCP 网络连接的各种属性和方法，如发送和接收数据。\n- `Reader`：指向 `bufio.Reader` 的指针，它提供了一个缓冲区，可以更高效地读取数据。这个读取器封装了 `TcpConn`，使得可以方便地进行如按行读取文本等操作。\n- `closeFlag`：布尔值，用于指示连接是否已经被关闭。如果为 `true`，则表示连接已经关闭，不应再进行读写操作。\n\n然后再看用于处理连接的函数 `controlWorker(c)`，其中有两个较为关键的函数，均在注释中标注了 `★`：\n\n```go\nfunc controlWorker(c *conn.Conn) {\n\t// 首条消息是从客户端发往服务器的，如果出错则关闭连接。\n\tres, err := c.ReadLine()\n\tif err != nil {\n\t\tlog.Warn(\"Read error, %v\", err)\n\t\treturn\n\t}\n\n\t// 读取成功则继续调试信息，打印返回的消息\n\tlog.Debug(\"get: %s\", res)\n\n\t// 将读取到的信息反序列化为 ClientCtlReq 结构体\n\tclientCtlReq := &msg.ClientCtlReq{}\n\tclientCtlRes := &msg.ClientCtlRes{}\n\tif err := json.Unmarshal([]byte(res), &clientCtlReq); err != nil {\n\t\tlog.Warn(\"Parse err: %v : %s\", err, res)\n\t\treturn\n\t}\n\t\n\t// ★ 检查代理配置是否正确\n\tsucc, info, needRes := checkProxy(clientCtlReq, c)\n\tif !succ {\n\t\tclientCtlRes.Code = 1\n\t\tclientCtlRes.Msg = info\n\t}\n\n\tif needRes {\n\t\t// 如果需要响应客户端，则在函数结束前关闭连接\n\t\tdefer c.Close()\n\t\t\n\t\t// 将响应消息序列化并写入连接\n\t\tbuf, _ := json.Marshal(clientCtlRes)\n\t\terr = c.Write(string(buf) + \"\\\\n\")\n\t\tif err != nil {\n\t\t\tlog.Warn(\"Write error, %v\", err)\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\treturn\n\t}\n\t\n\t// 检查代理连接是否存在\n\ts, ok := server.ProxyServers[clientCtlReq.ProxyName]\n\tif !ok {\n\t\tlog.Warn(\"ProxyName [%s] is not exist\", clientCtlReq.ProxyName)\n\t\treturn\n\t}\n\t\n\t// ★ 启动一个新的协程，用于读取客户端发送的控制信息\n\tgo readControlMsgFromClient(s, c)\n\n\t// 创建一个新的 ClientCtlReq 结构体，并设置类型为工作连接\n\tserverCtlReq := &msg.ClientCtlReq{}\n\tserverCtlReq.Type = consts.WorkConn\n\t// 进入一个循环，等待用户连接，如果代理服务器关闭，记录调试信息并退出循环\n\tfor {\n\t\tcloseFlag := s.WaitUserConn()\n\t\tif closeFlag {\n\t\t\tlog.Debug(\"ProxyName [%s], goroutine for dealing user conn is closed\", s.Name)\n\t\t\tbreak\n\t\t}\n\t\t// 序列化服务器控制请求并写入连接。如果写入失败，记录警告，关闭代理服务器并返回\n\t\tbuf, _ := json.Marshal(serverCtlReq)\n\t\terr = c.Write(string(buf) + \"\\\\n\")\n\t\tif err != nil {\n\t\t\tlog.Warn(\"ProxyName [%s], write to client error, proxy exit\", s.Name)\n\t\t\ts.Close()\n\t\t\treturn\n\t\t}\n\n\t\tlog.Debug(\"ProxyName [%s], write to client to add work conn success\", s.Name)\n\t}\n\n\tlog.Info(\"ProxyName [%s], I'm dead!\", s.Name)\n\treturn\n}\n```\n\n\n\n`checkProxy` 函数首先检验代理是否合法，然后通过检查 `req.Type` 的值来区分控制连接和工作连接。\n\n```Go\nfunc checkProxy(req *msg.ClientCtlReq, c *conn.Conn) (succ bool, info string, needRes bool) {\n\tsucc = false    // 默认设置成功标志为 false\n\tneedRes = true  // 默认需要向客户端发送响应\n\n\t// 检查代理名称是否存在\n\ts, ok := server.ProxyServers[req.ProxyName]\n\tif !ok {\n\t\tinfo = fmt.Sprintf(\"ProxyName [%s] is not exist\", req.ProxyName)\n\t\tlog.Warn(info)\n\t\treturn\n\t}\n\n\t// 检查密码是否正确\n\tif req.Passwd != s.Passwd {\n\t\tinfo = fmt.Sprintf(\"ProxyName [%s], password is not correct\", req.ProxyName)\n\t\tlog.Warn(info)\n\t\treturn\n\t}\n\n\t// 根据请求类型处理控制连接或工作连接\n\tif req.Type == consts.CtlConn {\n\t\t// 如果是控制连接\n\t\tif s.Status != consts.Idle {\n            // 如果代理已经在使用中，设置错误信息\n\t\t\tinfo = fmt.Sprintf(\"ProxyName [%s], already in use\", req.ProxyName)\n\t\t\tlog.Warn(info)\n\t\t\treturn\n\t\t}\n\n\t\t// 启动代理并监听用户连接，此操作不会阻塞\n\t\terr := s.Start()\n\t\tif err != nil {\n\t\t\tinfo = fmt.Sprintf(\"ProxyName [%s], start proxy error: %v\", req.ProxyName, err.Error())\n\t\t\tlog.Warn(info)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Info(\"ProxyName [%s], start proxy success\", req.ProxyName)\n\t} else if req.Type == consts.WorkConn {\n\t\t// 如果是工作连接，则不需要向客户端发送响应\n\t\tneedRes = false\n\t\tif s.Status != consts.Working {\n\t\t\tlog.Warn(\"ProxyName [%s], is not working when it gets one new work conn\", req.ProxyName)\n\t\t\treturn\n\t\t}\n\n\t\ts.GetNewCliConn(c) // 获取新的客户端连接\n\t} else {\n\t\tinfo = fmt.Sprintf(\"ProxyName [%s], type [%d] unsupport\", req.ProxyName, req.Type)\n\t\tlog.Warn(info)\n\t\treturn\n\t}\n\n    // 如果所有检查都通过，则设置成功标志为 true\n\tsucc = true\n\treturn\n}\n\n```\n\n其中控制连接主要用于设置和维护工作连接，以及进行心跳检测来确保客户端仍然活跃。\n\n控制连接是客户端与服务器之间的初始连接，用于管理和控制代理的状态。在控制连接中，客户端会发送一个包含代理名称和密码的请求，服务器会验证这些信息，如果验证成功，服务器就会根据请求的类型来启动代理或处理其他控制消息。\n\n而工作连接是在控制连接建立后由客户端发起的，用于实际的数据传输。工作连接允许用户数据通过代理服务器转发，实现客户端和服务端之间的通信。\n\n`readControlMsgFromClient` 函数用于读取客户端发送的控制信息 ，它接受一个代理服务器和连接作为参数，用于读取客户端发送的控制消息，包括对心跳信息的处理，用于保持客户端和服务端的连接。\n\n```go\nfunc readControlMsgFromClient(s *server.ProxyServer, c *conn.Conn) {\n\t// 用于控制循环读取消息的条件\n\tisContinueRead := true\n\t\n\t// 用于处理心跳超时的情况，超时则关闭服务器连接\n\tf := func() {\n\t\tisContinueRead = false\n\t\ts.Close()\n\t\tlog.Error(\"ProxyName [%s], client heartbeat timeout\", s.Name)\n\t}\n\t\n\t// 创建一个定时器 timer，在 HeartBeatTimeout 时间后执行函数 f\n\ttimer := time.AfterFunc(time.Duration(server.HeartBeatTimeout)*time.Second, f)\n\t// defer 语句保证在函数结束时停止定时器。\n\tdefer timer.Stop()\n\n\t// 循环读取客户端发送的消息，连接超时则跳出循环\n\tfor isContinueRead {\n\t\t// 从连接 c 中读取一行消息，存储在 content 中\n\t\tcontent, err := c.ReadLine()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tlog.Warn(\"ProxyName [%s], client is dead!\", s.Name)\n\t\t\t\ts.Close()\n\t\t\t\tbreak\n\t\t\t} else if nil == c || c.IsClosed() {\n\t\t\t\tlog.Warn(\"ProxyName [%s], client connection is closed\", s.Name)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tlog.Error(\"ProxyName [%s], read error: %v\", s.Name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// 创建一个指针，存储解析后的客户端控制请求消息\n\t\tclientCtlReq := &msg.ClientCtlReq{}\n\t\t// 将 content 解析为 msg.ClientCtlReq 结构体，并将解析结果存储在 clientCtlReq 中\n\t\tif err := json.Unmarshal([]byte(content), clientCtlReq); err != nil {\n\t\t\tlog.Warn(\"Parse err: %v : %s\", err, content)\n\t\t\tcontinue\n\t\t}\n\t\t// 判断消息是否为心跳请求\n\t\tif consts.CSHeartBeatReq == clientCtlReq.Type {\n\t\t\tlog.Debug(\"ProxyName [%s], get heartbeat\", s.Name)\n\t\t\t// 重置定时器，延长心跳超时时间，确保客户端保持活跃\n\t\t\ttimer.Reset(time.Duration(server.HeartBeatTimeout) * time.Second)\n\t\t\tclientCtlRes := &msg.ClientCtlRes{}\n\t\t\t// 设置心跳响应消息的响应码为 consts.SCHeartBeatRes，然后将响应序列化为 JSON 格式字符串\n\t\t\tclientCtlRes.GeneralRes.Code = consts.SCHeartBeatRes\n\t\t\tresponse, err := json.Marshal(clientCtlRes)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warn(\"Serialize ClientCtlRes err! err: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terr = c.Write(string(response) + \"\\\\n\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Send heartbeat response to client failed! Err:%v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### frpc\n\n`ini` 配置文件如下：\n\n```ini\n[common]\nserver_addr = 127.0.0.1\nserver_port = 7000\nlog_file = ./frpc.log\n# debug, info, warn, error\nlog_level = debug\n# file, console\nlog_way = console\n\n[test1]\npasswd = 123\nlocal_port = 22\n```\n\n同样是入口文件开始，位置是 `src/frp/cmd/frpc/main.go`：\n\n```go\nfunc main() {\n\terr := client.LoadConf(\"./frpc.ini\")\n\tif err != nil {\n\t\tos.Exit(-1)\n\t}\n\n\tlog.InitLog(client.LogWay, client.LogFile, client.LogLevel)\n\n\t// 等待所有控制协程退出，实际上是在声明将会有 len(client.ProxyClients) 数量的协程\n\tvar wait sync.WaitGroup\n\twait.Add(len(client.ProxyClients))\n\n    // 遍历所有代理客户端，并为每个客户端启动一个控制协程\n\tfor _, client := range client.ProxyClients {\n\t\tgo ControlProcess(client, &wait)\n\t}\n\n\tlog.Info(\"Start frpc success\")\n\n    // 等待所有控制协程退出\n\twait.Wait()\n\tlog.Warn(\"All proxy exit!\")\n}\n```\n\n加载配置文件和日志初始化都讲过了，不再赘述。将目光移至 `src/frp/cmd/frpc/control.go`，看看用于处理客户端的 `ControlProcess()`。其中关键函数是用于连接服务端的 `loginToServer` 函数。\n\n```go\nfunc ControlProcess(cli *client.ProxyClient, wait *sync.WaitGroup) {\n    // 延迟 wait.Done() 的执行直到 ControlProcess( )函数即将返回\n    // 这是通知 sync.WaitGroup 当前协程已经完成的标准方式\n\tdefer wait.Done()\n\n    // ★ 尝试登录到服务器，如果成功，返回一个连接对象\n\tc, err := loginToServer(cli)\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], connect to server failed!\", cli.Name)\n\t\treturn\n\t}\n\tconnection = c\n    // 确保函数结束时关闭网络连接\n\tdefer connection.Close()\n\n    // 无限循环并从服务器读取数据\n\tfor {\n\t\tcontent, err := connection.ReadLine()\n        // 遇到 io.EOF 或连接被关闭，尝试重新连接服务器\n\t\tif err == io.EOF || nil == connection || connection.IsClosed() {\n\t\t\tlog.Debug(\"ProxyName [%s], server close this control conn\", cli.Name)\n\t\t\t\n            // 使用指数退避策略来重连服务器，每次失败后等待时间翻倍，直到最大 60 秒\n            var sleepTime time.Duration = 1\n\t\t\tfor {\n\t\t\t\tlog.Debug(\"ProxyName [%s], try to reconnect to server[%s:%d]...\", cli.Name, client.ServerAddr, client.ServerPort)\n\t\t\t\ttmpConn, err := loginToServer(cli)\n\t\t\t\tif err == nil {\n\t\t\t\t\tconnection.Close()\n\t\t\t\t\tconnection = tmpConn\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif sleepTime < 60 {\n\t\t\t\t\tsleepTime = sleepTime * 2\n\t\t\t\t}\n\t\t\t\ttime.Sleep(sleepTime * time.Second)\n\t\t\t}\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\tlog.Warn(\"ProxyName [%s], read from server error, %v\", cli.Name, err)\n\t\t\tcontinue\n\t\t}\n\n        // 尝试解析服务器返回的内容为 ClientCtlRes 结构体\n\t\tclientCtlRes := &msg.ClientCtlRes{}\n\t\tif err := json.Unmarshal([]byte(content), clientCtlRes); err != nil {\n\t\t\tlog.Warn(\"Parse err: %v : %s\", err, content)\n\t\t\tcontinue\n\t\t}\n        \n        // 检查是否收到心跳响应，如果是，则重置心跳计时器\n\t\tif consts.SCHeartBeatRes == clientCtlRes.GeneralRes.Code {\n\t\t\tif heartBeatTimer != nil {\n\t\t\t\tlog.Debug(\"Client rcv heartbeat response\")\n\t\t\t\theartBeatTimer.Reset(time.Duration(client.HeartBeatTimeout) * time.Second)\n\t\t\t} else {\n\t\t\t\tlog.Error(\"heartBeatTimer is nil\")\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n        // ★ 如果收到的不是心跳响应，则尝试启动隧道\n\t\tcli.StartTunnel(client.ServerAddr, client.ServerPort)\n\t}\n}\n```\n\n接下来是 `loginToServer` 函数，核心函数有两个，分别是用于连接到指定地址端口的 `ConnectServer` 和用于启动心跳检测的 `startHeartBeat` 函数：\n\n```go\nfunc loginToServer(cli *client.ProxyClient) (c *conn.Conn, err error) {\n\t// ★ 建立连接，返回一个连接对象\n    c, err = conn.ConnectServer(client.ServerAddr, client.ServerPort)\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], connect to server [%s:%d] error, %v\", cli.Name, client.ServerAddr, client.ServerPort, err)\n\t\treturn\n\t}\n\t\n    // 创建一个 ClientCtlReq 结构体，指定请求类型 CtlConn，表示这是一个控制连接请求\n\treq := &msg.ClientCtlReq{\n\t\tType:      consts.CtlConn,\n\t\tProxyName: cli.Name,\n\t\tPasswd:    cli.Passwd,\n\t}\n    // 序列化为 JSON 并发送请求\n\tbuf, _ := json.Marshal(req)\n\terr = c.Write(string(buf) + \"\\n\")\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], write to server error, %v\", cli.Name, err)\n\t\treturn\n\t}\n\n    // 读取响应\n\tres, err := c.ReadLine()\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], read from server error, %v\", cli.Name, err)\n\t\treturn\n\t}\n\tlog.Debug(\"ProxyName [%s], read [%s]\", cli.Name, res)\n\n    // 将响应的内容解析为 ClientCtlRes 结构体\n\tclientCtlRes := &msg.ClientCtlRes{}\n\tif err = json.Unmarshal([]byte(res), &clientCtlRes); err != nil {\n\t\tlog.Error(\"ProxyName [%s], format server response error, %v\", cli.Name, err)\n\t\treturn\n\t}\n\n    // 检查响应代码\n\tif clientCtlRes.Code != 0 {\n\t\tlog.Error(\"ProxyName [%s], start proxy error, %s\", cli.Name, clientCtlRes.Msg)\n\t\treturn c, fmt.Errorf(\"%s\", clientCtlRes.Msg)\n\t}\n\n    // ★ 启动心跳\n\tgo startHeartBeat(c)\n\tlog.Debug(\"ProxyName [%s], connect to server[%s:%d] success!\", cli.Name, client.ServerAddr, client.ServerPort)\n\n\treturn\n}\n```\n\n先看实现连接的`ConnectServer` 函数，位于 `utils/conn`。这个函数实际上是对普通 TCP 连接的封装：\n\n```go\ntype Conn struct {\n\tTcpConn   *net.TCPConn\n\tReader    *bufio.Reader\n\tcloseFlag bool\n}\n\nfunc ConnectServer(host string, port int64) (c *Conn, err error) {\n\tc = &Conn{}\n    // 使用 net.ResolveTCPAddr 解析 TCP 地址\n\tservertAddr, err := net.ResolveTCPAddr(\"tcp4\", fmt.Sprintf(\"%s:%d\", host, port))\n\tif err != nil {\n\t\treturn\n\t}\n    // 建立到服务器的 TCP 连接\n\tconn, err := net.DialTCP(\"tcp\", nil, servertAddr)\n\tif err != nil {\n\t\treturn\n\t}\n    // 将建立的 TCP 连接赋给 Conn 结构体的 TcpConn 字段\n\tc.TcpConn = conn\n    // 创建一个新的缓冲读取器，并赋给 Conn 的 Reader 字段\n\tc.Reader = bufio.NewReader(c.TcpConn)\n    // 表示连接目前是打开的\n\tc.closeFlag = false\n\treturn c, nil\n}\n\n// 同文件中用于操作 Conn 结构体的函数此处不再展示\n// 还有一个用于实现隧道通信的 Join 函数，稍后会说\n```\n\n然后看 `startHeartBeat` 函数，该函数用于发起心跳包维持客户端与服务端的连接：\n\n```go\nfunc startHeartBeat(c *conn.Conn) {\n    // 心跳超时则关闭连接\n\tf := func() {\n\t\tlog.Error(\"HeartBeat timeout!\")\n\t\tif c != nil {\n\t\t\tc.Close()\n\t\t}\n\t}\n    \n   \t// 创建一个计时器，在指定的心跳超时时间后执行函数f\n\theartBeatTimer = time.AfterFunc(time.Duration(client.HeartBeatTimeout)*time.Second, f)\n\t// 确保在函数退出前停止计时器\n    defer heartBeatTimer.Stop()\n\n\tclientCtlReq := &msg.ClientCtlReq{\n\t\tType:      consts.CSHeartBeatReq,\n\t\tProxyName: \"\",\n\t\tPasswd:    \"\",\n\t}\n    \n    // 将心跳请求序列化为JSON格式\n\trequest, err := json.Marshal(clientCtlReq)\n\tif err != nil {\n\t\tlog.Warn(\"Serialize clientCtlReq err! Err: %v\", err)\n\t}\n\n    // 进入一个无限循环，每次循环开始时都会休眠一段时间，这个时间由心跳间隔决定\n\tlog.Debug(\"Start to send heartbeat\")\n\tfor {\n\t\ttime.Sleep(time.Duration(client.HeartBeatInterval) * time.Second)\n\t\tif c != nil && !c.IsClosed() {\n\t\t\terr = c.Write(string(request) + \"\\n\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Send hearbeat to server failed! Err:%v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.Debug(\"Heartbeat exit\")\n}\n```\n\n现在，我们实现了客户端与服务端的连接，并在连接后依靠心跳机制实现了维持通信，下一步就是建立隧道，实现通信功能。视角转到 `utils/conn` 的 `StartTunnel` 函数：\n\n```go\nfunc (p *ProxyClient) StartTunnel(serverAddr string, serverPort int64) (err error) {\n\t// 建立到本地服务的连接\n    localConn, err := p.GetLocalConn()\n\tif err != nil {\n\t\treturn\n\t}\n\t// ★ 建立到服务端的连接\n    remoteConn, err := p.GetRemoteConn(serverAddr, serverPort)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// l means local, r means remote\n\tlog.Debug(\"Join two conns, (l[%s] r[%s]) (l[%s] r[%s])\", localConn.GetLocalAddr(), localConn.GetRemoteAddr(),\n\t\tremoteConn.GetLocalAddr(), remoteConn.GetRemoteAddr())\n    // ★ 创建协程将本地连接和远程连接“连接”起来，使得数据可以在两者之间传输\n\tgo conn.Join(localConn, remoteConn)\n\treturn nil\n}\n```\n\n建立到本地服务的连接没什么好说的，获取配置文件中的本地端口做个调用即可。着重看下 `GetRemoteConn` 函数：\n\n```go\nfunc (p *ProxyClient) GetRemoteConn(addr string, port int64) (c *conn.Conn, err error) {\n    // 使用 defer 关键字来确保在函数返回前关闭连接\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tc.Close()\n\t\t}\n\t}()\n\n\tc, err = conn.ConnectServer(addr, port)\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], connect to server [%s:%d] error, %v\", p.Name, addr, port, err)\n\t\treturn\n\t}\n\n    // 构造一个客户端控制请求消息，声明为工作连接\n\treq := &msg.ClientCtlReq{\n\t\tType:      consts.WorkConn,\n\t\tProxyName: p.Name,\n\t\tPasswd:    p.Passwd,\n\t}\n\n    // 将请求序列化为 JSON 格式并发送\n\tbuf, _ := json.Marshal(req)\n\terr = c.Write(string(buf) + \"\\n\")\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], write to server error, %v\", p.Name, err)\n\t\treturn\n\t}\n\n\terr = nil\n\treturn\n}\n```\n\n最后我们再转到 `Join` 函数，这个函数是搭建隧道的关键，本质上就是实现两个连接之间的双向数据传输：\n\n```go\nfunc Join(c1 *Conn, c2 *Conn) {\n    // 等待两个数据传输协程的完成\n\tvar wait sync.WaitGroup\n    // 从一个连接读取数据并写入到另一个连接\n    // defer 用于确保在函数结束时关闭连接并通知 WaitGroup 协程已完成\n\tpipe := func(to *Conn, from *Conn) {\n\t\tdefer to.Close()\n\t\tdefer from.Close()\n\t\tdefer wait.Done()\n\n\t\tvar err error\n        // 使用 io.Copy 函数将数据从一个连接复制到另一个连接\n        // 这个操作会持续进行，直到遇到错误或者EOF（文件结束标志\n\t\t_, err = io.Copy(to.TcpConn, from.TcpConn)\n\t\tif err != nil {\n\t\t\tlog.Warn(\"join conns error, %v\", err)\n\t\t}\n\t}\n\n\twait.Add(2)\n    // 启动两个协程，分别处理从 c1 到 c2 和从 c2 到 c1 的数据传输\n\tgo pipe(c1, c2)\n\tgo pipe(c2, c1)\n\twait.Wait()\n\treturn\n}\n```\n\n## 后话\n\nOk，至此，frp v0.1.0 的源码就分析的差不多了，虽说有点老（接近 10 年前），但对理解内网穿透的实现原理也是很有帮助的。之后的版本中虽然做了很多改进，但整体实现思路其实没有太大变化。\n\n虽说不是第一次试着去阅读某个工具的源码，但边学边写博文还是第一次，可能略有混乱，但感觉也还好？唯一的问题是不适合把一段代码拆开，以 frpc 的 `controlWorker` 举例，里面先后使用了两个重要函数，一般这种情况下，我会按照代码执行逻辑先跳转到对应函数看看这个函数做了什么，看完之后再。但写文章的时候拆开整个函数，先贴前半部分，中间再塞调用的函数，然后再贴后半段函数，就感觉很怪，所以在这篇文章里，我就直接先介绍整个函数，标注其中调用的重要函数，然后在之后单独介绍。\n\n然后通篇写下来，想要吐槽的是 Golang 的错误处理机制，不论是阅读的时候还是写文章的时候都感到略有麻烦。就是那种，大家都知道按照 Golang 的风格会在操作跟一个错误处理，控制日志模块输出些信息，多数情况下对核心功能的实现没什么帮助，但你又不好省略，因为就多出两三行，贴代码的时候用 `// ... ...` 代替效果也有限，但直接省去不写也感觉很不对。就比较难受。\n\n别的都还好。\n\n我能找到的还有一篇 FRP v0.5.0 源码阅读的文章，感兴趣的可以跳过去看看，也挺不错的：\n\nhttps://www.joxrays.com/frp-source-code/","source":"_posts/frp_read.md","raw":"---\ntitle: FRP v0.1.0 源码阅读\ndate: 2024/6/15\nauthor: ma5hr00m\ncategories:\n- Source Code Read\n---\n\n\nfrp 是一款专注于内网穿透的、高性能的反向代理工具，做 Web 安全以及网络开发时常用。就算你没接触过这些领域，室友开黑打游戏时，也可能会使用 [Sakura FRP](https://www.natfrp.com/) 做内网穿透实现局域网联机。\n\n## v0.1.0 版本\n\nv0.1.0 版本的代码量很小，核心功能代码就 1079 行，项目结构也很简单，适合上手。\n\n```bash\nPROJECT:\n└─frp\n    ├─conf\n    ├─Godeps       \n    └─src\n        └─frp\n            ├─cmd\n            │  ├─frpc\n            │  └─frps\n            ├─models\n            │  ├─client | 客户端配置信息 & \n            │  ├─consts\n            │  ├─msg | 定义请求/响应信息的结构体\n            │  └─server | 服务端配置信息 & 处理代理服务器的函数\n            └─utils\n                ├─broadcast | \n                ├─conn | 设置本地监听器 & 获取/发起连接的函数\n                ├─log | 日志处理\n                └─pcrypto\n```\n\n在开始之前，先了解 Godeps，一个旧时代的包依赖管理工具，原理是扫描记录版本控制的信息，并在 go 命令前加壳以实现依赖管理。不过后来逐渐被大家更为熟知的 `go mod` 取代了，其 GitHub 仓库也被 archive 了。\n\n项目中使用该工具管理 Go 依赖库时，会在项目中生成 `/Godeps/Godeps.json` 配置文件。这里就不在解释了，自己看看就可以：\n\n```bash\n{\n\t\"ImportPath\": \"frp\",\n\t\"GoVersion\": \"go1.4\",\n\t\"Packages\": [\n\t\t\"./...\"\n\t],\n\t\"Deps\": [\n\t\t{\n\t\t\t\"ImportPath\": \"github.com/astaxie/beego/logs\",\n\t\t\t\"Comment\": \"v1.5.0-9-gfb7314f\",\n\t\t\t\"Rev\": \"fb7314f8ac86b83ccd34386518d97cf2363e2ae5\"\n\t\t},\n\t\t{\n\t\t\t\"ImportPath\": \"github.com/vaughan0/go-ini\",\n\t\t\t\"Rev\": \"a98ad7ee00ec53921f08832bc06ecf7fd600e6a1\"\n\t\t}\n\t]\n}\n```\n\nfrp 分客户端（frpc）和服务端（frps），使用时是先建立服务端再建立客户端，就按照这个顺序。\n\n### frps\n\n对应的配置文件如下：\n\n```ini\n[common]\nbind_addr = 0.0.0.0\nbind_port = 7000\nlog_file = ./frps.log\n# debug, info, warn, error\nlog_level = debug\n# file, console\nlog_way = console \n\n[test1]\npasswd = 123\nbind_addr = 0.0.0.0\nlisten_port = 6000\n```\n\n先看项目入口文件，位置是 `src/frp/cmd/frps/main.go`：\n\n```go\nfunc main() {\n\terr := server.LoadConf(\"./frps.ini\")\n\t// ... ...\n\t\n\tlog.InitLog(server.LogWay, server.LogFile, server.LogLevel)\n\t\n\tl, err := conn.Listen(server.BindAddr, server.BindPort)\n\t// ... ...\n\t\n\tlog.Info(\"Start frps success\")\n\tProcessControlConn(l)\n}\n```\n\n调用 `src/frp/models/server/config.go` 中的 `LoadConf` 方法加载配置文件；初始化日志记录，使用 server 包中定义的日志记录方式、日志文件和日志级别；建立连接；在前面无误的情况下打印 success 信息；最后调用 `ProcessControlConn` 函数，处理控制连接。\n\n然后看 `src/frp/models/server/config.go`。\n\n这个文件的功能就是使用 `github.com/vaughan0/go-ini` 库将配置文件信息映射为结构体，方便后续使用。配置文件可分为两部分，`[common]` 通用信息和代理服务器信息列表，其中 `[common]` 如果没在配置文件中指定，就是用该文件开头指定的默认值。其他配置信息都被当做代理服务器信息循环读取，文件开头初始化了一个 `ProxyServers`  映射，用于存储代理服务器的配置：\n\n```go\nvar ProxyServers map[string]*ProxyServer = make(map[string]*ProxyServer)\n\nfunc LoadConf(confFile string) (err error) {\n\t// ... ...\n\tfor name, section := range conf {\n\t\tif name != \"common\" {\n\t\t\tproxyServer := &ProxyServer{}\n\t\t\tproxyServer.Name = name\n\n\t\t\tproxyServer.Passwd, ok = section[\"passwd\"]\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"Parse ini file error: proxy [%s] no passwd found\", proxyServer.Name)\n\t\t\t}\n\n\t\t\tproxyServer.BindAddr, ok = section[\"bind_addr\"]\n\t\t\tif !ok {\n\t\t\t\tproxyServer.BindAddr = \"0.0.0.0\"\n\t\t\t}\n\n\t\t\tportStr, ok := section[\"listen_port\"]\n\t\t\tif ok {\n\t\t\t\tproxyServer.ListenPort, err = strconv.ParseInt(portStr, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"Parse ini file error: proxy [%s] listen_port error\", proxyServer.Name)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"Parse ini file error: proxy [%s] listen_port not found\", proxyServer.Name)\n\t\t\t}\n\n\t\t\tproxyServer.Init()\n\t\t\tProxyServers[proxyServer.Name] = proxyServer\n\t\t}\n\t}\n\t// 要求至少有一个代理服务器配置选项，如果没有就提示解析错误\n\tif len(ProxyServers) == 0 {\n\t\treturn fmt.Errorf(\"Parse ini file error: no proxy config found\")\n\t}\n\t// ... ...\n}\n```\n\n日志部分使用的是 `github.com/astaxie/beego/logs` 三方库。可以不细看，日志部分所需的配置信息由上面所说的配置文件指定的。\n\n再看 `src/frp/utils/conn/conn.go`，这部分功能是实现服务端与客户端的连接。\n\n文件开头定义了一个 `Listener` 结构体，用于存储 TCP 监听器的地址、监听器对象、连接通道和关闭标志。\n\n```go\ntype Listener struct {\n\taddr      net.Addr\n\tl         *net.TCPListener\n\tconns     chan *Conn\n\tcloseFlag bool\n}\n```\n\n`Listen` 函数用于在指定端口启动一个 TCP 监听器，接受绑定的地址和端口号作为参数（配置文件中指定），并返回一个 `Listener` 对象。\n\n```go\nfunc Listen(bindAddr string, bindPort int64) (l *Listener, err error) {\n\t// 解析TCP地址，指定 tcp4\n\ttcpAddr, err := net.ResolveTCPAddr(\"tcp4\", fmt.Sprintf(\"%s:%d\", bindAddr, bindPort))\n\tif err != nil {\n\t\treturn l, err\n\t}\n\n\t// 在解析的TCP地址上开始监听\n\tlistener, err := net.ListenTCP(\"tcp\", tcpAddr)\n\tif err != nil {\n\t\treturn l, err\n\t}\n\n\t// 使用监听器的地址、监听器对象、连接通道和关闭标志初始化 Listener 结构体\n\tl = &Listener{\n\t\taddr:      listener.Addr(),\n\t\tl:         listener,\n\t\tconns:     make(chan *Conn),\n\t\tcloseFlag: false,\n\t}\n\n\t// 启动一个协程来接受新的连接\n\tgo func() {\n\t\tfor {\n\t\t\t// 接受新的TCP连接\n\t\t\tconn, err := l.l.AcceptTCP()\n\t\t\tif err != nil {\n\t\t\t\t// 如果监听器已经关闭，则返回结束协程\n\t\t\t\tif l.closeFlag {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// 如果是其他错误，则忽略并继续等待新的连接\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// 为每个接受的连接创建一个 Conn 实例，并将其发送到 Listener 的连接通道中\n\t\t\tc := &Conn{\n\t\t\t\tTcpConn:   conn,\n\t\t\t\tcloseFlag: false,\n\t\t\t}\n\t\t\tc.Reader = bufio.NewReader(c.TcpConn)\n\t\t\tl.conns <- c\n\t\t}\n\t}()\n\treturn l, err\n}\n```\n\n返回的 `Listener` 是一个准备好接受连接的结构体。这个结构体包含了一个通道（`conns`），用于接收和存储新的连接。在 `Listen` 函数内部，有一个协程不断地接受新的连接并将它们放入这个通道。\n\n我们的目光再返回主函数。主函数建立好上文说的这个 `l` 后，就认为 frp 已经成功启动了，然后将这个 `l` 传递给控制模块进行管理，控制模块主体在 `src/frp/cmd/frps/control.go` 中。\n\n`ProcessControlConn` 函数启动一个无限循环，调用 `l.GetConn()` 方法尝试从监听器获取一个新的连接对象 `c` ：如果成功获取到新的连接，它将为每个新的连接启动一个新的协程 `controlWorker(c)`，这个协程将独立处理每个连接的控制逻辑；如果 `l.GetConn()` 返回错误，函数将停止运行。\n\n这里的连接对象 `c` 在项目的 `utils/conn` 中定义：\n\n```go\ntype Conn struct {\n\tTcpConn   *net.TCPConn\n\tReader    *bufio.Reader\n\tcloseFlag bool\n}\n```\n\n`Conn` 结构体是一个自定义的数据类型，用于封装 TCP 连接及其相关操作：\n\n- `TcpConn`：指向 `net.TCPConn` 的指针，它代表了底层的 TCP 连接。通过这个字段，可以访问和控制 TCP 网络连接的各种属性和方法，如发送和接收数据。\n- `Reader`：指向 `bufio.Reader` 的指针，它提供了一个缓冲区，可以更高效地读取数据。这个读取器封装了 `TcpConn`，使得可以方便地进行如按行读取文本等操作。\n- `closeFlag`：布尔值，用于指示连接是否已经被关闭。如果为 `true`，则表示连接已经关闭，不应再进行读写操作。\n\n然后再看用于处理连接的函数 `controlWorker(c)`，其中有两个较为关键的函数，均在注释中标注了 `★`：\n\n```go\nfunc controlWorker(c *conn.Conn) {\n\t// 首条消息是从客户端发往服务器的，如果出错则关闭连接。\n\tres, err := c.ReadLine()\n\tif err != nil {\n\t\tlog.Warn(\"Read error, %v\", err)\n\t\treturn\n\t}\n\n\t// 读取成功则继续调试信息，打印返回的消息\n\tlog.Debug(\"get: %s\", res)\n\n\t// 将读取到的信息反序列化为 ClientCtlReq 结构体\n\tclientCtlReq := &msg.ClientCtlReq{}\n\tclientCtlRes := &msg.ClientCtlRes{}\n\tif err := json.Unmarshal([]byte(res), &clientCtlReq); err != nil {\n\t\tlog.Warn(\"Parse err: %v : %s\", err, res)\n\t\treturn\n\t}\n\t\n\t// ★ 检查代理配置是否正确\n\tsucc, info, needRes := checkProxy(clientCtlReq, c)\n\tif !succ {\n\t\tclientCtlRes.Code = 1\n\t\tclientCtlRes.Msg = info\n\t}\n\n\tif needRes {\n\t\t// 如果需要响应客户端，则在函数结束前关闭连接\n\t\tdefer c.Close()\n\t\t\n\t\t// 将响应消息序列化并写入连接\n\t\tbuf, _ := json.Marshal(clientCtlRes)\n\t\terr = c.Write(string(buf) + \"\\\\n\")\n\t\tif err != nil {\n\t\t\tlog.Warn(\"Write error, %v\", err)\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\treturn\n\t}\n\t\n\t// 检查代理连接是否存在\n\ts, ok := server.ProxyServers[clientCtlReq.ProxyName]\n\tif !ok {\n\t\tlog.Warn(\"ProxyName [%s] is not exist\", clientCtlReq.ProxyName)\n\t\treturn\n\t}\n\t\n\t// ★ 启动一个新的协程，用于读取客户端发送的控制信息\n\tgo readControlMsgFromClient(s, c)\n\n\t// 创建一个新的 ClientCtlReq 结构体，并设置类型为工作连接\n\tserverCtlReq := &msg.ClientCtlReq{}\n\tserverCtlReq.Type = consts.WorkConn\n\t// 进入一个循环，等待用户连接，如果代理服务器关闭，记录调试信息并退出循环\n\tfor {\n\t\tcloseFlag := s.WaitUserConn()\n\t\tif closeFlag {\n\t\t\tlog.Debug(\"ProxyName [%s], goroutine for dealing user conn is closed\", s.Name)\n\t\t\tbreak\n\t\t}\n\t\t// 序列化服务器控制请求并写入连接。如果写入失败，记录警告，关闭代理服务器并返回\n\t\tbuf, _ := json.Marshal(serverCtlReq)\n\t\terr = c.Write(string(buf) + \"\\\\n\")\n\t\tif err != nil {\n\t\t\tlog.Warn(\"ProxyName [%s], write to client error, proxy exit\", s.Name)\n\t\t\ts.Close()\n\t\t\treturn\n\t\t}\n\n\t\tlog.Debug(\"ProxyName [%s], write to client to add work conn success\", s.Name)\n\t}\n\n\tlog.Info(\"ProxyName [%s], I'm dead!\", s.Name)\n\treturn\n}\n```\n\n\n\n`checkProxy` 函数首先检验代理是否合法，然后通过检查 `req.Type` 的值来区分控制连接和工作连接。\n\n```Go\nfunc checkProxy(req *msg.ClientCtlReq, c *conn.Conn) (succ bool, info string, needRes bool) {\n\tsucc = false    // 默认设置成功标志为 false\n\tneedRes = true  // 默认需要向客户端发送响应\n\n\t// 检查代理名称是否存在\n\ts, ok := server.ProxyServers[req.ProxyName]\n\tif !ok {\n\t\tinfo = fmt.Sprintf(\"ProxyName [%s] is not exist\", req.ProxyName)\n\t\tlog.Warn(info)\n\t\treturn\n\t}\n\n\t// 检查密码是否正确\n\tif req.Passwd != s.Passwd {\n\t\tinfo = fmt.Sprintf(\"ProxyName [%s], password is not correct\", req.ProxyName)\n\t\tlog.Warn(info)\n\t\treturn\n\t}\n\n\t// 根据请求类型处理控制连接或工作连接\n\tif req.Type == consts.CtlConn {\n\t\t// 如果是控制连接\n\t\tif s.Status != consts.Idle {\n            // 如果代理已经在使用中，设置错误信息\n\t\t\tinfo = fmt.Sprintf(\"ProxyName [%s], already in use\", req.ProxyName)\n\t\t\tlog.Warn(info)\n\t\t\treturn\n\t\t}\n\n\t\t// 启动代理并监听用户连接，此操作不会阻塞\n\t\terr := s.Start()\n\t\tif err != nil {\n\t\t\tinfo = fmt.Sprintf(\"ProxyName [%s], start proxy error: %v\", req.ProxyName, err.Error())\n\t\t\tlog.Warn(info)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Info(\"ProxyName [%s], start proxy success\", req.ProxyName)\n\t} else if req.Type == consts.WorkConn {\n\t\t// 如果是工作连接，则不需要向客户端发送响应\n\t\tneedRes = false\n\t\tif s.Status != consts.Working {\n\t\t\tlog.Warn(\"ProxyName [%s], is not working when it gets one new work conn\", req.ProxyName)\n\t\t\treturn\n\t\t}\n\n\t\ts.GetNewCliConn(c) // 获取新的客户端连接\n\t} else {\n\t\tinfo = fmt.Sprintf(\"ProxyName [%s], type [%d] unsupport\", req.ProxyName, req.Type)\n\t\tlog.Warn(info)\n\t\treturn\n\t}\n\n    // 如果所有检查都通过，则设置成功标志为 true\n\tsucc = true\n\treturn\n}\n\n```\n\n其中控制连接主要用于设置和维护工作连接，以及进行心跳检测来确保客户端仍然活跃。\n\n控制连接是客户端与服务器之间的初始连接，用于管理和控制代理的状态。在控制连接中，客户端会发送一个包含代理名称和密码的请求，服务器会验证这些信息，如果验证成功，服务器就会根据请求的类型来启动代理或处理其他控制消息。\n\n而工作连接是在控制连接建立后由客户端发起的，用于实际的数据传输。工作连接允许用户数据通过代理服务器转发，实现客户端和服务端之间的通信。\n\n`readControlMsgFromClient` 函数用于读取客户端发送的控制信息 ，它接受一个代理服务器和连接作为参数，用于读取客户端发送的控制消息，包括对心跳信息的处理，用于保持客户端和服务端的连接。\n\n```go\nfunc readControlMsgFromClient(s *server.ProxyServer, c *conn.Conn) {\n\t// 用于控制循环读取消息的条件\n\tisContinueRead := true\n\t\n\t// 用于处理心跳超时的情况，超时则关闭服务器连接\n\tf := func() {\n\t\tisContinueRead = false\n\t\ts.Close()\n\t\tlog.Error(\"ProxyName [%s], client heartbeat timeout\", s.Name)\n\t}\n\t\n\t// 创建一个定时器 timer，在 HeartBeatTimeout 时间后执行函数 f\n\ttimer := time.AfterFunc(time.Duration(server.HeartBeatTimeout)*time.Second, f)\n\t// defer 语句保证在函数结束时停止定时器。\n\tdefer timer.Stop()\n\n\t// 循环读取客户端发送的消息，连接超时则跳出循环\n\tfor isContinueRead {\n\t\t// 从连接 c 中读取一行消息，存储在 content 中\n\t\tcontent, err := c.ReadLine()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tlog.Warn(\"ProxyName [%s], client is dead!\", s.Name)\n\t\t\t\ts.Close()\n\t\t\t\tbreak\n\t\t\t} else if nil == c || c.IsClosed() {\n\t\t\t\tlog.Warn(\"ProxyName [%s], client connection is closed\", s.Name)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tlog.Error(\"ProxyName [%s], read error: %v\", s.Name, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// 创建一个指针，存储解析后的客户端控制请求消息\n\t\tclientCtlReq := &msg.ClientCtlReq{}\n\t\t// 将 content 解析为 msg.ClientCtlReq 结构体，并将解析结果存储在 clientCtlReq 中\n\t\tif err := json.Unmarshal([]byte(content), clientCtlReq); err != nil {\n\t\t\tlog.Warn(\"Parse err: %v : %s\", err, content)\n\t\t\tcontinue\n\t\t}\n\t\t// 判断消息是否为心跳请求\n\t\tif consts.CSHeartBeatReq == clientCtlReq.Type {\n\t\t\tlog.Debug(\"ProxyName [%s], get heartbeat\", s.Name)\n\t\t\t// 重置定时器，延长心跳超时时间，确保客户端保持活跃\n\t\t\ttimer.Reset(time.Duration(server.HeartBeatTimeout) * time.Second)\n\t\t\tclientCtlRes := &msg.ClientCtlRes{}\n\t\t\t// 设置心跳响应消息的响应码为 consts.SCHeartBeatRes，然后将响应序列化为 JSON 格式字符串\n\t\t\tclientCtlRes.GeneralRes.Code = consts.SCHeartBeatRes\n\t\t\tresponse, err := json.Marshal(clientCtlRes)\n\t\t\tif err != nil {\n\t\t\t\tlog.Warn(\"Serialize ClientCtlRes err! err: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terr = c.Write(string(response) + \"\\\\n\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Send heartbeat response to client failed! Err:%v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### frpc\n\n`ini` 配置文件如下：\n\n```ini\n[common]\nserver_addr = 127.0.0.1\nserver_port = 7000\nlog_file = ./frpc.log\n# debug, info, warn, error\nlog_level = debug\n# file, console\nlog_way = console\n\n[test1]\npasswd = 123\nlocal_port = 22\n```\n\n同样是入口文件开始，位置是 `src/frp/cmd/frpc/main.go`：\n\n```go\nfunc main() {\n\terr := client.LoadConf(\"./frpc.ini\")\n\tif err != nil {\n\t\tos.Exit(-1)\n\t}\n\n\tlog.InitLog(client.LogWay, client.LogFile, client.LogLevel)\n\n\t// 等待所有控制协程退出，实际上是在声明将会有 len(client.ProxyClients) 数量的协程\n\tvar wait sync.WaitGroup\n\twait.Add(len(client.ProxyClients))\n\n    // 遍历所有代理客户端，并为每个客户端启动一个控制协程\n\tfor _, client := range client.ProxyClients {\n\t\tgo ControlProcess(client, &wait)\n\t}\n\n\tlog.Info(\"Start frpc success\")\n\n    // 等待所有控制协程退出\n\twait.Wait()\n\tlog.Warn(\"All proxy exit!\")\n}\n```\n\n加载配置文件和日志初始化都讲过了，不再赘述。将目光移至 `src/frp/cmd/frpc/control.go`，看看用于处理客户端的 `ControlProcess()`。其中关键函数是用于连接服务端的 `loginToServer` 函数。\n\n```go\nfunc ControlProcess(cli *client.ProxyClient, wait *sync.WaitGroup) {\n    // 延迟 wait.Done() 的执行直到 ControlProcess( )函数即将返回\n    // 这是通知 sync.WaitGroup 当前协程已经完成的标准方式\n\tdefer wait.Done()\n\n    // ★ 尝试登录到服务器，如果成功，返回一个连接对象\n\tc, err := loginToServer(cli)\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], connect to server failed!\", cli.Name)\n\t\treturn\n\t}\n\tconnection = c\n    // 确保函数结束时关闭网络连接\n\tdefer connection.Close()\n\n    // 无限循环并从服务器读取数据\n\tfor {\n\t\tcontent, err := connection.ReadLine()\n        // 遇到 io.EOF 或连接被关闭，尝试重新连接服务器\n\t\tif err == io.EOF || nil == connection || connection.IsClosed() {\n\t\t\tlog.Debug(\"ProxyName [%s], server close this control conn\", cli.Name)\n\t\t\t\n            // 使用指数退避策略来重连服务器，每次失败后等待时间翻倍，直到最大 60 秒\n            var sleepTime time.Duration = 1\n\t\t\tfor {\n\t\t\t\tlog.Debug(\"ProxyName [%s], try to reconnect to server[%s:%d]...\", cli.Name, client.ServerAddr, client.ServerPort)\n\t\t\t\ttmpConn, err := loginToServer(cli)\n\t\t\t\tif err == nil {\n\t\t\t\t\tconnection.Close()\n\t\t\t\t\tconnection = tmpConn\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif sleepTime < 60 {\n\t\t\t\t\tsleepTime = sleepTime * 2\n\t\t\t\t}\n\t\t\t\ttime.Sleep(sleepTime * time.Second)\n\t\t\t}\n\t\t\tcontinue\n\t\t} else if err != nil {\n\t\t\tlog.Warn(\"ProxyName [%s], read from server error, %v\", cli.Name, err)\n\t\t\tcontinue\n\t\t}\n\n        // 尝试解析服务器返回的内容为 ClientCtlRes 结构体\n\t\tclientCtlRes := &msg.ClientCtlRes{}\n\t\tif err := json.Unmarshal([]byte(content), clientCtlRes); err != nil {\n\t\t\tlog.Warn(\"Parse err: %v : %s\", err, content)\n\t\t\tcontinue\n\t\t}\n        \n        // 检查是否收到心跳响应，如果是，则重置心跳计时器\n\t\tif consts.SCHeartBeatRes == clientCtlRes.GeneralRes.Code {\n\t\t\tif heartBeatTimer != nil {\n\t\t\t\tlog.Debug(\"Client rcv heartbeat response\")\n\t\t\t\theartBeatTimer.Reset(time.Duration(client.HeartBeatTimeout) * time.Second)\n\t\t\t} else {\n\t\t\t\tlog.Error(\"heartBeatTimer is nil\")\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n        // ★ 如果收到的不是心跳响应，则尝试启动隧道\n\t\tcli.StartTunnel(client.ServerAddr, client.ServerPort)\n\t}\n}\n```\n\n接下来是 `loginToServer` 函数，核心函数有两个，分别是用于连接到指定地址端口的 `ConnectServer` 和用于启动心跳检测的 `startHeartBeat` 函数：\n\n```go\nfunc loginToServer(cli *client.ProxyClient) (c *conn.Conn, err error) {\n\t// ★ 建立连接，返回一个连接对象\n    c, err = conn.ConnectServer(client.ServerAddr, client.ServerPort)\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], connect to server [%s:%d] error, %v\", cli.Name, client.ServerAddr, client.ServerPort, err)\n\t\treturn\n\t}\n\t\n    // 创建一个 ClientCtlReq 结构体，指定请求类型 CtlConn，表示这是一个控制连接请求\n\treq := &msg.ClientCtlReq{\n\t\tType:      consts.CtlConn,\n\t\tProxyName: cli.Name,\n\t\tPasswd:    cli.Passwd,\n\t}\n    // 序列化为 JSON 并发送请求\n\tbuf, _ := json.Marshal(req)\n\terr = c.Write(string(buf) + \"\\n\")\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], write to server error, %v\", cli.Name, err)\n\t\treturn\n\t}\n\n    // 读取响应\n\tres, err := c.ReadLine()\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], read from server error, %v\", cli.Name, err)\n\t\treturn\n\t}\n\tlog.Debug(\"ProxyName [%s], read [%s]\", cli.Name, res)\n\n    // 将响应的内容解析为 ClientCtlRes 结构体\n\tclientCtlRes := &msg.ClientCtlRes{}\n\tif err = json.Unmarshal([]byte(res), &clientCtlRes); err != nil {\n\t\tlog.Error(\"ProxyName [%s], format server response error, %v\", cli.Name, err)\n\t\treturn\n\t}\n\n    // 检查响应代码\n\tif clientCtlRes.Code != 0 {\n\t\tlog.Error(\"ProxyName [%s], start proxy error, %s\", cli.Name, clientCtlRes.Msg)\n\t\treturn c, fmt.Errorf(\"%s\", clientCtlRes.Msg)\n\t}\n\n    // ★ 启动心跳\n\tgo startHeartBeat(c)\n\tlog.Debug(\"ProxyName [%s], connect to server[%s:%d] success!\", cli.Name, client.ServerAddr, client.ServerPort)\n\n\treturn\n}\n```\n\n先看实现连接的`ConnectServer` 函数，位于 `utils/conn`。这个函数实际上是对普通 TCP 连接的封装：\n\n```go\ntype Conn struct {\n\tTcpConn   *net.TCPConn\n\tReader    *bufio.Reader\n\tcloseFlag bool\n}\n\nfunc ConnectServer(host string, port int64) (c *Conn, err error) {\n\tc = &Conn{}\n    // 使用 net.ResolveTCPAddr 解析 TCP 地址\n\tservertAddr, err := net.ResolveTCPAddr(\"tcp4\", fmt.Sprintf(\"%s:%d\", host, port))\n\tif err != nil {\n\t\treturn\n\t}\n    // 建立到服务器的 TCP 连接\n\tconn, err := net.DialTCP(\"tcp\", nil, servertAddr)\n\tif err != nil {\n\t\treturn\n\t}\n    // 将建立的 TCP 连接赋给 Conn 结构体的 TcpConn 字段\n\tc.TcpConn = conn\n    // 创建一个新的缓冲读取器，并赋给 Conn 的 Reader 字段\n\tc.Reader = bufio.NewReader(c.TcpConn)\n    // 表示连接目前是打开的\n\tc.closeFlag = false\n\treturn c, nil\n}\n\n// 同文件中用于操作 Conn 结构体的函数此处不再展示\n// 还有一个用于实现隧道通信的 Join 函数，稍后会说\n```\n\n然后看 `startHeartBeat` 函数，该函数用于发起心跳包维持客户端与服务端的连接：\n\n```go\nfunc startHeartBeat(c *conn.Conn) {\n    // 心跳超时则关闭连接\n\tf := func() {\n\t\tlog.Error(\"HeartBeat timeout!\")\n\t\tif c != nil {\n\t\t\tc.Close()\n\t\t}\n\t}\n    \n   \t// 创建一个计时器，在指定的心跳超时时间后执行函数f\n\theartBeatTimer = time.AfterFunc(time.Duration(client.HeartBeatTimeout)*time.Second, f)\n\t// 确保在函数退出前停止计时器\n    defer heartBeatTimer.Stop()\n\n\tclientCtlReq := &msg.ClientCtlReq{\n\t\tType:      consts.CSHeartBeatReq,\n\t\tProxyName: \"\",\n\t\tPasswd:    \"\",\n\t}\n    \n    // 将心跳请求序列化为JSON格式\n\trequest, err := json.Marshal(clientCtlReq)\n\tif err != nil {\n\t\tlog.Warn(\"Serialize clientCtlReq err! Err: %v\", err)\n\t}\n\n    // 进入一个无限循环，每次循环开始时都会休眠一段时间，这个时间由心跳间隔决定\n\tlog.Debug(\"Start to send heartbeat\")\n\tfor {\n\t\ttime.Sleep(time.Duration(client.HeartBeatInterval) * time.Second)\n\t\tif c != nil && !c.IsClosed() {\n\t\t\terr = c.Write(string(request) + \"\\n\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(\"Send hearbeat to server failed! Err:%v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\tlog.Debug(\"Heartbeat exit\")\n}\n```\n\n现在，我们实现了客户端与服务端的连接，并在连接后依靠心跳机制实现了维持通信，下一步就是建立隧道，实现通信功能。视角转到 `utils/conn` 的 `StartTunnel` 函数：\n\n```go\nfunc (p *ProxyClient) StartTunnel(serverAddr string, serverPort int64) (err error) {\n\t// 建立到本地服务的连接\n    localConn, err := p.GetLocalConn()\n\tif err != nil {\n\t\treturn\n\t}\n\t// ★ 建立到服务端的连接\n    remoteConn, err := p.GetRemoteConn(serverAddr, serverPort)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// l means local, r means remote\n\tlog.Debug(\"Join two conns, (l[%s] r[%s]) (l[%s] r[%s])\", localConn.GetLocalAddr(), localConn.GetRemoteAddr(),\n\t\tremoteConn.GetLocalAddr(), remoteConn.GetRemoteAddr())\n    // ★ 创建协程将本地连接和远程连接“连接”起来，使得数据可以在两者之间传输\n\tgo conn.Join(localConn, remoteConn)\n\treturn nil\n}\n```\n\n建立到本地服务的连接没什么好说的，获取配置文件中的本地端口做个调用即可。着重看下 `GetRemoteConn` 函数：\n\n```go\nfunc (p *ProxyClient) GetRemoteConn(addr string, port int64) (c *conn.Conn, err error) {\n    // 使用 defer 关键字来确保在函数返回前关闭连接\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tc.Close()\n\t\t}\n\t}()\n\n\tc, err = conn.ConnectServer(addr, port)\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], connect to server [%s:%d] error, %v\", p.Name, addr, port, err)\n\t\treturn\n\t}\n\n    // 构造一个客户端控制请求消息，声明为工作连接\n\treq := &msg.ClientCtlReq{\n\t\tType:      consts.WorkConn,\n\t\tProxyName: p.Name,\n\t\tPasswd:    p.Passwd,\n\t}\n\n    // 将请求序列化为 JSON 格式并发送\n\tbuf, _ := json.Marshal(req)\n\terr = c.Write(string(buf) + \"\\n\")\n\tif err != nil {\n\t\tlog.Error(\"ProxyName [%s], write to server error, %v\", p.Name, err)\n\t\treturn\n\t}\n\n\terr = nil\n\treturn\n}\n```\n\n最后我们再转到 `Join` 函数，这个函数是搭建隧道的关键，本质上就是实现两个连接之间的双向数据传输：\n\n```go\nfunc Join(c1 *Conn, c2 *Conn) {\n    // 等待两个数据传输协程的完成\n\tvar wait sync.WaitGroup\n    // 从一个连接读取数据并写入到另一个连接\n    // defer 用于确保在函数结束时关闭连接并通知 WaitGroup 协程已完成\n\tpipe := func(to *Conn, from *Conn) {\n\t\tdefer to.Close()\n\t\tdefer from.Close()\n\t\tdefer wait.Done()\n\n\t\tvar err error\n        // 使用 io.Copy 函数将数据从一个连接复制到另一个连接\n        // 这个操作会持续进行，直到遇到错误或者EOF（文件结束标志\n\t\t_, err = io.Copy(to.TcpConn, from.TcpConn)\n\t\tif err != nil {\n\t\t\tlog.Warn(\"join conns error, %v\", err)\n\t\t}\n\t}\n\n\twait.Add(2)\n    // 启动两个协程，分别处理从 c1 到 c2 和从 c2 到 c1 的数据传输\n\tgo pipe(c1, c2)\n\tgo pipe(c2, c1)\n\twait.Wait()\n\treturn\n}\n```\n\n## 后话\n\nOk，至此，frp v0.1.0 的源码就分析的差不多了，虽说有点老（接近 10 年前），但对理解内网穿透的实现原理也是很有帮助的。之后的版本中虽然做了很多改进，但整体实现思路其实没有太大变化。\n\n虽说不是第一次试着去阅读某个工具的源码，但边学边写博文还是第一次，可能略有混乱，但感觉也还好？唯一的问题是不适合把一段代码拆开，以 frpc 的 `controlWorker` 举例，里面先后使用了两个重要函数，一般这种情况下，我会按照代码执行逻辑先跳转到对应函数看看这个函数做了什么，看完之后再。但写文章的时候拆开整个函数，先贴前半部分，中间再塞调用的函数，然后再贴后半段函数，就感觉很怪，所以在这篇文章里，我就直接先介绍整个函数，标注其中调用的重要函数，然后在之后单独介绍。\n\n然后通篇写下来，想要吐槽的是 Golang 的错误处理机制，不论是阅读的时候还是写文章的时候都感到略有麻烦。就是那种，大家都知道按照 Golang 的风格会在操作跟一个错误处理，控制日志模块输出些信息，多数情况下对核心功能的实现没什么帮助，但你又不好省略，因为就多出两三行，贴代码的时候用 `// ... ...` 代替效果也有限，但直接省去不写也感觉很不对。就比较难受。\n\n别的都还好。\n\n我能找到的还有一篇 FRP v0.5.0 源码阅读的文章，感兴趣的可以跳过去看看，也挺不错的：\n\nhttps://www.joxrays.com/frp-source-code/","slug":"frp_read","published":1,"updated":"2024-06-15T18:25:12.754Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap0000af4lyfob6hsb3","content":"<p>frp 是一款专注于内网穿透的、高性能的反向代理工具，做 Web 安全以及网络开发时常用。就算你没接触过这些领域，室友开黑打游戏时，也可能会使用 <a href=\"https://www.natfrp.com/\">Sakura FRP</a> 做内网穿透实现局域网联机。</p>\n<h2 id=\"v0-1-0-版本\"><a href=\"#v0-1-0-版本\" class=\"headerlink\" title=\"v0.1.0 版本\"></a>v0.1.0 版本</h2><p>v0.1.0 版本的代码量很小，核心功能代码就 1079 行，项目结构也很简单，适合上手。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROJECT:</span><br><span class=\"line\">└─frp</span><br><span class=\"line\">    ├─conf</span><br><span class=\"line\">    ├─Godeps       </span><br><span class=\"line\">    └─src</span><br><span class=\"line\">        └─frp</span><br><span class=\"line\">            ├─cmd</span><br><span class=\"line\">            │  ├─frpc</span><br><span class=\"line\">            │  └─frps</span><br><span class=\"line\">            ├─models</span><br><span class=\"line\">            │  ├─client | 客户端配置信息 &amp; </span><br><span class=\"line\">            │  ├─consts</span><br><span class=\"line\">            │  ├─msg | 定义请求/响应信息的结构体</span><br><span class=\"line\">            │  └─server | 服务端配置信息 &amp; 处理代理服务器的函数</span><br><span class=\"line\">            └─utils</span><br><span class=\"line\">                ├─broadcast | </span><br><span class=\"line\">                ├─conn | 设置本地监听器 &amp; 获取/发起连接的函数</span><br><span class=\"line\">                ├─<span class=\"built_in\">log</span> | 日志处理</span><br><span class=\"line\">                └─pcrypto</span><br></pre></td></tr></table></figure>\n\n<p>在开始之前，先了解 Godeps，一个旧时代的包依赖管理工具，原理是扫描记录版本控制的信息，并在 go 命令前加壳以实现依赖管理。不过后来逐渐被大家更为熟知的 <code>go mod</code> 取代了，其 GitHub 仓库也被 archive 了。</p>\n<p>项目中使用该工具管理 Go 依赖库时，会在项目中生成 <code>/Godeps/Godeps.json</code> 配置文件。这里就不在解释了，自己看看就可以：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;ImportPath&quot;</span>: <span class=\"string\">&quot;frp&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;GoVersion&quot;</span>: <span class=\"string\">&quot;go1.4&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Packages&quot;</span>: [</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;./...&quot;</span></span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t<span class=\"string\">&quot;Deps&quot;</span>: [</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;ImportPath&quot;</span>: <span class=\"string\">&quot;github.com/astaxie/beego/logs&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;Comment&quot;</span>: <span class=\"string\">&quot;v1.5.0-9-gfb7314f&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;Rev&quot;</span>: <span class=\"string\">&quot;fb7314f8ac86b83ccd34386518d97cf2363e2ae5&quot;</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;ImportPath&quot;</span>: <span class=\"string\">&quot;github.com/vaughan0/go-ini&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;Rev&quot;</span>: <span class=\"string\">&quot;a98ad7ee00ec53921f08832bc06ecf7fd600e6a1&quot;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>frp 分客户端（frpc）和服务端（frps），使用时是先建立服务端再建立客户端，就按照这个顺序。</p>\n<h3 id=\"frps\"><a href=\"#frps\" class=\"headerlink\" title=\"frps\"></a>frps</h3><p>对应的配置文件如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[common]</span></span><br><span class=\"line\"><span class=\"attr\">bind_addr</span> = <span class=\"number\">0.0</span>.<span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"attr\">bind_port</span> = <span class=\"number\">7000</span></span><br><span class=\"line\"><span class=\"attr\">log_file</span> = ./frps.log</span><br><span class=\"line\"><span class=\"comment\"># debug, info, warn, error</span></span><br><span class=\"line\"><span class=\"attr\">log_level</span> = debug</span><br><span class=\"line\"><span class=\"comment\"># file, console</span></span><br><span class=\"line\"><span class=\"attr\">log_way</span> = console </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[test1]</span></span><br><span class=\"line\"><span class=\"attr\">passwd</span> = <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"attr\">bind_addr</span> = <span class=\"number\">0.0</span>.<span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"attr\">listen_port</span> = <span class=\"number\">6000</span></span><br></pre></td></tr></table></figure>\n\n<p>先看项目入口文件，位置是 <code>src/frp/cmd/frps/main.go</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\terr := server.LoadConf(<span class=\"string\">&quot;./frps.ini&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// ... ...</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlog.InitLog(server.LogWay, server.LogFile, server.LogLevel)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tl, err := conn.Listen(server.BindAddr, server.BindPort)</span><br><span class=\"line\">\t<span class=\"comment\">// ... ...</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlog.Info(<span class=\"string\">&quot;Start frps success&quot;</span>)</span><br><span class=\"line\">\tProcessControlConn(l)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用 <code>src/frp/models/server/config.go</code> 中的 <code>LoadConf</code> 方法加载配置文件；初始化日志记录，使用 server 包中定义的日志记录方式、日志文件和日志级别；建立连接；在前面无误的情况下打印 success 信息；最后调用 <code>ProcessControlConn</code> 函数，处理控制连接。</p>\n<p>然后看 <code>src/frp/models/server/config.go</code>。</p>\n<p>这个文件的功能就是使用 <code>github.com/vaughan0/go-ini</code> 库将配置文件信息映射为结构体，方便后续使用。配置文件可分为两部分，<code>[common]</code> 通用信息和代理服务器信息列表，其中 <code>[common]</code> 如果没在配置文件中指定，就是用该文件开头指定的默认值。其他配置信息都被当做代理服务器信息循环读取，文件开头初始化了一个 <code>ProxyServers</code>  映射，用于存储代理服务器的配置：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ProxyServers <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*ProxyServer = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*ProxyServer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadConf</span><span class=\"params\">(confFile <span class=\"type\">string</span>)</span></span> (err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ... ...</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> name, section := <span class=\"keyword\">range</span> conf &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> name != <span class=\"string\">&quot;common&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tproxyServer := &amp;ProxyServer&#123;&#125;</span><br><span class=\"line\">\t\t\tproxyServer.Name = name</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tproxyServer.Passwd, ok = section[<span class=\"string\">&quot;passwd&quot;</span>]</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;Parse ini file error: proxy [%s] no passwd found&quot;</span>, proxyServer.Name)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tproxyServer.BindAddr, ok = section[<span class=\"string\">&quot;bind_addr&quot;</span>]</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\tproxyServer.BindAddr = <span class=\"string\">&quot;0.0.0.0&quot;</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tportStr, ok := section[<span class=\"string\">&quot;listen_port&quot;</span>]</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">\t\t\t\tproxyServer.ListenPort, err = strconv.ParseInt(portStr, <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;Parse ini file error: proxy [%s] listen_port error&quot;</span>, proxyServer.Name)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;Parse ini file error: proxy [%s] listen_port not found&quot;</span>, proxyServer.Name)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tproxyServer.Init()</span><br><span class=\"line\">\t\t\tProxyServers[proxyServer.Name] = proxyServer</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 要求至少有一个代理服务器配置选项，如果没有就提示解析错误</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(ProxyServers) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;Parse ini file error: no proxy config found&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ... ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>日志部分使用的是 <code>github.com/astaxie/beego/logs</code> 三方库。可以不细看，日志部分所需的配置信息由上面所说的配置文件指定的。</p>\n<p>再看 <code>src/frp/utils/conn/conn.go</code>，这部分功能是实现服务端与客户端的连接。</p>\n<p>文件开头定义了一个 <code>Listener</code> 结构体，用于存储 TCP 监听器的地址、监听器对象、连接通道和关闭标志。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Listener <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\taddr      net.Addr</span><br><span class=\"line\">\tl         *net.TCPListener</span><br><span class=\"line\">\tconns     <span class=\"keyword\">chan</span> *Conn</span><br><span class=\"line\">\tcloseFlag <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Listen</code> 函数用于在指定端口启动一个 TCP 监听器，接受绑定的地址和端口号作为参数（配置文件中指定），并返回一个 <code>Listener</code> 对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Listen</span><span class=\"params\">(bindAddr <span class=\"type\">string</span>, bindPort <span class=\"type\">int64</span>)</span></span> (l *Listener, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 解析TCP地址，指定 tcp4</span></span><br><span class=\"line\">\ttcpAddr, err := net.ResolveTCPAddr(<span class=\"string\">&quot;tcp4&quot;</span>, fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, bindAddr, bindPort))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> l, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 在解析的TCP地址上开始监听</span></span><br><span class=\"line\">\tlistener, err := net.ListenTCP(<span class=\"string\">&quot;tcp&quot;</span>, tcpAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> l, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用监听器的地址、监听器对象、连接通道和关闭标志初始化 Listener 结构体</span></span><br><span class=\"line\">\tl = &amp;Listener&#123;</span><br><span class=\"line\">\t\taddr:      listener.Addr(),</span><br><span class=\"line\">\t\tl:         listener,</span><br><span class=\"line\">\t\tconns:     <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> *Conn),</span><br><span class=\"line\">\t\tcloseFlag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 启动一个协程来接受新的连接</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 接受新的TCP连接</span></span><br><span class=\"line\">\t\t\tconn, err := l.l.AcceptTCP()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果监听器已经关闭，则返回结束协程</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> l.closeFlag &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果是其他错误，则忽略并继续等待新的连接</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 为每个接受的连接创建一个 Conn 实例，并将其发送到 Listener 的连接通道中</span></span><br><span class=\"line\">\t\t\tc := &amp;Conn&#123;</span><br><span class=\"line\">\t\t\t\tTcpConn:   conn,</span><br><span class=\"line\">\t\t\t\tcloseFlag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc.Reader = bufio.NewReader(c.TcpConn)</span><br><span class=\"line\">\t\t\tl.conns &lt;- c</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>返回的 <code>Listener</code> 是一个准备好接受连接的结构体。这个结构体包含了一个通道（<code>conns</code>），用于接收和存储新的连接。在 <code>Listen</code> 函数内部，有一个协程不断地接受新的连接并将它们放入这个通道。</p>\n<p>我们的目光再返回主函数。主函数建立好上文说的这个 <code>l</code> 后，就认为 frp 已经成功启动了，然后将这个 <code>l</code> 传递给控制模块进行管理，控制模块主体在 <code>src/frp/cmd/frps/control.go</code> 中。</p>\n<p><code>ProcessControlConn</code> 函数启动一个无限循环，调用 <code>l.GetConn()</code> 方法尝试从监听器获取一个新的连接对象 <code>c</code> ：如果成功获取到新的连接，它将为每个新的连接启动一个新的协程 <code>controlWorker(c)</code>，这个协程将独立处理每个连接的控制逻辑；如果 <code>l.GetConn()</code> 返回错误，函数将停止运行。</p>\n<p>这里的连接对象 <code>c</code> 在项目的 <code>utils/conn</code> 中定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Conn <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTcpConn   *net.TCPConn</span><br><span class=\"line\">\tReader    *bufio.Reader</span><br><span class=\"line\">\tcloseFlag <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Conn</code> 结构体是一个自定义的数据类型，用于封装 TCP 连接及其相关操作：</p>\n<ul>\n<li><code>TcpConn</code>：指向 <code>net.TCPConn</code> 的指针，它代表了底层的 TCP 连接。通过这个字段，可以访问和控制 TCP 网络连接的各种属性和方法，如发送和接收数据。</li>\n<li><code>Reader</code>：指向 <code>bufio.Reader</code> 的指针，它提供了一个缓冲区，可以更高效地读取数据。这个读取器封装了 <code>TcpConn</code>，使得可以方便地进行如按行读取文本等操作。</li>\n<li><code>closeFlag</code>：布尔值，用于指示连接是否已经被关闭。如果为 <code>true</code>，则表示连接已经关闭，不应再进行读写操作。</li>\n</ul>\n<p>然后再看用于处理连接的函数 <code>controlWorker(c)</code>，其中有两个较为关键的函数，均在注释中标注了 <code>★</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">controlWorker</span><span class=\"params\">(c *conn.Conn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 首条消息是从客户端发往服务器的，如果出错则关闭连接。</span></span><br><span class=\"line\">\tres, err := c.ReadLine()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Warn(<span class=\"string\">&quot;Read error, %v&quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 读取成功则继续调试信息，打印返回的消息</span></span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;get: %s&quot;</span>, res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将读取到的信息反序列化为 ClientCtlReq 结构体</span></span><br><span class=\"line\">\tclientCtlReq := &amp;msg.ClientCtlReq&#123;&#125;</span><br><span class=\"line\">\tclientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := json.Unmarshal([]<span class=\"type\">byte</span>(res), &amp;clientCtlReq); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Warn(<span class=\"string\">&quot;Parse err: %v : %s&quot;</span>, err, res)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// ★ 检查代理配置是否正确</span></span><br><span class=\"line\">\tsucc, info, needRes := checkProxy(clientCtlReq, c)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !succ &#123;</span><br><span class=\"line\">\t\tclientCtlRes.Code = <span class=\"number\">1</span></span><br><span class=\"line\">\t\tclientCtlRes.Msg = info</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> needRes &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果需要响应客户端，则在函数结束前关闭连接</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> c.Close()</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将响应消息序列化并写入连接</span></span><br><span class=\"line\">\t\tbuf, _ := json.Marshal(clientCtlRes)</span><br><span class=\"line\">\t\terr = c.Write(<span class=\"type\">string</span>(buf) + <span class=\"string\">&quot;\\\\n&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;Write error, %v&quot;</span>, err)</span><br><span class=\"line\">\t\t\ttime.Sleep(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 检查代理连接是否存在</span></span><br><span class=\"line\">\ts, ok := server.ProxyServers[clientCtlReq.ProxyName]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s] is not exist&quot;</span>, clientCtlReq.ProxyName)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// ★ 启动一个新的协程，用于读取客户端发送的控制信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> readControlMsgFromClient(s, c)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个新的 ClientCtlReq 结构体，并设置类型为工作连接</span></span><br><span class=\"line\">\tserverCtlReq := &amp;msg.ClientCtlReq&#123;&#125;</span><br><span class=\"line\">\tserverCtlReq.Type = consts.WorkConn</span><br><span class=\"line\">\t<span class=\"comment\">// 进入一个循环，等待用户连接，如果代理服务器关闭，记录调试信息并退出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tcloseFlag := s.WaitUserConn()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> closeFlag &#123;</span><br><span class=\"line\">\t\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], goroutine for dealing user conn is closed&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 序列化服务器控制请求并写入连接。如果写入失败，记录警告，关闭代理服务器并返回</span></span><br><span class=\"line\">\t\tbuf, _ := json.Marshal(serverCtlReq)</span><br><span class=\"line\">\t\terr = c.Write(<span class=\"type\">string</span>(buf) + <span class=\"string\">&quot;\\\\n&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], write to client error, proxy exit&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\ts.Close()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], write to client to add work conn success&quot;</span>, s.Name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Info(<span class=\"string\">&quot;ProxyName [%s], I&#x27;m dead!&quot;</span>, s.Name)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>checkProxy</code> 函数首先检验代理是否合法，然后通过检查 <code>req.Type</code> 的值来区分控制连接和工作连接。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkProxy</span><span class=\"params\">(req *msg.ClientCtlReq, c *conn.Conn)</span></span> (succ <span class=\"type\">bool</span>, info <span class=\"type\">string</span>, needRes <span class=\"type\">bool</span>) &#123;</span><br><span class=\"line\">\tsucc = <span class=\"literal\">false</span>    <span class=\"comment\">// 默认设置成功标志为 false</span></span><br><span class=\"line\">\tneedRes = <span class=\"literal\">true</span>  <span class=\"comment\">// 默认需要向客户端发送响应</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 检查代理名称是否存在</span></span><br><span class=\"line\">\ts, ok := server.ProxyServers[req.ProxyName]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s] is not exist&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 检查密码是否正确</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> req.Passwd != s.Passwd &#123;</span><br><span class=\"line\">\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s], password is not correct&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 根据请求类型处理控制连接或工作连接</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> req.Type == consts.CtlConn &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果是控制连接</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.Status != consts.Idle &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果代理已经在使用中，设置错误信息</span></span><br><span class=\"line\">\t\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s], already in use&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 启动代理并监听用户连接，此操作不会阻塞</span></span><br><span class=\"line\">\t\terr := s.Start()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s], start proxy error: %v&quot;</span>, req.ProxyName, err.Error())</span><br><span class=\"line\">\t\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlog.Info(<span class=\"string\">&quot;ProxyName [%s], start proxy success&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> req.Type == consts.WorkConn &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果是工作连接，则不需要向客户端发送响应</span></span><br><span class=\"line\">\t\tneedRes = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.Status != consts.Working &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], is not working when it gets one new work conn&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts.GetNewCliConn(c) <span class=\"comment\">// 获取新的客户端连接</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s], type [%d] unsupport&quot;</span>, req.ProxyName, req.Type)</span><br><span class=\"line\">\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果所有检查都通过，则设置成功标志为 true</span></span><br><span class=\"line\">\tsucc = <span class=\"literal\">true</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中控制连接主要用于设置和维护工作连接，以及进行心跳检测来确保客户端仍然活跃。</p>\n<p>控制连接是客户端与服务器之间的初始连接，用于管理和控制代理的状态。在控制连接中，客户端会发送一个包含代理名称和密码的请求，服务器会验证这些信息，如果验证成功，服务器就会根据请求的类型来启动代理或处理其他控制消息。</p>\n<p>而工作连接是在控制连接建立后由客户端发起的，用于实际的数据传输。工作连接允许用户数据通过代理服务器转发，实现客户端和服务端之间的通信。</p>\n<p><code>readControlMsgFromClient</code> 函数用于读取客户端发送的控制信息 ，它接受一个代理服务器和连接作为参数，用于读取客户端发送的控制消息，包括对心跳信息的处理，用于保持客户端和服务端的连接。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readControlMsgFromClient</span><span class=\"params\">(s *server.ProxyServer, c *conn.Conn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 用于控制循环读取消息的条件</span></span><br><span class=\"line\">\tisContinueRead := <span class=\"literal\">true</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 用于处理心跳超时的情况，超时则关闭服务器连接</span></span><br><span class=\"line\">\tf := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tisContinueRead = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\ts.Close()</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], client heartbeat timeout&quot;</span>, s.Name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个定时器 timer，在 HeartBeatTimeout 时间后执行函数 f</span></span><br><span class=\"line\">\ttimer := time.AfterFunc(time.Duration(server.HeartBeatTimeout)*time.Second, f)</span><br><span class=\"line\">\t<span class=\"comment\">// defer 语句保证在函数结束时停止定时器。</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> timer.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 循环读取客户端发送的消息，连接超时则跳出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> isContinueRead &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 从连接 c 中读取一行消息，存储在 content 中</span></span><br><span class=\"line\">\t\tcontent, err := c.ReadLine()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], client is dead!&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\t\ts.Close()</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"literal\">nil</span> == c || c.IsClosed() &#123;</span><br><span class=\"line\">\t\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], client connection is closed&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], read error: %v&quot;</span>, s.Name, err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建一个指针，存储解析后的客户端控制请求消息</span></span><br><span class=\"line\">\t\tclientCtlReq := &amp;msg.ClientCtlReq&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将 content 解析为 msg.ClientCtlReq 结构体，并将解析结果存储在 clientCtlReq 中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := json.Unmarshal([]<span class=\"type\">byte</span>(content), clientCtlReq); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;Parse err: %v : %s&quot;</span>, err, content)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断消息是否为心跳请求</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> consts.CSHeartBeatReq == clientCtlReq.Type &#123;</span><br><span class=\"line\">\t\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], get heartbeat&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 重置定时器，延长心跳超时时间，确保客户端保持活跃</span></span><br><span class=\"line\">\t\t\ttimer.Reset(time.Duration(server.HeartBeatTimeout) * time.Second)</span><br><span class=\"line\">\t\t\tclientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 设置心跳响应消息的响应码为 consts.SCHeartBeatRes，然后将响应序列化为 JSON 格式字符串</span></span><br><span class=\"line\">\t\t\tclientCtlRes.GeneralRes.Code = consts.SCHeartBeatRes</span><br><span class=\"line\">\t\t\tresponse, err := json.Marshal(clientCtlRes)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Warn(<span class=\"string\">&quot;Serialize ClientCtlRes err! err: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\terr = c.Write(<span class=\"type\">string</span>(response) + <span class=\"string\">&quot;\\\\n&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Error(<span class=\"string\">&quot;Send heartbeat response to client failed! Err:%v&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"frpc\"><a href=\"#frpc\" class=\"headerlink\" title=\"frpc\"></a>frpc</h3><p><code>ini</code> 配置文件如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[common]</span></span><br><span class=\"line\"><span class=\"attr\">server_addr</span> = <span class=\"number\">127.0</span>.<span class=\"number\">0.1</span></span><br><span class=\"line\"><span class=\"attr\">server_port</span> = <span class=\"number\">7000</span></span><br><span class=\"line\"><span class=\"attr\">log_file</span> = ./frpc.log</span><br><span class=\"line\"><span class=\"comment\"># debug, info, warn, error</span></span><br><span class=\"line\"><span class=\"attr\">log_level</span> = debug</span><br><span class=\"line\"><span class=\"comment\"># file, console</span></span><br><span class=\"line\"><span class=\"attr\">log_way</span> = console</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[test1]</span></span><br><span class=\"line\"><span class=\"attr\">passwd</span> = <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"attr\">local_port</span> = <span class=\"number\">22</span></span><br></pre></td></tr></table></figure>\n\n<p>同样是入口文件开始，位置是 <code>src/frp/cmd/frpc/main.go</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\terr := client.LoadConf(<span class=\"string\">&quot;./frpc.ini&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tos.Exit(<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.InitLog(client.LogWay, client.LogFile, client.LogLevel)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 等待所有控制协程退出，实际上是在声明将会有 len(client.ProxyClients) 数量的协程</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wait sync.WaitGroup</span><br><span class=\"line\">\twait.Add(<span class=\"built_in\">len</span>(client.ProxyClients))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有代理客户端，并为每个客户端启动一个控制协程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, client := <span class=\"keyword\">range</span> client.ProxyClients &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> ControlProcess(client, &amp;wait)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Info(<span class=\"string\">&quot;Start frpc success&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有控制协程退出</span></span><br><span class=\"line\">\twait.Wait()</span><br><span class=\"line\">\tlog.Warn(<span class=\"string\">&quot;All proxy exit!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加载配置文件和日志初始化都讲过了，不再赘述。将目光移至 <code>src/frp/cmd/frpc/control.go</code>，看看用于处理客户端的 <code>ControlProcess()</code>。其中关键函数是用于连接服务端的 <code>loginToServer</code> 函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ControlProcess</span><span class=\"params\">(cli *client.ProxyClient, wait *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 延迟 wait.Done() 的执行直到 ControlProcess( )函数即将返回</span></span><br><span class=\"line\">    <span class=\"comment\">// 这是通知 sync.WaitGroup 当前协程已经完成的标准方式</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> wait.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ★ 尝试登录到服务器，如果成功，返回一个连接对象</span></span><br><span class=\"line\">\tc, err := loginToServer(cli)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], connect to server failed!&quot;</span>, cli.Name)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconnection = c</span><br><span class=\"line\">    <span class=\"comment\">// 确保函数结束时关闭网络连接</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> connection.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 无限循环并从服务器读取数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tcontent, err := connection.ReadLine()</span><br><span class=\"line\">        <span class=\"comment\">// 遇到 io.EOF 或连接被关闭，尝试重新连接服务器</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == io.EOF || <span class=\"literal\">nil</span> == connection || connection.IsClosed() &#123;</span><br><span class=\"line\">\t\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], server close this control conn&quot;</span>, cli.Name)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">            <span class=\"comment\">// 使用指数退避策略来重连服务器，每次失败后等待时间翻倍，直到最大 60 秒</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> sleepTime time.Duration = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], try to reconnect to server[%s:%d]...&quot;</span>, cli.Name, client.ServerAddr, client.ServerPort)</span><br><span class=\"line\">\t\t\t\ttmpConn, err := loginToServer(cli)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tconnection.Close()</span><br><span class=\"line\">\t\t\t\t\tconnection = tmpConn</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> sleepTime &lt; <span class=\"number\">60</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tsleepTime = sleepTime * <span class=\"number\">2</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\ttime.Sleep(sleepTime * time.Second)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], read from server error, %v&quot;</span>, cli.Name, err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 尝试解析服务器返回的内容为 ClientCtlRes 结构体</span></span><br><span class=\"line\">\t\tclientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := json.Unmarshal([]<span class=\"type\">byte</span>(content), clientCtlRes); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;Parse err: %v : %s&quot;</span>, err, content)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查是否收到心跳响应，如果是，则重置心跳计时器</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> consts.SCHeartBeatRes == clientCtlRes.GeneralRes.Code &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> heartBeatTimer != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Debug(<span class=\"string\">&quot;Client rcv heartbeat response&quot;</span>)</span><br><span class=\"line\">\t\t\t\theartBeatTimer.Reset(time.Duration(client.HeartBeatTimeout) * time.Second)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Error(<span class=\"string\">&quot;heartBeatTimer is nil&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ★ 如果收到的不是心跳响应，则尝试启动隧道</span></span><br><span class=\"line\">\t\tcli.StartTunnel(client.ServerAddr, client.ServerPort)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来是 <code>loginToServer</code> 函数，核心函数有两个，分别是用于连接到指定地址端口的 <code>ConnectServer</code> 和用于启动心跳检测的 <code>startHeartBeat</code> 函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loginToServer</span><span class=\"params\">(cli *client.ProxyClient)</span></span> (c *conn.Conn, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ★ 建立连接，返回一个连接对象</span></span><br><span class=\"line\">    c, err = conn.ConnectServer(client.ServerAddr, client.ServerPort)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], connect to server [%s:%d] error, %v&quot;</span>, cli.Name, client.ServerAddr, client.ServerPort, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个 ClientCtlReq 结构体，指定请求类型 CtlConn，表示这是一个控制连接请求</span></span><br><span class=\"line\">\treq := &amp;msg.ClientCtlReq&#123;</span><br><span class=\"line\">\t\tType:      consts.CtlConn,</span><br><span class=\"line\">\t\tProxyName: cli.Name,</span><br><span class=\"line\">\t\tPasswd:    cli.Passwd,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 序列化为 JSON 并发送请求</span></span><br><span class=\"line\">\tbuf, _ := json.Marshal(req)</span><br><span class=\"line\">\terr = c.Write(<span class=\"type\">string</span>(buf) + <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], write to server error, %v&quot;</span>, cli.Name, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读取响应</span></span><br><span class=\"line\">\tres, err := c.ReadLine()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], read from server error, %v&quot;</span>, cli.Name, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], read [%s]&quot;</span>, cli.Name, res)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将响应的内容解析为 ClientCtlRes 结构体</span></span><br><span class=\"line\">\tclientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err = json.Unmarshal([]<span class=\"type\">byte</span>(res), &amp;clientCtlRes); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], format server response error, %v&quot;</span>, cli.Name, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查响应代码</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> clientCtlRes.Code != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], start proxy error, %s&quot;</span>, cli.Name, clientCtlRes.Msg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c, fmt.Errorf(<span class=\"string\">&quot;%s&quot;</span>, clientCtlRes.Msg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ★ 启动心跳</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> startHeartBeat(c)</span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], connect to server[%s:%d] success!&quot;</span>, cli.Name, client.ServerAddr, client.ServerPort)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先看实现连接的<code>ConnectServer</code> 函数，位于 <code>utils/conn</code>。这个函数实际上是对普通 TCP 连接的封装：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Conn <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTcpConn   *net.TCPConn</span><br><span class=\"line\">\tReader    *bufio.Reader</span><br><span class=\"line\">\tcloseFlag <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ConnectServer</span><span class=\"params\">(host <span class=\"type\">string</span>, port <span class=\"type\">int64</span>)</span></span> (c *Conn, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tc = &amp;Conn&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 net.ResolveTCPAddr 解析 TCP 地址</span></span><br><span class=\"line\">\tservertAddr, err := net.ResolveTCPAddr(<span class=\"string\">&quot;tcp4&quot;</span>, fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, host, port))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 建立到服务器的 TCP 连接</span></span><br><span class=\"line\">\tconn, err := net.DialTCP(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"literal\">nil</span>, servertAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将建立的 TCP 连接赋给 Conn 结构体的 TcpConn 字段</span></span><br><span class=\"line\">\tc.TcpConn = conn</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新的缓冲读取器，并赋给 Conn 的 Reader 字段</span></span><br><span class=\"line\">\tc.Reader = bufio.NewReader(c.TcpConn)</span><br><span class=\"line\">    <span class=\"comment\">// 表示连接目前是打开的</span></span><br><span class=\"line\">\tc.closeFlag = <span class=\"literal\">false</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同文件中用于操作 Conn 结构体的函数此处不再展示</span></span><br><span class=\"line\"><span class=\"comment\">// 还有一个用于实现隧道通信的 Join 函数，稍后会说</span></span><br></pre></td></tr></table></figure>\n\n<p>然后看 <code>startHeartBeat</code> 函数，该函数用于发起心跳包维持客户端与服务端的连接：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startHeartBeat</span><span class=\"params\">(c *conn.Conn)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 心跳超时则关闭连接</span></span><br><span class=\"line\">\tf := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;HeartBeat timeout!&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tc.Close()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   \t<span class=\"comment\">// 创建一个计时器，在指定的心跳超时时间后执行函数f</span></span><br><span class=\"line\">\theartBeatTimer = time.AfterFunc(time.Duration(client.HeartBeatTimeout)*time.Second, f)</span><br><span class=\"line\">\t<span class=\"comment\">// 确保在函数退出前停止计时器</span></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> heartBeatTimer.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\tclientCtlReq := &amp;msg.ClientCtlReq&#123;</span><br><span class=\"line\">\t\tType:      consts.CSHeartBeatReq,</span><br><span class=\"line\">\t\tProxyName: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">\t\tPasswd:    <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将心跳请求序列化为JSON格式</span></span><br><span class=\"line\">\trequest, err := json.Marshal(clientCtlReq)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Warn(<span class=\"string\">&quot;Serialize clientCtlReq err! Err: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入一个无限循环，每次循环开始时都会休眠一段时间，这个时间由心跳间隔决定</span></span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;Start to send heartbeat&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\ttime.Sleep(time.Duration(client.HeartBeatInterval) * time.Second)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c != <span class=\"literal\">nil</span> &amp;&amp; !c.IsClosed() &#123;</span><br><span class=\"line\">\t\t\terr = c.Write(<span class=\"type\">string</span>(request) + <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Error(<span class=\"string\">&quot;Send hearbeat to server failed! Err:%v&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;Heartbeat exit&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们实现了客户端与服务端的连接，并在连接后依靠心跳机制实现了维持通信，下一步就是建立隧道，实现通信功能。视角转到 <code>utils/conn</code> 的 <code>StartTunnel</code> 函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ProxyClient)</span></span> StartTunnel(serverAddr <span class=\"type\">string</span>, serverPort <span class=\"type\">int64</span>) (err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 建立到本地服务的连接</span></span><br><span class=\"line\">    localConn, err := p.GetLocalConn()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ★ 建立到服务端的连接</span></span><br><span class=\"line\">    remoteConn, err := p.GetRemoteConn(serverAddr, serverPort)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// l means local, r means remote</span></span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;Join two conns, (l[%s] r[%s]) (l[%s] r[%s])&quot;</span>, localConn.GetLocalAddr(), localConn.GetRemoteAddr(),</span><br><span class=\"line\">\t\tremoteConn.GetLocalAddr(), remoteConn.GetRemoteAddr())</span><br><span class=\"line\">    <span class=\"comment\">// ★ 创建协程将本地连接和远程连接“连接”起来，使得数据可以在两者之间传输</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> conn.Join(localConn, remoteConn)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>建立到本地服务的连接没什么好说的，获取配置文件中的本地端口做个调用即可。着重看下 <code>GetRemoteConn</code> 函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ProxyClient)</span></span> GetRemoteConn(addr <span class=\"type\">string</span>, port <span class=\"type\">int64</span>) (c *conn.Conn, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 defer 关键字来确保在函数返回前关闭连接</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tc.Close()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tc, err = conn.ConnectServer(addr, port)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], connect to server [%s:%d] error, %v&quot;</span>, p.Name, addr, port, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造一个客户端控制请求消息，声明为工作连接</span></span><br><span class=\"line\">\treq := &amp;msg.ClientCtlReq&#123;</span><br><span class=\"line\">\t\tType:      consts.WorkConn,</span><br><span class=\"line\">\t\tProxyName: p.Name,</span><br><span class=\"line\">\t\tPasswd:    p.Passwd,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将请求序列化为 JSON 格式并发送</span></span><br><span class=\"line\">\tbuf, _ := json.Marshal(req)</span><br><span class=\"line\">\terr = c.Write(<span class=\"type\">string</span>(buf) + <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], write to server error, %v&quot;</span>, p.Name, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后我们再转到 <code>Join</code> 函数，这个函数是搭建隧道的关键，本质上就是实现两个连接之间的双向数据传输：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Join</span><span class=\"params\">(c1 *Conn, c2 *Conn)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 等待两个数据传输协程的完成</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wait sync.WaitGroup</span><br><span class=\"line\">    <span class=\"comment\">// 从一个连接读取数据并写入到另一个连接</span></span><br><span class=\"line\">    <span class=\"comment\">// defer 用于确保在函数结束时关闭连接并通知 WaitGroup 协程已完成</span></span><br><span class=\"line\">\tpipe := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(to *Conn, from *Conn)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> to.Close()</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> from.Close()</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> wait.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">        <span class=\"comment\">// 使用 io.Copy 函数将数据从一个连接复制到另一个连接</span></span><br><span class=\"line\">        <span class=\"comment\">// 这个操作会持续进行，直到遇到错误或者EOF（文件结束标志</span></span><br><span class=\"line\">\t\t_, err = io.Copy(to.TcpConn, from.TcpConn)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;join conns error, %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\twait.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 启动两个协程，分别处理从 c1 到 c2 和从 c2 到 c1 的数据传输</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> pipe(c1, c2)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> pipe(c2, c1)</span><br><span class=\"line\">\twait.Wait()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>Ok，至此，frp v0.1.0 的源码就分析的差不多了，虽说有点老（接近 10 年前），但对理解内网穿透的实现原理也是很有帮助的。之后的版本中虽然做了很多改进，但整体实现思路其实没有太大变化。</p>\n<p>虽说不是第一次试着去阅读某个工具的源码，但边学边写博文还是第一次，可能略有混乱，但感觉也还好？唯一的问题是不适合把一段代码拆开，以 frpc 的 <code>controlWorker</code> 举例，里面先后使用了两个重要函数，一般这种情况下，我会按照代码执行逻辑先跳转到对应函数看看这个函数做了什么，看完之后再。但写文章的时候拆开整个函数，先贴前半部分，中间再塞调用的函数，然后再贴后半段函数，就感觉很怪，所以在这篇文章里，我就直接先介绍整个函数，标注其中调用的重要函数，然后在之后单独介绍。</p>\n<p>然后通篇写下来，想要吐槽的是 Golang 的错误处理机制，不论是阅读的时候还是写文章的时候都感到略有麻烦。就是那种，大家都知道按照 Golang 的风格会在操作跟一个错误处理，控制日志模块输出些信息，多数情况下对核心功能的实现没什么帮助，但你又不好省略，因为就多出两三行，贴代码的时候用 <code>// ... ...</code> 代替效果也有限，但直接省去不写也感觉很不对。就比较难受。</p>\n<p>别的都还好。</p>\n<p>我能找到的还有一篇 FRP v0.5.0 源码阅读的文章，感兴趣的可以跳过去看看，也挺不错的：</p>\n<p><a href=\"https://www.joxrays.com/frp-source-code/\">https://www.joxrays.com/frp-source-code/</a></p>\n","excerpt":"","more":"<p>frp 是一款专注于内网穿透的、高性能的反向代理工具，做 Web 安全以及网络开发时常用。就算你没接触过这些领域，室友开黑打游戏时，也可能会使用 <a href=\"https://www.natfrp.com/\">Sakura FRP</a> 做内网穿透实现局域网联机。</p>\n<h2 id=\"v0-1-0-版本\"><a href=\"#v0-1-0-版本\" class=\"headerlink\" title=\"v0.1.0 版本\"></a>v0.1.0 版本</h2><p>v0.1.0 版本的代码量很小，核心功能代码就 1079 行，项目结构也很简单，适合上手。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PROJECT:</span><br><span class=\"line\">└─frp</span><br><span class=\"line\">    ├─conf</span><br><span class=\"line\">    ├─Godeps       </span><br><span class=\"line\">    └─src</span><br><span class=\"line\">        └─frp</span><br><span class=\"line\">            ├─cmd</span><br><span class=\"line\">            │  ├─frpc</span><br><span class=\"line\">            │  └─frps</span><br><span class=\"line\">            ├─models</span><br><span class=\"line\">            │  ├─client | 客户端配置信息 &amp; </span><br><span class=\"line\">            │  ├─consts</span><br><span class=\"line\">            │  ├─msg | 定义请求/响应信息的结构体</span><br><span class=\"line\">            │  └─server | 服务端配置信息 &amp; 处理代理服务器的函数</span><br><span class=\"line\">            └─utils</span><br><span class=\"line\">                ├─broadcast | </span><br><span class=\"line\">                ├─conn | 设置本地监听器 &amp; 获取/发起连接的函数</span><br><span class=\"line\">                ├─<span class=\"built_in\">log</span> | 日志处理</span><br><span class=\"line\">                └─pcrypto</span><br></pre></td></tr></table></figure>\n\n<p>在开始之前，先了解 Godeps，一个旧时代的包依赖管理工具，原理是扫描记录版本控制的信息，并在 go 命令前加壳以实现依赖管理。不过后来逐渐被大家更为熟知的 <code>go mod</code> 取代了，其 GitHub 仓库也被 archive 了。</p>\n<p>项目中使用该工具管理 Go 依赖库时，会在项目中生成 <code>/Godeps/Godeps.json</code> 配置文件。这里就不在解释了，自己看看就可以：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;ImportPath&quot;</span>: <span class=\"string\">&quot;frp&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;GoVersion&quot;</span>: <span class=\"string\">&quot;go1.4&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Packages&quot;</span>: [</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;./...&quot;</span></span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t<span class=\"string\">&quot;Deps&quot;</span>: [</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;ImportPath&quot;</span>: <span class=\"string\">&quot;github.com/astaxie/beego/logs&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;Comment&quot;</span>: <span class=\"string\">&quot;v1.5.0-9-gfb7314f&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;Rev&quot;</span>: <span class=\"string\">&quot;fb7314f8ac86b83ccd34386518d97cf2363e2ae5&quot;</span></span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;ImportPath&quot;</span>: <span class=\"string\">&quot;github.com/vaughan0/go-ini&quot;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;Rev&quot;</span>: <span class=\"string\">&quot;a98ad7ee00ec53921f08832bc06ecf7fd600e6a1&quot;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>frp 分客户端（frpc）和服务端（frps），使用时是先建立服务端再建立客户端，就按照这个顺序。</p>\n<h3 id=\"frps\"><a href=\"#frps\" class=\"headerlink\" title=\"frps\"></a>frps</h3><p>对应的配置文件如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[common]</span></span><br><span class=\"line\"><span class=\"attr\">bind_addr</span> = <span class=\"number\">0.0</span>.<span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"attr\">bind_port</span> = <span class=\"number\">7000</span></span><br><span class=\"line\"><span class=\"attr\">log_file</span> = ./frps.log</span><br><span class=\"line\"><span class=\"comment\"># debug, info, warn, error</span></span><br><span class=\"line\"><span class=\"attr\">log_level</span> = debug</span><br><span class=\"line\"><span class=\"comment\"># file, console</span></span><br><span class=\"line\"><span class=\"attr\">log_way</span> = console </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[test1]</span></span><br><span class=\"line\"><span class=\"attr\">passwd</span> = <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"attr\">bind_addr</span> = <span class=\"number\">0.0</span>.<span class=\"number\">0.0</span></span><br><span class=\"line\"><span class=\"attr\">listen_port</span> = <span class=\"number\">6000</span></span><br></pre></td></tr></table></figure>\n\n<p>先看项目入口文件，位置是 <code>src/frp/cmd/frps/main.go</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\terr := server.LoadConf(<span class=\"string\">&quot;./frps.ini&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// ... ...</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlog.InitLog(server.LogWay, server.LogFile, server.LogLevel)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tl, err := conn.Listen(server.BindAddr, server.BindPort)</span><br><span class=\"line\">\t<span class=\"comment\">// ... ...</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlog.Info(<span class=\"string\">&quot;Start frps success&quot;</span>)</span><br><span class=\"line\">\tProcessControlConn(l)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用 <code>src/frp/models/server/config.go</code> 中的 <code>LoadConf</code> 方法加载配置文件；初始化日志记录，使用 server 包中定义的日志记录方式、日志文件和日志级别；建立连接；在前面无误的情况下打印 success 信息；最后调用 <code>ProcessControlConn</code> 函数，处理控制连接。</p>\n<p>然后看 <code>src/frp/models/server/config.go</code>。</p>\n<p>这个文件的功能就是使用 <code>github.com/vaughan0/go-ini</code> 库将配置文件信息映射为结构体，方便后续使用。配置文件可分为两部分，<code>[common]</code> 通用信息和代理服务器信息列表，其中 <code>[common]</code> 如果没在配置文件中指定，就是用该文件开头指定的默认值。其他配置信息都被当做代理服务器信息循环读取，文件开头初始化了一个 <code>ProxyServers</code>  映射，用于存储代理服务器的配置：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ProxyServers <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*ProxyServer = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]*ProxyServer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadConf</span><span class=\"params\">(confFile <span class=\"type\">string</span>)</span></span> (err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ... ...</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> name, section := <span class=\"keyword\">range</span> conf &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> name != <span class=\"string\">&quot;common&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tproxyServer := &amp;ProxyServer&#123;&#125;</span><br><span class=\"line\">\t\t\tproxyServer.Name = name</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tproxyServer.Passwd, ok = section[<span class=\"string\">&quot;passwd&quot;</span>]</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;Parse ini file error: proxy [%s] no passwd found&quot;</span>, proxyServer.Name)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tproxyServer.BindAddr, ok = section[<span class=\"string\">&quot;bind_addr&quot;</span>]</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t\tproxyServer.BindAddr = <span class=\"string\">&quot;0.0.0.0&quot;</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tportStr, ok := section[<span class=\"string\">&quot;listen_port&quot;</span>]</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">\t\t\t\tproxyServer.ListenPort, err = strconv.ParseInt(portStr, <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;Parse ini file error: proxy [%s] listen_port error&quot;</span>, proxyServer.Name)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;Parse ini file error: proxy [%s] listen_port not found&quot;</span>, proxyServer.Name)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tproxyServer.Init()</span><br><span class=\"line\">\t\t\tProxyServers[proxyServer.Name] = proxyServer</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 要求至少有一个代理服务器配置选项，如果没有就提示解析错误</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(ProxyServers) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;Parse ini file error: no proxy config found&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ... ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>日志部分使用的是 <code>github.com/astaxie/beego/logs</code> 三方库。可以不细看，日志部分所需的配置信息由上面所说的配置文件指定的。</p>\n<p>再看 <code>src/frp/utils/conn/conn.go</code>，这部分功能是实现服务端与客户端的连接。</p>\n<p>文件开头定义了一个 <code>Listener</code> 结构体，用于存储 TCP 监听器的地址、监听器对象、连接通道和关闭标志。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Listener <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\taddr      net.Addr</span><br><span class=\"line\">\tl         *net.TCPListener</span><br><span class=\"line\">\tconns     <span class=\"keyword\">chan</span> *Conn</span><br><span class=\"line\">\tcloseFlag <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Listen</code> 函数用于在指定端口启动一个 TCP 监听器，接受绑定的地址和端口号作为参数（配置文件中指定），并返回一个 <code>Listener</code> 对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Listen</span><span class=\"params\">(bindAddr <span class=\"type\">string</span>, bindPort <span class=\"type\">int64</span>)</span></span> (l *Listener, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 解析TCP地址，指定 tcp4</span></span><br><span class=\"line\">\ttcpAddr, err := net.ResolveTCPAddr(<span class=\"string\">&quot;tcp4&quot;</span>, fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, bindAddr, bindPort))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> l, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 在解析的TCP地址上开始监听</span></span><br><span class=\"line\">\tlistener, err := net.ListenTCP(<span class=\"string\">&quot;tcp&quot;</span>, tcpAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> l, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 使用监听器的地址、监听器对象、连接通道和关闭标志初始化 Listener 结构体</span></span><br><span class=\"line\">\tl = &amp;Listener&#123;</span><br><span class=\"line\">\t\taddr:      listener.Addr(),</span><br><span class=\"line\">\t\tl:         listener,</span><br><span class=\"line\">\t\tconns:     <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> *Conn),</span><br><span class=\"line\">\t\tcloseFlag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 启动一个协程来接受新的连接</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 接受新的TCP连接</span></span><br><span class=\"line\">\t\t\tconn, err := l.l.AcceptTCP()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果监听器已经关闭，则返回结束协程</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> l.closeFlag &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果是其他错误，则忽略并继续等待新的连接</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 为每个接受的连接创建一个 Conn 实例，并将其发送到 Listener 的连接通道中</span></span><br><span class=\"line\">\t\t\tc := &amp;Conn&#123;</span><br><span class=\"line\">\t\t\t\tTcpConn:   conn,</span><br><span class=\"line\">\t\t\t\tcloseFlag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tc.Reader = bufio.NewReader(c.TcpConn)</span><br><span class=\"line\">\t\t\tl.conns &lt;- c</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>返回的 <code>Listener</code> 是一个准备好接受连接的结构体。这个结构体包含了一个通道（<code>conns</code>），用于接收和存储新的连接。在 <code>Listen</code> 函数内部，有一个协程不断地接受新的连接并将它们放入这个通道。</p>\n<p>我们的目光再返回主函数。主函数建立好上文说的这个 <code>l</code> 后，就认为 frp 已经成功启动了，然后将这个 <code>l</code> 传递给控制模块进行管理，控制模块主体在 <code>src/frp/cmd/frps/control.go</code> 中。</p>\n<p><code>ProcessControlConn</code> 函数启动一个无限循环，调用 <code>l.GetConn()</code> 方法尝试从监听器获取一个新的连接对象 <code>c</code> ：如果成功获取到新的连接，它将为每个新的连接启动一个新的协程 <code>controlWorker(c)</code>，这个协程将独立处理每个连接的控制逻辑；如果 <code>l.GetConn()</code> 返回错误，函数将停止运行。</p>\n<p>这里的连接对象 <code>c</code> 在项目的 <code>utils/conn</code> 中定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Conn <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTcpConn   *net.TCPConn</span><br><span class=\"line\">\tReader    *bufio.Reader</span><br><span class=\"line\">\tcloseFlag <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Conn</code> 结构体是一个自定义的数据类型，用于封装 TCP 连接及其相关操作：</p>\n<ul>\n<li><code>TcpConn</code>：指向 <code>net.TCPConn</code> 的指针，它代表了底层的 TCP 连接。通过这个字段，可以访问和控制 TCP 网络连接的各种属性和方法，如发送和接收数据。</li>\n<li><code>Reader</code>：指向 <code>bufio.Reader</code> 的指针，它提供了一个缓冲区，可以更高效地读取数据。这个读取器封装了 <code>TcpConn</code>，使得可以方便地进行如按行读取文本等操作。</li>\n<li><code>closeFlag</code>：布尔值，用于指示连接是否已经被关闭。如果为 <code>true</code>，则表示连接已经关闭，不应再进行读写操作。</li>\n</ul>\n<p>然后再看用于处理连接的函数 <code>controlWorker(c)</code>，其中有两个较为关键的函数，均在注释中标注了 <code>★</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">controlWorker</span><span class=\"params\">(c *conn.Conn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 首条消息是从客户端发往服务器的，如果出错则关闭连接。</span></span><br><span class=\"line\">\tres, err := c.ReadLine()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Warn(<span class=\"string\">&quot;Read error, %v&quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 读取成功则继续调试信息，打印返回的消息</span></span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;get: %s&quot;</span>, res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将读取到的信息反序列化为 ClientCtlReq 结构体</span></span><br><span class=\"line\">\tclientCtlReq := &amp;msg.ClientCtlReq&#123;&#125;</span><br><span class=\"line\">\tclientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := json.Unmarshal([]<span class=\"type\">byte</span>(res), &amp;clientCtlReq); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Warn(<span class=\"string\">&quot;Parse err: %v : %s&quot;</span>, err, res)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// ★ 检查代理配置是否正确</span></span><br><span class=\"line\">\tsucc, info, needRes := checkProxy(clientCtlReq, c)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !succ &#123;</span><br><span class=\"line\">\t\tclientCtlRes.Code = <span class=\"number\">1</span></span><br><span class=\"line\">\t\tclientCtlRes.Msg = info</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> needRes &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果需要响应客户端，则在函数结束前关闭连接</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> c.Close()</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将响应消息序列化并写入连接</span></span><br><span class=\"line\">\t\tbuf, _ := json.Marshal(clientCtlRes)</span><br><span class=\"line\">\t\terr = c.Write(<span class=\"type\">string</span>(buf) + <span class=\"string\">&quot;\\\\n&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;Write error, %v&quot;</span>, err)</span><br><span class=\"line\">\t\t\ttime.Sleep(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 检查代理连接是否存在</span></span><br><span class=\"line\">\ts, ok := server.ProxyServers[clientCtlReq.ProxyName]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s] is not exist&quot;</span>, clientCtlReq.ProxyName)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// ★ 启动一个新的协程，用于读取客户端发送的控制信息</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> readControlMsgFromClient(s, c)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个新的 ClientCtlReq 结构体，并设置类型为工作连接</span></span><br><span class=\"line\">\tserverCtlReq := &amp;msg.ClientCtlReq&#123;&#125;</span><br><span class=\"line\">\tserverCtlReq.Type = consts.WorkConn</span><br><span class=\"line\">\t<span class=\"comment\">// 进入一个循环，等待用户连接，如果代理服务器关闭，记录调试信息并退出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tcloseFlag := s.WaitUserConn()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> closeFlag &#123;</span><br><span class=\"line\">\t\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], goroutine for dealing user conn is closed&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 序列化服务器控制请求并写入连接。如果写入失败，记录警告，关闭代理服务器并返回</span></span><br><span class=\"line\">\t\tbuf, _ := json.Marshal(serverCtlReq)</span><br><span class=\"line\">\t\terr = c.Write(<span class=\"type\">string</span>(buf) + <span class=\"string\">&quot;\\\\n&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], write to client error, proxy exit&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\ts.Close()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], write to client to add work conn success&quot;</span>, s.Name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Info(<span class=\"string\">&quot;ProxyName [%s], I&#x27;m dead!&quot;</span>, s.Name)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>checkProxy</code> 函数首先检验代理是否合法，然后通过检查 <code>req.Type</code> 的值来区分控制连接和工作连接。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkProxy</span><span class=\"params\">(req *msg.ClientCtlReq, c *conn.Conn)</span></span> (succ <span class=\"type\">bool</span>, info <span class=\"type\">string</span>, needRes <span class=\"type\">bool</span>) &#123;</span><br><span class=\"line\">\tsucc = <span class=\"literal\">false</span>    <span class=\"comment\">// 默认设置成功标志为 false</span></span><br><span class=\"line\">\tneedRes = <span class=\"literal\">true</span>  <span class=\"comment\">// 默认需要向客户端发送响应</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 检查代理名称是否存在</span></span><br><span class=\"line\">\ts, ok := server.ProxyServers[req.ProxyName]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s] is not exist&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 检查密码是否正确</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> req.Passwd != s.Passwd &#123;</span><br><span class=\"line\">\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s], password is not correct&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 根据请求类型处理控制连接或工作连接</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> req.Type == consts.CtlConn &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果是控制连接</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.Status != consts.Idle &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果代理已经在使用中，设置错误信息</span></span><br><span class=\"line\">\t\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s], already in use&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 启动代理并监听用户连接，此操作不会阻塞</span></span><br><span class=\"line\">\t\terr := s.Start()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s], start proxy error: %v&quot;</span>, req.ProxyName, err.Error())</span><br><span class=\"line\">\t\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlog.Info(<span class=\"string\">&quot;ProxyName [%s], start proxy success&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> req.Type == consts.WorkConn &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果是工作连接，则不需要向客户端发送响应</span></span><br><span class=\"line\">\t\tneedRes = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> s.Status != consts.Working &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], is not working when it gets one new work conn&quot;</span>, req.ProxyName)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ts.GetNewCliConn(c) <span class=\"comment\">// 获取新的客户端连接</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tinfo = fmt.Sprintf(<span class=\"string\">&quot;ProxyName [%s], type [%d] unsupport&quot;</span>, req.ProxyName, req.Type)</span><br><span class=\"line\">\t\tlog.Warn(info)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果所有检查都通过，则设置成功标志为 true</span></span><br><span class=\"line\">\tsucc = <span class=\"literal\">true</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中控制连接主要用于设置和维护工作连接，以及进行心跳检测来确保客户端仍然活跃。</p>\n<p>控制连接是客户端与服务器之间的初始连接，用于管理和控制代理的状态。在控制连接中，客户端会发送一个包含代理名称和密码的请求，服务器会验证这些信息，如果验证成功，服务器就会根据请求的类型来启动代理或处理其他控制消息。</p>\n<p>而工作连接是在控制连接建立后由客户端发起的，用于实际的数据传输。工作连接允许用户数据通过代理服务器转发，实现客户端和服务端之间的通信。</p>\n<p><code>readControlMsgFromClient</code> 函数用于读取客户端发送的控制信息 ，它接受一个代理服务器和连接作为参数，用于读取客户端发送的控制消息，包括对心跳信息的处理，用于保持客户端和服务端的连接。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readControlMsgFromClient</span><span class=\"params\">(s *server.ProxyServer, c *conn.Conn)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 用于控制循环读取消息的条件</span></span><br><span class=\"line\">\tisContinueRead := <span class=\"literal\">true</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 用于处理心跳超时的情况，超时则关闭服务器连接</span></span><br><span class=\"line\">\tf := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tisContinueRead = <span class=\"literal\">false</span></span><br><span class=\"line\">\t\ts.Close()</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], client heartbeat timeout&quot;</span>, s.Name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个定时器 timer，在 HeartBeatTimeout 时间后执行函数 f</span></span><br><span class=\"line\">\ttimer := time.AfterFunc(time.Duration(server.HeartBeatTimeout)*time.Second, f)</span><br><span class=\"line\">\t<span class=\"comment\">// defer 语句保证在函数结束时停止定时器。</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> timer.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 循环读取客户端发送的消息，连接超时则跳出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> isContinueRead &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 从连接 c 中读取一行消息，存储在 content 中</span></span><br><span class=\"line\">\t\tcontent, err := c.ReadLine()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], client is dead!&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\t\ts.Close()</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"literal\">nil</span> == c || c.IsClosed() &#123;</span><br><span class=\"line\">\t\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], client connection is closed&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], read error: %v&quot;</span>, s.Name, err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 创建一个指针，存储解析后的客户端控制请求消息</span></span><br><span class=\"line\">\t\tclientCtlReq := &amp;msg.ClientCtlReq&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将 content 解析为 msg.ClientCtlReq 结构体，并将解析结果存储在 clientCtlReq 中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := json.Unmarshal([]<span class=\"type\">byte</span>(content), clientCtlReq); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;Parse err: %v : %s&quot;</span>, err, content)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 判断消息是否为心跳请求</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> consts.CSHeartBeatReq == clientCtlReq.Type &#123;</span><br><span class=\"line\">\t\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], get heartbeat&quot;</span>, s.Name)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 重置定时器，延长心跳超时时间，确保客户端保持活跃</span></span><br><span class=\"line\">\t\t\ttimer.Reset(time.Duration(server.HeartBeatTimeout) * time.Second)</span><br><span class=\"line\">\t\t\tclientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 设置心跳响应消息的响应码为 consts.SCHeartBeatRes，然后将响应序列化为 JSON 格式字符串</span></span><br><span class=\"line\">\t\t\tclientCtlRes.GeneralRes.Code = consts.SCHeartBeatRes</span><br><span class=\"line\">\t\t\tresponse, err := json.Marshal(clientCtlRes)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Warn(<span class=\"string\">&quot;Serialize ClientCtlRes err! err: %v&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\terr = c.Write(<span class=\"type\">string</span>(response) + <span class=\"string\">&quot;\\\\n&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Error(<span class=\"string\">&quot;Send heartbeat response to client failed! Err:%v&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"frpc\"><a href=\"#frpc\" class=\"headerlink\" title=\"frpc\"></a>frpc</h3><p><code>ini</code> 配置文件如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[common]</span></span><br><span class=\"line\"><span class=\"attr\">server_addr</span> = <span class=\"number\">127.0</span>.<span class=\"number\">0.1</span></span><br><span class=\"line\"><span class=\"attr\">server_port</span> = <span class=\"number\">7000</span></span><br><span class=\"line\"><span class=\"attr\">log_file</span> = ./frpc.log</span><br><span class=\"line\"><span class=\"comment\"># debug, info, warn, error</span></span><br><span class=\"line\"><span class=\"attr\">log_level</span> = debug</span><br><span class=\"line\"><span class=\"comment\"># file, console</span></span><br><span class=\"line\"><span class=\"attr\">log_way</span> = console</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[test1]</span></span><br><span class=\"line\"><span class=\"attr\">passwd</span> = <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"attr\">local_port</span> = <span class=\"number\">22</span></span><br></pre></td></tr></table></figure>\n\n<p>同样是入口文件开始，位置是 <code>src/frp/cmd/frpc/main.go</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\terr := client.LoadConf(<span class=\"string\">&quot;./frpc.ini&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tos.Exit(<span class=\"number\">-1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.InitLog(client.LogWay, client.LogFile, client.LogLevel)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 等待所有控制协程退出，实际上是在声明将会有 len(client.ProxyClients) 数量的协程</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wait sync.WaitGroup</span><br><span class=\"line\">\twait.Add(<span class=\"built_in\">len</span>(client.ProxyClients))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有代理客户端，并为每个客户端启动一个控制协程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, client := <span class=\"keyword\">range</span> client.ProxyClients &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> ControlProcess(client, &amp;wait)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlog.Info(<span class=\"string\">&quot;Start frpc success&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有控制协程退出</span></span><br><span class=\"line\">\twait.Wait()</span><br><span class=\"line\">\tlog.Warn(<span class=\"string\">&quot;All proxy exit!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加载配置文件和日志初始化都讲过了，不再赘述。将目光移至 <code>src/frp/cmd/frpc/control.go</code>，看看用于处理客户端的 <code>ControlProcess()</code>。其中关键函数是用于连接服务端的 <code>loginToServer</code> 函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ControlProcess</span><span class=\"params\">(cli *client.ProxyClient, wait *sync.WaitGroup)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 延迟 wait.Done() 的执行直到 ControlProcess( )函数即将返回</span></span><br><span class=\"line\">    <span class=\"comment\">// 这是通知 sync.WaitGroup 当前协程已经完成的标准方式</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> wait.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ★ 尝试登录到服务器，如果成功，返回一个连接对象</span></span><br><span class=\"line\">\tc, err := loginToServer(cli)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], connect to server failed!&quot;</span>, cli.Name)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconnection = c</span><br><span class=\"line\">    <span class=\"comment\">// 确保函数结束时关闭网络连接</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> connection.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 无限循环并从服务器读取数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tcontent, err := connection.ReadLine()</span><br><span class=\"line\">        <span class=\"comment\">// 遇到 io.EOF 或连接被关闭，尝试重新连接服务器</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == io.EOF || <span class=\"literal\">nil</span> == connection || connection.IsClosed() &#123;</span><br><span class=\"line\">\t\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], server close this control conn&quot;</span>, cli.Name)</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">            <span class=\"comment\">// 使用指数退避策略来重连服务器，每次失败后等待时间翻倍，直到最大 60 秒</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> sleepTime time.Duration = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], try to reconnect to server[%s:%d]...&quot;</span>, cli.Name, client.ServerAddr, client.ServerPort)</span><br><span class=\"line\">\t\t\t\ttmpConn, err := loginToServer(cli)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tconnection.Close()</span><br><span class=\"line\">\t\t\t\t\tconnection = tmpConn</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> sleepTime &lt; <span class=\"number\">60</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tsleepTime = sleepTime * <span class=\"number\">2</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\ttime.Sleep(sleepTime * time.Second)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;ProxyName [%s], read from server error, %v&quot;</span>, cli.Name, err)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 尝试解析服务器返回的内容为 ClientCtlRes 结构体</span></span><br><span class=\"line\">\t\tclientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := json.Unmarshal([]<span class=\"type\">byte</span>(content), clientCtlRes); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;Parse err: %v : %s&quot;</span>, err, content)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查是否收到心跳响应，如果是，则重置心跳计时器</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> consts.SCHeartBeatRes == clientCtlRes.GeneralRes.Code &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> heartBeatTimer != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Debug(<span class=\"string\">&quot;Client rcv heartbeat response&quot;</span>)</span><br><span class=\"line\">\t\t\t\theartBeatTimer.Reset(time.Duration(client.HeartBeatTimeout) * time.Second)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Error(<span class=\"string\">&quot;heartBeatTimer is nil&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ★ 如果收到的不是心跳响应，则尝试启动隧道</span></span><br><span class=\"line\">\t\tcli.StartTunnel(client.ServerAddr, client.ServerPort)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来是 <code>loginToServer</code> 函数，核心函数有两个，分别是用于连接到指定地址端口的 <code>ConnectServer</code> 和用于启动心跳检测的 <code>startHeartBeat</code> 函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loginToServer</span><span class=\"params\">(cli *client.ProxyClient)</span></span> (c *conn.Conn, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ★ 建立连接，返回一个连接对象</span></span><br><span class=\"line\">    c, err = conn.ConnectServer(client.ServerAddr, client.ServerPort)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], connect to server [%s:%d] error, %v&quot;</span>, cli.Name, client.ServerAddr, client.ServerPort, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个 ClientCtlReq 结构体，指定请求类型 CtlConn，表示这是一个控制连接请求</span></span><br><span class=\"line\">\treq := &amp;msg.ClientCtlReq&#123;</span><br><span class=\"line\">\t\tType:      consts.CtlConn,</span><br><span class=\"line\">\t\tProxyName: cli.Name,</span><br><span class=\"line\">\t\tPasswd:    cli.Passwd,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 序列化为 JSON 并发送请求</span></span><br><span class=\"line\">\tbuf, _ := json.Marshal(req)</span><br><span class=\"line\">\terr = c.Write(<span class=\"type\">string</span>(buf) + <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], write to server error, %v&quot;</span>, cli.Name, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 读取响应</span></span><br><span class=\"line\">\tres, err := c.ReadLine()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], read from server error, %v&quot;</span>, cli.Name, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], read [%s]&quot;</span>, cli.Name, res)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将响应的内容解析为 ClientCtlRes 结构体</span></span><br><span class=\"line\">\tclientCtlRes := &amp;msg.ClientCtlRes&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err = json.Unmarshal([]<span class=\"type\">byte</span>(res), &amp;clientCtlRes); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], format server response error, %v&quot;</span>, cli.Name, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查响应代码</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> clientCtlRes.Code != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], start proxy error, %s&quot;</span>, cli.Name, clientCtlRes.Msg)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c, fmt.Errorf(<span class=\"string\">&quot;%s&quot;</span>, clientCtlRes.Msg)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ★ 启动心跳</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> startHeartBeat(c)</span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;ProxyName [%s], connect to server[%s:%d] success!&quot;</span>, cli.Name, client.ServerAddr, client.ServerPort)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先看实现连接的<code>ConnectServer</code> 函数，位于 <code>utils/conn</code>。这个函数实际上是对普通 TCP 连接的封装：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Conn <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tTcpConn   *net.TCPConn</span><br><span class=\"line\">\tReader    *bufio.Reader</span><br><span class=\"line\">\tcloseFlag <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ConnectServer</span><span class=\"params\">(host <span class=\"type\">string</span>, port <span class=\"type\">int64</span>)</span></span> (c *Conn, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\tc = &amp;Conn&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 net.ResolveTCPAddr 解析 TCP 地址</span></span><br><span class=\"line\">\tservertAddr, err := net.ResolveTCPAddr(<span class=\"string\">&quot;tcp4&quot;</span>, fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, host, port))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 建立到服务器的 TCP 连接</span></span><br><span class=\"line\">\tconn, err := net.DialTCP(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"literal\">nil</span>, servertAddr)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将建立的 TCP 连接赋给 Conn 结构体的 TcpConn 字段</span></span><br><span class=\"line\">\tc.TcpConn = conn</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新的缓冲读取器，并赋给 Conn 的 Reader 字段</span></span><br><span class=\"line\">\tc.Reader = bufio.NewReader(c.TcpConn)</span><br><span class=\"line\">    <span class=\"comment\">// 表示连接目前是打开的</span></span><br><span class=\"line\">\tc.closeFlag = <span class=\"literal\">false</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同文件中用于操作 Conn 结构体的函数此处不再展示</span></span><br><span class=\"line\"><span class=\"comment\">// 还有一个用于实现隧道通信的 Join 函数，稍后会说</span></span><br></pre></td></tr></table></figure>\n\n<p>然后看 <code>startHeartBeat</code> 函数，该函数用于发起心跳包维持客户端与服务端的连接：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startHeartBeat</span><span class=\"params\">(c *conn.Conn)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 心跳超时则关闭连接</span></span><br><span class=\"line\">\tf := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;HeartBeat timeout!&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tc.Close()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   \t<span class=\"comment\">// 创建一个计时器，在指定的心跳超时时间后执行函数f</span></span><br><span class=\"line\">\theartBeatTimer = time.AfterFunc(time.Duration(client.HeartBeatTimeout)*time.Second, f)</span><br><span class=\"line\">\t<span class=\"comment\">// 确保在函数退出前停止计时器</span></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> heartBeatTimer.Stop()</span><br><span class=\"line\"></span><br><span class=\"line\">\tclientCtlReq := &amp;msg.ClientCtlReq&#123;</span><br><span class=\"line\">\t\tType:      consts.CSHeartBeatReq,</span><br><span class=\"line\">\t\tProxyName: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">\t\tPasswd:    <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将心跳请求序列化为JSON格式</span></span><br><span class=\"line\">\trequest, err := json.Marshal(clientCtlReq)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Warn(<span class=\"string\">&quot;Serialize clientCtlReq err! Err: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进入一个无限循环，每次循环开始时都会休眠一段时间，这个时间由心跳间隔决定</span></span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;Start to send heartbeat&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\ttime.Sleep(time.Duration(client.HeartBeatInterval) * time.Second)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c != <span class=\"literal\">nil</span> &amp;&amp; !c.IsClosed() &#123;</span><br><span class=\"line\">\t\t\terr = c.Write(<span class=\"type\">string</span>(request) + <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tlog.Error(<span class=\"string\">&quot;Send hearbeat to server failed! Err:%v&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;Heartbeat exit&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们实现了客户端与服务端的连接，并在连接后依靠心跳机制实现了维持通信，下一步就是建立隧道，实现通信功能。视角转到 <code>utils/conn</code> 的 <code>StartTunnel</code> 函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ProxyClient)</span></span> StartTunnel(serverAddr <span class=\"type\">string</span>, serverPort <span class=\"type\">int64</span>) (err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 建立到本地服务的连接</span></span><br><span class=\"line\">    localConn, err := p.GetLocalConn()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ★ 建立到服务端的连接</span></span><br><span class=\"line\">    remoteConn, err := p.GetRemoteConn(serverAddr, serverPort)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// l means local, r means remote</span></span><br><span class=\"line\">\tlog.Debug(<span class=\"string\">&quot;Join two conns, (l[%s] r[%s]) (l[%s] r[%s])&quot;</span>, localConn.GetLocalAddr(), localConn.GetRemoteAddr(),</span><br><span class=\"line\">\t\tremoteConn.GetLocalAddr(), remoteConn.GetRemoteAddr())</span><br><span class=\"line\">    <span class=\"comment\">// ★ 创建协程将本地连接和远程连接“连接”起来，使得数据可以在两者之间传输</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> conn.Join(localConn, remoteConn)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>建立到本地服务的连接没什么好说的，获取配置文件中的本地端口做个调用即可。着重看下 <code>GetRemoteConn</code> 函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ProxyClient)</span></span> GetRemoteConn(addr <span class=\"type\">string</span>, port <span class=\"type\">int64</span>) (c *conn.Conn, err <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 defer 关键字来确保在函数返回前关闭连接</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tc.Close()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tc, err = conn.ConnectServer(addr, port)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], connect to server [%s:%d] error, %v&quot;</span>, p.Name, addr, port, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造一个客户端控制请求消息，声明为工作连接</span></span><br><span class=\"line\">\treq := &amp;msg.ClientCtlReq&#123;</span><br><span class=\"line\">\t\tType:      consts.WorkConn,</span><br><span class=\"line\">\t\tProxyName: p.Name,</span><br><span class=\"line\">\t\tPasswd:    p.Passwd,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将请求序列化为 JSON 格式并发送</span></span><br><span class=\"line\">\tbuf, _ := json.Marshal(req)</span><br><span class=\"line\">\terr = c.Write(<span class=\"type\">string</span>(buf) + <span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(<span class=\"string\">&quot;ProxyName [%s], write to server error, %v&quot;</span>, p.Name, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = <span class=\"literal\">nil</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后我们再转到 <code>Join</code> 函数，这个函数是搭建隧道的关键，本质上就是实现两个连接之间的双向数据传输：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Join</span><span class=\"params\">(c1 *Conn, c2 *Conn)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 等待两个数据传输协程的完成</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> wait sync.WaitGroup</span><br><span class=\"line\">    <span class=\"comment\">// 从一个连接读取数据并写入到另一个连接</span></span><br><span class=\"line\">    <span class=\"comment\">// defer 用于确保在函数结束时关闭连接并通知 WaitGroup 协程已完成</span></span><br><span class=\"line\">\tpipe := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(to *Conn, from *Conn)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> to.Close()</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> from.Close()</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> wait.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> err <span class=\"type\">error</span></span><br><span class=\"line\">        <span class=\"comment\">// 使用 io.Copy 函数将数据从一个连接复制到另一个连接</span></span><br><span class=\"line\">        <span class=\"comment\">// 这个操作会持续进行，直到遇到错误或者EOF（文件结束标志</span></span><br><span class=\"line\">\t\t_, err = io.Copy(to.TcpConn, from.TcpConn)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Warn(<span class=\"string\">&quot;join conns error, %v&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\twait.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 启动两个协程，分别处理从 c1 到 c2 和从 c2 到 c1 的数据传输</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> pipe(c1, c2)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> pipe(c2, c1)</span><br><span class=\"line\">\twait.Wait()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>Ok，至此，frp v0.1.0 的源码就分析的差不多了，虽说有点老（接近 10 年前），但对理解内网穿透的实现原理也是很有帮助的。之后的版本中虽然做了很多改进，但整体实现思路其实没有太大变化。</p>\n<p>虽说不是第一次试着去阅读某个工具的源码，但边学边写博文还是第一次，可能略有混乱，但感觉也还好？唯一的问题是不适合把一段代码拆开，以 frpc 的 <code>controlWorker</code> 举例，里面先后使用了两个重要函数，一般这种情况下，我会按照代码执行逻辑先跳转到对应函数看看这个函数做了什么，看完之后再。但写文章的时候拆开整个函数，先贴前半部分，中间再塞调用的函数，然后再贴后半段函数，就感觉很怪，所以在这篇文章里，我就直接先介绍整个函数，标注其中调用的重要函数，然后在之后单独介绍。</p>\n<p>然后通篇写下来，想要吐槽的是 Golang 的错误处理机制，不论是阅读的时候还是写文章的时候都感到略有麻烦。就是那种，大家都知道按照 Golang 的风格会在操作跟一个错误处理，控制日志模块输出些信息，多数情况下对核心功能的实现没什么帮助，但你又不好省略，因为就多出两三行，贴代码的时候用 <code>// ... ...</code> 代替效果也有限，但直接省去不写也感觉很不对。就比较难受。</p>\n<p>别的都还好。</p>\n<p>我能找到的还有一篇 FRP v0.5.0 源码阅读的文章，感兴趣的可以跳过去看看，也挺不错的：</p>\n<p><a href=\"https://www.joxrays.com/frp-source-code/\">https://www.joxrays.com/frp-source-code/</a></p>\n"},{"title":"JavaScript 执行原理","date":"2024-02-09T16:00:00.000Z","author":"ma5hr00m","_content":"\n最近在复习 JavaScript 反混淆相关内容，正好给执行原理补个档，之前旧版的随旧博客一起遗失了，这里重新写了一篇。\n\n预计之后还会有 [JavaScript执行原理·补](#) 和 [JavaScript混淆/反混淆](#)，慢慢写吧。\n\n:::tip\n\n跳转到 [JavaScript混淆/反混淆](https://ma5hr00m.top/archives/2024/02/js-obfuscation-deobfuscation.html)\n\n:::\n\n## JavaScript\n\nJavaScript 是一门解释型语言，与 C/Golang 等静态编译语言不同。静态编译型语言通过编译器直接将代码转化为机器码，然后运行在机器上；JS 是先经过编译产生字节码，然后在虚拟机上运行字节码（这点与 Java&JVM 很相似），性能虽不及静态编译型语言，但获得了更多的灵活性。\n\n## 前置知识\n\n### JS Engine 引擎\n\n为什么需要 [JS Engine](https://en.wikipedia.org/wiki/JavaScript_engine)🤔️？\n\nJS Engine 其实就可以理解为上文中所说的虚拟机。机器底层的 CPU 只能执行指令集中的指令（即对应的汇编代码），无法直接识别高级语言。JS Engine 可以将 JS 代码编译为字节码，然后执行代码，同时还提供了分配内存和垃圾回收的功能，极大程度上减轻了开发人员的工作量，何乐而不为。\n\n从本质上来讲，JS Engine 就是一段程序，用于实现上述功能。\n\n互联网中最常见、使用最广泛的 JS Engine 是 **Google V8**。Google V8 是用 C++ 编写的开源高性能 JS Engine（同时也是 WebAssembly Engine），目前已被用于 Chrome 浏览器、Node.js、MongoDB 等多个知名项目。Chrome 占据了全球浏览器市场 60% 的份额，而 Node.js 已然成为服务器端 JS 代码的执行标准，由此可见 V8 使用之广泛。\n\n除此之外，还有一些常见的 JS Engine：\n\n- 由 Mozilla 为 Firefox 开发的 SpiderMonkey\n- 为 Safari 浏览器提供支持的 JavaScriptCore\n- 为 IE 提供支持的 Chakra\n\n本篇接下来的 JS Engine 都默认为 Google V8。\n\n### JS Runtime 运行时\n\n我们可以把 JS Runtime 理解为一栋房子，JS 代码都需要在这栋房子中运行。而这栋房子由很多部分共同组成，包括 JS Engine、外部 API 和回调队列（callback queue）。有时也把 JS 用到的 core lib 核心库看作 Runtime 的一部分。\n\n![20240221083858](https://img.ma5hr00m.top/blog/20240221083858.png)\n\n以 Chrome 浏览器的 JS Runtime 举例，浏览器的 Runtime 由对应的 JS Engine、Web API 和回调队列组成。JS Engine 在上文中有讲，不再赘述；Web API 是浏览器提供给 Engine 的一系列接口，并不是 JS 的一部分，目的是方便操纵数据和增强浏览器的功能，常用的 Web API 包括 DOM、Web Worker 等；回调队列包括准备好执行的回调函数，回调队列确保回调以先进先出（FIFO）方法执行，并在堆栈为空时将其传递到堆栈中。\n\n与浏览器 Runtime 不同的是，Node.js 没有 Web API，而是有叫作 C++ 绑定和线程池的其他部分。\n\n我们可以这样说，Chrome 和 Node.js 中的 JS 代码都依赖于 V8 运行，但它们运行在不同的 Runtime 中。\n\n在开始之前，我们要知道，V8 是一个非常复杂的项目，有超过 100w 行代码。我们可以根据功能将 V8 Engine 分为不同的子模块，其中最重要的四个子模块分别是：\n\n- [Parser](https://v8.dev/blog/scanner)：解析器，将 JS 源码转换为抽象语法树（AST）；\n- [Ignition](https://v8.dev/docs/ignition)：解释器，将 AST 转换为字节码（Bytecode），然后解释执行 Bytecode，同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；\n- [TurboFan](https://v8.dev/docs/turbofan)：编译器，利用 Ignitio 所收集的类型信息，将 Bytecode 转换为优化后的汇编代码；\n- [Orinoco](https://v8.dev/blog/trash-talk)：垃圾回收模块，负责将程序不再需要的内存空间回收；\n\n前三个子模块可以代表 JS 运行的主要三个阶段：解析、解释、编译，最后运行。接下来，我会以 V8 Engine 为例，讲讲 JS 代码到底是如何从编写到运行的。\n\n## Parser 解析\n\nParser 的功能是将 JS 源码转化为 AST。更确切地说，源码是先经过词法分析转化为 Token，然后 Toekn 经过语法分析转换为 AST。\n\n### Lexing 词法分析\n\n**词法分析** 这个过程会将由字符组成的字符串分解成代码块，这些代码块被称为“词法单元”（Token）。从数据方面来说，这一步是字符流（char stream）转换为标记流（token stream）。\n\n我们编写一个`main.js`文件，写入以下内容：\n\n```JavaScript\nconst a = 3;\n```\n\n以这段代码为例，会被分为`const`、`a`、`=`、`3`、`;`词法单元。`space`是否被当作词法单元，取决于其在当前编程语言中是否有意义，JS 中的空格是无意义，不会被当作词法单元。\n\n以下为经过词法分析的 JSON 格式的 Tokens：\n\n```JSON\n[\n    {\n        \"type\": \"Keyword\",\n        \"value\": \"const\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"a\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \"=\"\n    },\n    {\n        \"type\": \"Numeric\",\n        \"value\": \"3\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \";\"\n    }\n]\n```\n\n分词（Tokenizing）和词法分析（Lexing）的区别在于：词法单元的识别是通过有状态还是无状态的方式进行的，无状态的为分词。这里“状态”的有无则是根据数据的处理过程是否需要考虑其他相关信息决定的。\n\n在 JS 解析的过程中，我们需要考虑当前词法单元与前面的词法单元之间的关系，因此，JS 的解析是一个有状态的过程，我们就会将字符流转换为 token 的这一过程称为 Lexing 而非 Tokenizing。\n\n### Parsing 语法分析\n\n**语法分析** 是将标记流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，我们称其为抽象语法树（AST）。\n\n上文中的 Tokens 经过语法分析得到的 JSON 格式的 AST 如下：\n\n```JSON\n{\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"VariableDeclaration\",\n      \"declarations\": [\n        {\n          \"type\": \"VariableDeclarator\",\n          \"id\": {\n            \"type\": \"Identifier\",\n            \"name\": \"a\"\n          },\n          \"init\": {\n            \"type\": \"Literal\",\n            \"value\": 3,\n            \"raw\": \"3\"\n          }\n        }\n      ],\n      \"kind\": \"const\"\n    }\n  ],\n  \"sourceType\": \"script\"\n}\n```\n\n解析的过程就这么多，最终效果就是得到源码对应的AST。\n\n[Esprima](https://esprima.org/demo/parse.html#) 站点提供了在线解析 JS 代码的功能，输入 JS 代码就可以得到经过 Lexing 的 Tokens 和 经过 Parsing 的 AST，可以动手尝试一下。\n\n除此之外， [AST explorer](https://astexplorer.net/) 站点也可以在线将 JS 代码转化为 AST。这个网站是基于 acorn.js 实现的，[acorn.js](https://www.npmjs.com/package/acorn)  是一个 JavaScript Parser，你可以通过`npm`等包管理器下载并使用它。以下是一段使用 acorn.js 将指定代码转化为 AST 的案例。指定解析`console.log(1);`并以JSON格式输出：\n\n```JavaScript\nconst { Parser } = require('acorn')\n\nconst javascriptCode = `\n  console.log(1);\n`;\n\nconst ast = Parser.parse(javascriptCode, { ecmaVersion: 2024 });\nconsole.log(JSON.stringify(ast));\n```\n\n## Ignition 解释\n\nIgnition 的主要功能是负责将 AST 转换为字节码（Bytecode）并解释执行。\n\nBytecode 是一种包含执行程序、由一序列 op 代码/数据对组成的二进制文件，是一种中间码（IR），是机器码的一种抽象。它不面向任何机器，只面向当前虚拟机（这里是 V8 引擎）。\n\n> 我们常说的字节码多是指 Java 字节码，实际上很多动态编译解释的语言都有字节码，比如 Python/JavaScript/Ruby。\n\n早期的 V8 直接将 AST 编译为机器码，然后在机器中执行，因为这样的效率更高。但机器码会占用过多的系统内存，相比之下，Bytecode 占用的内存空间远比机器码少得多，Google 团队遂选择以时间换空间，转换为现在的 AST->Bytecode->机器码。\n\n![20240221083929](https://img.ma5hr00m.top/blog/20240221083929.png)\n\nNode.js 提供了很多关于 V8 引擎的选项，比如`--print-bytecode`用于获取源码对应的字节码。\n\n先编写这样一段 JS 代码并保存为 main.js 文件：\n\n```JavaScript\nfunction ma5hr00m() {\n  console.log(1);\n}\n\nma5hr00m();\n```\n\n然后使用`node --print-bytecode main.js`即可得到代码的 Bytecode，会输出非常非常多的内容，可以查找到`ma5hr00m()`函数对应的 Bytecode：\n\n```JavaScript\n[generated bytecode for function: ma5hr00m (0x3ae97a693191 )]                                                                     \nBytecode length: 19                                                                                                                                            \nParameter count 1                                                                                                                                              \nRegister count 3                                                                                                                                               \nFrame size 24                                                                                                                                                  \nBytecode age: 0                                                                                                                                                \n   24 S> 0x3ae97a6940ee @    0 : 21 00 00          LdaGlobal [0], [0]                                                                                          \n         0x3ae97a6940f1 @    3 : c3                Star1                                                                                                       \n   32 E> 0x3ae97a6940f2 @    4 : 2d f9 01 02       GetNamedProperty r1, [1], [2]                                                                               \n         0x3ae97a6940f6 @    8 : c4                Star0                                                                                                       \n         0x3ae97a6940f7 @    9 : 0d 01             LdaSmi [1]                                                                                                  \n         0x3ae97a6940f9 @   11 : c2                Star2                                                                                                       \n   32 E> 0x3ae97a6940fa @   12 : 5e fa f9 f8 04    CallProperty1 r0, r1, r2, [4]                                                                               \n         0x3ae97a6940ff @   17 : 0e                LdaUndefined                                                                                                \n   40 S> 0x3ae97a694100 @   18 : a9                Return                                                                                                      \nConstant pool (size = 2)                                                                                                                                       \n0x3ae97a694099: [FixedArray] in OldSpace                                                                                                                       \n - map: 0x2a087bbc0211                                                                                                                  \n - length: 2                                                                                                                                                   \n           0: 0x2a087bbc5ce9                                                                                                              \n           1: 0x398ad9accb91                                                                                                                  \nHandler Table (size = 0)                                                                                                                                       \nSource Position Table (size = 10)                                                                                                                              \n0x3ae97a694109 \n```\n\n我们可以简单分析其中 Bytecode 字段对应的指令：\n\n- 从全局加载一个值到寄存器中；\n- 将寄存器 1 的值存储到一个位置；\n- 从一个对象中获取属性并存储到寄存器 0；\n- ……\n\n这看起来很像我们学习过的汇编语言，或者说 Bytecode 就是抽象后的汇编，它仅面向虚拟机 CPU 而不是其他任何机器的 CPU，这就说明 V8 不需要为不同的 CPU 生成不同的代码，只需生成 Bytecode，这样也在某种程度上简化了 V8 的编译流程，提高了其可拓展性。\n\n## TurboFan 编译\n\nTurboFan 负责将 Bytecode 转换为优化后的机器码。\n\n前面说过，Ignition 子模块已经可以完成 AST->Bytecode 并解释执行，那为什么 V8 还需要 TurboFan 来编译 Bytecode 呢？\n\n前面说过，JavaScript 是一门解释型的语言。解释型语言的特点是：\n\n- 运行时逐行被解释器解释并执行；\n- 每次运行程序时都需要将源代码翻译成机器代码并执行；\n\n解释型语言的好处就是灵活且启动速度快，在 Web 应用场景下，这种策略是优于编译型语言的。但随着时代进步，Web 应用越来越庞大，解释型语言执行速度慢的缺点也逐渐凸显出来。在 V8 出现之前，所有 JS Engine 都采用着解释执行的方式。\n\n而 V8 率先引入了即时编译（JIT）的设计，这种设计混合了解释执行和编译执行两种策略，极大地提升了 JS 的执行速度。之后其它 JS Engine 也是迅速跟进。\n\n### JIT 即时编译\n\nJust-in-Time 技术是解释执行和编译执行二者之间权衡之后的产物。简单地说，V8 在启动过程中采用解释执行的策略，如果某段代码的超过某个阈值，V8 就会把这段代码编译成执行效率更高的机器码。\n\n不同 Engine 在实现 JIT 的手段上存在区别，但总体思想是一致的，就是在 Engine 内部添加一个监视器。监视器负责监视代码的运行情况，记录代码一共运行了多少次、代码如何运行等。监视器会根据代码重复次数以及运行某段代码占用的执行时长，对代码进行标记，标记共分为`warm`、`hot`和`very hot`三个等级。\n\n举个例子说明：\n\n```JavaScript\nfunction arraySum(arr) {\n    let sum = 0;\n    for (var i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n}\n```\n\n这段代码刚开始运行时，监视器监视着所有代码的运行情况。\n\n如果同一行代码重复执行几次，监视器会把这段代码标记为`warm`。\n\n被标记为`warm`的代码段会被 JIT 传递给 *基线编译器* 进行编译，并将结果储存。`warm`代码段的每一行都会被编译成一个`stub`，同时给这个`stub`分配一个以“行号 + 变量类型”的索引。此时并没有使用编译的代码替换原本的代码。\n\n如果监视器监视到，某行某个变量使用了同样的变量类型在此多次执行同样的代码，就会将`warm`升级为`hot`，并把已编译的代码 push 给浏览器，浏览器接收后就会用编译后的代码替换原本的代码。\n\n如果`hot`代码段重复次数非常多以至于占用了大部分执行时间，就标记为`very hot`。\n\n被标记为`very hot`的代码段会被 JIT 传递给 *优化编译器* 进行编译，生成一个更快速和高效的代码版本，并且存储。例如上面这段代码，`sum`和`arr[i]`两个数并不保证都是整数（JS 动态类型），每次`+=`执行前都需要先判断一遍数据类型，如果这段代码重复执行了非常多次且每次这两个变量都是 INT 型，那这段代码被丢给优化编译器进行编译时，就会被优化为优先进行 INT 类型的判断，以节约时间。\n\n如果上述经过优化的代码出现问题，某次执行数据判断的结果不是 INT 型，那这段经过优化编译得到的代码就会被直接丢弃，执行过程回到解释器/基线解释器，这个过程被称为 *去优化*。\n\n要注意，JIT 与虚拟机执行策略的选择有关，而和语言本身无关。除了 JS，其他解释型语言也会引入 JIT 技术，以提高执行效率。\n\n## 参阅文章\n\n- [JavaScript 语法解析、AST、V8、JIT](https://cheogo.github.io/learn-javascript/201709/runtime.html)\n- [JavaScript深入浅出第4课：V8引擎是如何工作的](https://kiwenlau.com/2019/07/16/how-does-v8-work/)，by 寒雁Talk\n- [WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理](https://zhuanlan.zhihu.com/p/25669120)，by 知乎\n- [JS中的JIT与基本执行逻辑](https://juejin.cn/post/6863269040300032008)，by 稀土掘金","source":"_posts/how-js-run.md","raw":"---\ntitle: JavaScript 执行原理\ndate: 2024/2/10\nauthor: ma5hr00m\ncategories:\n- JavaScript\n---\n\n最近在复习 JavaScript 反混淆相关内容，正好给执行原理补个档，之前旧版的随旧博客一起遗失了，这里重新写了一篇。\n\n预计之后还会有 [JavaScript执行原理·补](#) 和 [JavaScript混淆/反混淆](#)，慢慢写吧。\n\n:::tip\n\n跳转到 [JavaScript混淆/反混淆](https://ma5hr00m.top/archives/2024/02/js-obfuscation-deobfuscation.html)\n\n:::\n\n## JavaScript\n\nJavaScript 是一门解释型语言，与 C/Golang 等静态编译语言不同。静态编译型语言通过编译器直接将代码转化为机器码，然后运行在机器上；JS 是先经过编译产生字节码，然后在虚拟机上运行字节码（这点与 Java&JVM 很相似），性能虽不及静态编译型语言，但获得了更多的灵活性。\n\n## 前置知识\n\n### JS Engine 引擎\n\n为什么需要 [JS Engine](https://en.wikipedia.org/wiki/JavaScript_engine)🤔️？\n\nJS Engine 其实就可以理解为上文中所说的虚拟机。机器底层的 CPU 只能执行指令集中的指令（即对应的汇编代码），无法直接识别高级语言。JS Engine 可以将 JS 代码编译为字节码，然后执行代码，同时还提供了分配内存和垃圾回收的功能，极大程度上减轻了开发人员的工作量，何乐而不为。\n\n从本质上来讲，JS Engine 就是一段程序，用于实现上述功能。\n\n互联网中最常见、使用最广泛的 JS Engine 是 **Google V8**。Google V8 是用 C++ 编写的开源高性能 JS Engine（同时也是 WebAssembly Engine），目前已被用于 Chrome 浏览器、Node.js、MongoDB 等多个知名项目。Chrome 占据了全球浏览器市场 60% 的份额，而 Node.js 已然成为服务器端 JS 代码的执行标准，由此可见 V8 使用之广泛。\n\n除此之外，还有一些常见的 JS Engine：\n\n- 由 Mozilla 为 Firefox 开发的 SpiderMonkey\n- 为 Safari 浏览器提供支持的 JavaScriptCore\n- 为 IE 提供支持的 Chakra\n\n本篇接下来的 JS Engine 都默认为 Google V8。\n\n### JS Runtime 运行时\n\n我们可以把 JS Runtime 理解为一栋房子，JS 代码都需要在这栋房子中运行。而这栋房子由很多部分共同组成，包括 JS Engine、外部 API 和回调队列（callback queue）。有时也把 JS 用到的 core lib 核心库看作 Runtime 的一部分。\n\n![20240221083858](https://img.ma5hr00m.top/blog/20240221083858.png)\n\n以 Chrome 浏览器的 JS Runtime 举例，浏览器的 Runtime 由对应的 JS Engine、Web API 和回调队列组成。JS Engine 在上文中有讲，不再赘述；Web API 是浏览器提供给 Engine 的一系列接口，并不是 JS 的一部分，目的是方便操纵数据和增强浏览器的功能，常用的 Web API 包括 DOM、Web Worker 等；回调队列包括准备好执行的回调函数，回调队列确保回调以先进先出（FIFO）方法执行，并在堆栈为空时将其传递到堆栈中。\n\n与浏览器 Runtime 不同的是，Node.js 没有 Web API，而是有叫作 C++ 绑定和线程池的其他部分。\n\n我们可以这样说，Chrome 和 Node.js 中的 JS 代码都依赖于 V8 运行，但它们运行在不同的 Runtime 中。\n\n在开始之前，我们要知道，V8 是一个非常复杂的项目，有超过 100w 行代码。我们可以根据功能将 V8 Engine 分为不同的子模块，其中最重要的四个子模块分别是：\n\n- [Parser](https://v8.dev/blog/scanner)：解析器，将 JS 源码转换为抽象语法树（AST）；\n- [Ignition](https://v8.dev/docs/ignition)：解释器，将 AST 转换为字节码（Bytecode），然后解释执行 Bytecode，同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；\n- [TurboFan](https://v8.dev/docs/turbofan)：编译器，利用 Ignitio 所收集的类型信息，将 Bytecode 转换为优化后的汇编代码；\n- [Orinoco](https://v8.dev/blog/trash-talk)：垃圾回收模块，负责将程序不再需要的内存空间回收；\n\n前三个子模块可以代表 JS 运行的主要三个阶段：解析、解释、编译，最后运行。接下来，我会以 V8 Engine 为例，讲讲 JS 代码到底是如何从编写到运行的。\n\n## Parser 解析\n\nParser 的功能是将 JS 源码转化为 AST。更确切地说，源码是先经过词法分析转化为 Token，然后 Toekn 经过语法分析转换为 AST。\n\n### Lexing 词法分析\n\n**词法分析** 这个过程会将由字符组成的字符串分解成代码块，这些代码块被称为“词法单元”（Token）。从数据方面来说，这一步是字符流（char stream）转换为标记流（token stream）。\n\n我们编写一个`main.js`文件，写入以下内容：\n\n```JavaScript\nconst a = 3;\n```\n\n以这段代码为例，会被分为`const`、`a`、`=`、`3`、`;`词法单元。`space`是否被当作词法单元，取决于其在当前编程语言中是否有意义，JS 中的空格是无意义，不会被当作词法单元。\n\n以下为经过词法分析的 JSON 格式的 Tokens：\n\n```JSON\n[\n    {\n        \"type\": \"Keyword\",\n        \"value\": \"const\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"a\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \"=\"\n    },\n    {\n        \"type\": \"Numeric\",\n        \"value\": \"3\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \";\"\n    }\n]\n```\n\n分词（Tokenizing）和词法分析（Lexing）的区别在于：词法单元的识别是通过有状态还是无状态的方式进行的，无状态的为分词。这里“状态”的有无则是根据数据的处理过程是否需要考虑其他相关信息决定的。\n\n在 JS 解析的过程中，我们需要考虑当前词法单元与前面的词法单元之间的关系，因此，JS 的解析是一个有状态的过程，我们就会将字符流转换为 token 的这一过程称为 Lexing 而非 Tokenizing。\n\n### Parsing 语法分析\n\n**语法分析** 是将标记流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，我们称其为抽象语法树（AST）。\n\n上文中的 Tokens 经过语法分析得到的 JSON 格式的 AST 如下：\n\n```JSON\n{\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"VariableDeclaration\",\n      \"declarations\": [\n        {\n          \"type\": \"VariableDeclarator\",\n          \"id\": {\n            \"type\": \"Identifier\",\n            \"name\": \"a\"\n          },\n          \"init\": {\n            \"type\": \"Literal\",\n            \"value\": 3,\n            \"raw\": \"3\"\n          }\n        }\n      ],\n      \"kind\": \"const\"\n    }\n  ],\n  \"sourceType\": \"script\"\n}\n```\n\n解析的过程就这么多，最终效果就是得到源码对应的AST。\n\n[Esprima](https://esprima.org/demo/parse.html#) 站点提供了在线解析 JS 代码的功能，输入 JS 代码就可以得到经过 Lexing 的 Tokens 和 经过 Parsing 的 AST，可以动手尝试一下。\n\n除此之外， [AST explorer](https://astexplorer.net/) 站点也可以在线将 JS 代码转化为 AST。这个网站是基于 acorn.js 实现的，[acorn.js](https://www.npmjs.com/package/acorn)  是一个 JavaScript Parser，你可以通过`npm`等包管理器下载并使用它。以下是一段使用 acorn.js 将指定代码转化为 AST 的案例。指定解析`console.log(1);`并以JSON格式输出：\n\n```JavaScript\nconst { Parser } = require('acorn')\n\nconst javascriptCode = `\n  console.log(1);\n`;\n\nconst ast = Parser.parse(javascriptCode, { ecmaVersion: 2024 });\nconsole.log(JSON.stringify(ast));\n```\n\n## Ignition 解释\n\nIgnition 的主要功能是负责将 AST 转换为字节码（Bytecode）并解释执行。\n\nBytecode 是一种包含执行程序、由一序列 op 代码/数据对组成的二进制文件，是一种中间码（IR），是机器码的一种抽象。它不面向任何机器，只面向当前虚拟机（这里是 V8 引擎）。\n\n> 我们常说的字节码多是指 Java 字节码，实际上很多动态编译解释的语言都有字节码，比如 Python/JavaScript/Ruby。\n\n早期的 V8 直接将 AST 编译为机器码，然后在机器中执行，因为这样的效率更高。但机器码会占用过多的系统内存，相比之下，Bytecode 占用的内存空间远比机器码少得多，Google 团队遂选择以时间换空间，转换为现在的 AST->Bytecode->机器码。\n\n![20240221083929](https://img.ma5hr00m.top/blog/20240221083929.png)\n\nNode.js 提供了很多关于 V8 引擎的选项，比如`--print-bytecode`用于获取源码对应的字节码。\n\n先编写这样一段 JS 代码并保存为 main.js 文件：\n\n```JavaScript\nfunction ma5hr00m() {\n  console.log(1);\n}\n\nma5hr00m();\n```\n\n然后使用`node --print-bytecode main.js`即可得到代码的 Bytecode，会输出非常非常多的内容，可以查找到`ma5hr00m()`函数对应的 Bytecode：\n\n```JavaScript\n[generated bytecode for function: ma5hr00m (0x3ae97a693191 )]                                                                     \nBytecode length: 19                                                                                                                                            \nParameter count 1                                                                                                                                              \nRegister count 3                                                                                                                                               \nFrame size 24                                                                                                                                                  \nBytecode age: 0                                                                                                                                                \n   24 S> 0x3ae97a6940ee @    0 : 21 00 00          LdaGlobal [0], [0]                                                                                          \n         0x3ae97a6940f1 @    3 : c3                Star1                                                                                                       \n   32 E> 0x3ae97a6940f2 @    4 : 2d f9 01 02       GetNamedProperty r1, [1], [2]                                                                               \n         0x3ae97a6940f6 @    8 : c4                Star0                                                                                                       \n         0x3ae97a6940f7 @    9 : 0d 01             LdaSmi [1]                                                                                                  \n         0x3ae97a6940f9 @   11 : c2                Star2                                                                                                       \n   32 E> 0x3ae97a6940fa @   12 : 5e fa f9 f8 04    CallProperty1 r0, r1, r2, [4]                                                                               \n         0x3ae97a6940ff @   17 : 0e                LdaUndefined                                                                                                \n   40 S> 0x3ae97a694100 @   18 : a9                Return                                                                                                      \nConstant pool (size = 2)                                                                                                                                       \n0x3ae97a694099: [FixedArray] in OldSpace                                                                                                                       \n - map: 0x2a087bbc0211                                                                                                                  \n - length: 2                                                                                                                                                   \n           0: 0x2a087bbc5ce9                                                                                                              \n           1: 0x398ad9accb91                                                                                                                  \nHandler Table (size = 0)                                                                                                                                       \nSource Position Table (size = 10)                                                                                                                              \n0x3ae97a694109 \n```\n\n我们可以简单分析其中 Bytecode 字段对应的指令：\n\n- 从全局加载一个值到寄存器中；\n- 将寄存器 1 的值存储到一个位置；\n- 从一个对象中获取属性并存储到寄存器 0；\n- ……\n\n这看起来很像我们学习过的汇编语言，或者说 Bytecode 就是抽象后的汇编，它仅面向虚拟机 CPU 而不是其他任何机器的 CPU，这就说明 V8 不需要为不同的 CPU 生成不同的代码，只需生成 Bytecode，这样也在某种程度上简化了 V8 的编译流程，提高了其可拓展性。\n\n## TurboFan 编译\n\nTurboFan 负责将 Bytecode 转换为优化后的机器码。\n\n前面说过，Ignition 子模块已经可以完成 AST->Bytecode 并解释执行，那为什么 V8 还需要 TurboFan 来编译 Bytecode 呢？\n\n前面说过，JavaScript 是一门解释型的语言。解释型语言的特点是：\n\n- 运行时逐行被解释器解释并执行；\n- 每次运行程序时都需要将源代码翻译成机器代码并执行；\n\n解释型语言的好处就是灵活且启动速度快，在 Web 应用场景下，这种策略是优于编译型语言的。但随着时代进步，Web 应用越来越庞大，解释型语言执行速度慢的缺点也逐渐凸显出来。在 V8 出现之前，所有 JS Engine 都采用着解释执行的方式。\n\n而 V8 率先引入了即时编译（JIT）的设计，这种设计混合了解释执行和编译执行两种策略，极大地提升了 JS 的执行速度。之后其它 JS Engine 也是迅速跟进。\n\n### JIT 即时编译\n\nJust-in-Time 技术是解释执行和编译执行二者之间权衡之后的产物。简单地说，V8 在启动过程中采用解释执行的策略，如果某段代码的超过某个阈值，V8 就会把这段代码编译成执行效率更高的机器码。\n\n不同 Engine 在实现 JIT 的手段上存在区别，但总体思想是一致的，就是在 Engine 内部添加一个监视器。监视器负责监视代码的运行情况，记录代码一共运行了多少次、代码如何运行等。监视器会根据代码重复次数以及运行某段代码占用的执行时长，对代码进行标记，标记共分为`warm`、`hot`和`very hot`三个等级。\n\n举个例子说明：\n\n```JavaScript\nfunction arraySum(arr) {\n    let sum = 0;\n    for (var i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n}\n```\n\n这段代码刚开始运行时，监视器监视着所有代码的运行情况。\n\n如果同一行代码重复执行几次，监视器会把这段代码标记为`warm`。\n\n被标记为`warm`的代码段会被 JIT 传递给 *基线编译器* 进行编译，并将结果储存。`warm`代码段的每一行都会被编译成一个`stub`，同时给这个`stub`分配一个以“行号 + 变量类型”的索引。此时并没有使用编译的代码替换原本的代码。\n\n如果监视器监视到，某行某个变量使用了同样的变量类型在此多次执行同样的代码，就会将`warm`升级为`hot`，并把已编译的代码 push 给浏览器，浏览器接收后就会用编译后的代码替换原本的代码。\n\n如果`hot`代码段重复次数非常多以至于占用了大部分执行时间，就标记为`very hot`。\n\n被标记为`very hot`的代码段会被 JIT 传递给 *优化编译器* 进行编译，生成一个更快速和高效的代码版本，并且存储。例如上面这段代码，`sum`和`arr[i]`两个数并不保证都是整数（JS 动态类型），每次`+=`执行前都需要先判断一遍数据类型，如果这段代码重复执行了非常多次且每次这两个变量都是 INT 型，那这段代码被丢给优化编译器进行编译时，就会被优化为优先进行 INT 类型的判断，以节约时间。\n\n如果上述经过优化的代码出现问题，某次执行数据判断的结果不是 INT 型，那这段经过优化编译得到的代码就会被直接丢弃，执行过程回到解释器/基线解释器，这个过程被称为 *去优化*。\n\n要注意，JIT 与虚拟机执行策略的选择有关，而和语言本身无关。除了 JS，其他解释型语言也会引入 JIT 技术，以提高执行效率。\n\n## 参阅文章\n\n- [JavaScript 语法解析、AST、V8、JIT](https://cheogo.github.io/learn-javascript/201709/runtime.html)\n- [JavaScript深入浅出第4课：V8引擎是如何工作的](https://kiwenlau.com/2019/07/16/how-does-v8-work/)，by 寒雁Talk\n- [WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理](https://zhuanlan.zhihu.com/p/25669120)，by 知乎\n- [JS中的JIT与基本执行逻辑](https://juejin.cn/post/6863269040300032008)，by 稀土掘金","slug":"how-js-run","published":1,"updated":"2024-06-09T12:55:23.359Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap1000bf4ly6kdf3925","content":"<p>最近在复习 JavaScript 反混淆相关内容，正好给执行原理补个档，之前旧版的随旧博客一起遗失了，这里重新写了一篇。</p>\n<p>预计之后还会有 <a href=\"#\">JavaScript执行原理·补</a> 和 <a href=\"#\">JavaScript混淆&#x2F;反混淆</a>，慢慢写吧。</p>\n<p>:::tip</p>\n<p>跳转到 <a href=\"https://ma5hr00m.top/archives/2024/02/js-obfuscation-deobfuscation.html\">JavaScript混淆&#x2F;反混淆</a></p>\n<p>:::</p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p>JavaScript 是一门解释型语言，与 C&#x2F;Golang 等静态编译语言不同。静态编译型语言通过编译器直接将代码转化为机器码，然后运行在机器上；JS 是先经过编译产生字节码，然后在虚拟机上运行字节码（这点与 Java&amp;JVM 很相似），性能虽不及静态编译型语言，但获得了更多的灵活性。</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h3 id=\"JS-Engine-引擎\"><a href=\"#JS-Engine-引擎\" class=\"headerlink\" title=\"JS Engine 引擎\"></a>JS Engine 引擎</h3><p>为什么需要 <a href=\"https://en.wikipedia.org/wiki/JavaScript_engine\">JS Engine</a>🤔️？</p>\n<p>JS Engine 其实就可以理解为上文中所说的虚拟机。机器底层的 CPU 只能执行指令集中的指令（即对应的汇编代码），无法直接识别高级语言。JS Engine 可以将 JS 代码编译为字节码，然后执行代码，同时还提供了分配内存和垃圾回收的功能，极大程度上减轻了开发人员的工作量，何乐而不为。</p>\n<p>从本质上来讲，JS Engine 就是一段程序，用于实现上述功能。</p>\n<p>互联网中最常见、使用最广泛的 JS Engine 是 <strong>Google V8</strong>。Google V8 是用 C++ 编写的开源高性能 JS Engine（同时也是 WebAssembly Engine），目前已被用于 Chrome 浏览器、Node.js、MongoDB 等多个知名项目。Chrome 占据了全球浏览器市场 60% 的份额，而 Node.js 已然成为服务器端 JS 代码的执行标准，由此可见 V8 使用之广泛。</p>\n<p>除此之外，还有一些常见的 JS Engine：</p>\n<ul>\n<li>由 Mozilla 为 Firefox 开发的 SpiderMonkey</li>\n<li>为 Safari 浏览器提供支持的 JavaScriptCore</li>\n<li>为 IE 提供支持的 Chakra</li>\n</ul>\n<p>本篇接下来的 JS Engine 都默认为 Google V8。</p>\n<h3 id=\"JS-Runtime-运行时\"><a href=\"#JS-Runtime-运行时\" class=\"headerlink\" title=\"JS Runtime 运行时\"></a>JS Runtime 运行时</h3><p>我们可以把 JS Runtime 理解为一栋房子，JS 代码都需要在这栋房子中运行。而这栋房子由很多部分共同组成，包括 JS Engine、外部 API 和回调队列（callback queue）。有时也把 JS 用到的 core lib 核心库看作 Runtime 的一部分。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240221083858.png\" alt=\"20240221083858\"></p>\n<p>以 Chrome 浏览器的 JS Runtime 举例，浏览器的 Runtime 由对应的 JS Engine、Web API 和回调队列组成。JS Engine 在上文中有讲，不再赘述；Web API 是浏览器提供给 Engine 的一系列接口，并不是 JS 的一部分，目的是方便操纵数据和增强浏览器的功能，常用的 Web API 包括 DOM、Web Worker 等；回调队列包括准备好执行的回调函数，回调队列确保回调以先进先出（FIFO）方法执行，并在堆栈为空时将其传递到堆栈中。</p>\n<p>与浏览器 Runtime 不同的是，Node.js 没有 Web API，而是有叫作 C++ 绑定和线程池的其他部分。</p>\n<p>我们可以这样说，Chrome 和 Node.js 中的 JS 代码都依赖于 V8 运行，但它们运行在不同的 Runtime 中。</p>\n<p>在开始之前，我们要知道，V8 是一个非常复杂的项目，有超过 100w 行代码。我们可以根据功能将 V8 Engine 分为不同的子模块，其中最重要的四个子模块分别是：</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/scanner\">Parser</a>：解析器，将 JS 源码转换为抽象语法树（AST）；</li>\n<li><a href=\"https://v8.dev/docs/ignition\">Ignition</a>：解释器，将 AST 转换为字节码（Bytecode），然后解释执行 Bytecode，同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；</li>\n<li><a href=\"https://v8.dev/docs/turbofan\">TurboFan</a>：编译器，利用 Ignitio 所收集的类型信息，将 Bytecode 转换为优化后的汇编代码；</li>\n<li><a href=\"https://v8.dev/blog/trash-talk\">Orinoco</a>：垃圾回收模块，负责将程序不再需要的内存空间回收；</li>\n</ul>\n<p>前三个子模块可以代表 JS 运行的主要三个阶段：解析、解释、编译，最后运行。接下来，我会以 V8 Engine 为例，讲讲 JS 代码到底是如何从编写到运行的。</p>\n<h2 id=\"Parser-解析\"><a href=\"#Parser-解析\" class=\"headerlink\" title=\"Parser 解析\"></a>Parser 解析</h2><p>Parser 的功能是将 JS 源码转化为 AST。更确切地说，源码是先经过词法分析转化为 Token，然后 Toekn 经过语法分析转换为 AST。</p>\n<h3 id=\"Lexing-词法分析\"><a href=\"#Lexing-词法分析\" class=\"headerlink\" title=\"Lexing 词法分析\"></a>Lexing 词法分析</h3><p><strong>词法分析</strong> 这个过程会将由字符组成的字符串分解成代码块，这些代码块被称为“词法单元”（Token）。从数据方面来说，这一步是字符流（char stream）转换为标记流（token stream）。</p>\n<p>我们编写一个<code>main.js</code>文件，写入以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>以这段代码为例，会被分为<code>const</code>、<code>a</code>、<code>=</code>、<code>3</code>、<code>;</code>词法单元。<code>space</code>是否被当作词法单元，取决于其在当前编程语言中是否有意义，JS 中的空格是无意义，不会被当作词法单元。</p>\n<p>以下为经过词法分析的 JSON 格式的 Tokens：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Keyword&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;const&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Identifier&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Punctuator&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;=&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Numeric&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Punctuator&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;;&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p>分词（Tokenizing）和词法分析（Lexing）的区别在于：词法单元的识别是通过有状态还是无状态的方式进行的，无状态的为分词。这里“状态”的有无则是根据数据的处理过程是否需要考虑其他相关信息决定的。</p>\n<p>在 JS 解析的过程中，我们需要考虑当前词法单元与前面的词法单元之间的关系，因此，JS 的解析是一个有状态的过程，我们就会将字符流转换为 token 的这一过程称为 Lexing 而非 Tokenizing。</p>\n<h3 id=\"Parsing-语法分析\"><a href=\"#Parsing-语法分析\" class=\"headerlink\" title=\"Parsing 语法分析\"></a>Parsing 语法分析</h3><p><strong>语法分析</strong> 是将标记流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，我们称其为抽象语法树（AST）。</p>\n<p>上文中的 Tokens 经过语法分析得到的 JSON 格式的 AST 如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Program&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;body&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;VariableDeclaration&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;declarations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;VariableDeclarator&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Identifier&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;init&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Literal&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;raw&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">      <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;kind&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;const&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;sourceType&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;script&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>解析的过程就这么多，最终效果就是得到源码对应的AST。</p>\n<p><a href=\"https://esprima.org/demo/parse.html#\">Esprima</a> 站点提供了在线解析 JS 代码的功能，输入 JS 代码就可以得到经过 Lexing 的 Tokens 和 经过 Parsing 的 AST，可以动手尝试一下。</p>\n<p>除此之外， <a href=\"https://astexplorer.net/\">AST explorer</a> 站点也可以在线将 JS 代码转化为 AST。这个网站是基于 acorn.js 实现的，<a href=\"https://www.npmjs.com/package/acorn\">acorn.js</a>  是一个 JavaScript Parser，你可以通过<code>npm</code>等包管理器下载并使用它。以下是一段使用 acorn.js 将指定代码转化为 AST 的案例。指定解析<code>console.log(1);</code>并以JSON格式输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">Parser</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;acorn&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> javascriptCode = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  console.log(1);</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ast = <span class=\"title class_\">Parser</span>.<span class=\"title function_\">parse</span>(javascriptCode, &#123; <span class=\"attr\">ecmaVersion</span>: <span class=\"number\">2024</span> &#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(ast));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ignition-解释\"><a href=\"#Ignition-解释\" class=\"headerlink\" title=\"Ignition 解释\"></a>Ignition 解释</h2><p>Ignition 的主要功能是负责将 AST 转换为字节码（Bytecode）并解释执行。</p>\n<p>Bytecode 是一种包含执行程序、由一序列 op 代码&#x2F;数据对组成的二进制文件，是一种中间码（IR），是机器码的一种抽象。它不面向任何机器，只面向当前虚拟机（这里是 V8 引擎）。</p>\n<blockquote>\n<p>我们常说的字节码多是指 Java 字节码，实际上很多动态编译解释的语言都有字节码，比如 Python&#x2F;JavaScript&#x2F;Ruby。</p>\n</blockquote>\n<p>早期的 V8 直接将 AST 编译为机器码，然后在机器中执行，因为这样的效率更高。但机器码会占用过多的系统内存，相比之下，Bytecode 占用的内存空间远比机器码少得多，Google 团队遂选择以时间换空间，转换为现在的 AST-&gt;Bytecode-&gt;机器码。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240221083929.png\" alt=\"20240221083929\"></p>\n<p>Node.js 提供了很多关于 V8 引擎的选项，比如<code>--print-bytecode</code>用于获取源码对应的字节码。</p>\n<p>先编写这样一段 JS 代码并保存为 main.js 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ma5hr00m</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">ma5hr00m</span>();</span><br></pre></td></tr></table></figure>\n\n<p>然后使用<code>node --print-bytecode main.js</code>即可得到代码的 Bytecode，会输出非常非常多的内容，可以查找到<code>ma5hr00m()</code>函数对应的 Bytecode：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[generated bytecode <span class=\"keyword\">for</span> <span class=\"attr\">function</span>: ma5hr00m (<span class=\"number\">0x3ae97a693191</span> )]                                                                     </span><br><span class=\"line\"><span class=\"title class_\">Bytecode</span> <span class=\"attr\">length</span>: <span class=\"number\">19</span>                                                                                                                                            </span><br><span class=\"line\"><span class=\"title class_\">Parameter</span> count <span class=\"number\">1</span>                                                                                                                                              </span><br><span class=\"line\"><span class=\"title class_\">Register</span> count <span class=\"number\">3</span>                                                                                                                                               </span><br><span class=\"line\"><span class=\"title class_\">Frame</span> size <span class=\"number\">24</span>                                                                                                                                                  </span><br><span class=\"line\"><span class=\"title class_\">Bytecode</span> <span class=\"attr\">age</span>: <span class=\"number\">0</span>                                                                                                                                                </span><br><span class=\"line\">   <span class=\"number\">24</span> S&gt; <span class=\"number\">0x3ae97a6940ee</span> @    <span class=\"number\">0</span> : <span class=\"number\">21</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          <span class=\"title class_\">LdaGlobal</span> [<span class=\"number\">0</span>], [<span class=\"number\">0</span>]                                                                                          </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940f1</span> @    <span class=\"number\">3</span> : c3                <span class=\"title class_\">Star1</span>                                                                                                       </span><br><span class=\"line\">   <span class=\"number\">32</span> E&gt; <span class=\"number\">0x3ae97a6940f2</span> @    <span class=\"number\">4</span> : 2d f9 <span class=\"number\">01</span> <span class=\"number\">02</span>       <span class=\"title class_\">GetNamedProperty</span> r1, [<span class=\"number\">1</span>], [<span class=\"number\">2</span>]                                                                               </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940f6</span> @    <span class=\"number\">8</span> : c4                <span class=\"title class_\">Star0</span>                                                                                                       </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940f7</span> @    <span class=\"number\">9</span> : 0d <span class=\"number\">01</span>             <span class=\"title class_\">LdaSmi</span> [<span class=\"number\">1</span>]                                                                                                  </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940f9</span> @   <span class=\"number\">11</span> : c2                <span class=\"title class_\">Star2</span>                                                                                                       </span><br><span class=\"line\">   <span class=\"number\">32</span> E&gt; <span class=\"number\">0x3ae97a6940fa</span> @   <span class=\"number\">12</span> : 5e fa f9 f8 <span class=\"number\">04</span>    <span class=\"title class_\">CallProperty1</span> r0, r1, r2, [<span class=\"number\">4</span>]                                                                               </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940ff</span> @   <span class=\"number\">17</span> : 0e                <span class=\"title class_\">LdaUndefined</span>                                                                                                </span><br><span class=\"line\">   <span class=\"number\">40</span> S&gt; <span class=\"number\">0x3ae97a694100</span> @   <span class=\"number\">18</span> : a9                <span class=\"title class_\">Return</span>                                                                                                      </span><br><span class=\"line\"><span class=\"title class_\">Constant</span> pool (size = <span class=\"number\">2</span>)                                                                                                                                       </span><br><span class=\"line\"><span class=\"number\">0x3ae97a694099</span>: [<span class=\"title class_\">FixedArray</span>] <span class=\"keyword\">in</span> <span class=\"title class_\">OldSpace</span>                                                                                                                       </span><br><span class=\"line\"> - <span class=\"attr\">map</span>: <span class=\"number\">0x2a087bbc0211</span>                                                                                                                  </span><br><span class=\"line\"> - <span class=\"attr\">length</span>: <span class=\"number\">2</span>                                                                                                                                                   </span><br><span class=\"line\">           <span class=\"number\">0</span>: <span class=\"number\">0x2a087bbc5ce9</span>                                                                                                              </span><br><span class=\"line\">           <span class=\"number\">1</span>: <span class=\"number\">0x398ad9accb91</span>                                                                                                                  </span><br><span class=\"line\"><span class=\"title class_\">Handler</span> <span class=\"title class_\">Table</span> (size = <span class=\"number\">0</span>)                                                                                                                                       </span><br><span class=\"line\"><span class=\"title class_\">Source</span> <span class=\"title class_\">Position</span> <span class=\"title class_\">Table</span> (size = <span class=\"number\">10</span>)                                                                                                                              </span><br><span class=\"line\"><span class=\"number\">0x3ae97a694109</span> </span><br></pre></td></tr></table></figure>\n\n<p>我们可以简单分析其中 Bytecode 字段对应的指令：</p>\n<ul>\n<li>从全局加载一个值到寄存器中；</li>\n<li>将寄存器 1 的值存储到一个位置；</li>\n<li>从一个对象中获取属性并存储到寄存器 0；</li>\n<li>……</li>\n</ul>\n<p>这看起来很像我们学习过的汇编语言，或者说 Bytecode 就是抽象后的汇编，它仅面向虚拟机 CPU 而不是其他任何机器的 CPU，这就说明 V8 不需要为不同的 CPU 生成不同的代码，只需生成 Bytecode，这样也在某种程度上简化了 V8 的编译流程，提高了其可拓展性。</p>\n<h2 id=\"TurboFan-编译\"><a href=\"#TurboFan-编译\" class=\"headerlink\" title=\"TurboFan 编译\"></a>TurboFan 编译</h2><p>TurboFan 负责将 Bytecode 转换为优化后的机器码。</p>\n<p>前面说过，Ignition 子模块已经可以完成 AST-&gt;Bytecode 并解释执行，那为什么 V8 还需要 TurboFan 来编译 Bytecode 呢？</p>\n<p>前面说过，JavaScript 是一门解释型的语言。解释型语言的特点是：</p>\n<ul>\n<li>运行时逐行被解释器解释并执行；</li>\n<li>每次运行程序时都需要将源代码翻译成机器代码并执行；</li>\n</ul>\n<p>解释型语言的好处就是灵活且启动速度快，在 Web 应用场景下，这种策略是优于编译型语言的。但随着时代进步，Web 应用越来越庞大，解释型语言执行速度慢的缺点也逐渐凸显出来。在 V8 出现之前，所有 JS Engine 都采用着解释执行的方式。</p>\n<p>而 V8 率先引入了即时编译（JIT）的设计，这种设计混合了解释执行和编译执行两种策略，极大地提升了 JS 的执行速度。之后其它 JS Engine 也是迅速跟进。</p>\n<h3 id=\"JIT-即时编译\"><a href=\"#JIT-即时编译\" class=\"headerlink\" title=\"JIT 即时编译\"></a>JIT 即时编译</h3><p>Just-in-Time 技术是解释执行和编译执行二者之间权衡之后的产物。简单地说，V8 在启动过程中采用解释执行的策略，如果某段代码的超过某个阈值，V8 就会把这段代码编译成执行效率更高的机器码。</p>\n<p>不同 Engine 在实现 JIT 的手段上存在区别，但总体思想是一致的，就是在 Engine 内部添加一个监视器。监视器负责监视代码的运行情况，记录代码一共运行了多少次、代码如何运行等。监视器会根据代码重复次数以及运行某段代码占用的执行时长，对代码进行标记，标记共分为<code>warm</code>、<code>hot</code>和<code>very hot</code>三个等级。</p>\n<p>举个例子说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">arraySum</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">        sum += arr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码刚开始运行时，监视器监视着所有代码的运行情况。</p>\n<p>如果同一行代码重复执行几次，监视器会把这段代码标记为<code>warm</code>。</p>\n<p>被标记为<code>warm</code>的代码段会被 JIT 传递给 <em>基线编译器</em> 进行编译，并将结果储存。<code>warm</code>代码段的每一行都会被编译成一个<code>stub</code>，同时给这个<code>stub</code>分配一个以“行号 + 变量类型”的索引。此时并没有使用编译的代码替换原本的代码。</p>\n<p>如果监视器监视到，某行某个变量使用了同样的变量类型在此多次执行同样的代码，就会将<code>warm</code>升级为<code>hot</code>，并把已编译的代码 push 给浏览器，浏览器接收后就会用编译后的代码替换原本的代码。</p>\n<p>如果<code>hot</code>代码段重复次数非常多以至于占用了大部分执行时间，就标记为<code>very hot</code>。</p>\n<p>被标记为<code>very hot</code>的代码段会被 JIT 传递给 <em>优化编译器</em> 进行编译，生成一个更快速和高效的代码版本，并且存储。例如上面这段代码，<code>sum</code>和<code>arr[i]</code>两个数并不保证都是整数（JS 动态类型），每次<code>+=</code>执行前都需要先判断一遍数据类型，如果这段代码重复执行了非常多次且每次这两个变量都是 INT 型，那这段代码被丢给优化编译器进行编译时，就会被优化为优先进行 INT 类型的判断，以节约时间。</p>\n<p>如果上述经过优化的代码出现问题，某次执行数据判断的结果不是 INT 型，那这段经过优化编译得到的代码就会被直接丢弃，执行过程回到解释器&#x2F;基线解释器，这个过程被称为 <em>去优化</em>。</p>\n<p>要注意，JIT 与虚拟机执行策略的选择有关，而和语言本身无关。除了 JS，其他解释型语言也会引入 JIT 技术，以提高执行效率。</p>\n<h2 id=\"参阅文章\"><a href=\"#参阅文章\" class=\"headerlink\" title=\"参阅文章\"></a>参阅文章</h2><ul>\n<li><a href=\"https://cheogo.github.io/learn-javascript/201709/runtime.html\">JavaScript 语法解析、AST、V8、JIT</a></li>\n<li><a href=\"https://kiwenlau.com/2019/07/16/how-does-v8-work/\">JavaScript深入浅出第4课：V8引擎是如何工作的</a>，by 寒雁Talk</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25669120\">WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理</a>，by 知乎</li>\n<li><a href=\"https://juejin.cn/post/6863269040300032008\">JS中的JIT与基本执行逻辑</a>，by 稀土掘金</li>\n</ul>\n","excerpt":"","more":"<p>最近在复习 JavaScript 反混淆相关内容，正好给执行原理补个档，之前旧版的随旧博客一起遗失了，这里重新写了一篇。</p>\n<p>预计之后还会有 <a href=\"#\">JavaScript执行原理·补</a> 和 <a href=\"#\">JavaScript混淆&#x2F;反混淆</a>，慢慢写吧。</p>\n<p>:::tip</p>\n<p>跳转到 <a href=\"https://ma5hr00m.top/archives/2024/02/js-obfuscation-deobfuscation.html\">JavaScript混淆&#x2F;反混淆</a></p>\n<p>:::</p>\n<h2 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h2><p>JavaScript 是一门解释型语言，与 C&#x2F;Golang 等静态编译语言不同。静态编译型语言通过编译器直接将代码转化为机器码，然后运行在机器上；JS 是先经过编译产生字节码，然后在虚拟机上运行字节码（这点与 Java&amp;JVM 很相似），性能虽不及静态编译型语言，但获得了更多的灵活性。</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h3 id=\"JS-Engine-引擎\"><a href=\"#JS-Engine-引擎\" class=\"headerlink\" title=\"JS Engine 引擎\"></a>JS Engine 引擎</h3><p>为什么需要 <a href=\"https://en.wikipedia.org/wiki/JavaScript_engine\">JS Engine</a>🤔️？</p>\n<p>JS Engine 其实就可以理解为上文中所说的虚拟机。机器底层的 CPU 只能执行指令集中的指令（即对应的汇编代码），无法直接识别高级语言。JS Engine 可以将 JS 代码编译为字节码，然后执行代码，同时还提供了分配内存和垃圾回收的功能，极大程度上减轻了开发人员的工作量，何乐而不为。</p>\n<p>从本质上来讲，JS Engine 就是一段程序，用于实现上述功能。</p>\n<p>互联网中最常见、使用最广泛的 JS Engine 是 <strong>Google V8</strong>。Google V8 是用 C++ 编写的开源高性能 JS Engine（同时也是 WebAssembly Engine），目前已被用于 Chrome 浏览器、Node.js、MongoDB 等多个知名项目。Chrome 占据了全球浏览器市场 60% 的份额，而 Node.js 已然成为服务器端 JS 代码的执行标准，由此可见 V8 使用之广泛。</p>\n<p>除此之外，还有一些常见的 JS Engine：</p>\n<ul>\n<li>由 Mozilla 为 Firefox 开发的 SpiderMonkey</li>\n<li>为 Safari 浏览器提供支持的 JavaScriptCore</li>\n<li>为 IE 提供支持的 Chakra</li>\n</ul>\n<p>本篇接下来的 JS Engine 都默认为 Google V8。</p>\n<h3 id=\"JS-Runtime-运行时\"><a href=\"#JS-Runtime-运行时\" class=\"headerlink\" title=\"JS Runtime 运行时\"></a>JS Runtime 运行时</h3><p>我们可以把 JS Runtime 理解为一栋房子，JS 代码都需要在这栋房子中运行。而这栋房子由很多部分共同组成，包括 JS Engine、外部 API 和回调队列（callback queue）。有时也把 JS 用到的 core lib 核心库看作 Runtime 的一部分。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240221083858.png\" alt=\"20240221083858\"></p>\n<p>以 Chrome 浏览器的 JS Runtime 举例，浏览器的 Runtime 由对应的 JS Engine、Web API 和回调队列组成。JS Engine 在上文中有讲，不再赘述；Web API 是浏览器提供给 Engine 的一系列接口，并不是 JS 的一部分，目的是方便操纵数据和增强浏览器的功能，常用的 Web API 包括 DOM、Web Worker 等；回调队列包括准备好执行的回调函数，回调队列确保回调以先进先出（FIFO）方法执行，并在堆栈为空时将其传递到堆栈中。</p>\n<p>与浏览器 Runtime 不同的是，Node.js 没有 Web API，而是有叫作 C++ 绑定和线程池的其他部分。</p>\n<p>我们可以这样说，Chrome 和 Node.js 中的 JS 代码都依赖于 V8 运行，但它们运行在不同的 Runtime 中。</p>\n<p>在开始之前，我们要知道，V8 是一个非常复杂的项目，有超过 100w 行代码。我们可以根据功能将 V8 Engine 分为不同的子模块，其中最重要的四个子模块分别是：</p>\n<ul>\n<li><a href=\"https://v8.dev/blog/scanner\">Parser</a>：解析器，将 JS 源码转换为抽象语法树（AST）；</li>\n<li><a href=\"https://v8.dev/docs/ignition\">Ignition</a>：解释器，将 AST 转换为字节码（Bytecode），然后解释执行 Bytecode，同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；</li>\n<li><a href=\"https://v8.dev/docs/turbofan\">TurboFan</a>：编译器，利用 Ignitio 所收集的类型信息，将 Bytecode 转换为优化后的汇编代码；</li>\n<li><a href=\"https://v8.dev/blog/trash-talk\">Orinoco</a>：垃圾回收模块，负责将程序不再需要的内存空间回收；</li>\n</ul>\n<p>前三个子模块可以代表 JS 运行的主要三个阶段：解析、解释、编译，最后运行。接下来，我会以 V8 Engine 为例，讲讲 JS 代码到底是如何从编写到运行的。</p>\n<h2 id=\"Parser-解析\"><a href=\"#Parser-解析\" class=\"headerlink\" title=\"Parser 解析\"></a>Parser 解析</h2><p>Parser 的功能是将 JS 源码转化为 AST。更确切地说，源码是先经过词法分析转化为 Token，然后 Toekn 经过语法分析转换为 AST。</p>\n<h3 id=\"Lexing-词法分析\"><a href=\"#Lexing-词法分析\" class=\"headerlink\" title=\"Lexing 词法分析\"></a>Lexing 词法分析</h3><p><strong>词法分析</strong> 这个过程会将由字符组成的字符串分解成代码块，这些代码块被称为“词法单元”（Token）。从数据方面来说，这一步是字符流（char stream）转换为标记流（token stream）。</p>\n<p>我们编写一个<code>main.js</code>文件，写入以下内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>以这段代码为例，会被分为<code>const</code>、<code>a</code>、<code>=</code>、<code>3</code>、<code>;</code>词法单元。<code>space</code>是否被当作词法单元，取决于其在当前编程语言中是否有意义，JS 中的空格是无意义，不会被当作词法单元。</p>\n<p>以下为经过词法分析的 JSON 格式的 Tokens：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Keyword&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;const&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Identifier&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Punctuator&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;=&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Numeric&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Punctuator&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;;&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p>分词（Tokenizing）和词法分析（Lexing）的区别在于：词法单元的识别是通过有状态还是无状态的方式进行的，无状态的为分词。这里“状态”的有无则是根据数据的处理过程是否需要考虑其他相关信息决定的。</p>\n<p>在 JS 解析的过程中，我们需要考虑当前词法单元与前面的词法单元之间的关系，因此，JS 的解析是一个有状态的过程，我们就会将字符流转换为 token 的这一过程称为 Lexing 而非 Tokenizing。</p>\n<h3 id=\"Parsing-语法分析\"><a href=\"#Parsing-语法分析\" class=\"headerlink\" title=\"Parsing 语法分析\"></a>Parsing 语法分析</h3><p><strong>语法分析</strong> 是将标记流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，我们称其为抽象语法树（AST）。</p>\n<p>上文中的 Tokens 经过语法分析得到的 JSON 格式的 AST 如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Program&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;body&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;VariableDeclaration&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;declarations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;VariableDeclarator&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;id&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Identifier&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;init&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Literal&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;value&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;raw&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">      <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;kind&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;const&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;sourceType&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;script&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>解析的过程就这么多，最终效果就是得到源码对应的AST。</p>\n<p><a href=\"https://esprima.org/demo/parse.html#\">Esprima</a> 站点提供了在线解析 JS 代码的功能，输入 JS 代码就可以得到经过 Lexing 的 Tokens 和 经过 Parsing 的 AST，可以动手尝试一下。</p>\n<p>除此之外， <a href=\"https://astexplorer.net/\">AST explorer</a> 站点也可以在线将 JS 代码转化为 AST。这个网站是基于 acorn.js 实现的，<a href=\"https://www.npmjs.com/package/acorn\">acorn.js</a>  是一个 JavaScript Parser，你可以通过<code>npm</code>等包管理器下载并使用它。以下是一段使用 acorn.js 将指定代码转化为 AST 的案例。指定解析<code>console.log(1);</code>并以JSON格式输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">Parser</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;acorn&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> javascriptCode = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  console.log(1);</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ast = <span class=\"title class_\">Parser</span>.<span class=\"title function_\">parse</span>(javascriptCode, &#123; <span class=\"attr\">ecmaVersion</span>: <span class=\"number\">2024</span> &#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(ast));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ignition-解释\"><a href=\"#Ignition-解释\" class=\"headerlink\" title=\"Ignition 解释\"></a>Ignition 解释</h2><p>Ignition 的主要功能是负责将 AST 转换为字节码（Bytecode）并解释执行。</p>\n<p>Bytecode 是一种包含执行程序、由一序列 op 代码&#x2F;数据对组成的二进制文件，是一种中间码（IR），是机器码的一种抽象。它不面向任何机器，只面向当前虚拟机（这里是 V8 引擎）。</p>\n<blockquote>\n<p>我们常说的字节码多是指 Java 字节码，实际上很多动态编译解释的语言都有字节码，比如 Python&#x2F;JavaScript&#x2F;Ruby。</p>\n</blockquote>\n<p>早期的 V8 直接将 AST 编译为机器码，然后在机器中执行，因为这样的效率更高。但机器码会占用过多的系统内存，相比之下，Bytecode 占用的内存空间远比机器码少得多，Google 团队遂选择以时间换空间，转换为现在的 AST-&gt;Bytecode-&gt;机器码。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240221083929.png\" alt=\"20240221083929\"></p>\n<p>Node.js 提供了很多关于 V8 引擎的选项，比如<code>--print-bytecode</code>用于获取源码对应的字节码。</p>\n<p>先编写这样一段 JS 代码并保存为 main.js 文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ma5hr00m</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">ma5hr00m</span>();</span><br></pre></td></tr></table></figure>\n\n<p>然后使用<code>node --print-bytecode main.js</code>即可得到代码的 Bytecode，会输出非常非常多的内容，可以查找到<code>ma5hr00m()</code>函数对应的 Bytecode：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[generated bytecode <span class=\"keyword\">for</span> <span class=\"attr\">function</span>: ma5hr00m (<span class=\"number\">0x3ae97a693191</span> )]                                                                     </span><br><span class=\"line\"><span class=\"title class_\">Bytecode</span> <span class=\"attr\">length</span>: <span class=\"number\">19</span>                                                                                                                                            </span><br><span class=\"line\"><span class=\"title class_\">Parameter</span> count <span class=\"number\">1</span>                                                                                                                                              </span><br><span class=\"line\"><span class=\"title class_\">Register</span> count <span class=\"number\">3</span>                                                                                                                                               </span><br><span class=\"line\"><span class=\"title class_\">Frame</span> size <span class=\"number\">24</span>                                                                                                                                                  </span><br><span class=\"line\"><span class=\"title class_\">Bytecode</span> <span class=\"attr\">age</span>: <span class=\"number\">0</span>                                                                                                                                                </span><br><span class=\"line\">   <span class=\"number\">24</span> S&gt; <span class=\"number\">0x3ae97a6940ee</span> @    <span class=\"number\">0</span> : <span class=\"number\">21</span> <span class=\"number\">00</span> <span class=\"number\">00</span>          <span class=\"title class_\">LdaGlobal</span> [<span class=\"number\">0</span>], [<span class=\"number\">0</span>]                                                                                          </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940f1</span> @    <span class=\"number\">3</span> : c3                <span class=\"title class_\">Star1</span>                                                                                                       </span><br><span class=\"line\">   <span class=\"number\">32</span> E&gt; <span class=\"number\">0x3ae97a6940f2</span> @    <span class=\"number\">4</span> : 2d f9 <span class=\"number\">01</span> <span class=\"number\">02</span>       <span class=\"title class_\">GetNamedProperty</span> r1, [<span class=\"number\">1</span>], [<span class=\"number\">2</span>]                                                                               </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940f6</span> @    <span class=\"number\">8</span> : c4                <span class=\"title class_\">Star0</span>                                                                                                       </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940f7</span> @    <span class=\"number\">9</span> : 0d <span class=\"number\">01</span>             <span class=\"title class_\">LdaSmi</span> [<span class=\"number\">1</span>]                                                                                                  </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940f9</span> @   <span class=\"number\">11</span> : c2                <span class=\"title class_\">Star2</span>                                                                                                       </span><br><span class=\"line\">   <span class=\"number\">32</span> E&gt; <span class=\"number\">0x3ae97a6940fa</span> @   <span class=\"number\">12</span> : 5e fa f9 f8 <span class=\"number\">04</span>    <span class=\"title class_\">CallProperty1</span> r0, r1, r2, [<span class=\"number\">4</span>]                                                                               </span><br><span class=\"line\">         <span class=\"number\">0x3ae97a6940ff</span> @   <span class=\"number\">17</span> : 0e                <span class=\"title class_\">LdaUndefined</span>                                                                                                </span><br><span class=\"line\">   <span class=\"number\">40</span> S&gt; <span class=\"number\">0x3ae97a694100</span> @   <span class=\"number\">18</span> : a9                <span class=\"title class_\">Return</span>                                                                                                      </span><br><span class=\"line\"><span class=\"title class_\">Constant</span> pool (size = <span class=\"number\">2</span>)                                                                                                                                       </span><br><span class=\"line\"><span class=\"number\">0x3ae97a694099</span>: [<span class=\"title class_\">FixedArray</span>] <span class=\"keyword\">in</span> <span class=\"title class_\">OldSpace</span>                                                                                                                       </span><br><span class=\"line\"> - <span class=\"attr\">map</span>: <span class=\"number\">0x2a087bbc0211</span>                                                                                                                  </span><br><span class=\"line\"> - <span class=\"attr\">length</span>: <span class=\"number\">2</span>                                                                                                                                                   </span><br><span class=\"line\">           <span class=\"number\">0</span>: <span class=\"number\">0x2a087bbc5ce9</span>                                                                                                              </span><br><span class=\"line\">           <span class=\"number\">1</span>: <span class=\"number\">0x398ad9accb91</span>                                                                                                                  </span><br><span class=\"line\"><span class=\"title class_\">Handler</span> <span class=\"title class_\">Table</span> (size = <span class=\"number\">0</span>)                                                                                                                                       </span><br><span class=\"line\"><span class=\"title class_\">Source</span> <span class=\"title class_\">Position</span> <span class=\"title class_\">Table</span> (size = <span class=\"number\">10</span>)                                                                                                                              </span><br><span class=\"line\"><span class=\"number\">0x3ae97a694109</span> </span><br></pre></td></tr></table></figure>\n\n<p>我们可以简单分析其中 Bytecode 字段对应的指令：</p>\n<ul>\n<li>从全局加载一个值到寄存器中；</li>\n<li>将寄存器 1 的值存储到一个位置；</li>\n<li>从一个对象中获取属性并存储到寄存器 0；</li>\n<li>……</li>\n</ul>\n<p>这看起来很像我们学习过的汇编语言，或者说 Bytecode 就是抽象后的汇编，它仅面向虚拟机 CPU 而不是其他任何机器的 CPU，这就说明 V8 不需要为不同的 CPU 生成不同的代码，只需生成 Bytecode，这样也在某种程度上简化了 V8 的编译流程，提高了其可拓展性。</p>\n<h2 id=\"TurboFan-编译\"><a href=\"#TurboFan-编译\" class=\"headerlink\" title=\"TurboFan 编译\"></a>TurboFan 编译</h2><p>TurboFan 负责将 Bytecode 转换为优化后的机器码。</p>\n<p>前面说过，Ignition 子模块已经可以完成 AST-&gt;Bytecode 并解释执行，那为什么 V8 还需要 TurboFan 来编译 Bytecode 呢？</p>\n<p>前面说过，JavaScript 是一门解释型的语言。解释型语言的特点是：</p>\n<ul>\n<li>运行时逐行被解释器解释并执行；</li>\n<li>每次运行程序时都需要将源代码翻译成机器代码并执行；</li>\n</ul>\n<p>解释型语言的好处就是灵活且启动速度快，在 Web 应用场景下，这种策略是优于编译型语言的。但随着时代进步，Web 应用越来越庞大，解释型语言执行速度慢的缺点也逐渐凸显出来。在 V8 出现之前，所有 JS Engine 都采用着解释执行的方式。</p>\n<p>而 V8 率先引入了即时编译（JIT）的设计，这种设计混合了解释执行和编译执行两种策略，极大地提升了 JS 的执行速度。之后其它 JS Engine 也是迅速跟进。</p>\n<h3 id=\"JIT-即时编译\"><a href=\"#JIT-即时编译\" class=\"headerlink\" title=\"JIT 即时编译\"></a>JIT 即时编译</h3><p>Just-in-Time 技术是解释执行和编译执行二者之间权衡之后的产物。简单地说，V8 在启动过程中采用解释执行的策略，如果某段代码的超过某个阈值，V8 就会把这段代码编译成执行效率更高的机器码。</p>\n<p>不同 Engine 在实现 JIT 的手段上存在区别，但总体思想是一致的，就是在 Engine 内部添加一个监视器。监视器负责监视代码的运行情况，记录代码一共运行了多少次、代码如何运行等。监视器会根据代码重复次数以及运行某段代码占用的执行时长，对代码进行标记，标记共分为<code>warm</code>、<code>hot</code>和<code>very hot</code>三个等级。</p>\n<p>举个例子说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">arraySum</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">        sum += arr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码刚开始运行时，监视器监视着所有代码的运行情况。</p>\n<p>如果同一行代码重复执行几次，监视器会把这段代码标记为<code>warm</code>。</p>\n<p>被标记为<code>warm</code>的代码段会被 JIT 传递给 <em>基线编译器</em> 进行编译，并将结果储存。<code>warm</code>代码段的每一行都会被编译成一个<code>stub</code>，同时给这个<code>stub</code>分配一个以“行号 + 变量类型”的索引。此时并没有使用编译的代码替换原本的代码。</p>\n<p>如果监视器监视到，某行某个变量使用了同样的变量类型在此多次执行同样的代码，就会将<code>warm</code>升级为<code>hot</code>，并把已编译的代码 push 给浏览器，浏览器接收后就会用编译后的代码替换原本的代码。</p>\n<p>如果<code>hot</code>代码段重复次数非常多以至于占用了大部分执行时间，就标记为<code>very hot</code>。</p>\n<p>被标记为<code>very hot</code>的代码段会被 JIT 传递给 <em>优化编译器</em> 进行编译，生成一个更快速和高效的代码版本，并且存储。例如上面这段代码，<code>sum</code>和<code>arr[i]</code>两个数并不保证都是整数（JS 动态类型），每次<code>+=</code>执行前都需要先判断一遍数据类型，如果这段代码重复执行了非常多次且每次这两个变量都是 INT 型，那这段代码被丢给优化编译器进行编译时，就会被优化为优先进行 INT 类型的判断，以节约时间。</p>\n<p>如果上述经过优化的代码出现问题，某次执行数据判断的结果不是 INT 型，那这段经过优化编译得到的代码就会被直接丢弃，执行过程回到解释器&#x2F;基线解释器，这个过程被称为 <em>去优化</em>。</p>\n<p>要注意，JIT 与虚拟机执行策略的选择有关，而和语言本身无关。除了 JS，其他解释型语言也会引入 JIT 技术，以提高执行效率。</p>\n<h2 id=\"参阅文章\"><a href=\"#参阅文章\" class=\"headerlink\" title=\"参阅文章\"></a>参阅文章</h2><ul>\n<li><a href=\"https://cheogo.github.io/learn-javascript/201709/runtime.html\">JavaScript 语法解析、AST、V8、JIT</a></li>\n<li><a href=\"https://kiwenlau.com/2019/07/16/how-does-v8-work/\">JavaScript深入浅出第4课：V8引擎是如何工作的</a>，by 寒雁Talk</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25669120\">WebAssembly 系列（二）JavaScript Just-in-time (JIT) 工作原理</a>，by 知乎</li>\n<li><a href=\"https://juejin.cn/post/6863269040300032008\">JS中的JIT与基本执行逻辑</a>，by 稀土掘金</li>\n</ul>\n"},{"title":"HelloWeb 致新生","date":"2024-05-19T16:00:00.000Z","author":"ma5hr00m","_content":"\n# HelloWeb\n\n> 🚀本文档面向初次踏入 The Web World 的新生，希望为你们提供一个可供参考的学习路线。\n\n> ✨该文档最早公开于 [ma5hr00m/HelloWeb](https://github.com/ma5hr00m/HelloWeb)，计划用于 Vidar-Team2024 届招新。\n\n![helloweb-banner](https://img.ma5hr00m.top/blog/helloweb-banner.png)\n\n## 0x00 前言\n\nWeb 安全与 Web 开发往往是绑定在一起的，所以本文档会同时介绍 **安全&开发**，还会有一些零零散散的其他想要告诉新生的东西，所以内容会略多，希望多点耐心看完。\n\n在开始之前，你们需要准备一些东西，要求不高，相信大家都有：\n\n- 🧠能**独立思考**的大脑\n- 💻可以使用的电脑\n- 🔮流畅的网络\n- ❤️**积极好学**的心\n\n此外，所有想要涉足计算机领域的新生，都有必要去阅读一篇文章，其名为**《提问的智慧》**。篇幅不长，20min 即可，你可以从中学习到如何提出 **一个有价值的问题**，而不是掏出手机拍一张电脑屏幕，丢进群里就问“我该怎么办”，这是在浪费大家的时间。同时，你也可以把《提问的智慧》当作⼀个 AI prompt 指南。因为不论是对⼈还是对机器，提出一个有效的问题都能事半功倍地解决问题。\n\n你可以点击下面的链接以阅读这篇文章。此外，Vidar-Team2024 招新群中也提供了 PDF 版本，需要请自取。\n\n- [简体中文版《提问的智慧》](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md)\n\n> 🔍如果在此之前，你完全没有了解过计算机，但觉得能够成为一个整天抱着电脑“哐哐哐\"敲键盘、张口闭口都是别人听不懂的怪话的程序猿是一件很酷的事情，那你依然可以阅读本文档，但其中很多名词你可能从未了解，你可以暂时跳到 ***0x05 泛用技能- 信息搜集*** 小节。\n\n> 📷学会截屏。\n\n## 0x01 Web\n\n[Web](https://en.wikipedia.org/wiki/World_Wide_Web) 是 World Wide Web 的简称，是一个通过互联网访问的、由许多互相链接的的超文本组成的信息系统。这是指的广义上的 Web，即涵盖了整个世界范围内的互联网服务和资源的集合。这包括所有 **通过互联网连接** 的设备、服务、网络协议以及通过这些设备和服务访问的内容，它超越了单纯的网页和浏览器，涵盖了从大型服务器到个人设备的所有互联网技术。\n\n我们日常所说的往往是狭义上的 Web，更加专注于构成网站和网络应用技术实践，包括传统的前后端开发、运维以及 Web 安全等领域。这与大家的生活就很贴近了，今日的学习、办公、娱乐都已经脱离不开网络应用技术，输入一串 URL 后浏览器如何得到一个功能完备的 Web 页面、在自己手机的“学习通”里上传一份 docx 附件后如何将其传递给教师，这都属于 Web 的范畴。现在的你可能并不明晰这些功能的实现原理，但经过一段时间的学习，相信你就可以对这些功能的实现有一个明确的认知，或者已经能够自己开发一个具备类似功能的 Web 应用。\n\n除非有特殊说明，本文档后面的 Web 都是指狭义上的 Web 应用。\n\n### 发展史\n\n最初的 Web 应⽤非常简陋，程序托管在 ISP（Internet Service Provider，互联网服务提供商）那里，用户在自己的主机上访问对应 IP 获得对应的静态页面，页面中只有⽂字与图⽚，当时的用户能做的也只是浏览⽹⻚，没法与网页背后的机器（或人）进行更多的交流。这只是一个单方向的信息输出，人们并不满足于这一点。\n\n为了丰富 Web 应用的功能，满足人们增长的需求，之后就有了 Flash 等媒体技术，大名鼎鼎的 JavaScript 编程语言也被研发出来。⾳视频和动态交互的实现给予了用户更高的自由度，越来越多的公司也开始通过互联网宣传自家产品，让潜在用户在家就能看到他们的产品信息。\n\n随后，CGI（Common GatewayInterface）技术出现，Web 服务器可以通过 CGI 执⾏外部程序，外部程序可以根据请求内容⽣成动态内容返回给用户。现代 Web 应用的雏形已经出现。\n\n再之后，随着 PHP/JSP 等编程语⾔的开发，MVC 思想、REST（Representation State Transformation）架构⻛格的提出，Web 应⽤的功能进一步增强，一片勃勃生机万物竞发之势。但随之而来的是安全问题频出，Web 安全也开始得到开发者的重视。\n\n在之后就是越来越多的 Web 技术出现、应用逻辑越来越复杂，部分 Web 开发者难以忍受同时编写数据处理逻辑和网站页面，前后端分化。分化之后开发者们有了更多的精力钻研自己感兴趣的领域，技术不断发展，直到今天。\n\n这里简单说说 **前后端的划分**。前端就是⽤⼾可以直接看⻅的部分，⽐如说我们访问 [baidu.com](https://www.baidu.com)，浏览器显示的搜索框、按钮等组件，以及我们输入 URL 之后字符串如何传递给后端应用，这些都属于 Web 前端的范畴；与之相对的，后端就主要是⽤⼾看不⻅的部分，⽐如在百度中搜索 [Vidar-Team](https://www.baidu.com/s?wd=Vidar-Team)，服务器在数据库中根据关键词查找相关内容，处理后整合成格式恰当的数据，再交给前端让浏览器去渲染出一个包含相关信息的页面，这就是 Web 后端负责的⼯作。\n\n### Web 应用中的数据传递\n\n> 这部分内容对 0 基础新生来说可能较为困难，可暂时跳过。\n\n打开浏览器，地址栏中敲入 [https://vidar.club](https://vidar.club) 并回车，浏览器片刻就会返回给我们 Vidar-Team 的官网首页，这是如何实现的呢？下面我们会以此为例讲讲 Web 应用中的数据传递。\n\n当浏览器接收到用户输入的 URL 时，首先会做的就是 [DNS 查询](https://www.ruanyifeng.com/blog/2022/08/dns-query.html)，浏览器会去查找这个 URL 背后对应的资源在什么地方，也就是这个域名对应的 IP 是什么。 \n\n![helloweb-dns](https://img.ma5hr00m.top/blog/helloweb-dns.png)\n\n目前常见的 IP 地址格式一般为 [xxx.xxx.xxx.xxx]()，但人类要记住这样的 12 位纯数字比较困难。因此，开发者们决定⽤形象的域名（domain）来让⽤⼾记住资源的位置。你看，[vidar.club](https://vidar.club) 就⽐ [1.117.117.147](1.117.117.147) 这个 IP 好记太多了吧？浏览器根据域名向 DNS 服务器查询对应 IP 地址。DNS 服务器就像一本电话簿，里面详细记录了各种各样的域名与其对应的 IP 地址。在这个例子中，浏览器得到对应的 IP 地址就是 [1.117.117.147](1.117.117.147)。 \n\n浏览器得知服务器的 IP 地址后，就会与其对应的服务器进⾏ TCP 三次握⼿。三次握⼿机制的目的时让通信的两端建立可靠的连接，毕竟谁也不想看到一个内容残缺的网页。为了让连接更加安全，本地主机与服务器在三次握手之后就会进⾏ TLS 协商。你看我们输⼊的是 `https://`，这表明我们使⽤了 HTTPS 协议访问主机资源。相⽐于明文传输数据的 HTTP，HTTPS 使⽤了 SSL/TLS 协议对数据进⾏了加密处理，这会让访问变得更加安全。当三次握⼿和 TLS 协商完成后，我们就已经和服务器建⽴了安全连接啦。\n\n> 顺带一提，如果使用 `http://` 访问协会官网也会强制转化为 `https://` 哦，可以试试 [http://vidar.club](http://vidar.club)。\n\n建⽴安全连接后，浏览器会向服务器发送 HTTP `GET` 请求，请求服务器返回我们事先放在服务器上的对应⽹⻚的内容，这个请求的内容通常是⼀个 HTML ⽂件。当服务器收到请求后，就会使⽤相关的响应头和 HTML 内容进⾏回复。\n\n![helloweb-burpsuite](https://img.ma5hr00m.top/blog/helloweb-burpsuite.png)\n\n浏览器收到来自服务器的 `200 OK` 的 HTTP 响应，并收到服务端发过来的 HTML ⽂件后，会处理 HTML 标记并且构建 DOM 树，继⽽处理⻚⾯中引⽤的 CSS ⽂件，构建 CSSOM，将 DOM 树和 CSSOM 合并为渲染树，计算渲染树中每个元素的位置和⼤⼩，并确定它们在⻚⾯上的布局，最后在屏幕上进⾏绘制，最终就形成你看到的⻚⾯啦。\n\nHTTP 请求和响应的具体内容可以使⽤浏览器（推荐使⽤ Chrome、Firefox 或 Edge）的 F12 开发者⼯具进⾏查看，或者使用上图中的 BurpSuite 或者 Yakit 等抓包工具。\n\n![helloweb-edge](https://img.ma5hr00m.top/blog/helloweb-edge.png)\n\n如果对 Web 应用中的数据传递还有疑问，可先后观看以下两个视频，可以让你快速了解互联⽹和浏览器的运作流程：\n\n- [10 分钟带你了解互联⽹是如何运作的](https://www.bilibili.com/video/BV1Rz4y197Jd/?spm_id_from=333.788.recommend_more_video.-1&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180)\n- [浏览器是如何运作的](https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180)\n\n## 0x02 Web安全\n\n### 我是零基础小白，从哪里开始好呢？\n\n在 Web 安全领域中，我们较少提及 `C/C++`，更多的是 `Java`、`PHP`、`Golang` 等语言相关的安全问题。不过，如果你⽬前没有任何编程基础，我们依然推荐你先好好学习 C 语⾔。对于没有编程基础的新生，从 C 语⾔这样⼀⻔接近底层的⾼级语⾔开始学习，可以更好地学习计算机内部原理。并且，在学习 C 语⾔后，你就有了⼀定的编程基础，⼊⻔其他语⾔也绝⾮难事。\n\nC 语言的推荐教程是《C Primer Plus》，你可以跟着本书中的内容学习 C 语言。在学习的过程中，鼓励你跟着教程多上手跟着敲代码。计算机的学习与实践结合紧密，不是传统背书就行的。电子书地址提供在此，自行取用：\n\n- [《C Primer Plus 第6版 中文版》PDF 文件](https://github.com/erhuoyan/bookrack/blob/master/C%20Primer%20Plus%20%E7%AC%AC6%E7%89%88%20%E4%B8%AD%E6%96%87%E7%89%88.pdf)\n- [《C++ Primer Plus 第6版 中文版》原书代码和习题解答](https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th?tab=readme-ov-file)\n\n在上手敲代码之前，记得在你的系统中配置好 C 开发环境。\n\n### 技术栈的选择\n\n需要明确的是，安全和开发密不可分，在 Web 领域尤其如此。\n\n开发是安全的基础，如果没有⼀定的开发能⼒，在之后的 Web 安全学习中，⾯对⼀些代码审计也会感到⾮常茫然。所以，在学习 Web 安全之前，有必要先掌握一定的 Web 开发技术。\n\n> 🛠️如果你想要先行学习 Web 开发，可以跳到 ***0x03 Web开发*** 小节。\n\n我们一般推荐，在入门 Web 安全的同时，要同步学习并掌握一门较为熟悉的 Web 后端开发语言，你可以在 Java/Golang/PHP/Node.js 中任选其一，当然其他的语言比如 Rust 也可以，遵循自己的喜好选择即可。\n\n往前推个几年，研究 Web 安全最流行也必须掌握的语言是 PHP，那时的 CTF Web 赛题也是 PHP 赛题占主导。但在这两年风向有所变化，很多安全行业大牛（比如 [phith0n](https://www.leavesongs.com/)）认为，现在入门 Web 安全及漏洞挖掘最推荐学习的语言是 Java，毕竟现在多数 Web 应用都是之前的 Java 开发者留下的，包括现在的 CTF Web 中 Java 题目的占比也是越来越大。所以，如果你对前面提到的后端开发语言都不熟悉，不知道该选择哪个，也没什么很明确的规划，那就可以把 Java 作为首选项。\n\n此外，在 Web 安全领域中，确实有前端安全的存在，比如 XSS 等，但前端安全很多时候是作为一个“锦上添花”的存在，不是很推荐作为主要研究方向。当然，一切看你兴趣。\n\n- [Web 安全学习笔记](https://websec.readthedocs.io/zh/latest/)\n\n### CTF竞赛\n\n⼀直以来，Web 安全都是 CTF 竞赛重要的组成部分。\n\nCTF 竞赛⽬前主体还是 [Jeopardy 解题模式](https://ctf-wiki.org/introduction/mode/)，分为 Web/Re/Pwn/Crypto/Misc 五个⽅向。相⽐⼆进制，Web 安全在初期⼊⻔时⻔槛较低，并不需要对底层知识有太多的了解，对⼩⽩较为友好，能够快速上⼿做题。\n\n但不得不承认，Web 安全涉及内容更 **杂**。入门 Reverse 逆向工程，你只需要能读懂 C 即可，但入门 Web 需要你能在较短时间内快速接触并了解 Java/PHP/Golang 等编程语言。这需要你能坚持学习并投入一定量的时间。\n\n倒也不用焦虑，刚上手有不懂的很正常。CTF 比较讲究一个实践先于理论，你很难办到先把理论一口气全部学完，然后再开始上手实践，这不怎么现实，因为东西又多又杂，你也摸不准一道题目会想考你什么。遇到不会的积极去查去学就可以，什么不会补什么，多做题多做笔记，遇到不会的题目就及时复现写 Writeup，刚开始的时候多坐牢（指做不出来题目盯着屏幕做无用功），后面就能少做牢。\n\n在每个学年的上学期，Vidar-Team 会开放 HGAME-MINI 新生训练平台，里面的题目难度都比较适合初学者，可以多参与多做题，尝试把 Web 方向 AK 掉（All kill，指完成全部题目）。如果你想多做一些题目多学技术，可以使用下面的几个平台，这些平台都会提供往年的 CTF 赛题：\n\n- [buuoj](https://buuoj.cn/)\n- [攻防世界](https://adworld.xctf.org.cn/)\n\n此外，有一个较为特殊的 Web 靶场，即由 BurpSuite 官方提供的 PortSwigger 靶场。该靶场收录了几乎所有 Web 常见漏洞，提供了原理讲解和由易到难、种类齐全的 100+ 练习题，并提供了官方题解和社区视频题解，在此过程中你还能熟悉 BurpSuite 的使用，非常推荐。\n\n![helloweb-portswigger](https://img.ma5hr00m.top/blog/helloweb-portswigger.png)\n\n该靶场侧重让学习者了解并明白如何利用漏洞，并不是传统的 CTF 模式，所以没有找到 Flag 这一说，而是根据触发特定条件判断题目是否完成。靶场全英文。链接如下：\n\n- [PortSwigger WebSecurity Academy](https://portswigger.net/web-security)\n\n### 漏洞复现\n\n打 CTF 竞赛是社团活动的主要内容，但并不是全部，归根究底打比赛的目的也是学技术。在打比赛之外的时间，复现最新的漏洞或者一些老但知名的漏洞也是很好的学习方式。\n\nCVE（Common Vulnerabilities and Exposures，通用漏洞和暴露）是公开披露的网络安全漏洞列表。它是由 MITRE 公司维护和更新的安全漏洞列表，并由美国国土安全部（DHS）和网络安全与基础设施安全局（CISA）赞助。在CVE中，每个漏洞都会有一个唯一的CVE编号，即CVE ID，例如“CVE-2019-1234567”。这个编号是识别漏洞的唯一标识符，供安全研究员和受攻击的软件供应商使用，以便确定和回应安全漏洞。CVE编号由CVE编号机构（CVE Numbering Authority，CNA）分配，CVE编号机构主要由IT供应商、安全厂商和安全研究组织承担。\n\n我们一般所谓的复现漏洞，多数时候是指复现这些 CVE 漏洞，为了更好的理解这些漏洞的原理，我们会需要在本地搭建环境并进行模拟攻击。有时候自己搭环境会比较麻烦，网上找到的博客教程偶尔不靠谱。\n\n推荐一个 phith0n 的漏洞复现 GitHub 仓库，里面收录了很多有价值的漏洞，并且提供了构建环境所需的 Dockerfile 和 docker-compose.yml 文件，以及复现方式，非常方便：\n\n- [Vulhub 官网](https://vulhub.org/#/environments/) | [Vulhub 仓库](https://github.com/vulhub/vulhub)\n\n### 渗透\n\n> 📞遵纪守法，**任何渗透活动都应遵循相关的法律和道德准则**。勿碰黑灰产。\n\nWeb 渗透，也被称为 Web 渗透测试或 Web 渗透攻击，是一种评估网络应用安全性的方法。它涉及到模拟恶意攻击者的行为，以发现、利用和理解网络应用中的安全漏洞。\n\n这块和 Red Team 关系更近，有兴趣的可以自行了解。一次完整的渗透包括很多环节：选定目标后，首先要做信息搜集，使用一些工具或搜索引擎搜集目标相关资产，包括子域名什么的，然后进行外围打点，看看能不能找到一些突破口，拿下外围设备后就可以尝试上传木马控制主机权限，做权限维持，如果可以的话再进行提权，然后扫描内网网段，看能不能进行横向或者纵向移动，尝试拿下更多内网主机……\n\n如果你对渗透相关的安全内容感兴趣，可以通过以下两个靶场进行学习：\n\n- 国内：[春秋云镜 - 仿真场景](https://yunjing.ichunqiu.com/)\n- 国外：[Hack The Box](https://app.hackthebox.com/)\n\n更推荐后者，Hack The Box 提供了更加系统的 Red/Blue Team 的学习教程（全英文），以及对应的靶机实操练习。相信你可以从中找到乐趣。\n\n### 工具\n\nWeb 安全领域的工具实在是有“一点点”多，CTF、漏洞挖掘、渗透各自有各自的工具，相同功能的工具还有很多变种、不同团队的实现，该文档没法一一列举。此处就只列出最常用的安全工具，二选一即可：\n\n- [BurpSuite - 成熟的⽹络安全⼯具](https://portswigger.net/burp)\n- [Yakit - 集成化单兵安全能⼒平台](https://yaklang.io/products/intro/) \n\n如果你对这两个⼯具尚不了解，可以在⽹上搜索⼀些相关使⽤教程，起步阶段对这些⼯具的要求不⾼，简单的抓包改包即可。BurpSuite 的学习可以结合前面提到的 PortSwigger 靶场。\n\n## 0x03 Web开发\n\n欢迎来到有趣的 Web 开发领域，前面已经介绍过 Web 领域中前后端的划分，从开发的角度来说，一般推荐挑选其中一个方向进行学习。一方面是因为前后端开发技术经过了很多年的发展，各自都有着深厚的技术积累，即使你不准备去了解那些已经过时的旧技术，近几年的新技术也足够你学习很长一段时间了；另一方面是因为人的精力终究是有限的，想在短时间内同时推进前后端的学习并想要有所建树，是一件相对困难的事情。当然跟随自己的兴趣来就好，刚开始都接触一下也不是什么坏事，说不准你就是下一个全栈大师。\n\n但说实话，这东西也没什么固定的路数，协会 Web 成员在学习开发时的路线和技术栈也各不相同，没法提供一个同统一的路线。下文中的前后端开发入门都仅为编写文档的人的个人看法，请自行斟酌。\n\nWeb 前后端开发的学习过程差异较大，技术栈也少有重合，这里就分开介绍。\n\n> 🥳 HDU 有一个名为 [HDUHelp 杭电助手](https://www.hduhelp.cn/) 的社团。你会发现，杭电的很多网络服务都是由杭电助手开发并维护的，该社团也会在新学期开始时展开招新活动，老东西会为技术部新人提供相对统一的学习路线指导，欢迎加入杭电助手技术部~\n\n> 🔔 杭电助手后端部技术栈为 Golang；HDU 未央学社后端部技术栈为 Java。\n\n> 🥰 Vidar-Team 与 HDUHelp 关系颇深，协会 Web 方向成员与 HDUHelp 技术部成员重合度很高。\n\n### 前端开发\n\n前端开发对新手比较友好，因为你能直观地看到代码在浏览器中被渲染为页面，正反馈比较强，也不会说你学几天后做出来的东西没法给别人展示。\n\n这里简单介绍下 Web 前端开发入门需要学哪些东西，之后的内容可以自行探索。\n\n#### 原生三件套\n\n前端开发的基础就是 `HTML` + `CSS` + `JavaScript`，后面应用框架的学习也要基于这三者。把网站的前端比作人体的话，HTML 就是骨骼，负责支撑起网站的整体架构；CSS 是皮肤，负责给予网站优雅的外观；JavaScript 则是肌肉，让网站具备动态交互的能力。推荐教程是 [MDN Web](https://developer.mozilla.org/zh-CN/)，该站点是极其优质的 Web 前端开发知识库，认可度很高，很多流行前端框架的官方教程也把它作为 Web 前端领域中的 Wiki 来引用。\n\n当然，MDN 对初学者的问题是，其内容过于正式，单个小节的内容过多以至于消磨掉初学者耐心。如果你想在短时间内快速过一遍 Web 前端的简要内容，可以看这个：[菜鸟教程](https://www.runoob.com/)，精简很多，但内容不全且稍有过时。\n\n在学习的过程中，你会发现前端的东西比较杂乱，原生 HTML 中就有几百个标签，不同类的标签往往又会有十几个不同的属性，不同属性还有不同的可选值，CSS 中的各种选择器、伪类伪元素以及几百个属性也足以让你头大。不过这些你不用去记，真正到应用开发过程中，你就会发现能用到的其实不多，第一次看的时候稍微留意一下，脑子里有个概念、知道大概有这么个东西就行，敲代码的时候忘了就去翻文档，毕竟开发时又不是断网环境，只要你能把应用功能实现，怎么搞都行。\n\n`JavaScript` 相对前两者重要一些，因为网页的主要功能都要使用 `JavaScript`（下文简称 JS）实现，之后接触的前端应用框架也主要是 JS 框架，包括后面如果你想以一个前端开发者的身份快速上手后端开发，基于 JS 语法的一系列 Node.js 后端框架也是你的首选。因此，你有必要多投入一些精力到 JS 的学习上。\n\n这里推荐一份 JavaScript 的练习教程，跟着敲敲也蛮有帮助的，可以作为参考：[JavaScript 30](https://javascript30.com/)。\n\n#### JavaScript框架\n\n到了应用框架这层，你会发现——可选项更多了。开发者们整天轮子叠轮子的造，同一种功能的实现能给你整出来几十个大大小小的框架，开发者们也整天在社交媒体上因为技术选型而唇枪舌战。吵到今天，应用框架也大致分为了两派，分别是 Vue 和 React。\n\n你可以在这两者中挑一个上手，这里不做推荐，自己去官网看看，考虑自己喜欢哪种风格之后再上手，反正之后两个都得会（乐）。学的时候跟着官方教程走就好，下面是二者的官方文档：\n\n- [React](https://react.dev/) - [React 官方中文文档](https://zh-hans.react.dev/)\n- [Vue.js - 渐进式的 JavaScript 框架](https://vuejs.org/)\n- [Angular](https://angular.cn/)\n\n此外，当你上手前端应用框架时，就可以抛弃 JavaScript 而转向使用 TypeScript 了。\n\nTypeScript（简称 TS）是微软公司开发的一种基于 JS 的编程语言，其目的是增强 JS 的功能，使其更适合多人合作的项目。TypeScript 可以看成是 JS 的超集（superset），即它继承了后者的全部语法。所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。\n\nTS 对 JS 添加的最主要部分，就是一个独立的类型系统。JS 本身是有一套自己的类型系统，但其非常弱，运算符可以接受各种类型的值。这使得 JS 语法变得非常灵活，但客观上也增加了多人协同项目中出错的概率。在语法上，JS 属于动态类型语言。TS 引入了一个更强大、更严格的类型系统，属于静态类型语言。静态类型有利于代码的静态分析，更早地发现错误，提供了更好的 IDE 支持，做到语法提示和自动补全，提供了代码文档，有助于代码重构。\n\n平心而论，很多项目其实没必要使用 TypeScript，严格的类型限制和语法要求会降低开发效率。但你架不住多人合作的时候别的前端开发都要用，以及有时候参加项目竞标或者比赛，其他组都用 TS，你一个人用 JS 把项目搞定了，很多不懂技术的评委也只会认为你不会，而不是你不屑于去用。关于到底使用 JS 还是 TS 也是一个长期争论的问题，自行决定。\n\n> 🧐这块的描述确实不太准确，其他 JS 框架比如 Angular 的使用者也不在少数，上文中提到的 React 严格来说只能算视图层面的库，其背后的 Next.js 才是官方主推的应用框架。不过这些对初学者来说不重要，先大致有个了解，学到后面接触到这些的时候再去调整自己的技术栈。\n\n### 后端开发 - Golang\n\n与前端相比，后端就主要是在于机器交流，你要操纵用户看不到的数据。后端没法做到像前端那样敲个代码立马就能看到反馈，不过胜在学习路线清晰，整体开发流程更加统一。\n\n后端开发技术选型和语言关系比较大，此处以 Golang 为例进行介绍。\n\n#### 上手\n\nGolang，也称为 Go 语言，是由 Google 开发的一种静态强类型、编译型语言。Go 语言的语法与 C 在许多方面相似，但它包含了垃圾回收的功能，且支持并发编程，同时更加简洁。这些优势使得 Go 在网络开发以及云原生方面有一些独特的优势。如果你学过 C 的话，Go 其实挺好上手的。\n\n有以下两个推荐教程，不推荐看菜鸟教程，太浅了：\n\n- 在线学习 Golang 的网站，手把手教你一步步敲代码：[Go 语言之旅](https://tour.go-zh.org/welcome/1)\n- 看书的话就选这本，[Golang 圣经](https://golang-china.github.io/gopl-zh/)\n\n在踏入下一步之前，你还有必要先了解 SQL。SQL，全称为 **结构化查询语言**（Structured Query Language），是一种用于管理关系数据库的标准编程语言。它包括一系列用于创建、修改、删除和查询数据库的命令。Web 后端应用基本都会有存储数据的需求，你不能把数十万条需要持久存储的数据一直保存在本地内存中，而是需要用类似 MySQL 这样的数据库帮存储你的数据。\n\n- [W3school SQL教程](https://www.w3school.com.cn/sql/index.asp)\n\n#### 框架\n\n当你熟悉 Golang 语法之后，就可以上手 Web 应用框架了。推荐给初学者的 Golang 后端三件套是 `Gin` + `Gorm` + `MySQL`，去看各自的官方教程即可。\n\nGin 是一个 Web 应用框架，这个都懂。开发者固然可以使用 Golang 自带的 `net/http` 处理客户端请求、处理并返回数据，但每次都这么做未免有些累赘；而且有时我们需要为某些 API 添加统一的鉴权，或者为所有处理请求事件添加日志记录，如果我们使用原生库去一个接口一个接口地去完成这些工作，那可就太费事费力了。\n\n所以，经过积累，开发者们就将某些常用的功能，比如动态路由实现、分组控制、中间件、模板渲染与错误恢复等，将它们抽象出来并进行封装，打包成一个开箱即用的 Web 应用框架。当其他开发者想要实现某些功能时，直接导包引用该框架即可，这大幅提升了 Web 应用的开发效率，也在规范化和标准化等方面做出贡献。\n\n- [Gin](https://gin-gonic.com/)\n\nGorm 是一个基于 Golang 开发的全功能 ORM 框架。那什么是 ORM 呢？你在学习 Golang 语法时或许已经知道该如何拼接 SQL 语句并进行数据库操作了，但这么搞的问题是效率低下，而且有些粗心的开发者疏于对用户传入数据的处理，可能会导致一些安全问题，比如 SQL 注入漏洞。\n\n为了解决上述问题，ORM 应运而生。ORM 全称 **对象关系映射**（Object-Relational Mapping），是一种程序设计技术，用于实现面向对象编程语言里的对象和关系数据库之间的映射。有了 ORM，开发者可以直接使用面向对象的方式来操作数据库，无需编写 SQL 代码，大大提高了开发效率，框架自带的预处理等防范措施也提高了 Web 应用的安全性。当然，代价就是牺牲了一定的灵活性。\n\n- [GORM 指南](https://gorm.io/zh_CN/docs/index.html)\n\n此外，在你能够使用这三件套，以及其他库熟练地完成 CRUD 开发工作之后，我推荐你去读读这些框架的源码，从底层理解这些框架是如何实现数据处理以及其他功能的实现的，比如路由匹配的方式等等，然后尝试上手写写，自己实现。这个过程也是比较有趣的，你可以使用自己学习过的 Golang 语法与原生库结合，一步步地搭建出一个具备完备功能的 Framewok。如果你之前没有什么阅读源码的经验，也不知道何从下手，可以跟着下面这篇教程走，或许可以对你有所启发：\n\n- [7天用Go从零实现Web框架Gee教程](https://geektutu.com/post/gee.html)\n\n### 后端开发 - Java\n\n#### 上手\n\nJava 这门编程语言你可能已经耳熟能详，毕竟这几年 Java 卖课的比较多（挠头）。它的跨平台性、面向对象的特性以及丰富的类库使其在编程语言中独树一帜。如果你对 C++ 或者 C# 有所了解，那么就会发现 Java 的语法与它们有许多相似之处。但是，Java 在设计上追求简洁和易读，因此去除了一些容易引发错误的概念，如指针和运算符重载等。如果你之前没学习过面向对象的语言，初次上手可能略有费劲。\n\n推荐下学习资源，可以试试：\n\n- [Java教程 - 廖雪峰](https://www.liaoxuefeng.com/wiki/1252599548343744)\n- 黑马程序员Java零基础视频教程：[上部](https://www.bilibili.com/video/BV17F411T7Ao/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180) & [下部](https://www.bilibili.com/video/BV1yW4y1Y7Ms/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180)\n\n#### 框架\n\n学完语法之后，就可以学习对应的后端服务框架了。对于 Java 后端开发，比较推荐的技术栈是 `Spring Boot` + `Hibernate` + `MySQL`。 \n\nSpring Boot 是一个基于 Spring 框架的开源 Java 框架，它可以帮助你快速地创建出一个独立的、生产级别的 Spring 应用程序。学习资源推荐：\n\n- [Spring Boot 中文文档](https://springdoc.cn/spring-boot/)\n- [黑马程序员 SpringBoot2](https://www.bilibili.com/video/BV15b4y1a7yG/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180)\n\nHibernate 对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架，它可以帮助你更方便地操作数据库，而无需编写复杂的 SQL 代码。\n\n- [Hibernate 中文文档](https://hibernate.github.net.cn/)\n\n#### 安全\n\n再调过头来提一下 Java 安全。网上资料茫茫多，自己挑比较费时间，可以直接看下面推荐的这个教程，phith0n 出品，必属精品：\n\n- [攻击Java Web应用-[Java Web安全]](https://javasec.org/)\n\n 与此同时，phith0n 还建立了一个[“代码审计”知识星球](https://govuln.com/)，是一个专业、前沿、原创的 Web 代码安全与审计讨论社区，专注于分享原创的代码安全知识、漏洞挖掘方法，感兴趣的可以加一下。截至本文文档更新时，星球价格为 299￥ 终身制，不过确实值这个钱。\n\n## 0x04 Network\n\n因为本文档讨论的主要是狭义上的 Web，Network 其实一般不会在此处提及。但因为 Network 在 Web 渗透领域的使用，以及 Vidar-Team 最近两届的网管都是 Web 手，所以本文档也单独划出 Network 的小节。\n\n写这篇文档的人 Network 技术相对一般，这里就少啰嗦一些废话。如果你对计算机网络感兴趣但没有基础，可以自行学习 [HDU-CS-WIKI 计算机网络](https://hdu-cs.wiki/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C) 章节的内容，可以快速的给你通一遍网络相关概念，方便你进一步的学习。\n\n如果你对自己的网络水平有自信，并且有意向加入 Vidar-Team 成为下一届网管，就在招新群里吆喝一声，很快就可以吸引到 Vidar 历届网管的注意，线下交流讨论。\n\n此外，HDU 有一个由学生自发创建的去中心化网络，名为[“DN11”](https://dn11.top/)，欢迎有一定网络基础的学生加入。\n\n![helloweb-dn11](https://img.ma5hr00m.top/blog/helloweb-dn11.png)\n\n## 0x05 泛用技能\n\n有些东西并不怎么成体系，但也是新生有必要知道的，同时又不怎么好分类，索性一块丢到这个小节下面。\n\n### 信息搜集\n\n本文档是面向新手的教程，覆盖面有限，你可能想要更多相关资料。如果掌握了恰当的信息搜集⽅式，你就可以获得更多更优质的资源，实现更快的进步。\n\n#### 搜索引擎\n\n好的搜索引擎可以帮你检索出优质的学习资源，节约你在海量的⽂章中沙⾥淘⾦的时间。⾸推的搜索引擎是 [Google](https://www.google.com/)，它可以帮助你搜集全球范围内符合你关键词的⽹⻚，并过滤掉⼀些⽆⽤的⼴告和只会 cv 的⽂章，快速定位到你需要的资源。\n\n退⽽求其次，你也可以选择 Microsoft Bing，如果你从未接触过计算机技术，对你来说 [Bing](https://www.bing.com/) 可能更⽅便访问。\n\n如果你执着于使⽤[百度](https://www.baidu.com/)，你可以利⽤⼀些搜索引擎默认的语法来规避掉不想看到的⽹⻚。⽐如 `SQLI⼊⻔教程 -csdn`，这样你的搜索结果中就不会出现 CSDN 相关⽂章。\n\n#### 平台\n\n如果你对计算机感兴趣，你就不可避免的要接触 [GitHub](https://github.com/)。GitHub 是⼀个⾯向开发⼈员的开源代码托管平台，它允许⽤⼾创建和管理他们的代码仓库，与其他开发⼈员协作。在 GitHub 上你能找到很多优秀的开源项⽬，以及⼀些有趣的学习资料，你甚⾄可以在这⾥体会到寻宝的快感，尽情地去了解世界上其他的程序员都在做些什么、在研究什么东西。这其中就有很多 Web ⽅向的学习资料，包括开发、安全等各个领域。\n\n如果你有计算机⽅⾯的问题，你可以选择去 [Stack Overflow](https://stackoverflow.com/)。Stack Overflow 是⼀个⾯向程序员的问答⽹站，它是 Stack Exchange ⽹络的旗舰站点。它由 Jeff Atwood 和 Joel Spolsky 于 2008 年创建，提供了关于计算机主题的问题和答案。Stack Overflow 是全球最⼤、最值得信赖的在线社区之⼀，开发⼈员可以在这⾥学习、分享他们的编程知识。在问答型 AI 流行起来之前，这就是全世界程序员最常用的寻求问题解决方案的地方。\n\n#### AI\n\n你可以使⽤最近流⾏的 AI 帮助你学习。⽬前常⻅的问答 AI 有 [Chatgpt](https://chat.openai.com/)、New Bing 等，你可以借助它们来快速⼊⻔⼀个概念或者找到你问题的答案。\n\n此外，有一些基于 AI 的搜索引擎也可以尝试，比如 [devv_](https://devv.ai/)。\n\n> 😵请记住，不要把 AI 给你的回答当成真理，不要过度依赖 AI，它只是你的⼀个辅助⼯具。就像本文档开头所说的那样，你要保留 **独⽴思考** 的能⼒，什么事都问 AI 的结果就是你平滑的被 AI 取代。\n\n### Git版本管理工具\n\nGit 是一种**分布式版本控制系统**。它可以自动跟踪文件的变化、还原文件的历史记录、协调多人在同一个项目中工作，并且可以在必要情况下回溯到过去的任意版本。\n\n在软件开发中，版本控制系统可以帮助开发人员有效地管理和维护代码库，支持项目的分支、合并等操作。这样，这允许不同的成员可以同时对同一个项目进行开发，而不会产生代码冲突等问题。此外，版本控制系统还可以提供更好的安全备份和恢复机制，以防止意外的数据丢失或代码损坏。\n\n前文说过了 GitHub，经过简单的配置，你就可以使用 Git 将本地项目托管到 GitHub 平台，避免数据丢失的麻烦。\n\n从这个网站学习 Git 的使用，手把手式教学：[Learn Git Branching](https://learngitbranching.js.org/)\n\n### Linux操作系统\n\nLinux 是一个操作系统。它由 *Linus* 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。 现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。它自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。 以前有很多设置你可能需要在 Windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。\n\n此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。 这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。\n\n同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。 这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。\n\n现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。你可以使用 [VMware](https://www.vmware.com/) 或者 [VirtualBox](https://www.virtualbox.org/) 等软件创建 Linux 虚拟机，也可以干脆直接上 Linux 物理机。对于 Web 方向的学习来说，Linux 系统的熟练使用属于必备技能。\n\n## 0x06 可选事项\n\n### 个人博客\n\n推荐在个人博客记录⾃⼰的学习过程。在搭建博客的过程中你能学到很多有趣的知识。\n\n比较推荐的用来搭建个人博客的框架有 [Hexo](https://hexo.io/zh-tw/)、[Vitepress](https://vitepress.dev/)、[Hugo](https://gohugo.io/)、[WordPress](https://wordpress.com/zh-tw/) 等，可以都看看，选择一个自己喜欢的用（搭建个人博客很多时候考虑的还是美观性）。如果你对自己的前端技术有自信，也可以自己写一个。\n\n以下是几个高质量的杭电学长个人博客，可以看看他们的文章：\n\n| Name      | Blog Link              |\n| --------- | ---------------------- |\n| E99p1ant  | https://github.red/    |\n| LoRexxar  | https://lorexxar.cn/   |\n| lightness | https://lightless.me/  |\n| Cyris     | https://cyris.moe/     |\n| Chuj      | https://www.cjovi.icu/ |\n| daidr     | https://im.daidr.me/   |\n| Nick Xu   | https://nickxu.me/     |\n\n此外，我们编辑个人博客时一般使用的是 [Markdown](https://markdown.tw/) 格式，推荐学习一下。有很多 Markdown 编辑器可供选择，比如 [Typora](https://typora.io/)、[Obsidian](https://obsidian.md/)，直接使用 Visual Studio Code 配合插件也是可以的。\n\n在编辑博客时，你可能需要插入一些图片。你可以选择将图片与 Markdown 存储在同一个仓库中，不过更推荐使用 OSS+PicGo 的组合搭一个图床，然后在 .md 文件中通过外链引用图片，具体操作可以参考这个教程：[阿里云OSS PicGo 配置图床教程 超详细](https://zhuanlan.zhihu.com/p/104152479)。\n\n> 💸 警告，如果使用云存储服务搭建图床，建议使用 CDN 为外链引用添加限制，否则可能会有坏人刷你博客里的 OSS 外链图片，造成高额的经济损失。确保在有能力保护自己安全的情况下再用。\n\n### 兔兔的小游戏\n\n加⼊ Vidar-Team 招新群，你经常能看到可爱的兔兔机器⼈在帮助维持群内秩序，或者回答⼀些简单的问题。\n\n![helloweb-tutu](https://img.ma5hr00m.top/blog/helloweb-tutu.png)\n\n兔兔迎新机器⼈还具有⼀个 `%blog` 命令，⽤于查询协会成员的博客链接。功能存在⼀个 SQLI 漏洞，通过这个漏洞可以查询出数据库中的 Flag。拿到 Flag 后可以私聊 Web 方向学长领取一杯奶茶哦~\n\n### 其他学习路线\n\n这是面向新生的文档，自然会有很多介绍不够细致的地方，不过我感觉已经够新生学一阵子的了。如果你还想要参考其他学习路线，可以点击下面这几个网址，这是在 GitHub上很火爆的 Roadmap，也可以提供路线的建议：\n\n- [Frontend Developer Roadmap](https://roadmap.sh/frontend)\n- [Backend Developer Roadmap](https://roadmap.sh/backend)\n- [Roadmap do Desenvolvedor Web 2021](https://github.com/hideraldus13/roadmap-do-desenvolvedor-web)\n\n## 0x07 后话\n\n内容略多，希望你是耐⼼看到这⾥的。\n\nVidar 在本质上就是⼀群热爱信息安全的⼩伙伴自发成⽴的技术型团体，CTF 竞赛是我们⽇常活动的组成部分，并不是 Vidar 存在的唯⼀意义，你可以在这⾥尽情的研究你喜欢的技术，不仅是本⽂介绍的 Web，其他⼏个⽅向，以及较少提及的 IOT、区块链等都有学⻓在研究，你可以在这⾥轻松找到志同道合的朋友，⼀起学习。\n\n另外，协会希望⼤家不要急于求成，要先打好基础。扎实的基础知识会是你未来发展道路上的铺路⽯。同时，也不能只着眼于理论知识，也要在实战中学习，边学边练才是健康的状态。\n\n最后，再次欢迎对 Web 安全感兴趣的你！如果在学习过程中遇到困难，随时可以在招新群中提问，祝你在 Web 安全的学习道路上越⾛越远〜\n\n> 🏔️ 勿以浮沙筑⾼台，望学弟学妹们打牢基础，努力学习哇！","source":"_posts/hello_web.md","raw":"---\ntitle: HelloWeb 致新生\ndate: 2024/5/20\nauthor: ma5hr00m\ncategories:\n- Web\n---\n\n# HelloWeb\n\n> 🚀本文档面向初次踏入 The Web World 的新生，希望为你们提供一个可供参考的学习路线。\n\n> ✨该文档最早公开于 [ma5hr00m/HelloWeb](https://github.com/ma5hr00m/HelloWeb)，计划用于 Vidar-Team2024 届招新。\n\n![helloweb-banner](https://img.ma5hr00m.top/blog/helloweb-banner.png)\n\n## 0x00 前言\n\nWeb 安全与 Web 开发往往是绑定在一起的，所以本文档会同时介绍 **安全&开发**，还会有一些零零散散的其他想要告诉新生的东西，所以内容会略多，希望多点耐心看完。\n\n在开始之前，你们需要准备一些东西，要求不高，相信大家都有：\n\n- 🧠能**独立思考**的大脑\n- 💻可以使用的电脑\n- 🔮流畅的网络\n- ❤️**积极好学**的心\n\n此外，所有想要涉足计算机领域的新生，都有必要去阅读一篇文章，其名为**《提问的智慧》**。篇幅不长，20min 即可，你可以从中学习到如何提出 **一个有价值的问题**，而不是掏出手机拍一张电脑屏幕，丢进群里就问“我该怎么办”，这是在浪费大家的时间。同时，你也可以把《提问的智慧》当作⼀个 AI prompt 指南。因为不论是对⼈还是对机器，提出一个有效的问题都能事半功倍地解决问题。\n\n你可以点击下面的链接以阅读这篇文章。此外，Vidar-Team2024 招新群中也提供了 PDF 版本，需要请自取。\n\n- [简体中文版《提问的智慧》](https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md)\n\n> 🔍如果在此之前，你完全没有了解过计算机，但觉得能够成为一个整天抱着电脑“哐哐哐\"敲键盘、张口闭口都是别人听不懂的怪话的程序猿是一件很酷的事情，那你依然可以阅读本文档，但其中很多名词你可能从未了解，你可以暂时跳到 ***0x05 泛用技能- 信息搜集*** 小节。\n\n> 📷学会截屏。\n\n## 0x01 Web\n\n[Web](https://en.wikipedia.org/wiki/World_Wide_Web) 是 World Wide Web 的简称，是一个通过互联网访问的、由许多互相链接的的超文本组成的信息系统。这是指的广义上的 Web，即涵盖了整个世界范围内的互联网服务和资源的集合。这包括所有 **通过互联网连接** 的设备、服务、网络协议以及通过这些设备和服务访问的内容，它超越了单纯的网页和浏览器，涵盖了从大型服务器到个人设备的所有互联网技术。\n\n我们日常所说的往往是狭义上的 Web，更加专注于构成网站和网络应用技术实践，包括传统的前后端开发、运维以及 Web 安全等领域。这与大家的生活就很贴近了，今日的学习、办公、娱乐都已经脱离不开网络应用技术，输入一串 URL 后浏览器如何得到一个功能完备的 Web 页面、在自己手机的“学习通”里上传一份 docx 附件后如何将其传递给教师，这都属于 Web 的范畴。现在的你可能并不明晰这些功能的实现原理，但经过一段时间的学习，相信你就可以对这些功能的实现有一个明确的认知，或者已经能够自己开发一个具备类似功能的 Web 应用。\n\n除非有特殊说明，本文档后面的 Web 都是指狭义上的 Web 应用。\n\n### 发展史\n\n最初的 Web 应⽤非常简陋，程序托管在 ISP（Internet Service Provider，互联网服务提供商）那里，用户在自己的主机上访问对应 IP 获得对应的静态页面，页面中只有⽂字与图⽚，当时的用户能做的也只是浏览⽹⻚，没法与网页背后的机器（或人）进行更多的交流。这只是一个单方向的信息输出，人们并不满足于这一点。\n\n为了丰富 Web 应用的功能，满足人们增长的需求，之后就有了 Flash 等媒体技术，大名鼎鼎的 JavaScript 编程语言也被研发出来。⾳视频和动态交互的实现给予了用户更高的自由度，越来越多的公司也开始通过互联网宣传自家产品，让潜在用户在家就能看到他们的产品信息。\n\n随后，CGI（Common GatewayInterface）技术出现，Web 服务器可以通过 CGI 执⾏外部程序，外部程序可以根据请求内容⽣成动态内容返回给用户。现代 Web 应用的雏形已经出现。\n\n再之后，随着 PHP/JSP 等编程语⾔的开发，MVC 思想、REST（Representation State Transformation）架构⻛格的提出，Web 应⽤的功能进一步增强，一片勃勃生机万物竞发之势。但随之而来的是安全问题频出，Web 安全也开始得到开发者的重视。\n\n在之后就是越来越多的 Web 技术出现、应用逻辑越来越复杂，部分 Web 开发者难以忍受同时编写数据处理逻辑和网站页面，前后端分化。分化之后开发者们有了更多的精力钻研自己感兴趣的领域，技术不断发展，直到今天。\n\n这里简单说说 **前后端的划分**。前端就是⽤⼾可以直接看⻅的部分，⽐如说我们访问 [baidu.com](https://www.baidu.com)，浏览器显示的搜索框、按钮等组件，以及我们输入 URL 之后字符串如何传递给后端应用，这些都属于 Web 前端的范畴；与之相对的，后端就主要是⽤⼾看不⻅的部分，⽐如在百度中搜索 [Vidar-Team](https://www.baidu.com/s?wd=Vidar-Team)，服务器在数据库中根据关键词查找相关内容，处理后整合成格式恰当的数据，再交给前端让浏览器去渲染出一个包含相关信息的页面，这就是 Web 后端负责的⼯作。\n\n### Web 应用中的数据传递\n\n> 这部分内容对 0 基础新生来说可能较为困难，可暂时跳过。\n\n打开浏览器，地址栏中敲入 [https://vidar.club](https://vidar.club) 并回车，浏览器片刻就会返回给我们 Vidar-Team 的官网首页，这是如何实现的呢？下面我们会以此为例讲讲 Web 应用中的数据传递。\n\n当浏览器接收到用户输入的 URL 时，首先会做的就是 [DNS 查询](https://www.ruanyifeng.com/blog/2022/08/dns-query.html)，浏览器会去查找这个 URL 背后对应的资源在什么地方，也就是这个域名对应的 IP 是什么。 \n\n![helloweb-dns](https://img.ma5hr00m.top/blog/helloweb-dns.png)\n\n目前常见的 IP 地址格式一般为 [xxx.xxx.xxx.xxx]()，但人类要记住这样的 12 位纯数字比较困难。因此，开发者们决定⽤形象的域名（domain）来让⽤⼾记住资源的位置。你看，[vidar.club](https://vidar.club) 就⽐ [1.117.117.147](1.117.117.147) 这个 IP 好记太多了吧？浏览器根据域名向 DNS 服务器查询对应 IP 地址。DNS 服务器就像一本电话簿，里面详细记录了各种各样的域名与其对应的 IP 地址。在这个例子中，浏览器得到对应的 IP 地址就是 [1.117.117.147](1.117.117.147)。 \n\n浏览器得知服务器的 IP 地址后，就会与其对应的服务器进⾏ TCP 三次握⼿。三次握⼿机制的目的时让通信的两端建立可靠的连接，毕竟谁也不想看到一个内容残缺的网页。为了让连接更加安全，本地主机与服务器在三次握手之后就会进⾏ TLS 协商。你看我们输⼊的是 `https://`，这表明我们使⽤了 HTTPS 协议访问主机资源。相⽐于明文传输数据的 HTTP，HTTPS 使⽤了 SSL/TLS 协议对数据进⾏了加密处理，这会让访问变得更加安全。当三次握⼿和 TLS 协商完成后，我们就已经和服务器建⽴了安全连接啦。\n\n> 顺带一提，如果使用 `http://` 访问协会官网也会强制转化为 `https://` 哦，可以试试 [http://vidar.club](http://vidar.club)。\n\n建⽴安全连接后，浏览器会向服务器发送 HTTP `GET` 请求，请求服务器返回我们事先放在服务器上的对应⽹⻚的内容，这个请求的内容通常是⼀个 HTML ⽂件。当服务器收到请求后，就会使⽤相关的响应头和 HTML 内容进⾏回复。\n\n![helloweb-burpsuite](https://img.ma5hr00m.top/blog/helloweb-burpsuite.png)\n\n浏览器收到来自服务器的 `200 OK` 的 HTTP 响应，并收到服务端发过来的 HTML ⽂件后，会处理 HTML 标记并且构建 DOM 树，继⽽处理⻚⾯中引⽤的 CSS ⽂件，构建 CSSOM，将 DOM 树和 CSSOM 合并为渲染树，计算渲染树中每个元素的位置和⼤⼩，并确定它们在⻚⾯上的布局，最后在屏幕上进⾏绘制，最终就形成你看到的⻚⾯啦。\n\nHTTP 请求和响应的具体内容可以使⽤浏览器（推荐使⽤ Chrome、Firefox 或 Edge）的 F12 开发者⼯具进⾏查看，或者使用上图中的 BurpSuite 或者 Yakit 等抓包工具。\n\n![helloweb-edge](https://img.ma5hr00m.top/blog/helloweb-edge.png)\n\n如果对 Web 应用中的数据传递还有疑问，可先后观看以下两个视频，可以让你快速了解互联⽹和浏览器的运作流程：\n\n- [10 分钟带你了解互联⽹是如何运作的](https://www.bilibili.com/video/BV1Rz4y197Jd/?spm_id_from=333.788.recommend_more_video.-1&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180)\n- [浏览器是如何运作的](https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180)\n\n## 0x02 Web安全\n\n### 我是零基础小白，从哪里开始好呢？\n\n在 Web 安全领域中，我们较少提及 `C/C++`，更多的是 `Java`、`PHP`、`Golang` 等语言相关的安全问题。不过，如果你⽬前没有任何编程基础，我们依然推荐你先好好学习 C 语⾔。对于没有编程基础的新生，从 C 语⾔这样⼀⻔接近底层的⾼级语⾔开始学习，可以更好地学习计算机内部原理。并且，在学习 C 语⾔后，你就有了⼀定的编程基础，⼊⻔其他语⾔也绝⾮难事。\n\nC 语言的推荐教程是《C Primer Plus》，你可以跟着本书中的内容学习 C 语言。在学习的过程中，鼓励你跟着教程多上手跟着敲代码。计算机的学习与实践结合紧密，不是传统背书就行的。电子书地址提供在此，自行取用：\n\n- [《C Primer Plus 第6版 中文版》PDF 文件](https://github.com/erhuoyan/bookrack/blob/master/C%20Primer%20Plus%20%E7%AC%AC6%E7%89%88%20%E4%B8%AD%E6%96%87%E7%89%88.pdf)\n- [《C++ Primer Plus 第6版 中文版》原书代码和习题解答](https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th?tab=readme-ov-file)\n\n在上手敲代码之前，记得在你的系统中配置好 C 开发环境。\n\n### 技术栈的选择\n\n需要明确的是，安全和开发密不可分，在 Web 领域尤其如此。\n\n开发是安全的基础，如果没有⼀定的开发能⼒，在之后的 Web 安全学习中，⾯对⼀些代码审计也会感到⾮常茫然。所以，在学习 Web 安全之前，有必要先掌握一定的 Web 开发技术。\n\n> 🛠️如果你想要先行学习 Web 开发，可以跳到 ***0x03 Web开发*** 小节。\n\n我们一般推荐，在入门 Web 安全的同时，要同步学习并掌握一门较为熟悉的 Web 后端开发语言，你可以在 Java/Golang/PHP/Node.js 中任选其一，当然其他的语言比如 Rust 也可以，遵循自己的喜好选择即可。\n\n往前推个几年，研究 Web 安全最流行也必须掌握的语言是 PHP，那时的 CTF Web 赛题也是 PHP 赛题占主导。但在这两年风向有所变化，很多安全行业大牛（比如 [phith0n](https://www.leavesongs.com/)）认为，现在入门 Web 安全及漏洞挖掘最推荐学习的语言是 Java，毕竟现在多数 Web 应用都是之前的 Java 开发者留下的，包括现在的 CTF Web 中 Java 题目的占比也是越来越大。所以，如果你对前面提到的后端开发语言都不熟悉，不知道该选择哪个，也没什么很明确的规划，那就可以把 Java 作为首选项。\n\n此外，在 Web 安全领域中，确实有前端安全的存在，比如 XSS 等，但前端安全很多时候是作为一个“锦上添花”的存在，不是很推荐作为主要研究方向。当然，一切看你兴趣。\n\n- [Web 安全学习笔记](https://websec.readthedocs.io/zh/latest/)\n\n### CTF竞赛\n\n⼀直以来，Web 安全都是 CTF 竞赛重要的组成部分。\n\nCTF 竞赛⽬前主体还是 [Jeopardy 解题模式](https://ctf-wiki.org/introduction/mode/)，分为 Web/Re/Pwn/Crypto/Misc 五个⽅向。相⽐⼆进制，Web 安全在初期⼊⻔时⻔槛较低，并不需要对底层知识有太多的了解，对⼩⽩较为友好，能够快速上⼿做题。\n\n但不得不承认，Web 安全涉及内容更 **杂**。入门 Reverse 逆向工程，你只需要能读懂 C 即可，但入门 Web 需要你能在较短时间内快速接触并了解 Java/PHP/Golang 等编程语言。这需要你能坚持学习并投入一定量的时间。\n\n倒也不用焦虑，刚上手有不懂的很正常。CTF 比较讲究一个实践先于理论，你很难办到先把理论一口气全部学完，然后再开始上手实践，这不怎么现实，因为东西又多又杂，你也摸不准一道题目会想考你什么。遇到不会的积极去查去学就可以，什么不会补什么，多做题多做笔记，遇到不会的题目就及时复现写 Writeup，刚开始的时候多坐牢（指做不出来题目盯着屏幕做无用功），后面就能少做牢。\n\n在每个学年的上学期，Vidar-Team 会开放 HGAME-MINI 新生训练平台，里面的题目难度都比较适合初学者，可以多参与多做题，尝试把 Web 方向 AK 掉（All kill，指完成全部题目）。如果你想多做一些题目多学技术，可以使用下面的几个平台，这些平台都会提供往年的 CTF 赛题：\n\n- [buuoj](https://buuoj.cn/)\n- [攻防世界](https://adworld.xctf.org.cn/)\n\n此外，有一个较为特殊的 Web 靶场，即由 BurpSuite 官方提供的 PortSwigger 靶场。该靶场收录了几乎所有 Web 常见漏洞，提供了原理讲解和由易到难、种类齐全的 100+ 练习题，并提供了官方题解和社区视频题解，在此过程中你还能熟悉 BurpSuite 的使用，非常推荐。\n\n![helloweb-portswigger](https://img.ma5hr00m.top/blog/helloweb-portswigger.png)\n\n该靶场侧重让学习者了解并明白如何利用漏洞，并不是传统的 CTF 模式，所以没有找到 Flag 这一说，而是根据触发特定条件判断题目是否完成。靶场全英文。链接如下：\n\n- [PortSwigger WebSecurity Academy](https://portswigger.net/web-security)\n\n### 漏洞复现\n\n打 CTF 竞赛是社团活动的主要内容，但并不是全部，归根究底打比赛的目的也是学技术。在打比赛之外的时间，复现最新的漏洞或者一些老但知名的漏洞也是很好的学习方式。\n\nCVE（Common Vulnerabilities and Exposures，通用漏洞和暴露）是公开披露的网络安全漏洞列表。它是由 MITRE 公司维护和更新的安全漏洞列表，并由美国国土安全部（DHS）和网络安全与基础设施安全局（CISA）赞助。在CVE中，每个漏洞都会有一个唯一的CVE编号，即CVE ID，例如“CVE-2019-1234567”。这个编号是识别漏洞的唯一标识符，供安全研究员和受攻击的软件供应商使用，以便确定和回应安全漏洞。CVE编号由CVE编号机构（CVE Numbering Authority，CNA）分配，CVE编号机构主要由IT供应商、安全厂商和安全研究组织承担。\n\n我们一般所谓的复现漏洞，多数时候是指复现这些 CVE 漏洞，为了更好的理解这些漏洞的原理，我们会需要在本地搭建环境并进行模拟攻击。有时候自己搭环境会比较麻烦，网上找到的博客教程偶尔不靠谱。\n\n推荐一个 phith0n 的漏洞复现 GitHub 仓库，里面收录了很多有价值的漏洞，并且提供了构建环境所需的 Dockerfile 和 docker-compose.yml 文件，以及复现方式，非常方便：\n\n- [Vulhub 官网](https://vulhub.org/#/environments/) | [Vulhub 仓库](https://github.com/vulhub/vulhub)\n\n### 渗透\n\n> 📞遵纪守法，**任何渗透活动都应遵循相关的法律和道德准则**。勿碰黑灰产。\n\nWeb 渗透，也被称为 Web 渗透测试或 Web 渗透攻击，是一种评估网络应用安全性的方法。它涉及到模拟恶意攻击者的行为，以发现、利用和理解网络应用中的安全漏洞。\n\n这块和 Red Team 关系更近，有兴趣的可以自行了解。一次完整的渗透包括很多环节：选定目标后，首先要做信息搜集，使用一些工具或搜索引擎搜集目标相关资产，包括子域名什么的，然后进行外围打点，看看能不能找到一些突破口，拿下外围设备后就可以尝试上传木马控制主机权限，做权限维持，如果可以的话再进行提权，然后扫描内网网段，看能不能进行横向或者纵向移动，尝试拿下更多内网主机……\n\n如果你对渗透相关的安全内容感兴趣，可以通过以下两个靶场进行学习：\n\n- 国内：[春秋云镜 - 仿真场景](https://yunjing.ichunqiu.com/)\n- 国外：[Hack The Box](https://app.hackthebox.com/)\n\n更推荐后者，Hack The Box 提供了更加系统的 Red/Blue Team 的学习教程（全英文），以及对应的靶机实操练习。相信你可以从中找到乐趣。\n\n### 工具\n\nWeb 安全领域的工具实在是有“一点点”多，CTF、漏洞挖掘、渗透各自有各自的工具，相同功能的工具还有很多变种、不同团队的实现，该文档没法一一列举。此处就只列出最常用的安全工具，二选一即可：\n\n- [BurpSuite - 成熟的⽹络安全⼯具](https://portswigger.net/burp)\n- [Yakit - 集成化单兵安全能⼒平台](https://yaklang.io/products/intro/) \n\n如果你对这两个⼯具尚不了解，可以在⽹上搜索⼀些相关使⽤教程，起步阶段对这些⼯具的要求不⾼，简单的抓包改包即可。BurpSuite 的学习可以结合前面提到的 PortSwigger 靶场。\n\n## 0x03 Web开发\n\n欢迎来到有趣的 Web 开发领域，前面已经介绍过 Web 领域中前后端的划分，从开发的角度来说，一般推荐挑选其中一个方向进行学习。一方面是因为前后端开发技术经过了很多年的发展，各自都有着深厚的技术积累，即使你不准备去了解那些已经过时的旧技术，近几年的新技术也足够你学习很长一段时间了；另一方面是因为人的精力终究是有限的，想在短时间内同时推进前后端的学习并想要有所建树，是一件相对困难的事情。当然跟随自己的兴趣来就好，刚开始都接触一下也不是什么坏事，说不准你就是下一个全栈大师。\n\n但说实话，这东西也没什么固定的路数，协会 Web 成员在学习开发时的路线和技术栈也各不相同，没法提供一个同统一的路线。下文中的前后端开发入门都仅为编写文档的人的个人看法，请自行斟酌。\n\nWeb 前后端开发的学习过程差异较大，技术栈也少有重合，这里就分开介绍。\n\n> 🥳 HDU 有一个名为 [HDUHelp 杭电助手](https://www.hduhelp.cn/) 的社团。你会发现，杭电的很多网络服务都是由杭电助手开发并维护的，该社团也会在新学期开始时展开招新活动，老东西会为技术部新人提供相对统一的学习路线指导，欢迎加入杭电助手技术部~\n\n> 🔔 杭电助手后端部技术栈为 Golang；HDU 未央学社后端部技术栈为 Java。\n\n> 🥰 Vidar-Team 与 HDUHelp 关系颇深，协会 Web 方向成员与 HDUHelp 技术部成员重合度很高。\n\n### 前端开发\n\n前端开发对新手比较友好，因为你能直观地看到代码在浏览器中被渲染为页面，正反馈比较强，也不会说你学几天后做出来的东西没法给别人展示。\n\n这里简单介绍下 Web 前端开发入门需要学哪些东西，之后的内容可以自行探索。\n\n#### 原生三件套\n\n前端开发的基础就是 `HTML` + `CSS` + `JavaScript`，后面应用框架的学习也要基于这三者。把网站的前端比作人体的话，HTML 就是骨骼，负责支撑起网站的整体架构；CSS 是皮肤，负责给予网站优雅的外观；JavaScript 则是肌肉，让网站具备动态交互的能力。推荐教程是 [MDN Web](https://developer.mozilla.org/zh-CN/)，该站点是极其优质的 Web 前端开发知识库，认可度很高，很多流行前端框架的官方教程也把它作为 Web 前端领域中的 Wiki 来引用。\n\n当然，MDN 对初学者的问题是，其内容过于正式，单个小节的内容过多以至于消磨掉初学者耐心。如果你想在短时间内快速过一遍 Web 前端的简要内容，可以看这个：[菜鸟教程](https://www.runoob.com/)，精简很多，但内容不全且稍有过时。\n\n在学习的过程中，你会发现前端的东西比较杂乱，原生 HTML 中就有几百个标签，不同类的标签往往又会有十几个不同的属性，不同属性还有不同的可选值，CSS 中的各种选择器、伪类伪元素以及几百个属性也足以让你头大。不过这些你不用去记，真正到应用开发过程中，你就会发现能用到的其实不多，第一次看的时候稍微留意一下，脑子里有个概念、知道大概有这么个东西就行，敲代码的时候忘了就去翻文档，毕竟开发时又不是断网环境，只要你能把应用功能实现，怎么搞都行。\n\n`JavaScript` 相对前两者重要一些，因为网页的主要功能都要使用 `JavaScript`（下文简称 JS）实现，之后接触的前端应用框架也主要是 JS 框架，包括后面如果你想以一个前端开发者的身份快速上手后端开发，基于 JS 语法的一系列 Node.js 后端框架也是你的首选。因此，你有必要多投入一些精力到 JS 的学习上。\n\n这里推荐一份 JavaScript 的练习教程，跟着敲敲也蛮有帮助的，可以作为参考：[JavaScript 30](https://javascript30.com/)。\n\n#### JavaScript框架\n\n到了应用框架这层，你会发现——可选项更多了。开发者们整天轮子叠轮子的造，同一种功能的实现能给你整出来几十个大大小小的框架，开发者们也整天在社交媒体上因为技术选型而唇枪舌战。吵到今天，应用框架也大致分为了两派，分别是 Vue 和 React。\n\n你可以在这两者中挑一个上手，这里不做推荐，自己去官网看看，考虑自己喜欢哪种风格之后再上手，反正之后两个都得会（乐）。学的时候跟着官方教程走就好，下面是二者的官方文档：\n\n- [React](https://react.dev/) - [React 官方中文文档](https://zh-hans.react.dev/)\n- [Vue.js - 渐进式的 JavaScript 框架](https://vuejs.org/)\n- [Angular](https://angular.cn/)\n\n此外，当你上手前端应用框架时，就可以抛弃 JavaScript 而转向使用 TypeScript 了。\n\nTypeScript（简称 TS）是微软公司开发的一种基于 JS 的编程语言，其目的是增强 JS 的功能，使其更适合多人合作的项目。TypeScript 可以看成是 JS 的超集（superset），即它继承了后者的全部语法。所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。\n\nTS 对 JS 添加的最主要部分，就是一个独立的类型系统。JS 本身是有一套自己的类型系统，但其非常弱，运算符可以接受各种类型的值。这使得 JS 语法变得非常灵活，但客观上也增加了多人协同项目中出错的概率。在语法上，JS 属于动态类型语言。TS 引入了一个更强大、更严格的类型系统，属于静态类型语言。静态类型有利于代码的静态分析，更早地发现错误，提供了更好的 IDE 支持，做到语法提示和自动补全，提供了代码文档，有助于代码重构。\n\n平心而论，很多项目其实没必要使用 TypeScript，严格的类型限制和语法要求会降低开发效率。但你架不住多人合作的时候别的前端开发都要用，以及有时候参加项目竞标或者比赛，其他组都用 TS，你一个人用 JS 把项目搞定了，很多不懂技术的评委也只会认为你不会，而不是你不屑于去用。关于到底使用 JS 还是 TS 也是一个长期争论的问题，自行决定。\n\n> 🧐这块的描述确实不太准确，其他 JS 框架比如 Angular 的使用者也不在少数，上文中提到的 React 严格来说只能算视图层面的库，其背后的 Next.js 才是官方主推的应用框架。不过这些对初学者来说不重要，先大致有个了解，学到后面接触到这些的时候再去调整自己的技术栈。\n\n### 后端开发 - Golang\n\n与前端相比，后端就主要是在于机器交流，你要操纵用户看不到的数据。后端没法做到像前端那样敲个代码立马就能看到反馈，不过胜在学习路线清晰，整体开发流程更加统一。\n\n后端开发技术选型和语言关系比较大，此处以 Golang 为例进行介绍。\n\n#### 上手\n\nGolang，也称为 Go 语言，是由 Google 开发的一种静态强类型、编译型语言。Go 语言的语法与 C 在许多方面相似，但它包含了垃圾回收的功能，且支持并发编程，同时更加简洁。这些优势使得 Go 在网络开发以及云原生方面有一些独特的优势。如果你学过 C 的话，Go 其实挺好上手的。\n\n有以下两个推荐教程，不推荐看菜鸟教程，太浅了：\n\n- 在线学习 Golang 的网站，手把手教你一步步敲代码：[Go 语言之旅](https://tour.go-zh.org/welcome/1)\n- 看书的话就选这本，[Golang 圣经](https://golang-china.github.io/gopl-zh/)\n\n在踏入下一步之前，你还有必要先了解 SQL。SQL，全称为 **结构化查询语言**（Structured Query Language），是一种用于管理关系数据库的标准编程语言。它包括一系列用于创建、修改、删除和查询数据库的命令。Web 后端应用基本都会有存储数据的需求，你不能把数十万条需要持久存储的数据一直保存在本地内存中，而是需要用类似 MySQL 这样的数据库帮存储你的数据。\n\n- [W3school SQL教程](https://www.w3school.com.cn/sql/index.asp)\n\n#### 框架\n\n当你熟悉 Golang 语法之后，就可以上手 Web 应用框架了。推荐给初学者的 Golang 后端三件套是 `Gin` + `Gorm` + `MySQL`，去看各自的官方教程即可。\n\nGin 是一个 Web 应用框架，这个都懂。开发者固然可以使用 Golang 自带的 `net/http` 处理客户端请求、处理并返回数据，但每次都这么做未免有些累赘；而且有时我们需要为某些 API 添加统一的鉴权，或者为所有处理请求事件添加日志记录，如果我们使用原生库去一个接口一个接口地去完成这些工作，那可就太费事费力了。\n\n所以，经过积累，开发者们就将某些常用的功能，比如动态路由实现、分组控制、中间件、模板渲染与错误恢复等，将它们抽象出来并进行封装，打包成一个开箱即用的 Web 应用框架。当其他开发者想要实现某些功能时，直接导包引用该框架即可，这大幅提升了 Web 应用的开发效率，也在规范化和标准化等方面做出贡献。\n\n- [Gin](https://gin-gonic.com/)\n\nGorm 是一个基于 Golang 开发的全功能 ORM 框架。那什么是 ORM 呢？你在学习 Golang 语法时或许已经知道该如何拼接 SQL 语句并进行数据库操作了，但这么搞的问题是效率低下，而且有些粗心的开发者疏于对用户传入数据的处理，可能会导致一些安全问题，比如 SQL 注入漏洞。\n\n为了解决上述问题，ORM 应运而生。ORM 全称 **对象关系映射**（Object-Relational Mapping），是一种程序设计技术，用于实现面向对象编程语言里的对象和关系数据库之间的映射。有了 ORM，开发者可以直接使用面向对象的方式来操作数据库，无需编写 SQL 代码，大大提高了开发效率，框架自带的预处理等防范措施也提高了 Web 应用的安全性。当然，代价就是牺牲了一定的灵活性。\n\n- [GORM 指南](https://gorm.io/zh_CN/docs/index.html)\n\n此外，在你能够使用这三件套，以及其他库熟练地完成 CRUD 开发工作之后，我推荐你去读读这些框架的源码，从底层理解这些框架是如何实现数据处理以及其他功能的实现的，比如路由匹配的方式等等，然后尝试上手写写，自己实现。这个过程也是比较有趣的，你可以使用自己学习过的 Golang 语法与原生库结合，一步步地搭建出一个具备完备功能的 Framewok。如果你之前没有什么阅读源码的经验，也不知道何从下手，可以跟着下面这篇教程走，或许可以对你有所启发：\n\n- [7天用Go从零实现Web框架Gee教程](https://geektutu.com/post/gee.html)\n\n### 后端开发 - Java\n\n#### 上手\n\nJava 这门编程语言你可能已经耳熟能详，毕竟这几年 Java 卖课的比较多（挠头）。它的跨平台性、面向对象的特性以及丰富的类库使其在编程语言中独树一帜。如果你对 C++ 或者 C# 有所了解，那么就会发现 Java 的语法与它们有许多相似之处。但是，Java 在设计上追求简洁和易读，因此去除了一些容易引发错误的概念，如指针和运算符重载等。如果你之前没学习过面向对象的语言，初次上手可能略有费劲。\n\n推荐下学习资源，可以试试：\n\n- [Java教程 - 廖雪峰](https://www.liaoxuefeng.com/wiki/1252599548343744)\n- 黑马程序员Java零基础视频教程：[上部](https://www.bilibili.com/video/BV17F411T7Ao/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180) & [下部](https://www.bilibili.com/video/BV1yW4y1Y7Ms/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180)\n\n#### 框架\n\n学完语法之后，就可以学习对应的后端服务框架了。对于 Java 后端开发，比较推荐的技术栈是 `Spring Boot` + `Hibernate` + `MySQL`。 \n\nSpring Boot 是一个基于 Spring 框架的开源 Java 框架，它可以帮助你快速地创建出一个独立的、生产级别的 Spring 应用程序。学习资源推荐：\n\n- [Spring Boot 中文文档](https://springdoc.cn/spring-boot/)\n- [黑马程序员 SpringBoot2](https://www.bilibili.com/video/BV15b4y1a7yG/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180)\n\nHibernate 对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架，它可以帮助你更方便地操作数据库，而无需编写复杂的 SQL 代码。\n\n- [Hibernate 中文文档](https://hibernate.github.net.cn/)\n\n#### 安全\n\n再调过头来提一下 Java 安全。网上资料茫茫多，自己挑比较费时间，可以直接看下面推荐的这个教程，phith0n 出品，必属精品：\n\n- [攻击Java Web应用-[Java Web安全]](https://javasec.org/)\n\n 与此同时，phith0n 还建立了一个[“代码审计”知识星球](https://govuln.com/)，是一个专业、前沿、原创的 Web 代码安全与审计讨论社区，专注于分享原创的代码安全知识、漏洞挖掘方法，感兴趣的可以加一下。截至本文文档更新时，星球价格为 299￥ 终身制，不过确实值这个钱。\n\n## 0x04 Network\n\n因为本文档讨论的主要是狭义上的 Web，Network 其实一般不会在此处提及。但因为 Network 在 Web 渗透领域的使用，以及 Vidar-Team 最近两届的网管都是 Web 手，所以本文档也单独划出 Network 的小节。\n\n写这篇文档的人 Network 技术相对一般，这里就少啰嗦一些废话。如果你对计算机网络感兴趣但没有基础，可以自行学习 [HDU-CS-WIKI 计算机网络](https://hdu-cs.wiki/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C) 章节的内容，可以快速的给你通一遍网络相关概念，方便你进一步的学习。\n\n如果你对自己的网络水平有自信，并且有意向加入 Vidar-Team 成为下一届网管，就在招新群里吆喝一声，很快就可以吸引到 Vidar 历届网管的注意，线下交流讨论。\n\n此外，HDU 有一个由学生自发创建的去中心化网络，名为[“DN11”](https://dn11.top/)，欢迎有一定网络基础的学生加入。\n\n![helloweb-dn11](https://img.ma5hr00m.top/blog/helloweb-dn11.png)\n\n## 0x05 泛用技能\n\n有些东西并不怎么成体系，但也是新生有必要知道的，同时又不怎么好分类，索性一块丢到这个小节下面。\n\n### 信息搜集\n\n本文档是面向新手的教程，覆盖面有限，你可能想要更多相关资料。如果掌握了恰当的信息搜集⽅式，你就可以获得更多更优质的资源，实现更快的进步。\n\n#### 搜索引擎\n\n好的搜索引擎可以帮你检索出优质的学习资源，节约你在海量的⽂章中沙⾥淘⾦的时间。⾸推的搜索引擎是 [Google](https://www.google.com/)，它可以帮助你搜集全球范围内符合你关键词的⽹⻚，并过滤掉⼀些⽆⽤的⼴告和只会 cv 的⽂章，快速定位到你需要的资源。\n\n退⽽求其次，你也可以选择 Microsoft Bing，如果你从未接触过计算机技术，对你来说 [Bing](https://www.bing.com/) 可能更⽅便访问。\n\n如果你执着于使⽤[百度](https://www.baidu.com/)，你可以利⽤⼀些搜索引擎默认的语法来规避掉不想看到的⽹⻚。⽐如 `SQLI⼊⻔教程 -csdn`，这样你的搜索结果中就不会出现 CSDN 相关⽂章。\n\n#### 平台\n\n如果你对计算机感兴趣，你就不可避免的要接触 [GitHub](https://github.com/)。GitHub 是⼀个⾯向开发⼈员的开源代码托管平台，它允许⽤⼾创建和管理他们的代码仓库，与其他开发⼈员协作。在 GitHub 上你能找到很多优秀的开源项⽬，以及⼀些有趣的学习资料，你甚⾄可以在这⾥体会到寻宝的快感，尽情地去了解世界上其他的程序员都在做些什么、在研究什么东西。这其中就有很多 Web ⽅向的学习资料，包括开发、安全等各个领域。\n\n如果你有计算机⽅⾯的问题，你可以选择去 [Stack Overflow](https://stackoverflow.com/)。Stack Overflow 是⼀个⾯向程序员的问答⽹站，它是 Stack Exchange ⽹络的旗舰站点。它由 Jeff Atwood 和 Joel Spolsky 于 2008 年创建，提供了关于计算机主题的问题和答案。Stack Overflow 是全球最⼤、最值得信赖的在线社区之⼀，开发⼈员可以在这⾥学习、分享他们的编程知识。在问答型 AI 流行起来之前，这就是全世界程序员最常用的寻求问题解决方案的地方。\n\n#### AI\n\n你可以使⽤最近流⾏的 AI 帮助你学习。⽬前常⻅的问答 AI 有 [Chatgpt](https://chat.openai.com/)、New Bing 等，你可以借助它们来快速⼊⻔⼀个概念或者找到你问题的答案。\n\n此外，有一些基于 AI 的搜索引擎也可以尝试，比如 [devv_](https://devv.ai/)。\n\n> 😵请记住，不要把 AI 给你的回答当成真理，不要过度依赖 AI，它只是你的⼀个辅助⼯具。就像本文档开头所说的那样，你要保留 **独⽴思考** 的能⼒，什么事都问 AI 的结果就是你平滑的被 AI 取代。\n\n### Git版本管理工具\n\nGit 是一种**分布式版本控制系统**。它可以自动跟踪文件的变化、还原文件的历史记录、协调多人在同一个项目中工作，并且可以在必要情况下回溯到过去的任意版本。\n\n在软件开发中，版本控制系统可以帮助开发人员有效地管理和维护代码库，支持项目的分支、合并等操作。这样，这允许不同的成员可以同时对同一个项目进行开发，而不会产生代码冲突等问题。此外，版本控制系统还可以提供更好的安全备份和恢复机制，以防止意外的数据丢失或代码损坏。\n\n前文说过了 GitHub，经过简单的配置，你就可以使用 Git 将本地项目托管到 GitHub 平台，避免数据丢失的麻烦。\n\n从这个网站学习 Git 的使用，手把手式教学：[Learn Git Branching](https://learngitbranching.js.org/)\n\n### Linux操作系统\n\nLinux 是一个操作系统。它由 *Linus* 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。 现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。它自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。 以前有很多设置你可能需要在 Windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。\n\n此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。 这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。\n\n同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。 这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。\n\n现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。你可以使用 [VMware](https://www.vmware.com/) 或者 [VirtualBox](https://www.virtualbox.org/) 等软件创建 Linux 虚拟机，也可以干脆直接上 Linux 物理机。对于 Web 方向的学习来说，Linux 系统的熟练使用属于必备技能。\n\n## 0x06 可选事项\n\n### 个人博客\n\n推荐在个人博客记录⾃⼰的学习过程。在搭建博客的过程中你能学到很多有趣的知识。\n\n比较推荐的用来搭建个人博客的框架有 [Hexo](https://hexo.io/zh-tw/)、[Vitepress](https://vitepress.dev/)、[Hugo](https://gohugo.io/)、[WordPress](https://wordpress.com/zh-tw/) 等，可以都看看，选择一个自己喜欢的用（搭建个人博客很多时候考虑的还是美观性）。如果你对自己的前端技术有自信，也可以自己写一个。\n\n以下是几个高质量的杭电学长个人博客，可以看看他们的文章：\n\n| Name      | Blog Link              |\n| --------- | ---------------------- |\n| E99p1ant  | https://github.red/    |\n| LoRexxar  | https://lorexxar.cn/   |\n| lightness | https://lightless.me/  |\n| Cyris     | https://cyris.moe/     |\n| Chuj      | https://www.cjovi.icu/ |\n| daidr     | https://im.daidr.me/   |\n| Nick Xu   | https://nickxu.me/     |\n\n此外，我们编辑个人博客时一般使用的是 [Markdown](https://markdown.tw/) 格式，推荐学习一下。有很多 Markdown 编辑器可供选择，比如 [Typora](https://typora.io/)、[Obsidian](https://obsidian.md/)，直接使用 Visual Studio Code 配合插件也是可以的。\n\n在编辑博客时，你可能需要插入一些图片。你可以选择将图片与 Markdown 存储在同一个仓库中，不过更推荐使用 OSS+PicGo 的组合搭一个图床，然后在 .md 文件中通过外链引用图片，具体操作可以参考这个教程：[阿里云OSS PicGo 配置图床教程 超详细](https://zhuanlan.zhihu.com/p/104152479)。\n\n> 💸 警告，如果使用云存储服务搭建图床，建议使用 CDN 为外链引用添加限制，否则可能会有坏人刷你博客里的 OSS 外链图片，造成高额的经济损失。确保在有能力保护自己安全的情况下再用。\n\n### 兔兔的小游戏\n\n加⼊ Vidar-Team 招新群，你经常能看到可爱的兔兔机器⼈在帮助维持群内秩序，或者回答⼀些简单的问题。\n\n![helloweb-tutu](https://img.ma5hr00m.top/blog/helloweb-tutu.png)\n\n兔兔迎新机器⼈还具有⼀个 `%blog` 命令，⽤于查询协会成员的博客链接。功能存在⼀个 SQLI 漏洞，通过这个漏洞可以查询出数据库中的 Flag。拿到 Flag 后可以私聊 Web 方向学长领取一杯奶茶哦~\n\n### 其他学习路线\n\n这是面向新生的文档，自然会有很多介绍不够细致的地方，不过我感觉已经够新生学一阵子的了。如果你还想要参考其他学习路线，可以点击下面这几个网址，这是在 GitHub上很火爆的 Roadmap，也可以提供路线的建议：\n\n- [Frontend Developer Roadmap](https://roadmap.sh/frontend)\n- [Backend Developer Roadmap](https://roadmap.sh/backend)\n- [Roadmap do Desenvolvedor Web 2021](https://github.com/hideraldus13/roadmap-do-desenvolvedor-web)\n\n## 0x07 后话\n\n内容略多，希望你是耐⼼看到这⾥的。\n\nVidar 在本质上就是⼀群热爱信息安全的⼩伙伴自发成⽴的技术型团体，CTF 竞赛是我们⽇常活动的组成部分，并不是 Vidar 存在的唯⼀意义，你可以在这⾥尽情的研究你喜欢的技术，不仅是本⽂介绍的 Web，其他⼏个⽅向，以及较少提及的 IOT、区块链等都有学⻓在研究，你可以在这⾥轻松找到志同道合的朋友，⼀起学习。\n\n另外，协会希望⼤家不要急于求成，要先打好基础。扎实的基础知识会是你未来发展道路上的铺路⽯。同时，也不能只着眼于理论知识，也要在实战中学习，边学边练才是健康的状态。\n\n最后，再次欢迎对 Web 安全感兴趣的你！如果在学习过程中遇到困难，随时可以在招新群中提问，祝你在 Web 安全的学习道路上越⾛越远〜\n\n> 🏔️ 勿以浮沙筑⾼台，望学弟学妹们打牢基础，努力学习哇！","slug":"hello_web","published":1,"updated":"2024-06-09T12:54:58.204Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap1000ef4ly37wq4vdb","content":"<h1 id=\"HelloWeb\"><a href=\"#HelloWeb\" class=\"headerlink\" title=\"HelloWeb\"></a>HelloWeb</h1><blockquote>\n<p>🚀本文档面向初次踏入 The Web World 的新生，希望为你们提供一个可供参考的学习路线。</p>\n</blockquote>\n<blockquote>\n<p>✨该文档最早公开于 <a href=\"https://github.com/ma5hr00m/HelloWeb\">ma5hr00m&#x2F;HelloWeb</a>，计划用于 Vidar-Team2024 届招新。</p>\n</blockquote>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-banner.png\" alt=\"helloweb-banner\"></p>\n<h2 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h2><p>Web 安全与 Web 开发往往是绑定在一起的，所以本文档会同时介绍 <strong>安全&amp;开发</strong>，还会有一些零零散散的其他想要告诉新生的东西，所以内容会略多，希望多点耐心看完。</p>\n<p>在开始之前，你们需要准备一些东西，要求不高，相信大家都有：</p>\n<ul>\n<li>🧠能<strong>独立思考</strong>的大脑</li>\n<li>💻可以使用的电脑</li>\n<li>🔮流畅的网络</li>\n<li>❤️<strong>积极好学</strong>的心</li>\n</ul>\n<p>此外，所有想要涉足计算机领域的新生，都有必要去阅读一篇文章，其名为<strong>《提问的智慧》</strong>。篇幅不长，20min 即可，你可以从中学习到如何提出 <strong>一个有价值的问题</strong>，而不是掏出手机拍一张电脑屏幕，丢进群里就问“我该怎么办”，这是在浪费大家的时间。同时，你也可以把《提问的智慧》当作⼀个 AI prompt 指南。因为不论是对⼈还是对机器，提出一个有效的问题都能事半功倍地解决问题。</p>\n<p>你可以点击下面的链接以阅读这篇文章。此外，Vidar-Team2024 招新群中也提供了 PDF 版本，需要请自取。</p>\n<ul>\n<li><a href=\"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md\">简体中文版《提问的智慧》</a></li>\n</ul>\n<blockquote>\n<p>🔍如果在此之前，你完全没有了解过计算机，但觉得能够成为一个整天抱着电脑“哐哐哐”敲键盘、张口闭口都是别人听不懂的怪话的程序猿是一件很酷的事情，那你依然可以阅读本文档，但其中很多名词你可能从未了解，你可以暂时跳到 <em><strong>0x05 泛用技能- 信息搜集</strong></em> 小节。</p>\n</blockquote>\n<blockquote>\n<p>📷学会截屏。</p>\n</blockquote>\n<h2 id=\"0x01-Web\"><a href=\"#0x01-Web\" class=\"headerlink\" title=\"0x01 Web\"></a>0x01 Web</h2><p><a href=\"https://en.wikipedia.org/wiki/World_Wide_Web\">Web</a> 是 World Wide Web 的简称，是一个通过互联网访问的、由许多互相链接的的超文本组成的信息系统。这是指的广义上的 Web，即涵盖了整个世界范围内的互联网服务和资源的集合。这包括所有 <strong>通过互联网连接</strong> 的设备、服务、网络协议以及通过这些设备和服务访问的内容，它超越了单纯的网页和浏览器，涵盖了从大型服务器到个人设备的所有互联网技术。</p>\n<p>我们日常所说的往往是狭义上的 Web，更加专注于构成网站和网络应用技术实践，包括传统的前后端开发、运维以及 Web 安全等领域。这与大家的生活就很贴近了，今日的学习、办公、娱乐都已经脱离不开网络应用技术，输入一串 URL 后浏览器如何得到一个功能完备的 Web 页面、在自己手机的“学习通”里上传一份 docx 附件后如何将其传递给教师，这都属于 Web 的范畴。现在的你可能并不明晰这些功能的实现原理，但经过一段时间的学习，相信你就可以对这些功能的实现有一个明确的认知，或者已经能够自己开发一个具备类似功能的 Web 应用。</p>\n<p>除非有特殊说明，本文档后面的 Web 都是指狭义上的 Web 应用。</p>\n<h3 id=\"发展史\"><a href=\"#发展史\" class=\"headerlink\" title=\"发展史\"></a>发展史</h3><p>最初的 Web 应⽤非常简陋，程序托管在 ISP（Internet Service Provider，互联网服务提供商）那里，用户在自己的主机上访问对应 IP 获得对应的静态页面，页面中只有⽂字与图⽚，当时的用户能做的也只是浏览⽹⻚，没法与网页背后的机器（或人）进行更多的交流。这只是一个单方向的信息输出，人们并不满足于这一点。</p>\n<p>为了丰富 Web 应用的功能，满足人们增长的需求，之后就有了 Flash 等媒体技术，大名鼎鼎的 JavaScript 编程语言也被研发出来。⾳视频和动态交互的实现给予了用户更高的自由度，越来越多的公司也开始通过互联网宣传自家产品，让潜在用户在家就能看到他们的产品信息。</p>\n<p>随后，CGI（Common GatewayInterface）技术出现，Web 服务器可以通过 CGI 执⾏外部程序，外部程序可以根据请求内容⽣成动态内容返回给用户。现代 Web 应用的雏形已经出现。</p>\n<p>再之后，随着 PHP&#x2F;JSP 等编程语⾔的开发，MVC 思想、REST（Representation State Transformation）架构⻛格的提出，Web 应⽤的功能进一步增强，一片勃勃生机万物竞发之势。但随之而来的是安全问题频出，Web 安全也开始得到开发者的重视。</p>\n<p>在之后就是越来越多的 Web 技术出现、应用逻辑越来越复杂，部分 Web 开发者难以忍受同时编写数据处理逻辑和网站页面，前后端分化。分化之后开发者们有了更多的精力钻研自己感兴趣的领域，技术不断发展，直到今天。</p>\n<p>这里简单说说 <strong>前后端的划分</strong>。前端就是⽤⼾可以直接看⻅的部分，⽐如说我们访问 <a href=\"https://www.baidu.com/\">baidu.com</a>，浏览器显示的搜索框、按钮等组件，以及我们输入 URL 之后字符串如何传递给后端应用，这些都属于 Web 前端的范畴；与之相对的，后端就主要是⽤⼾看不⻅的部分，⽐如在百度中搜索 <a href=\"https://www.baidu.com/s?wd=Vidar-Team\">Vidar-Team</a>，服务器在数据库中根据关键词查找相关内容，处理后整合成格式恰当的数据，再交给前端让浏览器去渲染出一个包含相关信息的页面，这就是 Web 后端负责的⼯作。</p>\n<h3 id=\"Web-应用中的数据传递\"><a href=\"#Web-应用中的数据传递\" class=\"headerlink\" title=\"Web 应用中的数据传递\"></a>Web 应用中的数据传递</h3><blockquote>\n<p>这部分内容对 0 基础新生来说可能较为困难，可暂时跳过。</p>\n</blockquote>\n<p>打开浏览器，地址栏中敲入 <a href=\"https://vidar.club/\">https://vidar.club</a> 并回车，浏览器片刻就会返回给我们 Vidar-Team 的官网首页，这是如何实现的呢？下面我们会以此为例讲讲 Web 应用中的数据传递。</p>\n<p>当浏览器接收到用户输入的 URL 时，首先会做的就是 <a href=\"https://www.ruanyifeng.com/blog/2022/08/dns-query.html\">DNS 查询</a>，浏览器会去查找这个 URL 背后对应的资源在什么地方，也就是这个域名对应的 IP 是什么。 </p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-dns.png\" alt=\"helloweb-dns\"></p>\n<p>目前常见的 IP 地址格式一般为 <a href=\"\">xxx.xxx.xxx.xxx</a>，但人类要记住这样的 12 位纯数字比较困难。因此，开发者们决定⽤形象的域名（domain）来让⽤⼾记住资源的位置。你看，<a href=\"https://vidar.club/\">vidar.club</a> 就⽐ <a href=\"1.117.117.147\">1.117.117.147</a> 这个 IP 好记太多了吧？浏览器根据域名向 DNS 服务器查询对应 IP 地址。DNS 服务器就像一本电话簿，里面详细记录了各种各样的域名与其对应的 IP 地址。在这个例子中，浏览器得到对应的 IP 地址就是 <a href=\"1.117.117.147\">1.117.117.147</a>。 </p>\n<p>浏览器得知服务器的 IP 地址后，就会与其对应的服务器进⾏ TCP 三次握⼿。三次握⼿机制的目的时让通信的两端建立可靠的连接，毕竟谁也不想看到一个内容残缺的网页。为了让连接更加安全，本地主机与服务器在三次握手之后就会进⾏ TLS 协商。你看我们输⼊的是 <code>https://</code>，这表明我们使⽤了 HTTPS 协议访问主机资源。相⽐于明文传输数据的 HTTP，HTTPS 使⽤了 SSL&#x2F;TLS 协议对数据进⾏了加密处理，这会让访问变得更加安全。当三次握⼿和 TLS 协商完成后，我们就已经和服务器建⽴了安全连接啦。</p>\n<blockquote>\n<p>顺带一提，如果使用 <code>http://</code> 访问协会官网也会强制转化为 <code>https://</code> 哦，可以试试 <a href=\"http://vidar.club/\">http://vidar.club</a>。</p>\n</blockquote>\n<p>建⽴安全连接后，浏览器会向服务器发送 HTTP <code>GET</code> 请求，请求服务器返回我们事先放在服务器上的对应⽹⻚的内容，这个请求的内容通常是⼀个 HTML ⽂件。当服务器收到请求后，就会使⽤相关的响应头和 HTML 内容进⾏回复。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-burpsuite.png\" alt=\"helloweb-burpsuite\"></p>\n<p>浏览器收到来自服务器的 <code>200 OK</code> 的 HTTP 响应，并收到服务端发过来的 HTML ⽂件后，会处理 HTML 标记并且构建 DOM 树，继⽽处理⻚⾯中引⽤的 CSS ⽂件，构建 CSSOM，将 DOM 树和 CSSOM 合并为渲染树，计算渲染树中每个元素的位置和⼤⼩，并确定它们在⻚⾯上的布局，最后在屏幕上进⾏绘制，最终就形成你看到的⻚⾯啦。</p>\n<p>HTTP 请求和响应的具体内容可以使⽤浏览器（推荐使⽤ Chrome、Firefox 或 Edge）的 F12 开发者⼯具进⾏查看，或者使用上图中的 BurpSuite 或者 Yakit 等抓包工具。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-edge.png\" alt=\"helloweb-edge\"></p>\n<p>如果对 Web 应用中的数据传递还有疑问，可先后观看以下两个视频，可以让你快速了解互联⽹和浏览器的运作流程：</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1Rz4y197Jd/?spm_id_from=333.788.recommend_more_video.-1&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">10 分钟带你了解互联⽹是如何运作的</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">浏览器是如何运作的</a></li>\n</ul>\n<h2 id=\"0x02-Web安全\"><a href=\"#0x02-Web安全\" class=\"headerlink\" title=\"0x02 Web安全\"></a>0x02 Web安全</h2><h3 id=\"我是零基础小白，从哪里开始好呢？\"><a href=\"#我是零基础小白，从哪里开始好呢？\" class=\"headerlink\" title=\"我是零基础小白，从哪里开始好呢？\"></a>我是零基础小白，从哪里开始好呢？</h3><p>在 Web 安全领域中，我们较少提及 <code>C/C++</code>，更多的是 <code>Java</code>、<code>PHP</code>、<code>Golang</code> 等语言相关的安全问题。不过，如果你⽬前没有任何编程基础，我们依然推荐你先好好学习 C 语⾔。对于没有编程基础的新生，从 C 语⾔这样⼀⻔接近底层的⾼级语⾔开始学习，可以更好地学习计算机内部原理。并且，在学习 C 语⾔后，你就有了⼀定的编程基础，⼊⻔其他语⾔也绝⾮难事。</p>\n<p>C 语言的推荐教程是《C Primer Plus》，你可以跟着本书中的内容学习 C 语言。在学习的过程中，鼓励你跟着教程多上手跟着敲代码。计算机的学习与实践结合紧密，不是传统背书就行的。电子书地址提供在此，自行取用：</p>\n<ul>\n<li><a href=\"https://github.com/erhuoyan/bookrack/blob/master/C%20Primer%20Plus%20%E7%AC%AC6%E7%89%88%20%E4%B8%AD%E6%96%87%E7%89%88.pdf\">《C Primer Plus 第6版 中文版》PDF 文件</a></li>\n<li><a href=\"https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th?tab=readme-ov-file\">《C++ Primer Plus 第6版 中文版》原书代码和习题解答</a></li>\n</ul>\n<p>在上手敲代码之前，记得在你的系统中配置好 C 开发环境。</p>\n<h3 id=\"技术栈的选择\"><a href=\"#技术栈的选择\" class=\"headerlink\" title=\"技术栈的选择\"></a>技术栈的选择</h3><p>需要明确的是，安全和开发密不可分，在 Web 领域尤其如此。</p>\n<p>开发是安全的基础，如果没有⼀定的开发能⼒，在之后的 Web 安全学习中，⾯对⼀些代码审计也会感到⾮常茫然。所以，在学习 Web 安全之前，有必要先掌握一定的 Web 开发技术。</p>\n<blockquote>\n<p>🛠️如果你想要先行学习 Web 开发，可以跳到 <em><strong>0x03 Web开发</strong></em> 小节。</p>\n</blockquote>\n<p>我们一般推荐，在入门 Web 安全的同时，要同步学习并掌握一门较为熟悉的 Web 后端开发语言，你可以在 Java&#x2F;Golang&#x2F;PHP&#x2F;Node.js 中任选其一，当然其他的语言比如 Rust 也可以，遵循自己的喜好选择即可。</p>\n<p>往前推个几年，研究 Web 安全最流行也必须掌握的语言是 PHP，那时的 CTF Web 赛题也是 PHP 赛题占主导。但在这两年风向有所变化，很多安全行业大牛（比如 <a href=\"https://www.leavesongs.com/\">phith0n</a>）认为，现在入门 Web 安全及漏洞挖掘最推荐学习的语言是 Java，毕竟现在多数 Web 应用都是之前的 Java 开发者留下的，包括现在的 CTF Web 中 Java 题目的占比也是越来越大。所以，如果你对前面提到的后端开发语言都不熟悉，不知道该选择哪个，也没什么很明确的规划，那就可以把 Java 作为首选项。</p>\n<p>此外，在 Web 安全领域中，确实有前端安全的存在，比如 XSS 等，但前端安全很多时候是作为一个“锦上添花”的存在，不是很推荐作为主要研究方向。当然，一切看你兴趣。</p>\n<ul>\n<li><a href=\"https://websec.readthedocs.io/zh/latest/\">Web 安全学习笔记</a></li>\n</ul>\n<h3 id=\"CTF竞赛\"><a href=\"#CTF竞赛\" class=\"headerlink\" title=\"CTF竞赛\"></a>CTF竞赛</h3><p>⼀直以来，Web 安全都是 CTF 竞赛重要的组成部分。</p>\n<p>CTF 竞赛⽬前主体还是 <a href=\"https://ctf-wiki.org/introduction/mode/\">Jeopardy 解题模式</a>，分为 Web&#x2F;Re&#x2F;Pwn&#x2F;Crypto&#x2F;Misc 五个⽅向。相⽐⼆进制，Web 安全在初期⼊⻔时⻔槛较低，并不需要对底层知识有太多的了解，对⼩⽩较为友好，能够快速上⼿做题。</p>\n<p>但不得不承认，Web 安全涉及内容更 <strong>杂</strong>。入门 Reverse 逆向工程，你只需要能读懂 C 即可，但入门 Web 需要你能在较短时间内快速接触并了解 Java&#x2F;PHP&#x2F;Golang 等编程语言。这需要你能坚持学习并投入一定量的时间。</p>\n<p>倒也不用焦虑，刚上手有不懂的很正常。CTF 比较讲究一个实践先于理论，你很难办到先把理论一口气全部学完，然后再开始上手实践，这不怎么现实，因为东西又多又杂，你也摸不准一道题目会想考你什么。遇到不会的积极去查去学就可以，什么不会补什么，多做题多做笔记，遇到不会的题目就及时复现写 Writeup，刚开始的时候多坐牢（指做不出来题目盯着屏幕做无用功），后面就能少做牢。</p>\n<p>在每个学年的上学期，Vidar-Team 会开放 HGAME-MINI 新生训练平台，里面的题目难度都比较适合初学者，可以多参与多做题，尝试把 Web 方向 AK 掉（All kill，指完成全部题目）。如果你想多做一些题目多学技术，可以使用下面的几个平台，这些平台都会提供往年的 CTF 赛题：</p>\n<ul>\n<li><a href=\"https://buuoj.cn/\">buuoj</a></li>\n<li><a href=\"https://adworld.xctf.org.cn/\">攻防世界</a></li>\n</ul>\n<p>此外，有一个较为特殊的 Web 靶场，即由 BurpSuite 官方提供的 PortSwigger 靶场。该靶场收录了几乎所有 Web 常见漏洞，提供了原理讲解和由易到难、种类齐全的 100+ 练习题，并提供了官方题解和社区视频题解，在此过程中你还能熟悉 BurpSuite 的使用，非常推荐。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-portswigger.png\" alt=\"helloweb-portswigger\"></p>\n<p>该靶场侧重让学习者了解并明白如何利用漏洞，并不是传统的 CTF 模式，所以没有找到 Flag 这一说，而是根据触发特定条件判断题目是否完成。靶场全英文。链接如下：</p>\n<ul>\n<li><a href=\"https://portswigger.net/web-security\">PortSwigger WebSecurity Academy</a></li>\n</ul>\n<h3 id=\"漏洞复现\"><a href=\"#漏洞复现\" class=\"headerlink\" title=\"漏洞复现\"></a>漏洞复现</h3><p>打 CTF 竞赛是社团活动的主要内容，但并不是全部，归根究底打比赛的目的也是学技术。在打比赛之外的时间，复现最新的漏洞或者一些老但知名的漏洞也是很好的学习方式。</p>\n<p>CVE（Common Vulnerabilities and Exposures，通用漏洞和暴露）是公开披露的网络安全漏洞列表。它是由 MITRE 公司维护和更新的安全漏洞列表，并由美国国土安全部（DHS）和网络安全与基础设施安全局（CISA）赞助。在CVE中，每个漏洞都会有一个唯一的CVE编号，即CVE ID，例如“CVE-2019-1234567”。这个编号是识别漏洞的唯一标识符，供安全研究员和受攻击的软件供应商使用，以便确定和回应安全漏洞。CVE编号由CVE编号机构（CVE Numbering Authority，CNA）分配，CVE编号机构主要由IT供应商、安全厂商和安全研究组织承担。</p>\n<p>我们一般所谓的复现漏洞，多数时候是指复现这些 CVE 漏洞，为了更好的理解这些漏洞的原理，我们会需要在本地搭建环境并进行模拟攻击。有时候自己搭环境会比较麻烦，网上找到的博客教程偶尔不靠谱。</p>\n<p>推荐一个 phith0n 的漏洞复现 GitHub 仓库，里面收录了很多有价值的漏洞，并且提供了构建环境所需的 Dockerfile 和 docker-compose.yml 文件，以及复现方式，非常方便：</p>\n<ul>\n<li><a href=\"https://vulhub.org/#/environments/\">Vulhub 官网</a> | <a href=\"https://github.com/vulhub/vulhub\">Vulhub 仓库</a></li>\n</ul>\n<h3 id=\"渗透\"><a href=\"#渗透\" class=\"headerlink\" title=\"渗透\"></a>渗透</h3><blockquote>\n<p>📞遵纪守法，<strong>任何渗透活动都应遵循相关的法律和道德准则</strong>。勿碰黑灰产。</p>\n</blockquote>\n<p>Web 渗透，也被称为 Web 渗透测试或 Web 渗透攻击，是一种评估网络应用安全性的方法。它涉及到模拟恶意攻击者的行为，以发现、利用和理解网络应用中的安全漏洞。</p>\n<p>这块和 Red Team 关系更近，有兴趣的可以自行了解。一次完整的渗透包括很多环节：选定目标后，首先要做信息搜集，使用一些工具或搜索引擎搜集目标相关资产，包括子域名什么的，然后进行外围打点，看看能不能找到一些突破口，拿下外围设备后就可以尝试上传木马控制主机权限，做权限维持，如果可以的话再进行提权，然后扫描内网网段，看能不能进行横向或者纵向移动，尝试拿下更多内网主机……</p>\n<p>如果你对渗透相关的安全内容感兴趣，可以通过以下两个靶场进行学习：</p>\n<ul>\n<li>国内：<a href=\"https://yunjing.ichunqiu.com/\">春秋云镜 - 仿真场景</a></li>\n<li>国外：<a href=\"https://app.hackthebox.com/\">Hack The Box</a></li>\n</ul>\n<p>更推荐后者，Hack The Box 提供了更加系统的 Red&#x2F;Blue Team 的学习教程（全英文），以及对应的靶机实操练习。相信你可以从中找到乐趣。</p>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><p>Web 安全领域的工具实在是有“一点点”多，CTF、漏洞挖掘、渗透各自有各自的工具，相同功能的工具还有很多变种、不同团队的实现，该文档没法一一列举。此处就只列出最常用的安全工具，二选一即可：</p>\n<ul>\n<li><a href=\"https://portswigger.net/burp\">BurpSuite - 成熟的⽹络安全⼯具</a></li>\n<li><a href=\"https://yaklang.io/products/intro/\">Yakit - 集成化单兵安全能⼒平台</a></li>\n</ul>\n<p>如果你对这两个⼯具尚不了解，可以在⽹上搜索⼀些相关使⽤教程，起步阶段对这些⼯具的要求不⾼，简单的抓包改包即可。BurpSuite 的学习可以结合前面提到的 PortSwigger 靶场。</p>\n<h2 id=\"0x03-Web开发\"><a href=\"#0x03-Web开发\" class=\"headerlink\" title=\"0x03 Web开发\"></a>0x03 Web开发</h2><p>欢迎来到有趣的 Web 开发领域，前面已经介绍过 Web 领域中前后端的划分，从开发的角度来说，一般推荐挑选其中一个方向进行学习。一方面是因为前后端开发技术经过了很多年的发展，各自都有着深厚的技术积累，即使你不准备去了解那些已经过时的旧技术，近几年的新技术也足够你学习很长一段时间了；另一方面是因为人的精力终究是有限的，想在短时间内同时推进前后端的学习并想要有所建树，是一件相对困难的事情。当然跟随自己的兴趣来就好，刚开始都接触一下也不是什么坏事，说不准你就是下一个全栈大师。</p>\n<p>但说实话，这东西也没什么固定的路数，协会 Web 成员在学习开发时的路线和技术栈也各不相同，没法提供一个同统一的路线。下文中的前后端开发入门都仅为编写文档的人的个人看法，请自行斟酌。</p>\n<p>Web 前后端开发的学习过程差异较大，技术栈也少有重合，这里就分开介绍。</p>\n<blockquote>\n<p>🥳 HDU 有一个名为 <a href=\"https://www.hduhelp.cn/\">HDUHelp 杭电助手</a> 的社团。你会发现，杭电的很多网络服务都是由杭电助手开发并维护的，该社团也会在新学期开始时展开招新活动，老东西会为技术部新人提供相对统一的学习路线指导，欢迎加入杭电助手技术部~</p>\n</blockquote>\n<blockquote>\n<p>🔔 杭电助手后端部技术栈为 Golang；HDU 未央学社后端部技术栈为 Java。</p>\n</blockquote>\n<blockquote>\n<p>🥰 Vidar-Team 与 HDUHelp 关系颇深，协会 Web 方向成员与 HDUHelp 技术部成员重合度很高。</p>\n</blockquote>\n<h3 id=\"前端开发\"><a href=\"#前端开发\" class=\"headerlink\" title=\"前端开发\"></a>前端开发</h3><p>前端开发对新手比较友好，因为你能直观地看到代码在浏览器中被渲染为页面，正反馈比较强，也不会说你学几天后做出来的东西没法给别人展示。</p>\n<p>这里简单介绍下 Web 前端开发入门需要学哪些东西，之后的内容可以自行探索。</p>\n<h4 id=\"原生三件套\"><a href=\"#原生三件套\" class=\"headerlink\" title=\"原生三件套\"></a>原生三件套</h4><p>前端开发的基础就是 <code>HTML</code> + <code>CSS</code> + <code>JavaScript</code>，后面应用框架的学习也要基于这三者。把网站的前端比作人体的话，HTML 就是骨骼，负责支撑起网站的整体架构；CSS 是皮肤，负责给予网站优雅的外观；JavaScript 则是肌肉，让网站具备动态交互的能力。推荐教程是 <a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web</a>，该站点是极其优质的 Web 前端开发知识库，认可度很高，很多流行前端框架的官方教程也把它作为 Web 前端领域中的 Wiki 来引用。</p>\n<p>当然，MDN 对初学者的问题是，其内容过于正式，单个小节的内容过多以至于消磨掉初学者耐心。如果你想在短时间内快速过一遍 Web 前端的简要内容，可以看这个：<a href=\"https://www.runoob.com/\">菜鸟教程</a>，精简很多，但内容不全且稍有过时。</p>\n<p>在学习的过程中，你会发现前端的东西比较杂乱，原生 HTML 中就有几百个标签，不同类的标签往往又会有十几个不同的属性，不同属性还有不同的可选值，CSS 中的各种选择器、伪类伪元素以及几百个属性也足以让你头大。不过这些你不用去记，真正到应用开发过程中，你就会发现能用到的其实不多，第一次看的时候稍微留意一下，脑子里有个概念、知道大概有这么个东西就行，敲代码的时候忘了就去翻文档，毕竟开发时又不是断网环境，只要你能把应用功能实现，怎么搞都行。</p>\n<p><code>JavaScript</code> 相对前两者重要一些，因为网页的主要功能都要使用 <code>JavaScript</code>（下文简称 JS）实现，之后接触的前端应用框架也主要是 JS 框架，包括后面如果你想以一个前端开发者的身份快速上手后端开发，基于 JS 语法的一系列 Node.js 后端框架也是你的首选。因此，你有必要多投入一些精力到 JS 的学习上。</p>\n<p>这里推荐一份 JavaScript 的练习教程，跟着敲敲也蛮有帮助的，可以作为参考：<a href=\"https://javascript30.com/\">JavaScript 30</a>。</p>\n<h4 id=\"JavaScript框架\"><a href=\"#JavaScript框架\" class=\"headerlink\" title=\"JavaScript框架\"></a>JavaScript框架</h4><p>到了应用框架这层，你会发现——可选项更多了。开发者们整天轮子叠轮子的造，同一种功能的实现能给你整出来几十个大大小小的框架，开发者们也整天在社交媒体上因为技术选型而唇枪舌战。吵到今天，应用框架也大致分为了两派，分别是 Vue 和 React。</p>\n<p>你可以在这两者中挑一个上手，这里不做推荐，自己去官网看看，考虑自己喜欢哪种风格之后再上手，反正之后两个都得会（乐）。学的时候跟着官方教程走就好，下面是二者的官方文档：</p>\n<ul>\n<li><a href=\"https://react.dev/\">React</a> - <a href=\"https://zh-hans.react.dev/\">React 官方中文文档</a></li>\n<li><a href=\"https://vuejs.org/\">Vue.js - 渐进式的 JavaScript 框架</a></li>\n<li><a href=\"https://angular.cn/\">Angular</a></li>\n</ul>\n<p>此外，当你上手前端应用框架时，就可以抛弃 JavaScript 而转向使用 TypeScript 了。</p>\n<p>TypeScript（简称 TS）是微软公司开发的一种基于 JS 的编程语言，其目的是增强 JS 的功能，使其更适合多人合作的项目。TypeScript 可以看成是 JS 的超集（superset），即它继承了后者的全部语法。所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。</p>\n<p>TS 对 JS 添加的最主要部分，就是一个独立的类型系统。JS 本身是有一套自己的类型系统，但其非常弱，运算符可以接受各种类型的值。这使得 JS 语法变得非常灵活，但客观上也增加了多人协同项目中出错的概率。在语法上，JS 属于动态类型语言。TS 引入了一个更强大、更严格的类型系统，属于静态类型语言。静态类型有利于代码的静态分析，更早地发现错误，提供了更好的 IDE 支持，做到语法提示和自动补全，提供了代码文档，有助于代码重构。</p>\n<p>平心而论，很多项目其实没必要使用 TypeScript，严格的类型限制和语法要求会降低开发效率。但你架不住多人合作的时候别的前端开发都要用，以及有时候参加项目竞标或者比赛，其他组都用 TS，你一个人用 JS 把项目搞定了，很多不懂技术的评委也只会认为你不会，而不是你不屑于去用。关于到底使用 JS 还是 TS 也是一个长期争论的问题，自行决定。</p>\n<blockquote>\n<p>🧐这块的描述确实不太准确，其他 JS 框架比如 Angular 的使用者也不在少数，上文中提到的 React 严格来说只能算视图层面的库，其背后的 Next.js 才是官方主推的应用框架。不过这些对初学者来说不重要，先大致有个了解，学到后面接触到这些的时候再去调整自己的技术栈。</p>\n</blockquote>\n<h3 id=\"后端开发-Golang\"><a href=\"#后端开发-Golang\" class=\"headerlink\" title=\"后端开发 - Golang\"></a>后端开发 - Golang</h3><p>与前端相比，后端就主要是在于机器交流，你要操纵用户看不到的数据。后端没法做到像前端那样敲个代码立马就能看到反馈，不过胜在学习路线清晰，整体开发流程更加统一。</p>\n<p>后端开发技术选型和语言关系比较大，此处以 Golang 为例进行介绍。</p>\n<h4 id=\"上手\"><a href=\"#上手\" class=\"headerlink\" title=\"上手\"></a>上手</h4><p>Golang，也称为 Go 语言，是由 Google 开发的一种静态强类型、编译型语言。Go 语言的语法与 C 在许多方面相似，但它包含了垃圾回收的功能，且支持并发编程，同时更加简洁。这些优势使得 Go 在网络开发以及云原生方面有一些独特的优势。如果你学过 C 的话，Go 其实挺好上手的。</p>\n<p>有以下两个推荐教程，不推荐看菜鸟教程，太浅了：</p>\n<ul>\n<li>在线学习 Golang 的网站，手把手教你一步步敲代码：<a href=\"https://tour.go-zh.org/welcome/1\">Go 语言之旅</a></li>\n<li>看书的话就选这本，<a href=\"https://golang-china.github.io/gopl-zh/\">Golang 圣经</a></li>\n</ul>\n<p>在踏入下一步之前，你还有必要先了解 SQL。SQL，全称为 <strong>结构化查询语言</strong>（Structured Query Language），是一种用于管理关系数据库的标准编程语言。它包括一系列用于创建、修改、删除和查询数据库的命令。Web 后端应用基本都会有存储数据的需求，你不能把数十万条需要持久存储的数据一直保存在本地内存中，而是需要用类似 MySQL 这样的数据库帮存储你的数据。</p>\n<ul>\n<li><a href=\"https://www.w3school.com.cn/sql/index.asp\">W3school SQL教程</a></li>\n</ul>\n<h4 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h4><p>当你熟悉 Golang 语法之后，就可以上手 Web 应用框架了。推荐给初学者的 Golang 后端三件套是 <code>Gin</code> + <code>Gorm</code> + <code>MySQL</code>，去看各自的官方教程即可。</p>\n<p>Gin 是一个 Web 应用框架，这个都懂。开发者固然可以使用 Golang 自带的 <code>net/http</code> 处理客户端请求、处理并返回数据，但每次都这么做未免有些累赘；而且有时我们需要为某些 API 添加统一的鉴权，或者为所有处理请求事件添加日志记录，如果我们使用原生库去一个接口一个接口地去完成这些工作，那可就太费事费力了。</p>\n<p>所以，经过积累，开发者们就将某些常用的功能，比如动态路由实现、分组控制、中间件、模板渲染与错误恢复等，将它们抽象出来并进行封装，打包成一个开箱即用的 Web 应用框架。当其他开发者想要实现某些功能时，直接导包引用该框架即可，这大幅提升了 Web 应用的开发效率，也在规范化和标准化等方面做出贡献。</p>\n<ul>\n<li><a href=\"https://gin-gonic.com/\">Gin</a></li>\n</ul>\n<p>Gorm 是一个基于 Golang 开发的全功能 ORM 框架。那什么是 ORM 呢？你在学习 Golang 语法时或许已经知道该如何拼接 SQL 语句并进行数据库操作了，但这么搞的问题是效率低下，而且有些粗心的开发者疏于对用户传入数据的处理，可能会导致一些安全问题，比如 SQL 注入漏洞。</p>\n<p>为了解决上述问题，ORM 应运而生。ORM 全称 <strong>对象关系映射</strong>（Object-Relational Mapping），是一种程序设计技术，用于实现面向对象编程语言里的对象和关系数据库之间的映射。有了 ORM，开发者可以直接使用面向对象的方式来操作数据库，无需编写 SQL 代码，大大提高了开发效率，框架自带的预处理等防范措施也提高了 Web 应用的安全性。当然，代价就是牺牲了一定的灵活性。</p>\n<ul>\n<li><a href=\"https://gorm.io/zh_CN/docs/index.html\">GORM 指南</a></li>\n</ul>\n<p>此外，在你能够使用这三件套，以及其他库熟练地完成 CRUD 开发工作之后，我推荐你去读读这些框架的源码，从底层理解这些框架是如何实现数据处理以及其他功能的实现的，比如路由匹配的方式等等，然后尝试上手写写，自己实现。这个过程也是比较有趣的，你可以使用自己学习过的 Golang 语法与原生库结合，一步步地搭建出一个具备完备功能的 Framewok。如果你之前没有什么阅读源码的经验，也不知道何从下手，可以跟着下面这篇教程走，或许可以对你有所启发：</p>\n<ul>\n<li><a href=\"https://geektutu.com/post/gee.html\">7天用Go从零实现Web框架Gee教程</a></li>\n</ul>\n<h3 id=\"后端开发-Java\"><a href=\"#后端开发-Java\" class=\"headerlink\" title=\"后端开发 - Java\"></a>后端开发 - Java</h3><h4 id=\"上手-1\"><a href=\"#上手-1\" class=\"headerlink\" title=\"上手\"></a>上手</h4><p>Java 这门编程语言你可能已经耳熟能详，毕竟这几年 Java 卖课的比较多（挠头）。它的跨平台性、面向对象的特性以及丰富的类库使其在编程语言中独树一帜。如果你对 C++ 或者 C# 有所了解，那么就会发现 Java 的语法与它们有许多相似之处。但是，Java 在设计上追求简洁和易读，因此去除了一些容易引发错误的概念，如指针和运算符重载等。如果你之前没学习过面向对象的语言，初次上手可能略有费劲。</p>\n<p>推荐下学习资源，可以试试：</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">Java教程 - 廖雪峰</a></li>\n<li>黑马程序员Java零基础视频教程：<a href=\"https://www.bilibili.com/video/BV17F411T7Ao/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">上部</a> &amp; <a href=\"https://www.bilibili.com/video/BV1yW4y1Y7Ms/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">下部</a></li>\n</ul>\n<h4 id=\"框架-1\"><a href=\"#框架-1\" class=\"headerlink\" title=\"框架\"></a>框架</h4><p>学完语法之后，就可以学习对应的后端服务框架了。对于 Java 后端开发，比较推荐的技术栈是 <code>Spring Boot</code> + <code>Hibernate</code> + <code>MySQL</code>。 </p>\n<p>Spring Boot 是一个基于 Spring 框架的开源 Java 框架，它可以帮助你快速地创建出一个独立的、生产级别的 Spring 应用程序。学习资源推荐：</p>\n<ul>\n<li><a href=\"https://springdoc.cn/spring-boot/\">Spring Boot 中文文档</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV15b4y1a7yG/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">黑马程序员 SpringBoot2</a></li>\n</ul>\n<p>Hibernate 对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架，它可以帮助你更方便地操作数据库，而无需编写复杂的 SQL 代码。</p>\n<ul>\n<li><a href=\"https://hibernate.github.net.cn/\">Hibernate 中文文档</a></li>\n</ul>\n<h4 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h4><p>再调过头来提一下 Java 安全。网上资料茫茫多，自己挑比较费时间，可以直接看下面推荐的这个教程，phith0n 出品，必属精品：</p>\n<ul>\n<li><a href=\"https://javasec.org/\">攻击Java Web应用-[Java Web安全]</a></li>\n</ul>\n<p> 与此同时，phith0n 还建立了一个<a href=\"https://govuln.com/\">“代码审计”知识星球</a>，是一个专业、前沿、原创的 Web 代码安全与审计讨论社区，专注于分享原创的代码安全知识、漏洞挖掘方法，感兴趣的可以加一下。截至本文文档更新时，星球价格为 299￥ 终身制，不过确实值这个钱。</p>\n<h2 id=\"0x04-Network\"><a href=\"#0x04-Network\" class=\"headerlink\" title=\"0x04 Network\"></a>0x04 Network</h2><p>因为本文档讨论的主要是狭义上的 Web，Network 其实一般不会在此处提及。但因为 Network 在 Web 渗透领域的使用，以及 Vidar-Team 最近两届的网管都是 Web 手，所以本文档也单独划出 Network 的小节。</p>\n<p>写这篇文档的人 Network 技术相对一般，这里就少啰嗦一些废话。如果你对计算机网络感兴趣但没有基础，可以自行学习 <a href=\"https://hdu-cs.wiki/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\">HDU-CS-WIKI 计算机网络</a> 章节的内容，可以快速的给你通一遍网络相关概念，方便你进一步的学习。</p>\n<p>如果你对自己的网络水平有自信，并且有意向加入 Vidar-Team 成为下一届网管，就在招新群里吆喝一声，很快就可以吸引到 Vidar 历届网管的注意，线下交流讨论。</p>\n<p>此外，HDU 有一个由学生自发创建的去中心化网络，名为<a href=\"https://dn11.top/\">“DN11”</a>，欢迎有一定网络基础的学生加入。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-dn11.png\" alt=\"helloweb-dn11\"></p>\n<h2 id=\"0x05-泛用技能\"><a href=\"#0x05-泛用技能\" class=\"headerlink\" title=\"0x05 泛用技能\"></a>0x05 泛用技能</h2><p>有些东西并不怎么成体系，但也是新生有必要知道的，同时又不怎么好分类，索性一块丢到这个小节下面。</p>\n<h3 id=\"信息搜集\"><a href=\"#信息搜集\" class=\"headerlink\" title=\"信息搜集\"></a>信息搜集</h3><p>本文档是面向新手的教程，覆盖面有限，你可能想要更多相关资料。如果掌握了恰当的信息搜集⽅式，你就可以获得更多更优质的资源，实现更快的进步。</p>\n<h4 id=\"搜索引擎\"><a href=\"#搜索引擎\" class=\"headerlink\" title=\"搜索引擎\"></a>搜索引擎</h4><p>好的搜索引擎可以帮你检索出优质的学习资源，节约你在海量的⽂章中沙⾥淘⾦的时间。⾸推的搜索引擎是 <a href=\"https://www.google.com/\">Google</a>，它可以帮助你搜集全球范围内符合你关键词的⽹⻚，并过滤掉⼀些⽆⽤的⼴告和只会 cv 的⽂章，快速定位到你需要的资源。</p>\n<p>退⽽求其次，你也可以选择 Microsoft Bing，如果你从未接触过计算机技术，对你来说 <a href=\"https://www.bing.com/\">Bing</a> 可能更⽅便访问。</p>\n<p>如果你执着于使⽤<a href=\"https://www.baidu.com/\">百度</a>，你可以利⽤⼀些搜索引擎默认的语法来规避掉不想看到的⽹⻚。⽐如 <code>SQLI⼊⻔教程 -csdn</code>，这样你的搜索结果中就不会出现 CSDN 相关⽂章。</p>\n<h4 id=\"平台\"><a href=\"#平台\" class=\"headerlink\" title=\"平台\"></a>平台</h4><p>如果你对计算机感兴趣，你就不可避免的要接触 <a href=\"https://github.com/\">GitHub</a>。GitHub 是⼀个⾯向开发⼈员的开源代码托管平台，它允许⽤⼾创建和管理他们的代码仓库，与其他开发⼈员协作。在 GitHub 上你能找到很多优秀的开源项⽬，以及⼀些有趣的学习资料，你甚⾄可以在这⾥体会到寻宝的快感，尽情地去了解世界上其他的程序员都在做些什么、在研究什么东西。这其中就有很多 Web ⽅向的学习资料，包括开发、安全等各个领域。</p>\n<p>如果你有计算机⽅⾯的问题，你可以选择去 <a href=\"https://stackoverflow.com/\">Stack Overflow</a>。Stack Overflow 是⼀个⾯向程序员的问答⽹站，它是 Stack Exchange ⽹络的旗舰站点。它由 Jeff Atwood 和 Joel Spolsky 于 2008 年创建，提供了关于计算机主题的问题和答案。Stack Overflow 是全球最⼤、最值得信赖的在线社区之⼀，开发⼈员可以在这⾥学习、分享他们的编程知识。在问答型 AI 流行起来之前，这就是全世界程序员最常用的寻求问题解决方案的地方。</p>\n<h4 id=\"AI\"><a href=\"#AI\" class=\"headerlink\" title=\"AI\"></a>AI</h4><p>你可以使⽤最近流⾏的 AI 帮助你学习。⽬前常⻅的问答 AI 有 <a href=\"https://chat.openai.com/\">Chatgpt</a>、New Bing 等，你可以借助它们来快速⼊⻔⼀个概念或者找到你问题的答案。</p>\n<p>此外，有一些基于 AI 的搜索引擎也可以尝试，比如 <a href=\"https://devv.ai/\">devv_</a>。</p>\n<blockquote>\n<p>😵请记住，不要把 AI 给你的回答当成真理，不要过度依赖 AI，它只是你的⼀个辅助⼯具。就像本文档开头所说的那样，你要保留 <strong>独⽴思考</strong> 的能⼒，什么事都问 AI 的结果就是你平滑的被 AI 取代。</p>\n</blockquote>\n<h3 id=\"Git版本管理工具\"><a href=\"#Git版本管理工具\" class=\"headerlink\" title=\"Git版本管理工具\"></a>Git版本管理工具</h3><p>Git 是一种<strong>分布式版本控制系统</strong>。它可以自动跟踪文件的变化、还原文件的历史记录、协调多人在同一个项目中工作，并且可以在必要情况下回溯到过去的任意版本。</p>\n<p>在软件开发中，版本控制系统可以帮助开发人员有效地管理和维护代码库，支持项目的分支、合并等操作。这样，这允许不同的成员可以同时对同一个项目进行开发，而不会产生代码冲突等问题。此外，版本控制系统还可以提供更好的安全备份和恢复机制，以防止意外的数据丢失或代码损坏。</p>\n<p>前文说过了 GitHub，经过简单的配置，你就可以使用 Git 将本地项目托管到 GitHub 平台，避免数据丢失的麻烦。</p>\n<p>从这个网站学习 Git 的使用，手把手式教学：<a href=\"https://learngitbranching.js.org/\">Learn Git Branching</a></p>\n<h3 id=\"Linux操作系统\"><a href=\"#Linux操作系统\" class=\"headerlink\" title=\"Linux操作系统\"></a>Linux操作系统</h3><p>Linux 是一个操作系统。它由 <em>Linus</em> 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。 现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。它自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。 以前有很多设置你可能需要在 Windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。</p>\n<p>此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。 这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。</p>\n<p>同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。 这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。</p>\n<p>现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。你可以使用 <a href=\"https://www.vmware.com/\">VMware</a> 或者 <a href=\"https://www.virtualbox.org/\">VirtualBox</a> 等软件创建 Linux 虚拟机，也可以干脆直接上 Linux 物理机。对于 Web 方向的学习来说，Linux 系统的熟练使用属于必备技能。</p>\n<h2 id=\"0x06-可选事项\"><a href=\"#0x06-可选事项\" class=\"headerlink\" title=\"0x06 可选事项\"></a>0x06 可选事项</h2><h3 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h3><p>推荐在个人博客记录⾃⼰的学习过程。在搭建博客的过程中你能学到很多有趣的知识。</p>\n<p>比较推荐的用来搭建个人博客的框架有 <a href=\"https://hexo.io/zh-tw/\">Hexo</a>、<a href=\"https://vitepress.dev/\">Vitepress</a>、<a href=\"https://gohugo.io/\">Hugo</a>、<a href=\"https://wordpress.com/zh-tw/\">WordPress</a> 等，可以都看看，选择一个自己喜欢的用（搭建个人博客很多时候考虑的还是美观性）。如果你对自己的前端技术有自信，也可以自己写一个。</p>\n<p>以下是几个高质量的杭电学长个人博客，可以看看他们的文章：</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Blog Link</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>E99p1ant</td>\n<td><a href=\"https://github.red/\">https://github.red/</a></td>\n</tr>\n<tr>\n<td>LoRexxar</td>\n<td><a href=\"https://lorexxar.cn/\">https://lorexxar.cn/</a></td>\n</tr>\n<tr>\n<td>lightness</td>\n<td><a href=\"https://lightless.me/\">https://lightless.me/</a></td>\n</tr>\n<tr>\n<td>Cyris</td>\n<td><a href=\"https://cyris.moe/\">https://cyris.moe/</a></td>\n</tr>\n<tr>\n<td>Chuj</td>\n<td><a href=\"https://www.cjovi.icu/\">https://www.cjovi.icu/</a></td>\n</tr>\n<tr>\n<td>daidr</td>\n<td><a href=\"https://im.daidr.me/\">https://im.daidr.me/</a></td>\n</tr>\n<tr>\n<td>Nick Xu</td>\n<td><a href=\"https://nickxu.me/\">https://nickxu.me/</a></td>\n</tr>\n</tbody></table>\n<p>此外，我们编辑个人博客时一般使用的是 <a href=\"https://markdown.tw/\">Markdown</a> 格式，推荐学习一下。有很多 Markdown 编辑器可供选择，比如 <a href=\"https://typora.io/\">Typora</a>、<a href=\"https://obsidian.md/\">Obsidian</a>，直接使用 Visual Studio Code 配合插件也是可以的。</p>\n<p>在编辑博客时，你可能需要插入一些图片。你可以选择将图片与 Markdown 存储在同一个仓库中，不过更推荐使用 OSS+PicGo 的组合搭一个图床，然后在 .md 文件中通过外链引用图片，具体操作可以参考这个教程：<a href=\"https://zhuanlan.zhihu.com/p/104152479\">阿里云OSS PicGo 配置图床教程 超详细</a>。</p>\n<blockquote>\n<p>💸 警告，如果使用云存储服务搭建图床，建议使用 CDN 为外链引用添加限制，否则可能会有坏人刷你博客里的 OSS 外链图片，造成高额的经济损失。确保在有能力保护自己安全的情况下再用。</p>\n</blockquote>\n<h3 id=\"兔兔的小游戏\"><a href=\"#兔兔的小游戏\" class=\"headerlink\" title=\"兔兔的小游戏\"></a>兔兔的小游戏</h3><p>加⼊ Vidar-Team 招新群，你经常能看到可爱的兔兔机器⼈在帮助维持群内秩序，或者回答⼀些简单的问题。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-tutu.png\" alt=\"helloweb-tutu\"></p>\n<p>兔兔迎新机器⼈还具有⼀个 <code>%blog</code> 命令，⽤于查询协会成员的博客链接。功能存在⼀个 SQLI 漏洞，通过这个漏洞可以查询出数据库中的 Flag。拿到 Flag 后可以私聊 Web 方向学长领取一杯奶茶哦~</p>\n<h3 id=\"其他学习路线\"><a href=\"#其他学习路线\" class=\"headerlink\" title=\"其他学习路线\"></a>其他学习路线</h3><p>这是面向新生的文档，自然会有很多介绍不够细致的地方，不过我感觉已经够新生学一阵子的了。如果你还想要参考其他学习路线，可以点击下面这几个网址，这是在 GitHub上很火爆的 Roadmap，也可以提供路线的建议：</p>\n<ul>\n<li><a href=\"https://roadmap.sh/frontend\">Frontend Developer Roadmap</a></li>\n<li><a href=\"https://roadmap.sh/backend\">Backend Developer Roadmap</a></li>\n<li><a href=\"https://github.com/hideraldus13/roadmap-do-desenvolvedor-web\">Roadmap do Desenvolvedor Web 2021</a></li>\n</ul>\n<h2 id=\"0x07-后话\"><a href=\"#0x07-后话\" class=\"headerlink\" title=\"0x07 后话\"></a>0x07 后话</h2><p>内容略多，希望你是耐⼼看到这⾥的。</p>\n<p>Vidar 在本质上就是⼀群热爱信息安全的⼩伙伴自发成⽴的技术型团体，CTF 竞赛是我们⽇常活动的组成部分，并不是 Vidar 存在的唯⼀意义，你可以在这⾥尽情的研究你喜欢的技术，不仅是本⽂介绍的 Web，其他⼏个⽅向，以及较少提及的 IOT、区块链等都有学⻓在研究，你可以在这⾥轻松找到志同道合的朋友，⼀起学习。</p>\n<p>另外，协会希望⼤家不要急于求成，要先打好基础。扎实的基础知识会是你未来发展道路上的铺路⽯。同时，也不能只着眼于理论知识，也要在实战中学习，边学边练才是健康的状态。</p>\n<p>最后，再次欢迎对 Web 安全感兴趣的你！如果在学习过程中遇到困难，随时可以在招新群中提问，祝你在 Web 安全的学习道路上越⾛越远〜</p>\n<blockquote>\n<p>🏔️ 勿以浮沙筑⾼台，望学弟学妹们打牢基础，努力学习哇！</p>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"HelloWeb\"><a href=\"#HelloWeb\" class=\"headerlink\" title=\"HelloWeb\"></a>HelloWeb</h1><blockquote>\n<p>🚀本文档面向初次踏入 The Web World 的新生，希望为你们提供一个可供参考的学习路线。</p>\n</blockquote>\n<blockquote>\n<p>✨该文档最早公开于 <a href=\"https://github.com/ma5hr00m/HelloWeb\">ma5hr00m&#x2F;HelloWeb</a>，计划用于 Vidar-Team2024 届招新。</p>\n</blockquote>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-banner.png\" alt=\"helloweb-banner\"></p>\n<h2 id=\"0x00-前言\"><a href=\"#0x00-前言\" class=\"headerlink\" title=\"0x00 前言\"></a>0x00 前言</h2><p>Web 安全与 Web 开发往往是绑定在一起的，所以本文档会同时介绍 <strong>安全&amp;开发</strong>，还会有一些零零散散的其他想要告诉新生的东西，所以内容会略多，希望多点耐心看完。</p>\n<p>在开始之前，你们需要准备一些东西，要求不高，相信大家都有：</p>\n<ul>\n<li>🧠能<strong>独立思考</strong>的大脑</li>\n<li>💻可以使用的电脑</li>\n<li>🔮流畅的网络</li>\n<li>❤️<strong>积极好学</strong>的心</li>\n</ul>\n<p>此外，所有想要涉足计算机领域的新生，都有必要去阅读一篇文章，其名为<strong>《提问的智慧》</strong>。篇幅不长，20min 即可，你可以从中学习到如何提出 <strong>一个有价值的问题</strong>，而不是掏出手机拍一张电脑屏幕，丢进群里就问“我该怎么办”，这是在浪费大家的时间。同时，你也可以把《提问的智慧》当作⼀个 AI prompt 指南。因为不论是对⼈还是对机器，提出一个有效的问题都能事半功倍地解决问题。</p>\n<p>你可以点击下面的链接以阅读这篇文章。此外，Vidar-Team2024 招新群中也提供了 PDF 版本，需要请自取。</p>\n<ul>\n<li><a href=\"https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md\">简体中文版《提问的智慧》</a></li>\n</ul>\n<blockquote>\n<p>🔍如果在此之前，你完全没有了解过计算机，但觉得能够成为一个整天抱着电脑“哐哐哐”敲键盘、张口闭口都是别人听不懂的怪话的程序猿是一件很酷的事情，那你依然可以阅读本文档，但其中很多名词你可能从未了解，你可以暂时跳到 <em><strong>0x05 泛用技能- 信息搜集</strong></em> 小节。</p>\n</blockquote>\n<blockquote>\n<p>📷学会截屏。</p>\n</blockquote>\n<h2 id=\"0x01-Web\"><a href=\"#0x01-Web\" class=\"headerlink\" title=\"0x01 Web\"></a>0x01 Web</h2><p><a href=\"https://en.wikipedia.org/wiki/World_Wide_Web\">Web</a> 是 World Wide Web 的简称，是一个通过互联网访问的、由许多互相链接的的超文本组成的信息系统。这是指的广义上的 Web，即涵盖了整个世界范围内的互联网服务和资源的集合。这包括所有 <strong>通过互联网连接</strong> 的设备、服务、网络协议以及通过这些设备和服务访问的内容，它超越了单纯的网页和浏览器，涵盖了从大型服务器到个人设备的所有互联网技术。</p>\n<p>我们日常所说的往往是狭义上的 Web，更加专注于构成网站和网络应用技术实践，包括传统的前后端开发、运维以及 Web 安全等领域。这与大家的生活就很贴近了，今日的学习、办公、娱乐都已经脱离不开网络应用技术，输入一串 URL 后浏览器如何得到一个功能完备的 Web 页面、在自己手机的“学习通”里上传一份 docx 附件后如何将其传递给教师，这都属于 Web 的范畴。现在的你可能并不明晰这些功能的实现原理，但经过一段时间的学习，相信你就可以对这些功能的实现有一个明确的认知，或者已经能够自己开发一个具备类似功能的 Web 应用。</p>\n<p>除非有特殊说明，本文档后面的 Web 都是指狭义上的 Web 应用。</p>\n<h3 id=\"发展史\"><a href=\"#发展史\" class=\"headerlink\" title=\"发展史\"></a>发展史</h3><p>最初的 Web 应⽤非常简陋，程序托管在 ISP（Internet Service Provider，互联网服务提供商）那里，用户在自己的主机上访问对应 IP 获得对应的静态页面，页面中只有⽂字与图⽚，当时的用户能做的也只是浏览⽹⻚，没法与网页背后的机器（或人）进行更多的交流。这只是一个单方向的信息输出，人们并不满足于这一点。</p>\n<p>为了丰富 Web 应用的功能，满足人们增长的需求，之后就有了 Flash 等媒体技术，大名鼎鼎的 JavaScript 编程语言也被研发出来。⾳视频和动态交互的实现给予了用户更高的自由度，越来越多的公司也开始通过互联网宣传自家产品，让潜在用户在家就能看到他们的产品信息。</p>\n<p>随后，CGI（Common GatewayInterface）技术出现，Web 服务器可以通过 CGI 执⾏外部程序，外部程序可以根据请求内容⽣成动态内容返回给用户。现代 Web 应用的雏形已经出现。</p>\n<p>再之后，随着 PHP&#x2F;JSP 等编程语⾔的开发，MVC 思想、REST（Representation State Transformation）架构⻛格的提出，Web 应⽤的功能进一步增强，一片勃勃生机万物竞发之势。但随之而来的是安全问题频出，Web 安全也开始得到开发者的重视。</p>\n<p>在之后就是越来越多的 Web 技术出现、应用逻辑越来越复杂，部分 Web 开发者难以忍受同时编写数据处理逻辑和网站页面，前后端分化。分化之后开发者们有了更多的精力钻研自己感兴趣的领域，技术不断发展，直到今天。</p>\n<p>这里简单说说 <strong>前后端的划分</strong>。前端就是⽤⼾可以直接看⻅的部分，⽐如说我们访问 <a href=\"https://www.baidu.com/\">baidu.com</a>，浏览器显示的搜索框、按钮等组件，以及我们输入 URL 之后字符串如何传递给后端应用，这些都属于 Web 前端的范畴；与之相对的，后端就主要是⽤⼾看不⻅的部分，⽐如在百度中搜索 <a href=\"https://www.baidu.com/s?wd=Vidar-Team\">Vidar-Team</a>，服务器在数据库中根据关键词查找相关内容，处理后整合成格式恰当的数据，再交给前端让浏览器去渲染出一个包含相关信息的页面，这就是 Web 后端负责的⼯作。</p>\n<h3 id=\"Web-应用中的数据传递\"><a href=\"#Web-应用中的数据传递\" class=\"headerlink\" title=\"Web 应用中的数据传递\"></a>Web 应用中的数据传递</h3><blockquote>\n<p>这部分内容对 0 基础新生来说可能较为困难，可暂时跳过。</p>\n</blockquote>\n<p>打开浏览器，地址栏中敲入 <a href=\"https://vidar.club/\">https://vidar.club</a> 并回车，浏览器片刻就会返回给我们 Vidar-Team 的官网首页，这是如何实现的呢？下面我们会以此为例讲讲 Web 应用中的数据传递。</p>\n<p>当浏览器接收到用户输入的 URL 时，首先会做的就是 <a href=\"https://www.ruanyifeng.com/blog/2022/08/dns-query.html\">DNS 查询</a>，浏览器会去查找这个 URL 背后对应的资源在什么地方，也就是这个域名对应的 IP 是什么。 </p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-dns.png\" alt=\"helloweb-dns\"></p>\n<p>目前常见的 IP 地址格式一般为 <a href=\"\">xxx.xxx.xxx.xxx</a>，但人类要记住这样的 12 位纯数字比较困难。因此，开发者们决定⽤形象的域名（domain）来让⽤⼾记住资源的位置。你看，<a href=\"https://vidar.club/\">vidar.club</a> 就⽐ <a href=\"1.117.117.147\">1.117.117.147</a> 这个 IP 好记太多了吧？浏览器根据域名向 DNS 服务器查询对应 IP 地址。DNS 服务器就像一本电话簿，里面详细记录了各种各样的域名与其对应的 IP 地址。在这个例子中，浏览器得到对应的 IP 地址就是 <a href=\"1.117.117.147\">1.117.117.147</a>。 </p>\n<p>浏览器得知服务器的 IP 地址后，就会与其对应的服务器进⾏ TCP 三次握⼿。三次握⼿机制的目的时让通信的两端建立可靠的连接，毕竟谁也不想看到一个内容残缺的网页。为了让连接更加安全，本地主机与服务器在三次握手之后就会进⾏ TLS 协商。你看我们输⼊的是 <code>https://</code>，这表明我们使⽤了 HTTPS 协议访问主机资源。相⽐于明文传输数据的 HTTP，HTTPS 使⽤了 SSL&#x2F;TLS 协议对数据进⾏了加密处理，这会让访问变得更加安全。当三次握⼿和 TLS 协商完成后，我们就已经和服务器建⽴了安全连接啦。</p>\n<blockquote>\n<p>顺带一提，如果使用 <code>http://</code> 访问协会官网也会强制转化为 <code>https://</code> 哦，可以试试 <a href=\"http://vidar.club/\">http://vidar.club</a>。</p>\n</blockquote>\n<p>建⽴安全连接后，浏览器会向服务器发送 HTTP <code>GET</code> 请求，请求服务器返回我们事先放在服务器上的对应⽹⻚的内容，这个请求的内容通常是⼀个 HTML ⽂件。当服务器收到请求后，就会使⽤相关的响应头和 HTML 内容进⾏回复。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-burpsuite.png\" alt=\"helloweb-burpsuite\"></p>\n<p>浏览器收到来自服务器的 <code>200 OK</code> 的 HTTP 响应，并收到服务端发过来的 HTML ⽂件后，会处理 HTML 标记并且构建 DOM 树，继⽽处理⻚⾯中引⽤的 CSS ⽂件，构建 CSSOM，将 DOM 树和 CSSOM 合并为渲染树，计算渲染树中每个元素的位置和⼤⼩，并确定它们在⻚⾯上的布局，最后在屏幕上进⾏绘制，最终就形成你看到的⻚⾯啦。</p>\n<p>HTTP 请求和响应的具体内容可以使⽤浏览器（推荐使⽤ Chrome、Firefox 或 Edge）的 F12 开发者⼯具进⾏查看，或者使用上图中的 BurpSuite 或者 Yakit 等抓包工具。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-edge.png\" alt=\"helloweb-edge\"></p>\n<p>如果对 Web 应用中的数据传递还有疑问，可先后观看以下两个视频，可以让你快速了解互联⽹和浏览器的运作流程：</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1Rz4y197Jd/?spm_id_from=333.788.recommend_more_video.-1&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">10 分钟带你了解互联⽹是如何运作的</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">浏览器是如何运作的</a></li>\n</ul>\n<h2 id=\"0x02-Web安全\"><a href=\"#0x02-Web安全\" class=\"headerlink\" title=\"0x02 Web安全\"></a>0x02 Web安全</h2><h3 id=\"我是零基础小白，从哪里开始好呢？\"><a href=\"#我是零基础小白，从哪里开始好呢？\" class=\"headerlink\" title=\"我是零基础小白，从哪里开始好呢？\"></a>我是零基础小白，从哪里开始好呢？</h3><p>在 Web 安全领域中，我们较少提及 <code>C/C++</code>，更多的是 <code>Java</code>、<code>PHP</code>、<code>Golang</code> 等语言相关的安全问题。不过，如果你⽬前没有任何编程基础，我们依然推荐你先好好学习 C 语⾔。对于没有编程基础的新生，从 C 语⾔这样⼀⻔接近底层的⾼级语⾔开始学习，可以更好地学习计算机内部原理。并且，在学习 C 语⾔后，你就有了⼀定的编程基础，⼊⻔其他语⾔也绝⾮难事。</p>\n<p>C 语言的推荐教程是《C Primer Plus》，你可以跟着本书中的内容学习 C 语言。在学习的过程中，鼓励你跟着教程多上手跟着敲代码。计算机的学习与实践结合紧密，不是传统背书就行的。电子书地址提供在此，自行取用：</p>\n<ul>\n<li><a href=\"https://github.com/erhuoyan/bookrack/blob/master/C%20Primer%20Plus%20%E7%AC%AC6%E7%89%88%20%E4%B8%AD%E6%96%87%E7%89%88.pdf\">《C Primer Plus 第6版 中文版》PDF 文件</a></li>\n<li><a href=\"https://github.com/ShujiaHuang/Cpp-Primer-Plus-6th?tab=readme-ov-file\">《C++ Primer Plus 第6版 中文版》原书代码和习题解答</a></li>\n</ul>\n<p>在上手敲代码之前，记得在你的系统中配置好 C 开发环境。</p>\n<h3 id=\"技术栈的选择\"><a href=\"#技术栈的选择\" class=\"headerlink\" title=\"技术栈的选择\"></a>技术栈的选择</h3><p>需要明确的是，安全和开发密不可分，在 Web 领域尤其如此。</p>\n<p>开发是安全的基础，如果没有⼀定的开发能⼒，在之后的 Web 安全学习中，⾯对⼀些代码审计也会感到⾮常茫然。所以，在学习 Web 安全之前，有必要先掌握一定的 Web 开发技术。</p>\n<blockquote>\n<p>🛠️如果你想要先行学习 Web 开发，可以跳到 <em><strong>0x03 Web开发</strong></em> 小节。</p>\n</blockquote>\n<p>我们一般推荐，在入门 Web 安全的同时，要同步学习并掌握一门较为熟悉的 Web 后端开发语言，你可以在 Java&#x2F;Golang&#x2F;PHP&#x2F;Node.js 中任选其一，当然其他的语言比如 Rust 也可以，遵循自己的喜好选择即可。</p>\n<p>往前推个几年，研究 Web 安全最流行也必须掌握的语言是 PHP，那时的 CTF Web 赛题也是 PHP 赛题占主导。但在这两年风向有所变化，很多安全行业大牛（比如 <a href=\"https://www.leavesongs.com/\">phith0n</a>）认为，现在入门 Web 安全及漏洞挖掘最推荐学习的语言是 Java，毕竟现在多数 Web 应用都是之前的 Java 开发者留下的，包括现在的 CTF Web 中 Java 题目的占比也是越来越大。所以，如果你对前面提到的后端开发语言都不熟悉，不知道该选择哪个，也没什么很明确的规划，那就可以把 Java 作为首选项。</p>\n<p>此外，在 Web 安全领域中，确实有前端安全的存在，比如 XSS 等，但前端安全很多时候是作为一个“锦上添花”的存在，不是很推荐作为主要研究方向。当然，一切看你兴趣。</p>\n<ul>\n<li><a href=\"https://websec.readthedocs.io/zh/latest/\">Web 安全学习笔记</a></li>\n</ul>\n<h3 id=\"CTF竞赛\"><a href=\"#CTF竞赛\" class=\"headerlink\" title=\"CTF竞赛\"></a>CTF竞赛</h3><p>⼀直以来，Web 安全都是 CTF 竞赛重要的组成部分。</p>\n<p>CTF 竞赛⽬前主体还是 <a href=\"https://ctf-wiki.org/introduction/mode/\">Jeopardy 解题模式</a>，分为 Web&#x2F;Re&#x2F;Pwn&#x2F;Crypto&#x2F;Misc 五个⽅向。相⽐⼆进制，Web 安全在初期⼊⻔时⻔槛较低，并不需要对底层知识有太多的了解，对⼩⽩较为友好，能够快速上⼿做题。</p>\n<p>但不得不承认，Web 安全涉及内容更 <strong>杂</strong>。入门 Reverse 逆向工程，你只需要能读懂 C 即可，但入门 Web 需要你能在较短时间内快速接触并了解 Java&#x2F;PHP&#x2F;Golang 等编程语言。这需要你能坚持学习并投入一定量的时间。</p>\n<p>倒也不用焦虑，刚上手有不懂的很正常。CTF 比较讲究一个实践先于理论，你很难办到先把理论一口气全部学完，然后再开始上手实践，这不怎么现实，因为东西又多又杂，你也摸不准一道题目会想考你什么。遇到不会的积极去查去学就可以，什么不会补什么，多做题多做笔记，遇到不会的题目就及时复现写 Writeup，刚开始的时候多坐牢（指做不出来题目盯着屏幕做无用功），后面就能少做牢。</p>\n<p>在每个学年的上学期，Vidar-Team 会开放 HGAME-MINI 新生训练平台，里面的题目难度都比较适合初学者，可以多参与多做题，尝试把 Web 方向 AK 掉（All kill，指完成全部题目）。如果你想多做一些题目多学技术，可以使用下面的几个平台，这些平台都会提供往年的 CTF 赛题：</p>\n<ul>\n<li><a href=\"https://buuoj.cn/\">buuoj</a></li>\n<li><a href=\"https://adworld.xctf.org.cn/\">攻防世界</a></li>\n</ul>\n<p>此外，有一个较为特殊的 Web 靶场，即由 BurpSuite 官方提供的 PortSwigger 靶场。该靶场收录了几乎所有 Web 常见漏洞，提供了原理讲解和由易到难、种类齐全的 100+ 练习题，并提供了官方题解和社区视频题解，在此过程中你还能熟悉 BurpSuite 的使用，非常推荐。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-portswigger.png\" alt=\"helloweb-portswigger\"></p>\n<p>该靶场侧重让学习者了解并明白如何利用漏洞，并不是传统的 CTF 模式，所以没有找到 Flag 这一说，而是根据触发特定条件判断题目是否完成。靶场全英文。链接如下：</p>\n<ul>\n<li><a href=\"https://portswigger.net/web-security\">PortSwigger WebSecurity Academy</a></li>\n</ul>\n<h3 id=\"漏洞复现\"><a href=\"#漏洞复现\" class=\"headerlink\" title=\"漏洞复现\"></a>漏洞复现</h3><p>打 CTF 竞赛是社团活动的主要内容，但并不是全部，归根究底打比赛的目的也是学技术。在打比赛之外的时间，复现最新的漏洞或者一些老但知名的漏洞也是很好的学习方式。</p>\n<p>CVE（Common Vulnerabilities and Exposures，通用漏洞和暴露）是公开披露的网络安全漏洞列表。它是由 MITRE 公司维护和更新的安全漏洞列表，并由美国国土安全部（DHS）和网络安全与基础设施安全局（CISA）赞助。在CVE中，每个漏洞都会有一个唯一的CVE编号，即CVE ID，例如“CVE-2019-1234567”。这个编号是识别漏洞的唯一标识符，供安全研究员和受攻击的软件供应商使用，以便确定和回应安全漏洞。CVE编号由CVE编号机构（CVE Numbering Authority，CNA）分配，CVE编号机构主要由IT供应商、安全厂商和安全研究组织承担。</p>\n<p>我们一般所谓的复现漏洞，多数时候是指复现这些 CVE 漏洞，为了更好的理解这些漏洞的原理，我们会需要在本地搭建环境并进行模拟攻击。有时候自己搭环境会比较麻烦，网上找到的博客教程偶尔不靠谱。</p>\n<p>推荐一个 phith0n 的漏洞复现 GitHub 仓库，里面收录了很多有价值的漏洞，并且提供了构建环境所需的 Dockerfile 和 docker-compose.yml 文件，以及复现方式，非常方便：</p>\n<ul>\n<li><a href=\"https://vulhub.org/#/environments/\">Vulhub 官网</a> | <a href=\"https://github.com/vulhub/vulhub\">Vulhub 仓库</a></li>\n</ul>\n<h3 id=\"渗透\"><a href=\"#渗透\" class=\"headerlink\" title=\"渗透\"></a>渗透</h3><blockquote>\n<p>📞遵纪守法，<strong>任何渗透活动都应遵循相关的法律和道德准则</strong>。勿碰黑灰产。</p>\n</blockquote>\n<p>Web 渗透，也被称为 Web 渗透测试或 Web 渗透攻击，是一种评估网络应用安全性的方法。它涉及到模拟恶意攻击者的行为，以发现、利用和理解网络应用中的安全漏洞。</p>\n<p>这块和 Red Team 关系更近，有兴趣的可以自行了解。一次完整的渗透包括很多环节：选定目标后，首先要做信息搜集，使用一些工具或搜索引擎搜集目标相关资产，包括子域名什么的，然后进行外围打点，看看能不能找到一些突破口，拿下外围设备后就可以尝试上传木马控制主机权限，做权限维持，如果可以的话再进行提权，然后扫描内网网段，看能不能进行横向或者纵向移动，尝试拿下更多内网主机……</p>\n<p>如果你对渗透相关的安全内容感兴趣，可以通过以下两个靶场进行学习：</p>\n<ul>\n<li>国内：<a href=\"https://yunjing.ichunqiu.com/\">春秋云镜 - 仿真场景</a></li>\n<li>国外：<a href=\"https://app.hackthebox.com/\">Hack The Box</a></li>\n</ul>\n<p>更推荐后者，Hack The Box 提供了更加系统的 Red&#x2F;Blue Team 的学习教程（全英文），以及对应的靶机实操练习。相信你可以从中找到乐趣。</p>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><p>Web 安全领域的工具实在是有“一点点”多，CTF、漏洞挖掘、渗透各自有各自的工具，相同功能的工具还有很多变种、不同团队的实现，该文档没法一一列举。此处就只列出最常用的安全工具，二选一即可：</p>\n<ul>\n<li><a href=\"https://portswigger.net/burp\">BurpSuite - 成熟的⽹络安全⼯具</a></li>\n<li><a href=\"https://yaklang.io/products/intro/\">Yakit - 集成化单兵安全能⼒平台</a></li>\n</ul>\n<p>如果你对这两个⼯具尚不了解，可以在⽹上搜索⼀些相关使⽤教程，起步阶段对这些⼯具的要求不⾼，简单的抓包改包即可。BurpSuite 的学习可以结合前面提到的 PortSwigger 靶场。</p>\n<h2 id=\"0x03-Web开发\"><a href=\"#0x03-Web开发\" class=\"headerlink\" title=\"0x03 Web开发\"></a>0x03 Web开发</h2><p>欢迎来到有趣的 Web 开发领域，前面已经介绍过 Web 领域中前后端的划分，从开发的角度来说，一般推荐挑选其中一个方向进行学习。一方面是因为前后端开发技术经过了很多年的发展，各自都有着深厚的技术积累，即使你不准备去了解那些已经过时的旧技术，近几年的新技术也足够你学习很长一段时间了；另一方面是因为人的精力终究是有限的，想在短时间内同时推进前后端的学习并想要有所建树，是一件相对困难的事情。当然跟随自己的兴趣来就好，刚开始都接触一下也不是什么坏事，说不准你就是下一个全栈大师。</p>\n<p>但说实话，这东西也没什么固定的路数，协会 Web 成员在学习开发时的路线和技术栈也各不相同，没法提供一个同统一的路线。下文中的前后端开发入门都仅为编写文档的人的个人看法，请自行斟酌。</p>\n<p>Web 前后端开发的学习过程差异较大，技术栈也少有重合，这里就分开介绍。</p>\n<blockquote>\n<p>🥳 HDU 有一个名为 <a href=\"https://www.hduhelp.cn/\">HDUHelp 杭电助手</a> 的社团。你会发现，杭电的很多网络服务都是由杭电助手开发并维护的，该社团也会在新学期开始时展开招新活动，老东西会为技术部新人提供相对统一的学习路线指导，欢迎加入杭电助手技术部~</p>\n</blockquote>\n<blockquote>\n<p>🔔 杭电助手后端部技术栈为 Golang；HDU 未央学社后端部技术栈为 Java。</p>\n</blockquote>\n<blockquote>\n<p>🥰 Vidar-Team 与 HDUHelp 关系颇深，协会 Web 方向成员与 HDUHelp 技术部成员重合度很高。</p>\n</blockquote>\n<h3 id=\"前端开发\"><a href=\"#前端开发\" class=\"headerlink\" title=\"前端开发\"></a>前端开发</h3><p>前端开发对新手比较友好，因为你能直观地看到代码在浏览器中被渲染为页面，正反馈比较强，也不会说你学几天后做出来的东西没法给别人展示。</p>\n<p>这里简单介绍下 Web 前端开发入门需要学哪些东西，之后的内容可以自行探索。</p>\n<h4 id=\"原生三件套\"><a href=\"#原生三件套\" class=\"headerlink\" title=\"原生三件套\"></a>原生三件套</h4><p>前端开发的基础就是 <code>HTML</code> + <code>CSS</code> + <code>JavaScript</code>，后面应用框架的学习也要基于这三者。把网站的前端比作人体的话，HTML 就是骨骼，负责支撑起网站的整体架构；CSS 是皮肤，负责给予网站优雅的外观；JavaScript 则是肌肉，让网站具备动态交互的能力。推荐教程是 <a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web</a>，该站点是极其优质的 Web 前端开发知识库，认可度很高，很多流行前端框架的官方教程也把它作为 Web 前端领域中的 Wiki 来引用。</p>\n<p>当然，MDN 对初学者的问题是，其内容过于正式，单个小节的内容过多以至于消磨掉初学者耐心。如果你想在短时间内快速过一遍 Web 前端的简要内容，可以看这个：<a href=\"https://www.runoob.com/\">菜鸟教程</a>，精简很多，但内容不全且稍有过时。</p>\n<p>在学习的过程中，你会发现前端的东西比较杂乱，原生 HTML 中就有几百个标签，不同类的标签往往又会有十几个不同的属性，不同属性还有不同的可选值，CSS 中的各种选择器、伪类伪元素以及几百个属性也足以让你头大。不过这些你不用去记，真正到应用开发过程中，你就会发现能用到的其实不多，第一次看的时候稍微留意一下，脑子里有个概念、知道大概有这么个东西就行，敲代码的时候忘了就去翻文档，毕竟开发时又不是断网环境，只要你能把应用功能实现，怎么搞都行。</p>\n<p><code>JavaScript</code> 相对前两者重要一些，因为网页的主要功能都要使用 <code>JavaScript</code>（下文简称 JS）实现，之后接触的前端应用框架也主要是 JS 框架，包括后面如果你想以一个前端开发者的身份快速上手后端开发，基于 JS 语法的一系列 Node.js 后端框架也是你的首选。因此，你有必要多投入一些精力到 JS 的学习上。</p>\n<p>这里推荐一份 JavaScript 的练习教程，跟着敲敲也蛮有帮助的，可以作为参考：<a href=\"https://javascript30.com/\">JavaScript 30</a>。</p>\n<h4 id=\"JavaScript框架\"><a href=\"#JavaScript框架\" class=\"headerlink\" title=\"JavaScript框架\"></a>JavaScript框架</h4><p>到了应用框架这层，你会发现——可选项更多了。开发者们整天轮子叠轮子的造，同一种功能的实现能给你整出来几十个大大小小的框架，开发者们也整天在社交媒体上因为技术选型而唇枪舌战。吵到今天，应用框架也大致分为了两派，分别是 Vue 和 React。</p>\n<p>你可以在这两者中挑一个上手，这里不做推荐，自己去官网看看，考虑自己喜欢哪种风格之后再上手，反正之后两个都得会（乐）。学的时候跟着官方教程走就好，下面是二者的官方文档：</p>\n<ul>\n<li><a href=\"https://react.dev/\">React</a> - <a href=\"https://zh-hans.react.dev/\">React 官方中文文档</a></li>\n<li><a href=\"https://vuejs.org/\">Vue.js - 渐进式的 JavaScript 框架</a></li>\n<li><a href=\"https://angular.cn/\">Angular</a></li>\n</ul>\n<p>此外，当你上手前端应用框架时，就可以抛弃 JavaScript 而转向使用 TypeScript 了。</p>\n<p>TypeScript（简称 TS）是微软公司开发的一种基于 JS 的编程语言，其目的是增强 JS 的功能，使其更适合多人合作的项目。TypeScript 可以看成是 JS 的超集（superset），即它继承了后者的全部语法。所有 JavaScript 脚本都可以当作 TypeScript 脚本（但是可能会报错），此外它再增加了一些自己的语法。</p>\n<p>TS 对 JS 添加的最主要部分，就是一个独立的类型系统。JS 本身是有一套自己的类型系统，但其非常弱，运算符可以接受各种类型的值。这使得 JS 语法变得非常灵活，但客观上也增加了多人协同项目中出错的概率。在语法上，JS 属于动态类型语言。TS 引入了一个更强大、更严格的类型系统，属于静态类型语言。静态类型有利于代码的静态分析，更早地发现错误，提供了更好的 IDE 支持，做到语法提示和自动补全，提供了代码文档，有助于代码重构。</p>\n<p>平心而论，很多项目其实没必要使用 TypeScript，严格的类型限制和语法要求会降低开发效率。但你架不住多人合作的时候别的前端开发都要用，以及有时候参加项目竞标或者比赛，其他组都用 TS，你一个人用 JS 把项目搞定了，很多不懂技术的评委也只会认为你不会，而不是你不屑于去用。关于到底使用 JS 还是 TS 也是一个长期争论的问题，自行决定。</p>\n<blockquote>\n<p>🧐这块的描述确实不太准确，其他 JS 框架比如 Angular 的使用者也不在少数，上文中提到的 React 严格来说只能算视图层面的库，其背后的 Next.js 才是官方主推的应用框架。不过这些对初学者来说不重要，先大致有个了解，学到后面接触到这些的时候再去调整自己的技术栈。</p>\n</blockquote>\n<h3 id=\"后端开发-Golang\"><a href=\"#后端开发-Golang\" class=\"headerlink\" title=\"后端开发 - Golang\"></a>后端开发 - Golang</h3><p>与前端相比，后端就主要是在于机器交流，你要操纵用户看不到的数据。后端没法做到像前端那样敲个代码立马就能看到反馈，不过胜在学习路线清晰，整体开发流程更加统一。</p>\n<p>后端开发技术选型和语言关系比较大，此处以 Golang 为例进行介绍。</p>\n<h4 id=\"上手\"><a href=\"#上手\" class=\"headerlink\" title=\"上手\"></a>上手</h4><p>Golang，也称为 Go 语言，是由 Google 开发的一种静态强类型、编译型语言。Go 语言的语法与 C 在许多方面相似，但它包含了垃圾回收的功能，且支持并发编程，同时更加简洁。这些优势使得 Go 在网络开发以及云原生方面有一些独特的优势。如果你学过 C 的话，Go 其实挺好上手的。</p>\n<p>有以下两个推荐教程，不推荐看菜鸟教程，太浅了：</p>\n<ul>\n<li>在线学习 Golang 的网站，手把手教你一步步敲代码：<a href=\"https://tour.go-zh.org/welcome/1\">Go 语言之旅</a></li>\n<li>看书的话就选这本，<a href=\"https://golang-china.github.io/gopl-zh/\">Golang 圣经</a></li>\n</ul>\n<p>在踏入下一步之前，你还有必要先了解 SQL。SQL，全称为 <strong>结构化查询语言</strong>（Structured Query Language），是一种用于管理关系数据库的标准编程语言。它包括一系列用于创建、修改、删除和查询数据库的命令。Web 后端应用基本都会有存储数据的需求，你不能把数十万条需要持久存储的数据一直保存在本地内存中，而是需要用类似 MySQL 这样的数据库帮存储你的数据。</p>\n<ul>\n<li><a href=\"https://www.w3school.com.cn/sql/index.asp\">W3school SQL教程</a></li>\n</ul>\n<h4 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h4><p>当你熟悉 Golang 语法之后，就可以上手 Web 应用框架了。推荐给初学者的 Golang 后端三件套是 <code>Gin</code> + <code>Gorm</code> + <code>MySQL</code>，去看各自的官方教程即可。</p>\n<p>Gin 是一个 Web 应用框架，这个都懂。开发者固然可以使用 Golang 自带的 <code>net/http</code> 处理客户端请求、处理并返回数据，但每次都这么做未免有些累赘；而且有时我们需要为某些 API 添加统一的鉴权，或者为所有处理请求事件添加日志记录，如果我们使用原生库去一个接口一个接口地去完成这些工作，那可就太费事费力了。</p>\n<p>所以，经过积累，开发者们就将某些常用的功能，比如动态路由实现、分组控制、中间件、模板渲染与错误恢复等，将它们抽象出来并进行封装，打包成一个开箱即用的 Web 应用框架。当其他开发者想要实现某些功能时，直接导包引用该框架即可，这大幅提升了 Web 应用的开发效率，也在规范化和标准化等方面做出贡献。</p>\n<ul>\n<li><a href=\"https://gin-gonic.com/\">Gin</a></li>\n</ul>\n<p>Gorm 是一个基于 Golang 开发的全功能 ORM 框架。那什么是 ORM 呢？你在学习 Golang 语法时或许已经知道该如何拼接 SQL 语句并进行数据库操作了，但这么搞的问题是效率低下，而且有些粗心的开发者疏于对用户传入数据的处理，可能会导致一些安全问题，比如 SQL 注入漏洞。</p>\n<p>为了解决上述问题，ORM 应运而生。ORM 全称 <strong>对象关系映射</strong>（Object-Relational Mapping），是一种程序设计技术，用于实现面向对象编程语言里的对象和关系数据库之间的映射。有了 ORM，开发者可以直接使用面向对象的方式来操作数据库，无需编写 SQL 代码，大大提高了开发效率，框架自带的预处理等防范措施也提高了 Web 应用的安全性。当然，代价就是牺牲了一定的灵活性。</p>\n<ul>\n<li><a href=\"https://gorm.io/zh_CN/docs/index.html\">GORM 指南</a></li>\n</ul>\n<p>此外，在你能够使用这三件套，以及其他库熟练地完成 CRUD 开发工作之后，我推荐你去读读这些框架的源码，从底层理解这些框架是如何实现数据处理以及其他功能的实现的，比如路由匹配的方式等等，然后尝试上手写写，自己实现。这个过程也是比较有趣的，你可以使用自己学习过的 Golang 语法与原生库结合，一步步地搭建出一个具备完备功能的 Framewok。如果你之前没有什么阅读源码的经验，也不知道何从下手，可以跟着下面这篇教程走，或许可以对你有所启发：</p>\n<ul>\n<li><a href=\"https://geektutu.com/post/gee.html\">7天用Go从零实现Web框架Gee教程</a></li>\n</ul>\n<h3 id=\"后端开发-Java\"><a href=\"#后端开发-Java\" class=\"headerlink\" title=\"后端开发 - Java\"></a>后端开发 - Java</h3><h4 id=\"上手-1\"><a href=\"#上手-1\" class=\"headerlink\" title=\"上手\"></a>上手</h4><p>Java 这门编程语言你可能已经耳熟能详，毕竟这几年 Java 卖课的比较多（挠头）。它的跨平台性、面向对象的特性以及丰富的类库使其在编程语言中独树一帜。如果你对 C++ 或者 C# 有所了解，那么就会发现 Java 的语法与它们有许多相似之处。但是，Java 在设计上追求简洁和易读，因此去除了一些容易引发错误的概念，如指针和运算符重载等。如果你之前没学习过面向对象的语言，初次上手可能略有费劲。</p>\n<p>推荐下学习资源，可以试试：</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">Java教程 - 廖雪峰</a></li>\n<li>黑马程序员Java零基础视频教程：<a href=\"https://www.bilibili.com/video/BV17F411T7Ao/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">上部</a> &amp; <a href=\"https://www.bilibili.com/video/BV1yW4y1Y7Ms/?spm_id_from=333.788.recommend_more_video.0&vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">下部</a></li>\n</ul>\n<h4 id=\"框架-1\"><a href=\"#框架-1\" class=\"headerlink\" title=\"框架\"></a>框架</h4><p>学完语法之后，就可以学习对应的后端服务框架了。对于 Java 后端开发，比较推荐的技术栈是 <code>Spring Boot</code> + <code>Hibernate</code> + <code>MySQL</code>。 </p>\n<p>Spring Boot 是一个基于 Spring 框架的开源 Java 框架，它可以帮助你快速地创建出一个独立的、生产级别的 Spring 应用程序。学习资源推荐：</p>\n<ul>\n<li><a href=\"https://springdoc.cn/spring-boot/\">Spring Boot 中文文档</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV15b4y1a7yG/?vd_source=d77df35177e7fa05ef5f9e0b6ddf2180\">黑马程序员 SpringBoot2</a></li>\n</ul>\n<p>Hibernate 对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，是一个全自动的 ORM 框架，它可以帮助你更方便地操作数据库，而无需编写复杂的 SQL 代码。</p>\n<ul>\n<li><a href=\"https://hibernate.github.net.cn/\">Hibernate 中文文档</a></li>\n</ul>\n<h4 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h4><p>再调过头来提一下 Java 安全。网上资料茫茫多，自己挑比较费时间，可以直接看下面推荐的这个教程，phith0n 出品，必属精品：</p>\n<ul>\n<li><a href=\"https://javasec.org/\">攻击Java Web应用-[Java Web安全]</a></li>\n</ul>\n<p> 与此同时，phith0n 还建立了一个<a href=\"https://govuln.com/\">“代码审计”知识星球</a>，是一个专业、前沿、原创的 Web 代码安全与审计讨论社区，专注于分享原创的代码安全知识、漏洞挖掘方法，感兴趣的可以加一下。截至本文文档更新时，星球价格为 299￥ 终身制，不过确实值这个钱。</p>\n<h2 id=\"0x04-Network\"><a href=\"#0x04-Network\" class=\"headerlink\" title=\"0x04 Network\"></a>0x04 Network</h2><p>因为本文档讨论的主要是狭义上的 Web，Network 其实一般不会在此处提及。但因为 Network 在 Web 渗透领域的使用，以及 Vidar-Team 最近两届的网管都是 Web 手，所以本文档也单独划出 Network 的小节。</p>\n<p>写这篇文档的人 Network 技术相对一般，这里就少啰嗦一些废话。如果你对计算机网络感兴趣但没有基础，可以自行学习 <a href=\"https://hdu-cs.wiki/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/9.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\">HDU-CS-WIKI 计算机网络</a> 章节的内容，可以快速的给你通一遍网络相关概念，方便你进一步的学习。</p>\n<p>如果你对自己的网络水平有自信，并且有意向加入 Vidar-Team 成为下一届网管，就在招新群里吆喝一声，很快就可以吸引到 Vidar 历届网管的注意，线下交流讨论。</p>\n<p>此外，HDU 有一个由学生自发创建的去中心化网络，名为<a href=\"https://dn11.top/\">“DN11”</a>，欢迎有一定网络基础的学生加入。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-dn11.png\" alt=\"helloweb-dn11\"></p>\n<h2 id=\"0x05-泛用技能\"><a href=\"#0x05-泛用技能\" class=\"headerlink\" title=\"0x05 泛用技能\"></a>0x05 泛用技能</h2><p>有些东西并不怎么成体系，但也是新生有必要知道的，同时又不怎么好分类，索性一块丢到这个小节下面。</p>\n<h3 id=\"信息搜集\"><a href=\"#信息搜集\" class=\"headerlink\" title=\"信息搜集\"></a>信息搜集</h3><p>本文档是面向新手的教程，覆盖面有限，你可能想要更多相关资料。如果掌握了恰当的信息搜集⽅式，你就可以获得更多更优质的资源，实现更快的进步。</p>\n<h4 id=\"搜索引擎\"><a href=\"#搜索引擎\" class=\"headerlink\" title=\"搜索引擎\"></a>搜索引擎</h4><p>好的搜索引擎可以帮你检索出优质的学习资源，节约你在海量的⽂章中沙⾥淘⾦的时间。⾸推的搜索引擎是 <a href=\"https://www.google.com/\">Google</a>，它可以帮助你搜集全球范围内符合你关键词的⽹⻚，并过滤掉⼀些⽆⽤的⼴告和只会 cv 的⽂章，快速定位到你需要的资源。</p>\n<p>退⽽求其次，你也可以选择 Microsoft Bing，如果你从未接触过计算机技术，对你来说 <a href=\"https://www.bing.com/\">Bing</a> 可能更⽅便访问。</p>\n<p>如果你执着于使⽤<a href=\"https://www.baidu.com/\">百度</a>，你可以利⽤⼀些搜索引擎默认的语法来规避掉不想看到的⽹⻚。⽐如 <code>SQLI⼊⻔教程 -csdn</code>，这样你的搜索结果中就不会出现 CSDN 相关⽂章。</p>\n<h4 id=\"平台\"><a href=\"#平台\" class=\"headerlink\" title=\"平台\"></a>平台</h4><p>如果你对计算机感兴趣，你就不可避免的要接触 <a href=\"https://github.com/\">GitHub</a>。GitHub 是⼀个⾯向开发⼈员的开源代码托管平台，它允许⽤⼾创建和管理他们的代码仓库，与其他开发⼈员协作。在 GitHub 上你能找到很多优秀的开源项⽬，以及⼀些有趣的学习资料，你甚⾄可以在这⾥体会到寻宝的快感，尽情地去了解世界上其他的程序员都在做些什么、在研究什么东西。这其中就有很多 Web ⽅向的学习资料，包括开发、安全等各个领域。</p>\n<p>如果你有计算机⽅⾯的问题，你可以选择去 <a href=\"https://stackoverflow.com/\">Stack Overflow</a>。Stack Overflow 是⼀个⾯向程序员的问答⽹站，它是 Stack Exchange ⽹络的旗舰站点。它由 Jeff Atwood 和 Joel Spolsky 于 2008 年创建，提供了关于计算机主题的问题和答案。Stack Overflow 是全球最⼤、最值得信赖的在线社区之⼀，开发⼈员可以在这⾥学习、分享他们的编程知识。在问答型 AI 流行起来之前，这就是全世界程序员最常用的寻求问题解决方案的地方。</p>\n<h4 id=\"AI\"><a href=\"#AI\" class=\"headerlink\" title=\"AI\"></a>AI</h4><p>你可以使⽤最近流⾏的 AI 帮助你学习。⽬前常⻅的问答 AI 有 <a href=\"https://chat.openai.com/\">Chatgpt</a>、New Bing 等，你可以借助它们来快速⼊⻔⼀个概念或者找到你问题的答案。</p>\n<p>此外，有一些基于 AI 的搜索引擎也可以尝试，比如 <a href=\"https://devv.ai/\">devv_</a>。</p>\n<blockquote>\n<p>😵请记住，不要把 AI 给你的回答当成真理，不要过度依赖 AI，它只是你的⼀个辅助⼯具。就像本文档开头所说的那样，你要保留 <strong>独⽴思考</strong> 的能⼒，什么事都问 AI 的结果就是你平滑的被 AI 取代。</p>\n</blockquote>\n<h3 id=\"Git版本管理工具\"><a href=\"#Git版本管理工具\" class=\"headerlink\" title=\"Git版本管理工具\"></a>Git版本管理工具</h3><p>Git 是一种<strong>分布式版本控制系统</strong>。它可以自动跟踪文件的变化、还原文件的历史记录、协调多人在同一个项目中工作，并且可以在必要情况下回溯到过去的任意版本。</p>\n<p>在软件开发中，版本控制系统可以帮助开发人员有效地管理和维护代码库，支持项目的分支、合并等操作。这样，这允许不同的成员可以同时对同一个项目进行开发，而不会产生代码冲突等问题。此外，版本控制系统还可以提供更好的安全备份和恢复机制，以防止意外的数据丢失或代码损坏。</p>\n<p>前文说过了 GitHub，经过简单的配置，你就可以使用 Git 将本地项目托管到 GitHub 平台，避免数据丢失的麻烦。</p>\n<p>从这个网站学习 Git 的使用，手把手式教学：<a href=\"https://learngitbranching.js.org/\">Learn Git Branching</a></p>\n<h3 id=\"Linux操作系统\"><a href=\"#Linux操作系统\" class=\"headerlink\" title=\"Linux操作系统\"></a>Linux操作系统</h3><p>Linux 是一个操作系统。它由 <em>Linus</em> 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。 现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。它自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。 以前有很多设置你可能需要在 Windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。</p>\n<p>此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。 这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。</p>\n<p>同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。 这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。</p>\n<p>现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。你可以使用 <a href=\"https://www.vmware.com/\">VMware</a> 或者 <a href=\"https://www.virtualbox.org/\">VirtualBox</a> 等软件创建 Linux 虚拟机，也可以干脆直接上 Linux 物理机。对于 Web 方向的学习来说，Linux 系统的熟练使用属于必备技能。</p>\n<h2 id=\"0x06-可选事项\"><a href=\"#0x06-可选事项\" class=\"headerlink\" title=\"0x06 可选事项\"></a>0x06 可选事项</h2><h3 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h3><p>推荐在个人博客记录⾃⼰的学习过程。在搭建博客的过程中你能学到很多有趣的知识。</p>\n<p>比较推荐的用来搭建个人博客的框架有 <a href=\"https://hexo.io/zh-tw/\">Hexo</a>、<a href=\"https://vitepress.dev/\">Vitepress</a>、<a href=\"https://gohugo.io/\">Hugo</a>、<a href=\"https://wordpress.com/zh-tw/\">WordPress</a> 等，可以都看看，选择一个自己喜欢的用（搭建个人博客很多时候考虑的还是美观性）。如果你对自己的前端技术有自信，也可以自己写一个。</p>\n<p>以下是几个高质量的杭电学长个人博客，可以看看他们的文章：</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Blog Link</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>E99p1ant</td>\n<td><a href=\"https://github.red/\">https://github.red/</a></td>\n</tr>\n<tr>\n<td>LoRexxar</td>\n<td><a href=\"https://lorexxar.cn/\">https://lorexxar.cn/</a></td>\n</tr>\n<tr>\n<td>lightness</td>\n<td><a href=\"https://lightless.me/\">https://lightless.me/</a></td>\n</tr>\n<tr>\n<td>Cyris</td>\n<td><a href=\"https://cyris.moe/\">https://cyris.moe/</a></td>\n</tr>\n<tr>\n<td>Chuj</td>\n<td><a href=\"https://www.cjovi.icu/\">https://www.cjovi.icu/</a></td>\n</tr>\n<tr>\n<td>daidr</td>\n<td><a href=\"https://im.daidr.me/\">https://im.daidr.me/</a></td>\n</tr>\n<tr>\n<td>Nick Xu</td>\n<td><a href=\"https://nickxu.me/\">https://nickxu.me/</a></td>\n</tr>\n</tbody></table>\n<p>此外，我们编辑个人博客时一般使用的是 <a href=\"https://markdown.tw/\">Markdown</a> 格式，推荐学习一下。有很多 Markdown 编辑器可供选择，比如 <a href=\"https://typora.io/\">Typora</a>、<a href=\"https://obsidian.md/\">Obsidian</a>，直接使用 Visual Studio Code 配合插件也是可以的。</p>\n<p>在编辑博客时，你可能需要插入一些图片。你可以选择将图片与 Markdown 存储在同一个仓库中，不过更推荐使用 OSS+PicGo 的组合搭一个图床，然后在 .md 文件中通过外链引用图片，具体操作可以参考这个教程：<a href=\"https://zhuanlan.zhihu.com/p/104152479\">阿里云OSS PicGo 配置图床教程 超详细</a>。</p>\n<blockquote>\n<p>💸 警告，如果使用云存储服务搭建图床，建议使用 CDN 为外链引用添加限制，否则可能会有坏人刷你博客里的 OSS 外链图片，造成高额的经济损失。确保在有能力保护自己安全的情况下再用。</p>\n</blockquote>\n<h3 id=\"兔兔的小游戏\"><a href=\"#兔兔的小游戏\" class=\"headerlink\" title=\"兔兔的小游戏\"></a>兔兔的小游戏</h3><p>加⼊ Vidar-Team 招新群，你经常能看到可爱的兔兔机器⼈在帮助维持群内秩序，或者回答⼀些简单的问题。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/helloweb-tutu.png\" alt=\"helloweb-tutu\"></p>\n<p>兔兔迎新机器⼈还具有⼀个 <code>%blog</code> 命令，⽤于查询协会成员的博客链接。功能存在⼀个 SQLI 漏洞，通过这个漏洞可以查询出数据库中的 Flag。拿到 Flag 后可以私聊 Web 方向学长领取一杯奶茶哦~</p>\n<h3 id=\"其他学习路线\"><a href=\"#其他学习路线\" class=\"headerlink\" title=\"其他学习路线\"></a>其他学习路线</h3><p>这是面向新生的文档，自然会有很多介绍不够细致的地方，不过我感觉已经够新生学一阵子的了。如果你还想要参考其他学习路线，可以点击下面这几个网址，这是在 GitHub上很火爆的 Roadmap，也可以提供路线的建议：</p>\n<ul>\n<li><a href=\"https://roadmap.sh/frontend\">Frontend Developer Roadmap</a></li>\n<li><a href=\"https://roadmap.sh/backend\">Backend Developer Roadmap</a></li>\n<li><a href=\"https://github.com/hideraldus13/roadmap-do-desenvolvedor-web\">Roadmap do Desenvolvedor Web 2021</a></li>\n</ul>\n<h2 id=\"0x07-后话\"><a href=\"#0x07-后话\" class=\"headerlink\" title=\"0x07 后话\"></a>0x07 后话</h2><p>内容略多，希望你是耐⼼看到这⾥的。</p>\n<p>Vidar 在本质上就是⼀群热爱信息安全的⼩伙伴自发成⽴的技术型团体，CTF 竞赛是我们⽇常活动的组成部分，并不是 Vidar 存在的唯⼀意义，你可以在这⾥尽情的研究你喜欢的技术，不仅是本⽂介绍的 Web，其他⼏个⽅向，以及较少提及的 IOT、区块链等都有学⻓在研究，你可以在这⾥轻松找到志同道合的朋友，⼀起学习。</p>\n<p>另外，协会希望⼤家不要急于求成，要先打好基础。扎实的基础知识会是你未来发展道路上的铺路⽯。同时，也不能只着眼于理论知识，也要在实战中学习，边学边练才是健康的状态。</p>\n<p>最后，再次欢迎对 Web 安全感兴趣的你！如果在学习过程中遇到困难，随时可以在招新群中提问，祝你在 Web 安全的学习道路上越⾛越远〜</p>\n<blockquote>\n<p>🏔️ 勿以浮沙筑⾼台，望学弟学妹们打牢基础，努力学习哇！</p>\n</blockquote>\n"},{"title":"你知道 Clash 吗？","date":"2024-06-11T16:00:00.000Z","author":"ma5hr00m","_content":"\n[什么是 Clash? | Clash 知识库](https://clash.wiki/)\n\n有一说一，大家肯定都知道 Clash，但很多人对这东西的印象就是一个翻墙工具，导入订阅链接点几下就行，并不理解 Clash 究竟做了什么。\n\nClash 是一个运行在网络层和应用层的、基于规则的代理工具，它所能做的不仅仅是帮你转发流量到互联网访问其它应用（当然这算是主要功能）。Clash 在本质上是对用户本机的流量进行管理，实现智能路由和访问控制，如果你会写 Clash 配置文件的话，就可以轻松实现访问外网应用时自动走代理，而在访问指定国内应用时不走代理直接访问。\n\n其工作原理和工作流程说来也简单，用一句话就能解释清楚：接收本机流量后根据规则进行转发，下文会对这一过程进行介绍。\n\n看完这篇文章，你应该可以对 Clash 的本质以及其工作原理有一个相对清晰的认识，可以轻松看懂那些“订阅链接”背后是什么，并且可以独立编写 Clash 配置文件。\n\n## 工作流程\n\n我们可以把 Clash 的工作过程简单分为三步，\n\n1. **Inbound 入站：**当你在设备上启动 Clash 时，它会创建一个或多个本地监听端口，这些端口用于接收来自设备上的应用程序的网络请求；\n2. **基于规则的路由：**Clash 配置文件中的 **`rules`** 部分定义了如何处理不同类型的网络请求。例如上文说的只转发部分流量；\n3. **Outbound 出站：**Clash 根据配置文件中的规则，将入站的网络请求转发到不同的出站连接，可以连接到某个网络接口、某个代理服务器，也可以是某个策略组。\n\n![20240613024509](https://img.ma5hr00m.top/blog/20240613024509.png)\n\n## 四种代理模式\n\n在 Clash 操作页面，可以看到四种代理模式，一般情况下选择“规则”就好，足够用户使用。这里对这四种都做一下介绍：\n\n1. **规则（Rule）**：这是 Clash 配置中最重要的部分之一。规则用于定义哪些流量应该被代理，哪些应该直连。用户可以根据域名、IP、地理位置等条件来设置规则。\n2. **直连（Direct）**：直连选项通常用于设置哪些流量不需要通过代理服务器直接访问。这通常用于访问本地网络资源或者信任的网站。\n3. **全局（Global）**：全局模式下，所有的网络流量都会通过代理服务器。这个模式适用于需要代理所有流量的情况。\n4. **脚本（Script）**：脚本功能允许用户编写或使用现有的 JavaScript 脚本来自定义复杂的流量处理逻辑，比如修改请求头、响应内容等，从而实现更灵活的分流规则。\n\n## 配置文件\n\n[https://clash.skk.moe/](https://clash.skk.moe/)\n\n前面说的入站、入站和规则都需要在配置文件中指定。Clash 的主配置文件名为 `config.yaml`，默认情况下会在 `$HOME/.config/clash` 目录读取配置文件。如果该目录不存在，Clash 会在该位置生成一个最小的配置文件。\n\n如果需要指定其他位置的配置文件，需要在命令行中使用 `-f` 参数：\n\n```bash\nclash -f /etc/clash/config.yaml\n```\n\n一份完整的 Clash 配置文件包括多个部分，下面一一介绍。\n\n### General 配置\n\n在 Clash 配置文件中，General 配置包含了一些必需的字段以及可选的配置项，通常位于配置文件开头部分。其中 `port`，`socks-port` 和 `allow-lan` 是必需的字段，用于指定 Clash 的端口、SOCKS5 代理端口以及是否允许局域网连接。如果需要启用透明代理，还需要指定 `redir-port` 字段，用于指定透明代理的端口。\n\n还有个特殊的 `mixed` 字段，用于指定混合配置端口，这个端口同时支持 HTTP(S) 和 SOCKS5 协议。\n\n除了这些必需字段外，还有一些可选的配置项，下面简单罗列几个：\n\n- `dns`：用于配置DNS相关设置。\n- `external-controller`：用于指定 RESTful API 的地址和端口。\n- `secret`：可选项，用于设置 RESTful API 的密钥。\n- `cfw-bypass`：可选项，用于配置规则以绕过代理。\n\n在编写 General 配置时可以参考以下内容，各个字段的作用都以注释的形式标注：\n\n```yaml\nport: 7890 # HTTP端口\nsocks-port: 7891 # SOCKS5端口\nredir-port: 7892 # Linux和macOS的重定向端口\nmixed: 7893 # 混合端口\nallow-lan: false\n\n# 仅在设置allow-lan为true时适用\n# \"*\": 绑定所有IP地址\n# 192.168.122.11: 绑定单个IPv4地址\n# \"[aaaa::a8aa:ff:fe09:57d8]\": 绑定单个IPv6地址\nbind-address: \"*\"\n\n# Rule / Global/ Direct（默认为Rule）\nmode: Rule\n\n# 将日志级别设置为stdout（默认为info）\n# info / warning / error / debug / silent\nlog-level: info\n\nexternal-controller: 127.0.0.1:9090 # Clash的RESTful API\n\n# 您可以将静态Web资源（如clash-dashboard）放入一个目录，并且Clash将在`${API}/ui`中提供服务\n# 输入是相对于配置目录的相对路径或绝对路径\nexternal-ui: \"path/to/local/clash-dashboard\"\n\nsecret: \"\" # RESTful API的密钥（可选）\n\nexperimental: # 实验性功能\n  ignore-resolve-fail: true # 忽略DNS解析失败，默认值为true\n\n# 本地SOCKS5/HTTP(S)服务器的身份验证\nauthentication:\n  - \"user1:pass1\"\n  - \"user2:pass2\"\n\n# 实验性主机，支持通配符（例如*.clash.dev 甚至*.foo.*.example.com）\n# 静态域比通配符域具有更高的优先级（foo.example.com > *.example.com）\nhosts:\n  '*.clash.dev': 127.0.0.1\n  'alpha.clash.dev': '::1'\n\ndns:\n  enable: true # 设置为true以启用DNS（默认为false）\n  ipv6: false # 默认为false\n  listen: 0.0.0.0:53\n  enhanced-mode: fake-ip # 或redir-host\n  fake-ip-range: 198.18.0.1/16 # 如果不知道是什么，请勿更改\n  nameserver:\n    - 114.114.114.114\n    - tcp://1.1.1.1\n  fallback: # 与nameserver并发请求，当GEOIP国家不是CN时使用fallback\n    - tls://dns.rubyfish.cn:853 # DNS over TLS\n    - https://1.1.1.1/dns-query # DNS over HTTPS\n  fallback-filter:\n    geoip: true # 默认\n    ipcidr: # 这些子网中的IP将被视为污染\n      - 240.0.0.0/4\n```\n\n### Proxy 配置\n\nProxy 配置以及 Proxy Group 配置就是 Clash 控制流量出站的主要配置。\n\nProxy 配置用于指定 Clash 连接代理服务器的相关信息。这包括代理服务器的地址、端口、类型等信息。通过正确配置这一部分，Clash 可以根据你的需求将流量转发到不同的代理服务器。例如，你可以设置多个代理节点，并为它们指定不同的类型，如 **`ss`**、**`vmess`**、**`socks5`**、**`http`** 和 **`snell`**。\n\n配置 Proxy 部分时可以参考以下内容：\n\n```yaml\nproxy:\n  # shadowsocks\n  - name: \"ss1\"\n    type: ss\n    server: server\n    port: 443\n    cipher: chacha20-ietf-poly1305\n    password: \"password\"\n    # udp: true\n\n  - name: \"ss2\"\n    type: ss\n    server: server\n    port: 443\n    cipher: chacha20-ietf-poly1305\n    password: \"password\"\n    plugin: v2ray-plugin\n    plugin-opts:\n      mode: websocket\n      # tls: true\n      # skip-cert-verify: true\n      # host: bing.com\n      # path: \"/\"\n      # mux: true\n      # headers:\n      #   custom: value\n\n  # vmess\n  - name: \"vmess\"\n    type: vmess\n    server: server\n    port: 443\n    uuid: uuid\n    alterid: 32\n    cipher: auto\n    # udp: true\n    # tls: true\n    # skip-cert-verify: true\n    # network: ws\n    # ws-path: /path\n    # ws-headers:\n    #   host: v2ray.com\n\n  # socks5\n  - name: \"socks\"\n    type: socks5\n    server: server\n    port: 443\n    # username: username\n    # password: password\n    # tls: true\n    # skip-cert-verify: true\n    # udp: true\n\n  # http\n  - name: \"http\"\n    type: http\n    server: server\n    port: 443\n    # username: username\n    # password: password\n    # tls: true\n    # skip-cert-verify: true\n\n  # snell\n  - name: \"snell\"\n    type: snell\n    server: server\n    port: 44046\n    psk: yourpsk\n    # obfs-opts:\n    #   mode: http\n    #   host: bing.com\n```\n\n### Proxy Group 配置\n\nproxy group 配置部分的作用是定义策略组，这些策略组可以在规则中使用来决定网络请求通过哪个代理节点。策略组允许你根据不同的场景和需求，组合和管理多个代理节点。例如，你可以创建一个策略组来自动选择延迟最低的节点，或者创建一个策略组来手动选择特定的节点。\n\n配置 Proxy Group 部分时可以参考以下内容：\n\n```yaml\nproxy-group:\n  # url-test 通过测试访问 URL 的速度来选择使用哪个代理。\n  - name: \"auto\"\n    type: url-test\n    proxies:\n      - ss1\n      - ss2\n      - vmess1\n    url: 'http://www.gstatic.com/generate_204'\n    interval: 300\n\n  # fallback 通过优先级选择可用的策略。可用性通过访问 URL 来测试，就像自动 url-test 组一样。\n  - name: \"fallback-auto\"\n    type: fallback\n    proxies:\n      - ss1\n      - ss2\n      - vmess1\n    url: 'http://www.gstatic.com/generate_204'\n    interval: 300\n\n  # load-balance: 相同 eTLD 的请求将在同一个代理上拨号。\n  - name: \"load-balance\"\n    type: load-balance\n    proxies:\n      - ss1\n      - ss2\n      - vmess1\n    url: 'http://www.gstatic.com/generate_204'\n    interval: 300\n\n  # select 用于选择代理或代理组\n  # 您可以使用 RESTful API 切换代理，推荐在 GUI 中使用。\n  - name: Proxy\n    type: select\n    proxies:\n      - ss1\n      - ss2\n      - vmess1\n      - auto\n```\n\n### Rule 配置\n\nRule 配置部分的作用是定义网络请求的匹配规则，以决定哪些请求应该被代理、直连或拒绝。这些规则基于请求的不同属性，如域名、IP 地址、端口号或地理位置来匹配流量。\n\n配置 Rule 部分时可以参考以下内容：\n\n```yaml\nrule:\n  - domain-suffix,google.com,[策略组的名称]\n  - domain-keyword,google,[策略组的名称]\n  - domain,google.com,[策略组的名称]\n  - domain-suffix,ad.com,REJECT\n  - ip-cidr,127.0.0.0/8,DIRECT\n  # rename source-ip-cidr and would remove after prerelease\n  - src-ip-cidr,192.168.1.201/32,DIRECT\n  - geoip,CN,DIRECT\n  - dst-port,80,DIRECT\n  - src-port,7777,DIRECT\n  # final would remove after prerelease\n  # you also can use `final,Proxy` or `final,,Proxy` now\n  - match,[策略组的名称]\n```\n\n后面会详细介绍每一种可用的规则，后面再细看。\n\n## Inbound 入站协议\n\n- SOCKS5\n- HTTP(S)\n- Redirect TCP\n- TProxy TCP\n- TProxy UDP\n- Linux TUN 设备（仅 Premium 版本）\n\n[一口气搞明白有点奇怪的 Socks 5 协议以及 HTTP 代理](https://www.txthinking.com/talks/articles/socks5-and-http-proxy.article)\n\n入站协议中主要就是对 SOCKS5 和 HTTP 做区分，三种透明代理后面单独说。\n\nSOCKS5 代理提供全面的网络协议支持，支持认证、更安全，同时支持 UDP 协议，以及提供了较好的性能和兼容性。HTTP 代理则仅能代理 HTTP 和 HTTPS 协议的流量，通常用于网页浏览，它可以高效地缓存数据，降低带宽消耗，但不适用于所有网络协议。\n\n一般浏览网页的话配个 HTTP 代理就行，其他情况直接 SOCKS5。\n\n## Outbound 出站 Proxy\n\nClash 出站种类较多，且各自使用场景不同。前面讲过了配置文件的写法，可以把 Clash 出站分为 Proxy 和 Proxy Group 两种，这里也分开介绍。\n\n### Shadowsocks/ShadowsocksR\n\n[Shadowsocks/SS教程 - tlanyan](https://itlanyan.com/on-fuck-gfw-again/)\n\n**Shadowsocks** 是一个基于 SOCKS5 协议的加密代理，它使用各种加密方法来保护数据流。Clash 支持的 Shadowsocks 加密方法包括：\n\n| 系列 | 加密方法 |\n| --- | --- |\n| AEAD | aes-128-gcm, aes-192-gcm, aes-256-gcm, chacha20-ietf-poly1305, xchacha20-ietf-poly1305 |\n| 流式 | aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20 |\n| 块式 | aes-128-ctr, aes-192-ctr, aes-256-ctr |\n\n此外，Clash 还支持 Shadowsocks 的插件，如 obfs 和 v2ray-plugin，这些插件可以提供额外的混淆功能，进一步增强隐私保护。\n\n**ShadowsocksR** 是 Shadowsocks 的一个扩展版本，它增加了更多的混淆和协议选项，以提高抗审查能力。Clash 支持的 ShadowsocksR 加密方法和混淆方法包括：\n\n| 系列 | 加密方法 |\n| --- | --- |\n| 流式 | aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20 |\n\n一般情况下，我们现在各种平台的订阅基本都是默认的 ss 协议。\n\n补充个小趣闻，ssr 协议在其发展过程中引起了一些争议。最初，ssr 项目因为违反 GPL 许可证而受到批评。原开发者对此表示不满，因为这违反了开源项目的基本原则。后来，ssr 项目改为采用与 ss 相同的 GPL、Apache 许可证、MIT 许可证等多重自由软件许可协议，缓解了部分争议。\n\n### Vmess\n\n**VMess** 是一个无状态的加密通信协议，且所有数据都通过 TCP 传输。\n\n每当 VMess 客户端发起请求时，服务器会判断是否来自合法客户端。如果验证通过，请求就会被转发。之后，获得的响应会被发送回客户端。VMess 使用非对称格式，客户端的请求和服务器的响应格式不同。\n\nClash 支持以下 Vmess 的加密方法:\n\n- auto：自动选择，默认值。\n- aes-128-gcm：推荐在 PC 上使用。它是一种高效的加密算法，通常用于需要高吞吐量的应用。\n- chacha20-poly1305：推荐在移动设备上使用。它适用于那些没有硬件AES 加速的设备，因为它在软件实现中更快。\n- none\n\n### SOCKS5\n\n### HTTP\n\n### Snell\n\nClash 也集成了对 Snell 的支持。\n\n**Snell** 是一种精简的加密代理协议，由 Surge 团队开发，也是一种较为经典的反审查协议。它的设计初衷是为了提供极致的性能和简单的配置过程，同时支持 UDP over TCP中继。此外，Snell 是单一二进制文件，零依赖（除了glibc），这也使得 Snell 易于部署和维护。\n该协议的使用场景主要集中在需要绕过网络审查、保护隐私和数据加密的环境中。由于其高性能和简单配置的特点，Snell适用于个人用户和小型企业，尤其是在网络审查较为严格的地区。\n\n小提示，Snell@v4 没有提供向下兼容，需要客户端服务端均进行升级。\n\n想知道更多相关知识去看这个 gitbook：https://manual.nssurge.com/others/snell.html\n\n### Trojan\n\nClash 内置了对流行协议 Trojan 的支持。\n\n**Trojan** 是近几年才兴起的网络工具，特点同样是确保数据传输的安全性和隐私性。但与传统的 ss/ssr 不同的是，ss/ssr 保证数据传输安全的手段是加密混淆，而 Trojan 的思路是将流量伪装成最常见的 HTTPS 流量。\n\n[trojan教程 - tlanyan](https://itlanyan.com/trojan-tutorial/)\n\n## Outbound 出站 Proxy Groups\n\nProxy Groups 策略组用于根据不同策略分发规则传递过来的请求，其可以直接被规则引用，也可以被其他策略组引用，而最上级策略组被规则引用。\n\n### Relay 中继\n\n```yaml\nRelay:\n  - name: \"US-JP Relay\"\n    type: relay\n    proxies:\n      - \"US-Proxy\"\n      - \"JP-Proxy\"\n```\n\n适用于当用户需要将流量通过特定的国家或地区进行中继时。比如用户想要访问仅限日本的内容，但同时想要通过美国的代理增加匿名性。\n\n### URL-Test 延迟测试\n\n```yaml\nUrl-Test:\n  - name: \"Fastest-Proxy\"\n    type: url-test\n    proxies:\n      - \"Proxy-A\"\n      - \"Proxy-B\"\n    url: \"http://www.gstatic.com/generate_204\"\n    interval: 600\n```\n\n自动选择延迟最低的代理服务器。比如用户在进行在线游戏或视频会议时，需要确保连接是最快的。\n\n### Fallback 可用性测试\n\n```yaml\nFallback:\n  - name: \"Available-Proxy\"\n    type: fallback\n    proxies:\n      - \"Proxy-A\"\n      - \"Proxy-B\"\n    url: \"http://www.gstatic.com/generate_204\"\n    interval: 600\n```\n\n确保总是有一个可用的代理服务器。比如用户在进行重要的网络操作，如在线交易，需要确保不会因为代理服务器的问题而中断。\n\n### Load-Balance 负载均衡\n\n```yaml\nLoad-Balance:\n  - name: \"Balance-Group\"\n    type: load-balance\n    proxies:\n      - \"Proxy-A\"\n      - \"Proxy-B\"\n    sticky-session: true\n```\n\n当用户想要在多个代理服务器之间分配负载时。比如用户在下载大文件或进行多线程下载时，可以平均分配流量以优化速度。\n\n### Select 手动选择\n\n```yaml\nSelect:\n  - name: \"Manual-Select\"\n    type: select\n    proxies:\n      - \"Proxy-A\"\n      - \"Proxy-B\"\n    interface-name: \"en0\"\n```\n\n最常用，平常在 Clash 里点点点切换代理服务器的时候基本都是在用 Select 策略组。\n\n适用于用户想要完全控制选择哪个代理服务器。比如用户根据不同的网络活动（如流媒体、游戏或工作）手动切换代理服务器。\n\n### DIRECT 直连出站\n\n```yaml\nDirect:\n  - name: \"Direct-Connection\"\n    type: direct\n    interface-name: \"en0\"\n```\n\n## Outbound 出站 Proxy Providers\n\n前面介绍了 Clash 出站时的 Proxy 和 Proxy Groups，单独的机场订阅链接这两个就够用了。一般情况下是配置文件中配置一串 Proxy，然后 Proxy Groups 中配置一个 Select 策略供用户自行选择，额外再配置几个 url-test 用于实现自动选择和流量监测。\n\n但如果我们有多个机场链接，现在想编写一个统一的配置文件，流畅地在多个订阅之间切换代理服务器，应该怎么做？刚开始的想法可能是 cv 硬编码进去，但这种实现方案比较臃肿。幸好，Clash Premium Core 已经支持了 **Proxy Providers**，实现提供在线规则集，可以通过托管链接获取节点信息，避免了硬编码。\n\n一个可供参考的使用示范如下：\n\n```yaml\n# config.yaml\nproxy-providers:\n  test:\n    type: file\n    path: /test.yaml\n    health-check:\n      enable: true\n      interval: 36000\n      url: http://www.gstatic.com/generate_204\n```\n\n```yaml\n# test.yaml\nproxies:\n  - name: \"ss1\"\n    type: ss\n    server: server\n    port: 443\n    cipher: chacha20-ietf-poly1305\n    password: \"password\"\n\n  - name: \"ss2\"\n    type: ss\n    server: server\n    port: 443\n    cipher: chacha20-ietf-poly1305\n    password: \"password\"\n    plugin: obfs\n    plugin-opts:\n      mode: tls\n```\n\n[Clash proxy-provider 搭配 subconverter 使用小记 - 方寸间](https://www.10101.io/2020/02/12/use-clash-proxy-provider-with-subconverter)\n\n## Rules 规则\n\n规则是 Clash 的精华部分，也是一份配置文档中最为冗长的部分。打开你现在使用的订阅链接配置文件，几千行的配置信息中，可能只有前几十行是出入站配置，剩下的所有都是 rules 规则。\n\n一条规则的基本格式如下：\n\n```yaml\n# 类型,参数,策略(,no-resolve)\nTYPE,ARGUMENT,POLICY(,no-resolve)\n```\n\n其中 `no-resolve` 选项是可选的, 它用于跳过规则的 DNS 解析。当你想要使用 `GEOIP`、`IP-CIDR`、`IP-CIDR6`、`SCRIPT` 规则，但又不想立即将域名解析为 IP 地址时，这个选项就很有用了。\nClash 可用的规则类型其实不多，感觉自己也讲不出什么新点，但不写在着文章里感觉又不完整，索性 cv 了[这份文档](https://clash.wiki/configuration/rules.html#%E8%A7%84%E5%88%99%E7%B1%BB%E5%9E%8B)，就稍微改了下格式，推荐去原文档看。\n\n### DOMAIN 域名\n\n```yaml\nDOMAIN,www.google.com,policy\n```\n\n将 `www.google.com` 路由到 `policy`。\n\n### DOMAIN-SUFFIX 域名后缀\n\n```yaml\nDOMAIN-SUFFIX,youtube.com,policy\n```\n\n将任何以 `youtube.com` 结尾的域名路由到 `policy`。在这种情况下，`www.youtube.com` 和 `foo.bar.youtube.com` 都将路由到 `policy`。\n\n### DOMAIN-KEYWORD 域名关键字\n\n```yaml\nDOMAIN-KEYWORD,google,policy\n```\n\n将任何包含 `google` 关键字的域名路由到 `policy`。在这种情况下，`www.google.com` 或 `googleapis.com` 都将路由到 `policy`。\n\n### GEOIP IP地理位置 (国家代码)\n\nGEOIP 规则用于根据数据包的目标 IP 地址的**国家代码**路由数据包，Clash 使用 [**MaxMind GeoLite2**](https://dev.maxmind.com/geoip/geoip2/geolite2/) 数据库来实现这一功能。使用这种规则时，Clash 将域名解析为 IP 地址，然后查找 IP 地址的国家代码。\n\n```yaml\nGEOIP,CN,policy\n```\n\n将任何目标 IP 地址为中国的数据包路由到 `policy`。\n\n### IP-CIDR IPv4地址段\n\nIP-CIDR 规则用于根据数据包的**目标 IPv4 地址**路由数据包。使用这种规则时, Clash 将域名解析为 IPv4 地址。\n\n```yaml\nIP-CIDR,127.0.0.0/8,DIRECT\n```\n\n将任何目标 IP 地址为 `127.0.0.0/8` 的数据包路由到 `DIRECT`。\n\n### IP-CIDR6 IPv6地址段\n\nIP-CIDR6 规则用于根据数据包的**目标 IPv6 地址**路由数据包。使用这种规则时, Clash 将域名解析为 IPv6 地址。\n\n```yaml\nIP-CIDR6,2620:0:2d0:200::7/32,policy\n```\n\n将任何目标 IP 地址为 `2620:0:2d0:200::7/32` 的数据包路由到 `policy`。\n\n### SRC-IP-CIDR 源IP段地址\n\nSRC-IP-CIDR 规则用于根据数据包的**源 IPv4 地址**路由数据包。\n\n```yaml\nSRC-IP-CIDR,192.168.1.201/32,DIRECT\n```\n\n将任何源 IP 地址为 `192.168.1.201/32` 的数据包路由到 `DIRECT`。\n\n### SRC-PORT 源端口\n\nSRC-PORT 规则用于根据数据包的**源端口**路由数据包。\n\n```yaml\nSRC-PORT,80,policy\n```\n\n将任何源端口为 `80` 的数据包路由到 `policy`。\n\n### DST-PORT 目标端口\n\nDST-PORT 规则用于根据数据包的**目标端口**路由数据包。\n\n```yaml\nDST-PORT,80,policy\n```\n\n将任何目标端口为 `80` 的数据包路由到 `policy`。\n\n### PROCESS-NAME 源进程名\n\nPROCESS-NAME 规则用于根据发送数据包的进程名称路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。\n\n```yaml\nPROCESS-NAME,nc,DIRECT\n```\n\n将任何来自进程 `nc` 的数据包路由到 `DIRECT`。\n\n### PROCESS-PATH 源进程路径\n\nPROCESS-PATH 规则用于根据发送数据包的进程路径路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。\n\n```yaml\nPROCESS-PATH,/usr/local/bin/nc,DIRECT\n```\n\n将任何来自路径为 `/usr/local/bin/nc` 的进程的数据包路由到 `DIRECT`。\n\n### IPSET IP集\n\nIPSET 规则用于根据 IP 集匹配并路由数据包. 根据 [**IPSET 的官方网站**](https://ipset.netfilter.org/) 的介绍:\n\n> IP 集是 Linux 内核中的一个框架, 可以通过 ipset 程序进行管理。根据类型，IP 集可以存储 IP 地址、网络、 (TCP/UDP) 端口号、MAC 地址、接口名称或它们以某种方式的组合，以确保在集合中匹配条目时具有闪电般的速度。\n> \n\n因此, 此功能仅在 Linux 上工作, 并且需要安装 `ipset`。使用此规则时, Clash 将解析域名以获取 IP 地址, 然后查找 IP 地址是否在 IP 集中. 如果要跳过 DNS 解析, 请使用 **`no-resolve`** 选项.\n\n```yaml\nIPSET,chnroute,policy\n```\n\n将任何目标 IP 地址在 IP 集 `chnroute` 中的数据包路由到 `policy`.\n\n### RULE-SET 规则集\n\n此功能仅在 [**Premium 版本**](https://clash.wiki/premium/introduction.html) 中可用。\n\nRULE-SET 规则用于根据 [**Rule Providers 规则集**](https://clash.wiki/premium/rule-providers.html) 的结果路由数据包。当 Clash 使用此规则时，它会从指定的 Rule Providers 规则集中加载规则，然后将数据包与规则进行匹配。 如果数据包与任何规则匹配，则将数据包路由到指定的策略, 否则跳过此规则。\n\n使用 RULE-SET 时，当规则集的类型为 IPCIDR ，Clash 将解析域名以获取 IP 地址。\n\n```yaml\nRULE-SET,my-rule-provider,DIRECT\n```\n\n从 `my-rule-provider` 加载所有规则。\n\n### SCRIPT 脚本\n\n此功能仅在 [**Premium 版本**](https://clash.wiki/premium/introduction.html) 中可用。\n\nSCRIPT 规则用于根据脚本的结果路由数据包。当 Clash 使用此规则时，它会执行指定的脚本，然后将数据包路由到脚本的输出。使用 SCRIPT 时，Clash 将解析域名以获取 IP 地址。\n\n```yaml\nSCRIPT,script-path,DIRECT\n```\n\n将数据包路由到脚本 `script-path` 的输出.\n\n### MATCH 全匹配\n\nMATCH 规则用于路由剩余的数据包。该规则是**必需**的，通常用作最后一条规则。\n\n```yaml\nMATCH,policy\n```\n\n将剩余的数据包路由到 `policy`。\n\n## 透明代理\n\n### tproxy\n\n参考：[tproxy（透明代理）](https://www.zhaohuabing.com/learning-linux/docs/tproxy/)\n\ntproxy 即 transparent（透明） proxy。这里的 transparent（透明）有两层含义：\n\n1. 代理对于 client 是透明的，client 端无需进行任何配置。即无需修改请求地址，也无需采用代理协议和代理服务器进行协商。与之相对比的是 socks 代理或者 http 代理，需要在 client 端设置代理的地址，在发起请求时也需要通过代理协议告知代理服务器其需要访问的真实地址。\n2. 代理对于 server 是透明的，server 端看到的是 client 端的地址，而不是 proxy 的地址\n\n这么说可能不够直观，通过下面这张图看会比较好，后者为透明代理，可以清晰地看到 client 发出请求的目的 IP 就是目标服务器的 IP：\n\n![20240613024955](https://img.ma5hr00m.top/blog/20240613024955.png)\n\n从上面的描述能看出来，因为透明代理是在网络层面实现的，实现了全局代理的效果，所以无需在每个应用程序中配置，简化了操作，也在一定程度上增强了代理的隐蔽性。\n\n但由于客户端请求数据包的目的地址不是代理服务器，因此需要通过路由和 iptables 规则（Clash 实现，无需用户手动操作）将客户端的请求发送给代理服务器处理。\n\n### redirect\n\nredirect 是另一种实现透明代理的方式。redirect 透明代理主要用于 TCP 流量，是通过修改数据包的目的端口来实现的。这种方法不需要像 tproxy 那样在网络层面进行操作，而是在传输层上实现的。\n\n以下是 Clash 基于 redirect 实现透明代理的过程：\n\n1. 当客户端发起一个 TCP 连接时，iptables 规会捕获到这个连接请求；\n2. 根据设置的规则，iptables 会将这个连接的目的端口重定向到 Clash 监听的端口上；\n3. Clash 接收到这个连接后，根据内部的规则处理，然后将流量转发到真正的目标服务器。\n\n使用 redirect 的优点是配置相对简单，特别是在不支持 tproxy 的系统上。它可以直接在 iptables 中设置，无需对操作系统的网络栈进行复杂的配置。这使得 redirect 成为一个在简单场景下快速部署透明代理的好选择。","source":"_posts/how_does_clash_work.md","raw":"---\ntitle: 你知道 Clash 吗？\ndate: 2024/6/12\nauthor: ma5hr00m\ncategories:\n- Network\n---\n\n[什么是 Clash? | Clash 知识库](https://clash.wiki/)\n\n有一说一，大家肯定都知道 Clash，但很多人对这东西的印象就是一个翻墙工具，导入订阅链接点几下就行，并不理解 Clash 究竟做了什么。\n\nClash 是一个运行在网络层和应用层的、基于规则的代理工具，它所能做的不仅仅是帮你转发流量到互联网访问其它应用（当然这算是主要功能）。Clash 在本质上是对用户本机的流量进行管理，实现智能路由和访问控制，如果你会写 Clash 配置文件的话，就可以轻松实现访问外网应用时自动走代理，而在访问指定国内应用时不走代理直接访问。\n\n其工作原理和工作流程说来也简单，用一句话就能解释清楚：接收本机流量后根据规则进行转发，下文会对这一过程进行介绍。\n\n看完这篇文章，你应该可以对 Clash 的本质以及其工作原理有一个相对清晰的认识，可以轻松看懂那些“订阅链接”背后是什么，并且可以独立编写 Clash 配置文件。\n\n## 工作流程\n\n我们可以把 Clash 的工作过程简单分为三步，\n\n1. **Inbound 入站：**当你在设备上启动 Clash 时，它会创建一个或多个本地监听端口，这些端口用于接收来自设备上的应用程序的网络请求；\n2. **基于规则的路由：**Clash 配置文件中的 **`rules`** 部分定义了如何处理不同类型的网络请求。例如上文说的只转发部分流量；\n3. **Outbound 出站：**Clash 根据配置文件中的规则，将入站的网络请求转发到不同的出站连接，可以连接到某个网络接口、某个代理服务器，也可以是某个策略组。\n\n![20240613024509](https://img.ma5hr00m.top/blog/20240613024509.png)\n\n## 四种代理模式\n\n在 Clash 操作页面，可以看到四种代理模式，一般情况下选择“规则”就好，足够用户使用。这里对这四种都做一下介绍：\n\n1. **规则（Rule）**：这是 Clash 配置中最重要的部分之一。规则用于定义哪些流量应该被代理，哪些应该直连。用户可以根据域名、IP、地理位置等条件来设置规则。\n2. **直连（Direct）**：直连选项通常用于设置哪些流量不需要通过代理服务器直接访问。这通常用于访问本地网络资源或者信任的网站。\n3. **全局（Global）**：全局模式下，所有的网络流量都会通过代理服务器。这个模式适用于需要代理所有流量的情况。\n4. **脚本（Script）**：脚本功能允许用户编写或使用现有的 JavaScript 脚本来自定义复杂的流量处理逻辑，比如修改请求头、响应内容等，从而实现更灵活的分流规则。\n\n## 配置文件\n\n[https://clash.skk.moe/](https://clash.skk.moe/)\n\n前面说的入站、入站和规则都需要在配置文件中指定。Clash 的主配置文件名为 `config.yaml`，默认情况下会在 `$HOME/.config/clash` 目录读取配置文件。如果该目录不存在，Clash 会在该位置生成一个最小的配置文件。\n\n如果需要指定其他位置的配置文件，需要在命令行中使用 `-f` 参数：\n\n```bash\nclash -f /etc/clash/config.yaml\n```\n\n一份完整的 Clash 配置文件包括多个部分，下面一一介绍。\n\n### General 配置\n\n在 Clash 配置文件中，General 配置包含了一些必需的字段以及可选的配置项，通常位于配置文件开头部分。其中 `port`，`socks-port` 和 `allow-lan` 是必需的字段，用于指定 Clash 的端口、SOCKS5 代理端口以及是否允许局域网连接。如果需要启用透明代理，还需要指定 `redir-port` 字段，用于指定透明代理的端口。\n\n还有个特殊的 `mixed` 字段，用于指定混合配置端口，这个端口同时支持 HTTP(S) 和 SOCKS5 协议。\n\n除了这些必需字段外，还有一些可选的配置项，下面简单罗列几个：\n\n- `dns`：用于配置DNS相关设置。\n- `external-controller`：用于指定 RESTful API 的地址和端口。\n- `secret`：可选项，用于设置 RESTful API 的密钥。\n- `cfw-bypass`：可选项，用于配置规则以绕过代理。\n\n在编写 General 配置时可以参考以下内容，各个字段的作用都以注释的形式标注：\n\n```yaml\nport: 7890 # HTTP端口\nsocks-port: 7891 # SOCKS5端口\nredir-port: 7892 # Linux和macOS的重定向端口\nmixed: 7893 # 混合端口\nallow-lan: false\n\n# 仅在设置allow-lan为true时适用\n# \"*\": 绑定所有IP地址\n# 192.168.122.11: 绑定单个IPv4地址\n# \"[aaaa::a8aa:ff:fe09:57d8]\": 绑定单个IPv6地址\nbind-address: \"*\"\n\n# Rule / Global/ Direct（默认为Rule）\nmode: Rule\n\n# 将日志级别设置为stdout（默认为info）\n# info / warning / error / debug / silent\nlog-level: info\n\nexternal-controller: 127.0.0.1:9090 # Clash的RESTful API\n\n# 您可以将静态Web资源（如clash-dashboard）放入一个目录，并且Clash将在`${API}/ui`中提供服务\n# 输入是相对于配置目录的相对路径或绝对路径\nexternal-ui: \"path/to/local/clash-dashboard\"\n\nsecret: \"\" # RESTful API的密钥（可选）\n\nexperimental: # 实验性功能\n  ignore-resolve-fail: true # 忽略DNS解析失败，默认值为true\n\n# 本地SOCKS5/HTTP(S)服务器的身份验证\nauthentication:\n  - \"user1:pass1\"\n  - \"user2:pass2\"\n\n# 实验性主机，支持通配符（例如*.clash.dev 甚至*.foo.*.example.com）\n# 静态域比通配符域具有更高的优先级（foo.example.com > *.example.com）\nhosts:\n  '*.clash.dev': 127.0.0.1\n  'alpha.clash.dev': '::1'\n\ndns:\n  enable: true # 设置为true以启用DNS（默认为false）\n  ipv6: false # 默认为false\n  listen: 0.0.0.0:53\n  enhanced-mode: fake-ip # 或redir-host\n  fake-ip-range: 198.18.0.1/16 # 如果不知道是什么，请勿更改\n  nameserver:\n    - 114.114.114.114\n    - tcp://1.1.1.1\n  fallback: # 与nameserver并发请求，当GEOIP国家不是CN时使用fallback\n    - tls://dns.rubyfish.cn:853 # DNS over TLS\n    - https://1.1.1.1/dns-query # DNS over HTTPS\n  fallback-filter:\n    geoip: true # 默认\n    ipcidr: # 这些子网中的IP将被视为污染\n      - 240.0.0.0/4\n```\n\n### Proxy 配置\n\nProxy 配置以及 Proxy Group 配置就是 Clash 控制流量出站的主要配置。\n\nProxy 配置用于指定 Clash 连接代理服务器的相关信息。这包括代理服务器的地址、端口、类型等信息。通过正确配置这一部分，Clash 可以根据你的需求将流量转发到不同的代理服务器。例如，你可以设置多个代理节点，并为它们指定不同的类型，如 **`ss`**、**`vmess`**、**`socks5`**、**`http`** 和 **`snell`**。\n\n配置 Proxy 部分时可以参考以下内容：\n\n```yaml\nproxy:\n  # shadowsocks\n  - name: \"ss1\"\n    type: ss\n    server: server\n    port: 443\n    cipher: chacha20-ietf-poly1305\n    password: \"password\"\n    # udp: true\n\n  - name: \"ss2\"\n    type: ss\n    server: server\n    port: 443\n    cipher: chacha20-ietf-poly1305\n    password: \"password\"\n    plugin: v2ray-plugin\n    plugin-opts:\n      mode: websocket\n      # tls: true\n      # skip-cert-verify: true\n      # host: bing.com\n      # path: \"/\"\n      # mux: true\n      # headers:\n      #   custom: value\n\n  # vmess\n  - name: \"vmess\"\n    type: vmess\n    server: server\n    port: 443\n    uuid: uuid\n    alterid: 32\n    cipher: auto\n    # udp: true\n    # tls: true\n    # skip-cert-verify: true\n    # network: ws\n    # ws-path: /path\n    # ws-headers:\n    #   host: v2ray.com\n\n  # socks5\n  - name: \"socks\"\n    type: socks5\n    server: server\n    port: 443\n    # username: username\n    # password: password\n    # tls: true\n    # skip-cert-verify: true\n    # udp: true\n\n  # http\n  - name: \"http\"\n    type: http\n    server: server\n    port: 443\n    # username: username\n    # password: password\n    # tls: true\n    # skip-cert-verify: true\n\n  # snell\n  - name: \"snell\"\n    type: snell\n    server: server\n    port: 44046\n    psk: yourpsk\n    # obfs-opts:\n    #   mode: http\n    #   host: bing.com\n```\n\n### Proxy Group 配置\n\nproxy group 配置部分的作用是定义策略组，这些策略组可以在规则中使用来决定网络请求通过哪个代理节点。策略组允许你根据不同的场景和需求，组合和管理多个代理节点。例如，你可以创建一个策略组来自动选择延迟最低的节点，或者创建一个策略组来手动选择特定的节点。\n\n配置 Proxy Group 部分时可以参考以下内容：\n\n```yaml\nproxy-group:\n  # url-test 通过测试访问 URL 的速度来选择使用哪个代理。\n  - name: \"auto\"\n    type: url-test\n    proxies:\n      - ss1\n      - ss2\n      - vmess1\n    url: 'http://www.gstatic.com/generate_204'\n    interval: 300\n\n  # fallback 通过优先级选择可用的策略。可用性通过访问 URL 来测试，就像自动 url-test 组一样。\n  - name: \"fallback-auto\"\n    type: fallback\n    proxies:\n      - ss1\n      - ss2\n      - vmess1\n    url: 'http://www.gstatic.com/generate_204'\n    interval: 300\n\n  # load-balance: 相同 eTLD 的请求将在同一个代理上拨号。\n  - name: \"load-balance\"\n    type: load-balance\n    proxies:\n      - ss1\n      - ss2\n      - vmess1\n    url: 'http://www.gstatic.com/generate_204'\n    interval: 300\n\n  # select 用于选择代理或代理组\n  # 您可以使用 RESTful API 切换代理，推荐在 GUI 中使用。\n  - name: Proxy\n    type: select\n    proxies:\n      - ss1\n      - ss2\n      - vmess1\n      - auto\n```\n\n### Rule 配置\n\nRule 配置部分的作用是定义网络请求的匹配规则，以决定哪些请求应该被代理、直连或拒绝。这些规则基于请求的不同属性，如域名、IP 地址、端口号或地理位置来匹配流量。\n\n配置 Rule 部分时可以参考以下内容：\n\n```yaml\nrule:\n  - domain-suffix,google.com,[策略组的名称]\n  - domain-keyword,google,[策略组的名称]\n  - domain,google.com,[策略组的名称]\n  - domain-suffix,ad.com,REJECT\n  - ip-cidr,127.0.0.0/8,DIRECT\n  # rename source-ip-cidr and would remove after prerelease\n  - src-ip-cidr,192.168.1.201/32,DIRECT\n  - geoip,CN,DIRECT\n  - dst-port,80,DIRECT\n  - src-port,7777,DIRECT\n  # final would remove after prerelease\n  # you also can use `final,Proxy` or `final,,Proxy` now\n  - match,[策略组的名称]\n```\n\n后面会详细介绍每一种可用的规则，后面再细看。\n\n## Inbound 入站协议\n\n- SOCKS5\n- HTTP(S)\n- Redirect TCP\n- TProxy TCP\n- TProxy UDP\n- Linux TUN 设备（仅 Premium 版本）\n\n[一口气搞明白有点奇怪的 Socks 5 协议以及 HTTP 代理](https://www.txthinking.com/talks/articles/socks5-and-http-proxy.article)\n\n入站协议中主要就是对 SOCKS5 和 HTTP 做区分，三种透明代理后面单独说。\n\nSOCKS5 代理提供全面的网络协议支持，支持认证、更安全，同时支持 UDP 协议，以及提供了较好的性能和兼容性。HTTP 代理则仅能代理 HTTP 和 HTTPS 协议的流量，通常用于网页浏览，它可以高效地缓存数据，降低带宽消耗，但不适用于所有网络协议。\n\n一般浏览网页的话配个 HTTP 代理就行，其他情况直接 SOCKS5。\n\n## Outbound 出站 Proxy\n\nClash 出站种类较多，且各自使用场景不同。前面讲过了配置文件的写法，可以把 Clash 出站分为 Proxy 和 Proxy Group 两种，这里也分开介绍。\n\n### Shadowsocks/ShadowsocksR\n\n[Shadowsocks/SS教程 - tlanyan](https://itlanyan.com/on-fuck-gfw-again/)\n\n**Shadowsocks** 是一个基于 SOCKS5 协议的加密代理，它使用各种加密方法来保护数据流。Clash 支持的 Shadowsocks 加密方法包括：\n\n| 系列 | 加密方法 |\n| --- | --- |\n| AEAD | aes-128-gcm, aes-192-gcm, aes-256-gcm, chacha20-ietf-poly1305, xchacha20-ietf-poly1305 |\n| 流式 | aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20 |\n| 块式 | aes-128-ctr, aes-192-ctr, aes-256-ctr |\n\n此外，Clash 还支持 Shadowsocks 的插件，如 obfs 和 v2ray-plugin，这些插件可以提供额外的混淆功能，进一步增强隐私保护。\n\n**ShadowsocksR** 是 Shadowsocks 的一个扩展版本，它增加了更多的混淆和协议选项，以提高抗审查能力。Clash 支持的 ShadowsocksR 加密方法和混淆方法包括：\n\n| 系列 | 加密方法 |\n| --- | --- |\n| 流式 | aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20 |\n\n一般情况下，我们现在各种平台的订阅基本都是默认的 ss 协议。\n\n补充个小趣闻，ssr 协议在其发展过程中引起了一些争议。最初，ssr 项目因为违反 GPL 许可证而受到批评。原开发者对此表示不满，因为这违反了开源项目的基本原则。后来，ssr 项目改为采用与 ss 相同的 GPL、Apache 许可证、MIT 许可证等多重自由软件许可协议，缓解了部分争议。\n\n### Vmess\n\n**VMess** 是一个无状态的加密通信协议，且所有数据都通过 TCP 传输。\n\n每当 VMess 客户端发起请求时，服务器会判断是否来自合法客户端。如果验证通过，请求就会被转发。之后，获得的响应会被发送回客户端。VMess 使用非对称格式，客户端的请求和服务器的响应格式不同。\n\nClash 支持以下 Vmess 的加密方法:\n\n- auto：自动选择，默认值。\n- aes-128-gcm：推荐在 PC 上使用。它是一种高效的加密算法，通常用于需要高吞吐量的应用。\n- chacha20-poly1305：推荐在移动设备上使用。它适用于那些没有硬件AES 加速的设备，因为它在软件实现中更快。\n- none\n\n### SOCKS5\n\n### HTTP\n\n### Snell\n\nClash 也集成了对 Snell 的支持。\n\n**Snell** 是一种精简的加密代理协议，由 Surge 团队开发，也是一种较为经典的反审查协议。它的设计初衷是为了提供极致的性能和简单的配置过程，同时支持 UDP over TCP中继。此外，Snell 是单一二进制文件，零依赖（除了glibc），这也使得 Snell 易于部署和维护。\n该协议的使用场景主要集中在需要绕过网络审查、保护隐私和数据加密的环境中。由于其高性能和简单配置的特点，Snell适用于个人用户和小型企业，尤其是在网络审查较为严格的地区。\n\n小提示，Snell@v4 没有提供向下兼容，需要客户端服务端均进行升级。\n\n想知道更多相关知识去看这个 gitbook：https://manual.nssurge.com/others/snell.html\n\n### Trojan\n\nClash 内置了对流行协议 Trojan 的支持。\n\n**Trojan** 是近几年才兴起的网络工具，特点同样是确保数据传输的安全性和隐私性。但与传统的 ss/ssr 不同的是，ss/ssr 保证数据传输安全的手段是加密混淆，而 Trojan 的思路是将流量伪装成最常见的 HTTPS 流量。\n\n[trojan教程 - tlanyan](https://itlanyan.com/trojan-tutorial/)\n\n## Outbound 出站 Proxy Groups\n\nProxy Groups 策略组用于根据不同策略分发规则传递过来的请求，其可以直接被规则引用，也可以被其他策略组引用，而最上级策略组被规则引用。\n\n### Relay 中继\n\n```yaml\nRelay:\n  - name: \"US-JP Relay\"\n    type: relay\n    proxies:\n      - \"US-Proxy\"\n      - \"JP-Proxy\"\n```\n\n适用于当用户需要将流量通过特定的国家或地区进行中继时。比如用户想要访问仅限日本的内容，但同时想要通过美国的代理增加匿名性。\n\n### URL-Test 延迟测试\n\n```yaml\nUrl-Test:\n  - name: \"Fastest-Proxy\"\n    type: url-test\n    proxies:\n      - \"Proxy-A\"\n      - \"Proxy-B\"\n    url: \"http://www.gstatic.com/generate_204\"\n    interval: 600\n```\n\n自动选择延迟最低的代理服务器。比如用户在进行在线游戏或视频会议时，需要确保连接是最快的。\n\n### Fallback 可用性测试\n\n```yaml\nFallback:\n  - name: \"Available-Proxy\"\n    type: fallback\n    proxies:\n      - \"Proxy-A\"\n      - \"Proxy-B\"\n    url: \"http://www.gstatic.com/generate_204\"\n    interval: 600\n```\n\n确保总是有一个可用的代理服务器。比如用户在进行重要的网络操作，如在线交易，需要确保不会因为代理服务器的问题而中断。\n\n### Load-Balance 负载均衡\n\n```yaml\nLoad-Balance:\n  - name: \"Balance-Group\"\n    type: load-balance\n    proxies:\n      - \"Proxy-A\"\n      - \"Proxy-B\"\n    sticky-session: true\n```\n\n当用户想要在多个代理服务器之间分配负载时。比如用户在下载大文件或进行多线程下载时，可以平均分配流量以优化速度。\n\n### Select 手动选择\n\n```yaml\nSelect:\n  - name: \"Manual-Select\"\n    type: select\n    proxies:\n      - \"Proxy-A\"\n      - \"Proxy-B\"\n    interface-name: \"en0\"\n```\n\n最常用，平常在 Clash 里点点点切换代理服务器的时候基本都是在用 Select 策略组。\n\n适用于用户想要完全控制选择哪个代理服务器。比如用户根据不同的网络活动（如流媒体、游戏或工作）手动切换代理服务器。\n\n### DIRECT 直连出站\n\n```yaml\nDirect:\n  - name: \"Direct-Connection\"\n    type: direct\n    interface-name: \"en0\"\n```\n\n## Outbound 出站 Proxy Providers\n\n前面介绍了 Clash 出站时的 Proxy 和 Proxy Groups，单独的机场订阅链接这两个就够用了。一般情况下是配置文件中配置一串 Proxy，然后 Proxy Groups 中配置一个 Select 策略供用户自行选择，额外再配置几个 url-test 用于实现自动选择和流量监测。\n\n但如果我们有多个机场链接，现在想编写一个统一的配置文件，流畅地在多个订阅之间切换代理服务器，应该怎么做？刚开始的想法可能是 cv 硬编码进去，但这种实现方案比较臃肿。幸好，Clash Premium Core 已经支持了 **Proxy Providers**，实现提供在线规则集，可以通过托管链接获取节点信息，避免了硬编码。\n\n一个可供参考的使用示范如下：\n\n```yaml\n# config.yaml\nproxy-providers:\n  test:\n    type: file\n    path: /test.yaml\n    health-check:\n      enable: true\n      interval: 36000\n      url: http://www.gstatic.com/generate_204\n```\n\n```yaml\n# test.yaml\nproxies:\n  - name: \"ss1\"\n    type: ss\n    server: server\n    port: 443\n    cipher: chacha20-ietf-poly1305\n    password: \"password\"\n\n  - name: \"ss2\"\n    type: ss\n    server: server\n    port: 443\n    cipher: chacha20-ietf-poly1305\n    password: \"password\"\n    plugin: obfs\n    plugin-opts:\n      mode: tls\n```\n\n[Clash proxy-provider 搭配 subconverter 使用小记 - 方寸间](https://www.10101.io/2020/02/12/use-clash-proxy-provider-with-subconverter)\n\n## Rules 规则\n\n规则是 Clash 的精华部分，也是一份配置文档中最为冗长的部分。打开你现在使用的订阅链接配置文件，几千行的配置信息中，可能只有前几十行是出入站配置，剩下的所有都是 rules 规则。\n\n一条规则的基本格式如下：\n\n```yaml\n# 类型,参数,策略(,no-resolve)\nTYPE,ARGUMENT,POLICY(,no-resolve)\n```\n\n其中 `no-resolve` 选项是可选的, 它用于跳过规则的 DNS 解析。当你想要使用 `GEOIP`、`IP-CIDR`、`IP-CIDR6`、`SCRIPT` 规则，但又不想立即将域名解析为 IP 地址时，这个选项就很有用了。\nClash 可用的规则类型其实不多，感觉自己也讲不出什么新点，但不写在着文章里感觉又不完整，索性 cv 了[这份文档](https://clash.wiki/configuration/rules.html#%E8%A7%84%E5%88%99%E7%B1%BB%E5%9E%8B)，就稍微改了下格式，推荐去原文档看。\n\n### DOMAIN 域名\n\n```yaml\nDOMAIN,www.google.com,policy\n```\n\n将 `www.google.com` 路由到 `policy`。\n\n### DOMAIN-SUFFIX 域名后缀\n\n```yaml\nDOMAIN-SUFFIX,youtube.com,policy\n```\n\n将任何以 `youtube.com` 结尾的域名路由到 `policy`。在这种情况下，`www.youtube.com` 和 `foo.bar.youtube.com` 都将路由到 `policy`。\n\n### DOMAIN-KEYWORD 域名关键字\n\n```yaml\nDOMAIN-KEYWORD,google,policy\n```\n\n将任何包含 `google` 关键字的域名路由到 `policy`。在这种情况下，`www.google.com` 或 `googleapis.com` 都将路由到 `policy`。\n\n### GEOIP IP地理位置 (国家代码)\n\nGEOIP 规则用于根据数据包的目标 IP 地址的**国家代码**路由数据包，Clash 使用 [**MaxMind GeoLite2**](https://dev.maxmind.com/geoip/geoip2/geolite2/) 数据库来实现这一功能。使用这种规则时，Clash 将域名解析为 IP 地址，然后查找 IP 地址的国家代码。\n\n```yaml\nGEOIP,CN,policy\n```\n\n将任何目标 IP 地址为中国的数据包路由到 `policy`。\n\n### IP-CIDR IPv4地址段\n\nIP-CIDR 规则用于根据数据包的**目标 IPv4 地址**路由数据包。使用这种规则时, Clash 将域名解析为 IPv4 地址。\n\n```yaml\nIP-CIDR,127.0.0.0/8,DIRECT\n```\n\n将任何目标 IP 地址为 `127.0.0.0/8` 的数据包路由到 `DIRECT`。\n\n### IP-CIDR6 IPv6地址段\n\nIP-CIDR6 规则用于根据数据包的**目标 IPv6 地址**路由数据包。使用这种规则时, Clash 将域名解析为 IPv6 地址。\n\n```yaml\nIP-CIDR6,2620:0:2d0:200::7/32,policy\n```\n\n将任何目标 IP 地址为 `2620:0:2d0:200::7/32` 的数据包路由到 `policy`。\n\n### SRC-IP-CIDR 源IP段地址\n\nSRC-IP-CIDR 规则用于根据数据包的**源 IPv4 地址**路由数据包。\n\n```yaml\nSRC-IP-CIDR,192.168.1.201/32,DIRECT\n```\n\n将任何源 IP 地址为 `192.168.1.201/32` 的数据包路由到 `DIRECT`。\n\n### SRC-PORT 源端口\n\nSRC-PORT 规则用于根据数据包的**源端口**路由数据包。\n\n```yaml\nSRC-PORT,80,policy\n```\n\n将任何源端口为 `80` 的数据包路由到 `policy`。\n\n### DST-PORT 目标端口\n\nDST-PORT 规则用于根据数据包的**目标端口**路由数据包。\n\n```yaml\nDST-PORT,80,policy\n```\n\n将任何目标端口为 `80` 的数据包路由到 `policy`。\n\n### PROCESS-NAME 源进程名\n\nPROCESS-NAME 规则用于根据发送数据包的进程名称路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。\n\n```yaml\nPROCESS-NAME,nc,DIRECT\n```\n\n将任何来自进程 `nc` 的数据包路由到 `DIRECT`。\n\n### PROCESS-PATH 源进程路径\n\nPROCESS-PATH 规则用于根据发送数据包的进程路径路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。\n\n```yaml\nPROCESS-PATH,/usr/local/bin/nc,DIRECT\n```\n\n将任何来自路径为 `/usr/local/bin/nc` 的进程的数据包路由到 `DIRECT`。\n\n### IPSET IP集\n\nIPSET 规则用于根据 IP 集匹配并路由数据包. 根据 [**IPSET 的官方网站**](https://ipset.netfilter.org/) 的介绍:\n\n> IP 集是 Linux 内核中的一个框架, 可以通过 ipset 程序进行管理。根据类型，IP 集可以存储 IP 地址、网络、 (TCP/UDP) 端口号、MAC 地址、接口名称或它们以某种方式的组合，以确保在集合中匹配条目时具有闪电般的速度。\n> \n\n因此, 此功能仅在 Linux 上工作, 并且需要安装 `ipset`。使用此规则时, Clash 将解析域名以获取 IP 地址, 然后查找 IP 地址是否在 IP 集中. 如果要跳过 DNS 解析, 请使用 **`no-resolve`** 选项.\n\n```yaml\nIPSET,chnroute,policy\n```\n\n将任何目标 IP 地址在 IP 集 `chnroute` 中的数据包路由到 `policy`.\n\n### RULE-SET 规则集\n\n此功能仅在 [**Premium 版本**](https://clash.wiki/premium/introduction.html) 中可用。\n\nRULE-SET 规则用于根据 [**Rule Providers 规则集**](https://clash.wiki/premium/rule-providers.html) 的结果路由数据包。当 Clash 使用此规则时，它会从指定的 Rule Providers 规则集中加载规则，然后将数据包与规则进行匹配。 如果数据包与任何规则匹配，则将数据包路由到指定的策略, 否则跳过此规则。\n\n使用 RULE-SET 时，当规则集的类型为 IPCIDR ，Clash 将解析域名以获取 IP 地址。\n\n```yaml\nRULE-SET,my-rule-provider,DIRECT\n```\n\n从 `my-rule-provider` 加载所有规则。\n\n### SCRIPT 脚本\n\n此功能仅在 [**Premium 版本**](https://clash.wiki/premium/introduction.html) 中可用。\n\nSCRIPT 规则用于根据脚本的结果路由数据包。当 Clash 使用此规则时，它会执行指定的脚本，然后将数据包路由到脚本的输出。使用 SCRIPT 时，Clash 将解析域名以获取 IP 地址。\n\n```yaml\nSCRIPT,script-path,DIRECT\n```\n\n将数据包路由到脚本 `script-path` 的输出.\n\n### MATCH 全匹配\n\nMATCH 规则用于路由剩余的数据包。该规则是**必需**的，通常用作最后一条规则。\n\n```yaml\nMATCH,policy\n```\n\n将剩余的数据包路由到 `policy`。\n\n## 透明代理\n\n### tproxy\n\n参考：[tproxy（透明代理）](https://www.zhaohuabing.com/learning-linux/docs/tproxy/)\n\ntproxy 即 transparent（透明） proxy。这里的 transparent（透明）有两层含义：\n\n1. 代理对于 client 是透明的，client 端无需进行任何配置。即无需修改请求地址，也无需采用代理协议和代理服务器进行协商。与之相对比的是 socks 代理或者 http 代理，需要在 client 端设置代理的地址，在发起请求时也需要通过代理协议告知代理服务器其需要访问的真实地址。\n2. 代理对于 server 是透明的，server 端看到的是 client 端的地址，而不是 proxy 的地址\n\n这么说可能不够直观，通过下面这张图看会比较好，后者为透明代理，可以清晰地看到 client 发出请求的目的 IP 就是目标服务器的 IP：\n\n![20240613024955](https://img.ma5hr00m.top/blog/20240613024955.png)\n\n从上面的描述能看出来，因为透明代理是在网络层面实现的，实现了全局代理的效果，所以无需在每个应用程序中配置，简化了操作，也在一定程度上增强了代理的隐蔽性。\n\n但由于客户端请求数据包的目的地址不是代理服务器，因此需要通过路由和 iptables 规则（Clash 实现，无需用户手动操作）将客户端的请求发送给代理服务器处理。\n\n### redirect\n\nredirect 是另一种实现透明代理的方式。redirect 透明代理主要用于 TCP 流量，是通过修改数据包的目的端口来实现的。这种方法不需要像 tproxy 那样在网络层面进行操作，而是在传输层上实现的。\n\n以下是 Clash 基于 redirect 实现透明代理的过程：\n\n1. 当客户端发起一个 TCP 连接时，iptables 规会捕获到这个连接请求；\n2. 根据设置的规则，iptables 会将这个连接的目的端口重定向到 Clash 监听的端口上；\n3. Clash 接收到这个连接后，根据内部的规则处理，然后将流量转发到真正的目标服务器。\n\n使用 redirect 的优点是配置相对简单，特别是在不支持 tproxy 的系统上。它可以直接在 iptables 中设置，无需对操作系统的网络栈进行复杂的配置。这使得 redirect 成为一个在简单场景下快速部署透明代理的好选择。","slug":"how_does_clash_work","published":1,"updated":"2024-06-14T17:34:50.868Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap2000ff4ly2cg2e96d","content":"<p><a href=\"https://clash.wiki/\">什么是 Clash? | Clash 知识库</a></p>\n<p>有一说一，大家肯定都知道 Clash，但很多人对这东西的印象就是一个翻墙工具，导入订阅链接点几下就行，并不理解 Clash 究竟做了什么。</p>\n<p>Clash 是一个运行在网络层和应用层的、基于规则的代理工具，它所能做的不仅仅是帮你转发流量到互联网访问其它应用（当然这算是主要功能）。Clash 在本质上是对用户本机的流量进行管理，实现智能路由和访问控制，如果你会写 Clash 配置文件的话，就可以轻松实现访问外网应用时自动走代理，而在访问指定国内应用时不走代理直接访问。</p>\n<p>其工作原理和工作流程说来也简单，用一句话就能解释清楚：接收本机流量后根据规则进行转发，下文会对这一过程进行介绍。</p>\n<p>看完这篇文章，你应该可以对 Clash 的本质以及其工作原理有一个相对清晰的认识，可以轻松看懂那些“订阅链接”背后是什么，并且可以独立编写 Clash 配置文件。</p>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p>我们可以把 Clash 的工作过程简单分为三步，</p>\n<ol>\n<li><strong>Inbound 入站：</strong>当你在设备上启动 Clash 时，它会创建一个或多个本地监听端口，这些端口用于接收来自设备上的应用程序的网络请求；</li>\n<li><strong>基于规则的路由：</strong>Clash 配置文件中的 <strong><code>rules</code></strong> 部分定义了如何处理不同类型的网络请求。例如上文说的只转发部分流量；</li>\n<li><strong>Outbound 出站：</strong>Clash 根据配置文件中的规则，将入站的网络请求转发到不同的出站连接，可以连接到某个网络接口、某个代理服务器，也可以是某个策略组。</li>\n</ol>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240613024509.png\" alt=\"20240613024509\"></p>\n<h2 id=\"四种代理模式\"><a href=\"#四种代理模式\" class=\"headerlink\" title=\"四种代理模式\"></a>四种代理模式</h2><p>在 Clash 操作页面，可以看到四种代理模式，一般情况下选择“规则”就好，足够用户使用。这里对这四种都做一下介绍：</p>\n<ol>\n<li><strong>规则（Rule）</strong>：这是 Clash 配置中最重要的部分之一。规则用于定义哪些流量应该被代理，哪些应该直连。用户可以根据域名、IP、地理位置等条件来设置规则。</li>\n<li><strong>直连（Direct）</strong>：直连选项通常用于设置哪些流量不需要通过代理服务器直接访问。这通常用于访问本地网络资源或者信任的网站。</li>\n<li><strong>全局（Global）</strong>：全局模式下，所有的网络流量都会通过代理服务器。这个模式适用于需要代理所有流量的情况。</li>\n<li><strong>脚本（Script）</strong>：脚本功能允许用户编写或使用现有的 JavaScript 脚本来自定义复杂的流量处理逻辑，比如修改请求头、响应内容等，从而实现更灵活的分流规则。</li>\n</ol>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p><a href=\"https://clash.skk.moe/\">https://clash.skk.moe/</a></p>\n<p>前面说的入站、入站和规则都需要在配置文件中指定。Clash 的主配置文件名为 <code>config.yaml</code>，默认情况下会在 <code>$HOME/.config/clash</code> 目录读取配置文件。如果该目录不存在，Clash 会在该位置生成一个最小的配置文件。</p>\n<p>如果需要指定其他位置的配置文件，需要在命令行中使用 <code>-f</code> 参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clash -f /etc/clash/config.yaml</span><br></pre></td></tr></table></figure>\n\n<p>一份完整的 Clash 配置文件包括多个部分，下面一一介绍。</p>\n<h3 id=\"General-配置\"><a href=\"#General-配置\" class=\"headerlink\" title=\"General 配置\"></a>General 配置</h3><p>在 Clash 配置文件中，General 配置包含了一些必需的字段以及可选的配置项，通常位于配置文件开头部分。其中 <code>port</code>，<code>socks-port</code> 和 <code>allow-lan</code> 是必需的字段，用于指定 Clash 的端口、SOCKS5 代理端口以及是否允许局域网连接。如果需要启用透明代理，还需要指定 <code>redir-port</code> 字段，用于指定透明代理的端口。</p>\n<p>还有个特殊的 <code>mixed</code> 字段，用于指定混合配置端口，这个端口同时支持 HTTP(S) 和 SOCKS5 协议。</p>\n<p>除了这些必需字段外，还有一些可选的配置项，下面简单罗列几个：</p>\n<ul>\n<li><code>dns</code>：用于配置DNS相关设置。</li>\n<li><code>external-controller</code>：用于指定 RESTful API 的地址和端口。</li>\n<li><code>secret</code>：可选项，用于设置 RESTful API 的密钥。</li>\n<li><code>cfw-bypass</code>：可选项，用于配置规则以绕过代理。</li>\n</ul>\n<p>在编写 General 配置时可以参考以下内容，各个字段的作用都以注释的形式标注：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">port:</span> <span class=\"number\">7890</span> <span class=\"comment\"># HTTP端口</span></span><br><span class=\"line\"><span class=\"attr\">socks-port:</span> <span class=\"number\">7891</span> <span class=\"comment\"># SOCKS5端口</span></span><br><span class=\"line\"><span class=\"attr\">redir-port:</span> <span class=\"number\">7892</span> <span class=\"comment\"># Linux和macOS的重定向端口</span></span><br><span class=\"line\"><span class=\"attr\">mixed:</span> <span class=\"number\">7893</span> <span class=\"comment\"># 混合端口</span></span><br><span class=\"line\"><span class=\"attr\">allow-lan:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 仅在设置allow-lan为true时适用</span></span><br><span class=\"line\"><span class=\"comment\"># &quot;*&quot;: 绑定所有IP地址</span></span><br><span class=\"line\"><span class=\"comment\"># 192.168.122.11: 绑定单个IPv4地址</span></span><br><span class=\"line\"><span class=\"comment\"># &quot;[aaaa::a8aa:ff:fe09:57d8]&quot;: 绑定单个IPv6地址</span></span><br><span class=\"line\"><span class=\"attr\">bind-address:</span> <span class=\"string\">&quot;*&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Rule / Global/ Direct（默认为Rule）</span></span><br><span class=\"line\"><span class=\"attr\">mode:</span> <span class=\"string\">Rule</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将日志级别设置为stdout（默认为info）</span></span><br><span class=\"line\"><span class=\"comment\"># info / warning / error / debug / silent</span></span><br><span class=\"line\"><span class=\"attr\">log-level:</span> <span class=\"string\">info</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">external-controller:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"string\">:9090</span> <span class=\"comment\"># Clash的RESTful API</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 您可以将静态Web资源（如clash-dashboard）放入一个目录，并且Clash将在`$&#123;API&#125;/ui`中提供服务</span></span><br><span class=\"line\"><span class=\"comment\"># 输入是相对于配置目录的相对路径或绝对路径</span></span><br><span class=\"line\"><span class=\"attr\">external-ui:</span> <span class=\"string\">&quot;path/to/local/clash-dashboard&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">secret:</span> <span class=\"string\">&quot;&quot;</span> <span class=\"comment\"># RESTful API的密钥（可选）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">experimental:</span> <span class=\"comment\"># 实验性功能</span></span><br><span class=\"line\">  <span class=\"attr\">ignore-resolve-fail:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 忽略DNS解析失败，默认值为true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本地SOCKS5/HTTP(S)服务器的身份验证</span></span><br><span class=\"line\"><span class=\"attr\">authentication:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">&quot;user1:pass1&quot;</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">&quot;user2:pass2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实验性主机，支持通配符（例如*.clash.dev 甚至*.foo.*.example.com）</span></span><br><span class=\"line\"><span class=\"comment\"># 静态域比通配符域具有更高的优先级（foo.example.com &gt; *.example.com）</span></span><br><span class=\"line\"><span class=\"attr\">hosts:</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;*.clash.dev&#x27;</span><span class=\"string\">:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">  <span class=\"attr\">&#x27;alpha.clash.dev&#x27;:</span> <span class=\"string\">&#x27;::1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">dns:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 设置为true以启用DNS（默认为false）</span></span><br><span class=\"line\">  <span class=\"attr\">ipv6:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 默认为false</span></span><br><span class=\"line\">  <span class=\"attr\">listen:</span> <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span><span class=\"string\">:53</span></span><br><span class=\"line\">  <span class=\"attr\">enhanced-mode:</span> <span class=\"string\">fake-ip</span> <span class=\"comment\"># 或redir-host</span></span><br><span class=\"line\">  <span class=\"attr\">fake-ip-range:</span> <span class=\"number\">198.18</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"string\">/16</span> <span class=\"comment\"># 如果不知道是什么，请勿更改</span></span><br><span class=\"line\">  <span class=\"attr\">nameserver:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"number\">114.114</span><span class=\"number\">.114</span><span class=\"number\">.114</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">tcp://1.1.1.1</span></span><br><span class=\"line\">  <span class=\"attr\">fallback:</span> <span class=\"comment\"># 与nameserver并发请求，当GEOIP国家不是CN时使用fallback</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">tls://dns.rubyfish.cn:853</span> <span class=\"comment\"># DNS over TLS</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">https://1.1.1.1/dns-query</span> <span class=\"comment\"># DNS over HTTPS</span></span><br><span class=\"line\">  <span class=\"attr\">fallback-filter:</span></span><br><span class=\"line\">    <span class=\"attr\">geoip:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 默认</span></span><br><span class=\"line\">    <span class=\"attr\">ipcidr:</span> <span class=\"comment\"># 这些子网中的IP将被视为污染</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">240.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span><span class=\"string\">/4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Proxy-配置\"><a href=\"#Proxy-配置\" class=\"headerlink\" title=\"Proxy 配置\"></a>Proxy 配置</h3><p>Proxy 配置以及 Proxy Group 配置就是 Clash 控制流量出站的主要配置。</p>\n<p>Proxy 配置用于指定 Clash 连接代理服务器的相关信息。这包括代理服务器的地址、端口、类型等信息。通过正确配置这一部分，Clash 可以根据你的需求将流量转发到不同的代理服务器。例如，你可以设置多个代理节点，并为它们指定不同的类型，如 <strong><code>ss</code><strong>、</strong><code>vmess</code><strong>、</strong><code>socks5</code><strong>、</strong><code>http</code></strong> 和 **<code>snell</code>**。</p>\n<p>配置 Proxy 部分时可以参考以下内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">proxy:</span></span><br><span class=\"line\">  <span class=\"comment\"># shadowsocks</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;ss1&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">ss</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">chacha20-ietf-poly1305</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">&quot;password&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># udp: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;ss2&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">ss</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">chacha20-ietf-poly1305</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">&quot;password&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">plugin:</span> <span class=\"string\">v2ray-plugin</span></span><br><span class=\"line\">    <span class=\"attr\">plugin-opts:</span></span><br><span class=\"line\">      <span class=\"attr\">mode:</span> <span class=\"string\">websocket</span></span><br><span class=\"line\">      <span class=\"comment\"># tls: true</span></span><br><span class=\"line\">      <span class=\"comment\"># skip-cert-verify: true</span></span><br><span class=\"line\">      <span class=\"comment\"># host: bing.com</span></span><br><span class=\"line\">      <span class=\"comment\"># path: &quot;/&quot;</span></span><br><span class=\"line\">      <span class=\"comment\"># mux: true</span></span><br><span class=\"line\">      <span class=\"comment\"># headers:</span></span><br><span class=\"line\">      <span class=\"comment\">#   custom: value</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># vmess</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;vmess&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">vmess</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">uuid:</span> <span class=\"string\">uuid</span></span><br><span class=\"line\">    <span class=\"attr\">alterid:</span> <span class=\"number\">32</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">auto</span></span><br><span class=\"line\">    <span class=\"comment\"># udp: true</span></span><br><span class=\"line\">    <span class=\"comment\"># tls: true</span></span><br><span class=\"line\">    <span class=\"comment\"># skip-cert-verify: true</span></span><br><span class=\"line\">    <span class=\"comment\"># network: ws</span></span><br><span class=\"line\">    <span class=\"comment\"># ws-path: /path</span></span><br><span class=\"line\">    <span class=\"comment\"># ws-headers:</span></span><br><span class=\"line\">    <span class=\"comment\">#   host: v2ray.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># socks5</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;socks&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">socks5</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"comment\"># username: username</span></span><br><span class=\"line\">    <span class=\"comment\"># password: password</span></span><br><span class=\"line\">    <span class=\"comment\"># tls: true</span></span><br><span class=\"line\">    <span class=\"comment\"># skip-cert-verify: true</span></span><br><span class=\"line\">    <span class=\"comment\"># udp: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># http</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;http&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">http</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"comment\"># username: username</span></span><br><span class=\"line\">    <span class=\"comment\"># password: password</span></span><br><span class=\"line\">    <span class=\"comment\"># tls: true</span></span><br><span class=\"line\">    <span class=\"comment\"># skip-cert-verify: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># snell</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;snell&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">snell</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">44046</span></span><br><span class=\"line\">    <span class=\"attr\">psk:</span> <span class=\"string\">yourpsk</span></span><br><span class=\"line\">    <span class=\"comment\"># obfs-opts:</span></span><br><span class=\"line\">    <span class=\"comment\">#   mode: http</span></span><br><span class=\"line\">    <span class=\"comment\">#   host: bing.com</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Proxy-Group-配置\"><a href=\"#Proxy-Group-配置\" class=\"headerlink\" title=\"Proxy Group 配置\"></a>Proxy Group 配置</h3><p>proxy group 配置部分的作用是定义策略组，这些策略组可以在规则中使用来决定网络请求通过哪个代理节点。策略组允许你根据不同的场景和需求，组合和管理多个代理节点。例如，你可以创建一个策略组来自动选择延迟最低的节点，或者创建一个策略组来手动选择特定的节点。</p>\n<p>配置 Proxy Group 部分时可以参考以下内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">proxy-group:</span></span><br><span class=\"line\">  <span class=\"comment\"># url-test 通过测试访问 URL 的速度来选择使用哪个代理。</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;auto&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">url-test</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vmess1</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">300</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># fallback 通过优先级选择可用的策略。可用性通过访问 URL 来测试，就像自动 url-test 组一样。</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;fallback-auto&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">fallback</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vmess1</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">300</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># load-balance: 相同 eTLD 的请求将在同一个代理上拨号。</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;load-balance&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">load-balance</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vmess1</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">300</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># select 用于选择代理或代理组</span></span><br><span class=\"line\">  <span class=\"comment\"># 您可以使用 RESTful API 切换代理，推荐在 GUI 中使用。</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Proxy</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">select</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vmess1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">auto</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Rule-配置\"><a href=\"#Rule-配置\" class=\"headerlink\" title=\"Rule 配置\"></a>Rule 配置</h3><p>Rule 配置部分的作用是定义网络请求的匹配规则，以决定哪些请求应该被代理、直连或拒绝。这些规则基于请求的不同属性，如域名、IP 地址、端口号或地理位置来匹配流量。</p>\n<p>配置 Rule 部分时可以参考以下内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rule:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">domain-suffix,google.com,[策略组的名称]</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">domain-keyword,google,[策略组的名称]</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">domain,google.com,[策略组的名称]</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">domain-suffix,ad.com,REJECT</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">ip-cidr,127.0.0.0/8,DIRECT</span></span><br><span class=\"line\">  <span class=\"comment\"># rename source-ip-cidr and would remove after prerelease</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">src-ip-cidr,192.168.1.201/32,DIRECT</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">geoip,CN,DIRECT</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">dst-port,80,DIRECT</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">src-port,7777,DIRECT</span></span><br><span class=\"line\">  <span class=\"comment\"># final would remove after prerelease</span></span><br><span class=\"line\">  <span class=\"comment\"># you also can use `final,Proxy` or `final,,Proxy` now</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">match,[策略组的名称]</span></span><br></pre></td></tr></table></figure>\n\n<p>后面会详细介绍每一种可用的规则，后面再细看。</p>\n<h2 id=\"Inbound-入站协议\"><a href=\"#Inbound-入站协议\" class=\"headerlink\" title=\"Inbound 入站协议\"></a>Inbound 入站协议</h2><ul>\n<li>SOCKS5</li>\n<li>HTTP(S)</li>\n<li>Redirect TCP</li>\n<li>TProxy TCP</li>\n<li>TProxy UDP</li>\n<li>Linux TUN 设备（仅 Premium 版本）</li>\n</ul>\n<p><a href=\"https://www.txthinking.com/talks/articles/socks5-and-http-proxy.article\">一口气搞明白有点奇怪的 Socks 5 协议以及 HTTP 代理</a></p>\n<p>入站协议中主要就是对 SOCKS5 和 HTTP 做区分，三种透明代理后面单独说。</p>\n<p>SOCKS5 代理提供全面的网络协议支持，支持认证、更安全，同时支持 UDP 协议，以及提供了较好的性能和兼容性。HTTP 代理则仅能代理 HTTP 和 HTTPS 协议的流量，通常用于网页浏览，它可以高效地缓存数据，降低带宽消耗，但不适用于所有网络协议。</p>\n<p>一般浏览网页的话配个 HTTP 代理就行，其他情况直接 SOCKS5。</p>\n<h2 id=\"Outbound-出站-Proxy\"><a href=\"#Outbound-出站-Proxy\" class=\"headerlink\" title=\"Outbound 出站 Proxy\"></a>Outbound 出站 Proxy</h2><p>Clash 出站种类较多，且各自使用场景不同。前面讲过了配置文件的写法，可以把 Clash 出站分为 Proxy 和 Proxy Group 两种，这里也分开介绍。</p>\n<h3 id=\"Shadowsocks-ShadowsocksR\"><a href=\"#Shadowsocks-ShadowsocksR\" class=\"headerlink\" title=\"Shadowsocks&#x2F;ShadowsocksR\"></a>Shadowsocks&#x2F;ShadowsocksR</h3><p><a href=\"https://itlanyan.com/on-fuck-gfw-again/\">Shadowsocks&#x2F;SS教程 - tlanyan</a></p>\n<p><strong>Shadowsocks</strong> 是一个基于 SOCKS5 协议的加密代理，它使用各种加密方法来保护数据流。Clash 支持的 Shadowsocks 加密方法包括：</p>\n<table>\n<thead>\n<tr>\n<th>系列</th>\n<th>加密方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AEAD</td>\n<td>aes-128-gcm, aes-192-gcm, aes-256-gcm, chacha20-ietf-poly1305, xchacha20-ietf-poly1305</td>\n</tr>\n<tr>\n<td>流式</td>\n<td>aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20</td>\n</tr>\n<tr>\n<td>块式</td>\n<td>aes-128-ctr, aes-192-ctr, aes-256-ctr</td>\n</tr>\n</tbody></table>\n<p>此外，Clash 还支持 Shadowsocks 的插件，如 obfs 和 v2ray-plugin，这些插件可以提供额外的混淆功能，进一步增强隐私保护。</p>\n<p><strong>ShadowsocksR</strong> 是 Shadowsocks 的一个扩展版本，它增加了更多的混淆和协议选项，以提高抗审查能力。Clash 支持的 ShadowsocksR 加密方法和混淆方法包括：</p>\n<table>\n<thead>\n<tr>\n<th>系列</th>\n<th>加密方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>流式</td>\n<td>aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20</td>\n</tr>\n</tbody></table>\n<p>一般情况下，我们现在各种平台的订阅基本都是默认的 ss 协议。</p>\n<p>补充个小趣闻，ssr 协议在其发展过程中引起了一些争议。最初，ssr 项目因为违反 GPL 许可证而受到批评。原开发者对此表示不满，因为这违反了开源项目的基本原则。后来，ssr 项目改为采用与 ss 相同的 GPL、Apache 许可证、MIT 许可证等多重自由软件许可协议，缓解了部分争议。</p>\n<h3 id=\"Vmess\"><a href=\"#Vmess\" class=\"headerlink\" title=\"Vmess\"></a>Vmess</h3><p><strong>VMess</strong> 是一个无状态的加密通信协议，且所有数据都通过 TCP 传输。</p>\n<p>每当 VMess 客户端发起请求时，服务器会判断是否来自合法客户端。如果验证通过，请求就会被转发。之后，获得的响应会被发送回客户端。VMess 使用非对称格式，客户端的请求和服务器的响应格式不同。</p>\n<p>Clash 支持以下 Vmess 的加密方法:</p>\n<ul>\n<li>auto：自动选择，默认值。</li>\n<li>aes-128-gcm：推荐在 PC 上使用。它是一种高效的加密算法，通常用于需要高吞吐量的应用。</li>\n<li>chacha20-poly1305：推荐在移动设备上使用。它适用于那些没有硬件AES 加速的设备，因为它在软件实现中更快。</li>\n<li>none</li>\n</ul>\n<h3 id=\"SOCKS5\"><a href=\"#SOCKS5\" class=\"headerlink\" title=\"SOCKS5\"></a>SOCKS5</h3><h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><h3 id=\"Snell\"><a href=\"#Snell\" class=\"headerlink\" title=\"Snell\"></a>Snell</h3><p>Clash 也集成了对 Snell 的支持。</p>\n<p><strong>Snell</strong> 是一种精简的加密代理协议，由 Surge 团队开发，也是一种较为经典的反审查协议。它的设计初衷是为了提供极致的性能和简单的配置过程，同时支持 UDP over TCP中继。此外，Snell 是单一二进制文件，零依赖（除了glibc），这也使得 Snell 易于部署和维护。<br>该协议的使用场景主要集中在需要绕过网络审查、保护隐私和数据加密的环境中。由于其高性能和简单配置的特点，Snell适用于个人用户和小型企业，尤其是在网络审查较为严格的地区。</p>\n<p>小提示，Snell@v4 没有提供向下兼容，需要客户端服务端均进行升级。</p>\n<p>想知道更多相关知识去看这个 gitbook：<a href=\"https://manual.nssurge.com/others/snell.html\">https://manual.nssurge.com/others/snell.html</a></p>\n<h3 id=\"Trojan\"><a href=\"#Trojan\" class=\"headerlink\" title=\"Trojan\"></a>Trojan</h3><p>Clash 内置了对流行协议 Trojan 的支持。</p>\n<p><strong>Trojan</strong> 是近几年才兴起的网络工具，特点同样是确保数据传输的安全性和隐私性。但与传统的 ss&#x2F;ssr 不同的是，ss&#x2F;ssr 保证数据传输安全的手段是加密混淆，而 Trojan 的思路是将流量伪装成最常见的 HTTPS 流量。</p>\n<p><a href=\"https://itlanyan.com/trojan-tutorial/\">trojan教程 - tlanyan</a></p>\n<h2 id=\"Outbound-出站-Proxy-Groups\"><a href=\"#Outbound-出站-Proxy-Groups\" class=\"headerlink\" title=\"Outbound 出站 Proxy Groups\"></a>Outbound 出站 Proxy Groups</h2><p>Proxy Groups 策略组用于根据不同策略分发规则传递过来的请求，其可以直接被规则引用，也可以被其他策略组引用，而最上级策略组被规则引用。</p>\n<h3 id=\"Relay-中继\"><a href=\"#Relay-中继\" class=\"headerlink\" title=\"Relay 中继\"></a>Relay 中继</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Relay:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;US-JP Relay&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">relay</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;US-Proxy&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;JP-Proxy&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>适用于当用户需要将流量通过特定的国家或地区进行中继时。比如用户想要访问仅限日本的内容，但同时想要通过美国的代理增加匿名性。</p>\n<h3 id=\"URL-Test-延迟测试\"><a href=\"#URL-Test-延迟测试\" class=\"headerlink\" title=\"URL-Test 延迟测试\"></a>URL-Test 延迟测试</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Url-Test:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Fastest-Proxy&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">url-test</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-A&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-B&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&quot;http://www.gstatic.com/generate_204&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">600</span></span><br></pre></td></tr></table></figure>\n\n<p>自动选择延迟最低的代理服务器。比如用户在进行在线游戏或视频会议时，需要确保连接是最快的。</p>\n<h3 id=\"Fallback-可用性测试\"><a href=\"#Fallback-可用性测试\" class=\"headerlink\" title=\"Fallback 可用性测试\"></a>Fallback 可用性测试</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Fallback:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Available-Proxy&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">fallback</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-A&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-B&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&quot;http://www.gstatic.com/generate_204&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">600</span></span><br></pre></td></tr></table></figure>\n\n<p>确保总是有一个可用的代理服务器。比如用户在进行重要的网络操作，如在线交易，需要确保不会因为代理服务器的问题而中断。</p>\n<h3 id=\"Load-Balance-负载均衡\"><a href=\"#Load-Balance-负载均衡\" class=\"headerlink\" title=\"Load-Balance 负载均衡\"></a>Load-Balance 负载均衡</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Load-Balance:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Balance-Group&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">load-balance</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-A&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-B&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">sticky-session:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>当用户想要在多个代理服务器之间分配负载时。比如用户在下载大文件或进行多线程下载时，可以平均分配流量以优化速度。</p>\n<h3 id=\"Select-手动选择\"><a href=\"#Select-手动选择\" class=\"headerlink\" title=\"Select 手动选择\"></a>Select 手动选择</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Select:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Manual-Select&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">select</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-A&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-B&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">interface-name:</span> <span class=\"string\">&quot;en0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>最常用，平常在 Clash 里点点点切换代理服务器的时候基本都是在用 Select 策略组。</p>\n<p>适用于用户想要完全控制选择哪个代理服务器。比如用户根据不同的网络活动（如流媒体、游戏或工作）手动切换代理服务器。</p>\n<h3 id=\"DIRECT-直连出站\"><a href=\"#DIRECT-直连出站\" class=\"headerlink\" title=\"DIRECT 直连出站\"></a>DIRECT 直连出站</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Direct:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Direct-Connection&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">direct</span></span><br><span class=\"line\">    <span class=\"attr\">interface-name:</span> <span class=\"string\">&quot;en0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Outbound-出站-Proxy-Providers\"><a href=\"#Outbound-出站-Proxy-Providers\" class=\"headerlink\" title=\"Outbound 出站 Proxy Providers\"></a>Outbound 出站 Proxy Providers</h2><p>前面介绍了 Clash 出站时的 Proxy 和 Proxy Groups，单独的机场订阅链接这两个就够用了。一般情况下是配置文件中配置一串 Proxy，然后 Proxy Groups 中配置一个 Select 策略供用户自行选择，额外再配置几个 url-test 用于实现自动选择和流量监测。</p>\n<p>但如果我们有多个机场链接，现在想编写一个统一的配置文件，流畅地在多个订阅之间切换代理服务器，应该怎么做？刚开始的想法可能是 cv 硬编码进去，但这种实现方案比较臃肿。幸好，Clash Premium Core 已经支持了 <strong>Proxy Providers</strong>，实现提供在线规则集，可以通过托管链接获取节点信息，避免了硬编码。</p>\n<p>一个可供参考的使用示范如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># config.yaml</span></span><br><span class=\"line\"><span class=\"attr\">proxy-providers:</span></span><br><span class=\"line\">  <span class=\"attr\">test:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">file</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/test.yaml</span></span><br><span class=\"line\">    <span class=\"attr\">health-check:</span></span><br><span class=\"line\">      <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"number\">36000</span></span><br><span class=\"line\">      <span class=\"attr\">url:</span> <span class=\"string\">http://www.gstatic.com/generate_204</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># test.yaml</span></span><br><span class=\"line\"><span class=\"attr\">proxies:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;ss1&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">ss</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">chacha20-ietf-poly1305</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">&quot;password&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;ss2&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">ss</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">chacha20-ietf-poly1305</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">&quot;password&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">plugin:</span> <span class=\"string\">obfs</span></span><br><span class=\"line\">    <span class=\"attr\">plugin-opts:</span></span><br><span class=\"line\">      <span class=\"attr\">mode:</span> <span class=\"string\">tls</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.10101.io/2020/02/12/use-clash-proxy-provider-with-subconverter\">Clash proxy-provider 搭配 subconverter 使用小记 - 方寸间</a></p>\n<h2 id=\"Rules-规则\"><a href=\"#Rules-规则\" class=\"headerlink\" title=\"Rules 规则\"></a>Rules 规则</h2><p>规则是 Clash 的精华部分，也是一份配置文档中最为冗长的部分。打开你现在使用的订阅链接配置文件，几千行的配置信息中，可能只有前几十行是出入站配置，剩下的所有都是 rules 规则。</p>\n<p>一条规则的基本格式如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 类型,参数,策略(,no-resolve)</span></span><br><span class=\"line\"><span class=\"string\">TYPE,ARGUMENT,POLICY(,no-resolve)</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>no-resolve</code> 选项是可选的, 它用于跳过规则的 DNS 解析。当你想要使用 <code>GEOIP</code>、<code>IP-CIDR</code>、<code>IP-CIDR6</code>、<code>SCRIPT</code> 规则，但又不想立即将域名解析为 IP 地址时，这个选项就很有用了。<br>Clash 可用的规则类型其实不多，感觉自己也讲不出什么新点，但不写在着文章里感觉又不完整，索性 cv 了<a href=\"https://clash.wiki/configuration/rules.html#%E8%A7%84%E5%88%99%E7%B1%BB%E5%9E%8B\">这份文档</a>，就稍微改了下格式，推荐去原文档看。</p>\n<h3 id=\"DOMAIN-域名\"><a href=\"#DOMAIN-域名\" class=\"headerlink\" title=\"DOMAIN 域名\"></a>DOMAIN 域名</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">DOMAIN,www.google.com,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将 <code>www.google.com</code> 路由到 <code>policy</code>。</p>\n<h3 id=\"DOMAIN-SUFFIX-域名后缀\"><a href=\"#DOMAIN-SUFFIX-域名后缀\" class=\"headerlink\" title=\"DOMAIN-SUFFIX 域名后缀\"></a>DOMAIN-SUFFIX 域名后缀</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">DOMAIN-SUFFIX,youtube.com,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何以 <code>youtube.com</code> 结尾的域名路由到 <code>policy</code>。在这种情况下，<code>www.youtube.com</code> 和 <code>foo.bar.youtube.com</code> 都将路由到 <code>policy</code>。</p>\n<h3 id=\"DOMAIN-KEYWORD-域名关键字\"><a href=\"#DOMAIN-KEYWORD-域名关键字\" class=\"headerlink\" title=\"DOMAIN-KEYWORD 域名关键字\"></a>DOMAIN-KEYWORD 域名关键字</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">DOMAIN-KEYWORD,google,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何包含 <code>google</code> 关键字的域名路由到 <code>policy</code>。在这种情况下，<code>www.google.com</code> 或 <code>googleapis.com</code> 都将路由到 <code>policy</code>。</p>\n<h3 id=\"GEOIP-IP地理位置-国家代码\"><a href=\"#GEOIP-IP地理位置-国家代码\" class=\"headerlink\" title=\"GEOIP IP地理位置 (国家代码)\"></a>GEOIP IP地理位置 (国家代码)</h3><p>GEOIP 规则用于根据数据包的目标 IP 地址的<strong>国家代码</strong>路由数据包，Clash 使用 <a href=\"https://dev.maxmind.com/geoip/geoip2/geolite2/\"><strong>MaxMind GeoLite2</strong></a> 数据库来实现这一功能。使用这种规则时，Clash 将域名解析为 IP 地址，然后查找 IP 地址的国家代码。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">GEOIP,CN,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标 IP 地址为中国的数据包路由到 <code>policy</code>。</p>\n<h3 id=\"IP-CIDR-IPv4地址段\"><a href=\"#IP-CIDR-IPv4地址段\" class=\"headerlink\" title=\"IP-CIDR IPv4地址段\"></a>IP-CIDR IPv4地址段</h3><p>IP-CIDR 规则用于根据数据包的<strong>目标 IPv4 地址</strong>路由数据包。使用这种规则时, Clash 将域名解析为 IPv4 地址。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">IP-CIDR,127.0.0.0/8,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标 IP 地址为 <code>127.0.0.0/8</code> 的数据包路由到 <code>DIRECT</code>。</p>\n<h3 id=\"IP-CIDR6-IPv6地址段\"><a href=\"#IP-CIDR6-IPv6地址段\" class=\"headerlink\" title=\"IP-CIDR6 IPv6地址段\"></a>IP-CIDR6 IPv6地址段</h3><p>IP-CIDR6 规则用于根据数据包的<strong>目标 IPv6 地址</strong>路由数据包。使用这种规则时, Clash 将域名解析为 IPv6 地址。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">IP-CIDR6,2620:0:2d0:200::7/32,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标 IP 地址为 <code>2620:0:2d0:200::7/32</code> 的数据包路由到 <code>policy</code>。</p>\n<h3 id=\"SRC-IP-CIDR-源IP段地址\"><a href=\"#SRC-IP-CIDR-源IP段地址\" class=\"headerlink\" title=\"SRC-IP-CIDR 源IP段地址\"></a>SRC-IP-CIDR 源IP段地址</h3><p>SRC-IP-CIDR 规则用于根据数据包的<strong>源 IPv4 地址</strong>路由数据包。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">SRC-IP-CIDR,192.168.1.201/32,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何源 IP 地址为 <code>192.168.1.201/32</code> 的数据包路由到 <code>DIRECT</code>。</p>\n<h3 id=\"SRC-PORT-源端口\"><a href=\"#SRC-PORT-源端口\" class=\"headerlink\" title=\"SRC-PORT 源端口\"></a>SRC-PORT 源端口</h3><p>SRC-PORT 规则用于根据数据包的<strong>源端口</strong>路由数据包。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">SRC-PORT,80,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何源端口为 <code>80</code> 的数据包路由到 <code>policy</code>。</p>\n<h3 id=\"DST-PORT-目标端口\"><a href=\"#DST-PORT-目标端口\" class=\"headerlink\" title=\"DST-PORT 目标端口\"></a>DST-PORT 目标端口</h3><p>DST-PORT 规则用于根据数据包的<strong>目标端口</strong>路由数据包。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">DST-PORT,80,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标端口为 <code>80</code> 的数据包路由到 <code>policy</code>。</p>\n<h3 id=\"PROCESS-NAME-源进程名\"><a href=\"#PROCESS-NAME-源进程名\" class=\"headerlink\" title=\"PROCESS-NAME 源进程名\"></a>PROCESS-NAME 源进程名</h3><p>PROCESS-NAME 规则用于根据发送数据包的进程名称路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">PROCESS-NAME,nc,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何来自进程 <code>nc</code> 的数据包路由到 <code>DIRECT</code>。</p>\n<h3 id=\"PROCESS-PATH-源进程路径\"><a href=\"#PROCESS-PATH-源进程路径\" class=\"headerlink\" title=\"PROCESS-PATH 源进程路径\"></a>PROCESS-PATH 源进程路径</h3><p>PROCESS-PATH 规则用于根据发送数据包的进程路径路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">PROCESS-PATH,/usr/local/bin/nc,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何来自路径为 <code>/usr/local/bin/nc</code> 的进程的数据包路由到 <code>DIRECT</code>。</p>\n<h3 id=\"IPSET-IP集\"><a href=\"#IPSET-IP集\" class=\"headerlink\" title=\"IPSET IP集\"></a>IPSET IP集</h3><p>IPSET 规则用于根据 IP 集匹配并路由数据包. 根据 <a href=\"https://ipset.netfilter.org/\"><strong>IPSET 的官方网站</strong></a> 的介绍:</p>\n<blockquote>\n<p>IP 集是 Linux 内核中的一个框架, 可以通过 ipset 程序进行管理。根据类型，IP 集可以存储 IP 地址、网络、 (TCP&#x2F;UDP) 端口号、MAC 地址、接口名称或它们以某种方式的组合，以确保在集合中匹配条目时具有闪电般的速度。</p>\n</blockquote>\n<p>因此, 此功能仅在 Linux 上工作, 并且需要安装 <code>ipset</code>。使用此规则时, Clash 将解析域名以获取 IP 地址, 然后查找 IP 地址是否在 IP 集中. 如果要跳过 DNS 解析, 请使用 <strong><code>no-resolve</code></strong> 选项.</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">IPSET,chnroute,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标 IP 地址在 IP 集 <code>chnroute</code> 中的数据包路由到 <code>policy</code>.</p>\n<h3 id=\"RULE-SET-规则集\"><a href=\"#RULE-SET-规则集\" class=\"headerlink\" title=\"RULE-SET 规则集\"></a>RULE-SET 规则集</h3><p>此功能仅在 <a href=\"https://clash.wiki/premium/introduction.html\"><strong>Premium 版本</strong></a> 中可用。</p>\n<p>RULE-SET 规则用于根据 <a href=\"https://clash.wiki/premium/rule-providers.html\"><strong>Rule Providers 规则集</strong></a> 的结果路由数据包。当 Clash 使用此规则时，它会从指定的 Rule Providers 规则集中加载规则，然后将数据包与规则进行匹配。 如果数据包与任何规则匹配，则将数据包路由到指定的策略, 否则跳过此规则。</p>\n<p>使用 RULE-SET 时，当规则集的类型为 IPCIDR ，Clash 将解析域名以获取 IP 地址。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">RULE-SET,my-rule-provider,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>从 <code>my-rule-provider</code> 加载所有规则。</p>\n<h3 id=\"SCRIPT-脚本\"><a href=\"#SCRIPT-脚本\" class=\"headerlink\" title=\"SCRIPT 脚本\"></a>SCRIPT 脚本</h3><p>此功能仅在 <a href=\"https://clash.wiki/premium/introduction.html\"><strong>Premium 版本</strong></a> 中可用。</p>\n<p>SCRIPT 规则用于根据脚本的结果路由数据包。当 Clash 使用此规则时，它会执行指定的脚本，然后将数据包路由到脚本的输出。使用 SCRIPT 时，Clash 将解析域名以获取 IP 地址。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">SCRIPT,script-path,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将数据包路由到脚本 <code>script-path</code> 的输出.</p>\n<h3 id=\"MATCH-全匹配\"><a href=\"#MATCH-全匹配\" class=\"headerlink\" title=\"MATCH 全匹配\"></a>MATCH 全匹配</h3><p>MATCH 规则用于路由剩余的数据包。该规则是<strong>必需</strong>的，通常用作最后一条规则。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">MATCH,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将剩余的数据包路由到 <code>policy</code>。</p>\n<h2 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h2><h3 id=\"tproxy\"><a href=\"#tproxy\" class=\"headerlink\" title=\"tproxy\"></a>tproxy</h3><p>参考：<a href=\"https://www.zhaohuabing.com/learning-linux/docs/tproxy/\">tproxy（透明代理）</a></p>\n<p>tproxy 即 transparent（透明） proxy。这里的 transparent（透明）有两层含义：</p>\n<ol>\n<li>代理对于 client 是透明的，client 端无需进行任何配置。即无需修改请求地址，也无需采用代理协议和代理服务器进行协商。与之相对比的是 socks 代理或者 http 代理，需要在 client 端设置代理的地址，在发起请求时也需要通过代理协议告知代理服务器其需要访问的真实地址。</li>\n<li>代理对于 server 是透明的，server 端看到的是 client 端的地址，而不是 proxy 的地址</li>\n</ol>\n<p>这么说可能不够直观，通过下面这张图看会比较好，后者为透明代理，可以清晰地看到 client 发出请求的目的 IP 就是目标服务器的 IP：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240613024955.png\" alt=\"20240613024955\"></p>\n<p>从上面的描述能看出来，因为透明代理是在网络层面实现的，实现了全局代理的效果，所以无需在每个应用程序中配置，简化了操作，也在一定程度上增强了代理的隐蔽性。</p>\n<p>但由于客户端请求数据包的目的地址不是代理服务器，因此需要通过路由和 iptables 规则（Clash 实现，无需用户手动操作）将客户端的请求发送给代理服务器处理。</p>\n<h3 id=\"redirect\"><a href=\"#redirect\" class=\"headerlink\" title=\"redirect\"></a>redirect</h3><p>redirect 是另一种实现透明代理的方式。redirect 透明代理主要用于 TCP 流量，是通过修改数据包的目的端口来实现的。这种方法不需要像 tproxy 那样在网络层面进行操作，而是在传输层上实现的。</p>\n<p>以下是 Clash 基于 redirect 实现透明代理的过程：</p>\n<ol>\n<li>当客户端发起一个 TCP 连接时，iptables 规会捕获到这个连接请求；</li>\n<li>根据设置的规则，iptables 会将这个连接的目的端口重定向到 Clash 监听的端口上；</li>\n<li>Clash 接收到这个连接后，根据内部的规则处理，然后将流量转发到真正的目标服务器。</li>\n</ol>\n<p>使用 redirect 的优点是配置相对简单，特别是在不支持 tproxy 的系统上。它可以直接在 iptables 中设置，无需对操作系统的网络栈进行复杂的配置。这使得 redirect 成为一个在简单场景下快速部署透明代理的好选择。</p>\n","excerpt":"","more":"<p><a href=\"https://clash.wiki/\">什么是 Clash? | Clash 知识库</a></p>\n<p>有一说一，大家肯定都知道 Clash，但很多人对这东西的印象就是一个翻墙工具，导入订阅链接点几下就行，并不理解 Clash 究竟做了什么。</p>\n<p>Clash 是一个运行在网络层和应用层的、基于规则的代理工具，它所能做的不仅仅是帮你转发流量到互联网访问其它应用（当然这算是主要功能）。Clash 在本质上是对用户本机的流量进行管理，实现智能路由和访问控制，如果你会写 Clash 配置文件的话，就可以轻松实现访问外网应用时自动走代理，而在访问指定国内应用时不走代理直接访问。</p>\n<p>其工作原理和工作流程说来也简单，用一句话就能解释清楚：接收本机流量后根据规则进行转发，下文会对这一过程进行介绍。</p>\n<p>看完这篇文章，你应该可以对 Clash 的本质以及其工作原理有一个相对清晰的认识，可以轻松看懂那些“订阅链接”背后是什么，并且可以独立编写 Clash 配置文件。</p>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p>我们可以把 Clash 的工作过程简单分为三步，</p>\n<ol>\n<li><strong>Inbound 入站：</strong>当你在设备上启动 Clash 时，它会创建一个或多个本地监听端口，这些端口用于接收来自设备上的应用程序的网络请求；</li>\n<li><strong>基于规则的路由：</strong>Clash 配置文件中的 <strong><code>rules</code></strong> 部分定义了如何处理不同类型的网络请求。例如上文说的只转发部分流量；</li>\n<li><strong>Outbound 出站：</strong>Clash 根据配置文件中的规则，将入站的网络请求转发到不同的出站连接，可以连接到某个网络接口、某个代理服务器，也可以是某个策略组。</li>\n</ol>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240613024509.png\" alt=\"20240613024509\"></p>\n<h2 id=\"四种代理模式\"><a href=\"#四种代理模式\" class=\"headerlink\" title=\"四种代理模式\"></a>四种代理模式</h2><p>在 Clash 操作页面，可以看到四种代理模式，一般情况下选择“规则”就好，足够用户使用。这里对这四种都做一下介绍：</p>\n<ol>\n<li><strong>规则（Rule）</strong>：这是 Clash 配置中最重要的部分之一。规则用于定义哪些流量应该被代理，哪些应该直连。用户可以根据域名、IP、地理位置等条件来设置规则。</li>\n<li><strong>直连（Direct）</strong>：直连选项通常用于设置哪些流量不需要通过代理服务器直接访问。这通常用于访问本地网络资源或者信任的网站。</li>\n<li><strong>全局（Global）</strong>：全局模式下，所有的网络流量都会通过代理服务器。这个模式适用于需要代理所有流量的情况。</li>\n<li><strong>脚本（Script）</strong>：脚本功能允许用户编写或使用现有的 JavaScript 脚本来自定义复杂的流量处理逻辑，比如修改请求头、响应内容等，从而实现更灵活的分流规则。</li>\n</ol>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p><a href=\"https://clash.skk.moe/\">https://clash.skk.moe/</a></p>\n<p>前面说的入站、入站和规则都需要在配置文件中指定。Clash 的主配置文件名为 <code>config.yaml</code>，默认情况下会在 <code>$HOME/.config/clash</code> 目录读取配置文件。如果该目录不存在，Clash 会在该位置生成一个最小的配置文件。</p>\n<p>如果需要指定其他位置的配置文件，需要在命令行中使用 <code>-f</code> 参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clash -f /etc/clash/config.yaml</span><br></pre></td></tr></table></figure>\n\n<p>一份完整的 Clash 配置文件包括多个部分，下面一一介绍。</p>\n<h3 id=\"General-配置\"><a href=\"#General-配置\" class=\"headerlink\" title=\"General 配置\"></a>General 配置</h3><p>在 Clash 配置文件中，General 配置包含了一些必需的字段以及可选的配置项，通常位于配置文件开头部分。其中 <code>port</code>，<code>socks-port</code> 和 <code>allow-lan</code> 是必需的字段，用于指定 Clash 的端口、SOCKS5 代理端口以及是否允许局域网连接。如果需要启用透明代理，还需要指定 <code>redir-port</code> 字段，用于指定透明代理的端口。</p>\n<p>还有个特殊的 <code>mixed</code> 字段，用于指定混合配置端口，这个端口同时支持 HTTP(S) 和 SOCKS5 协议。</p>\n<p>除了这些必需字段外，还有一些可选的配置项，下面简单罗列几个：</p>\n<ul>\n<li><code>dns</code>：用于配置DNS相关设置。</li>\n<li><code>external-controller</code>：用于指定 RESTful API 的地址和端口。</li>\n<li><code>secret</code>：可选项，用于设置 RESTful API 的密钥。</li>\n<li><code>cfw-bypass</code>：可选项，用于配置规则以绕过代理。</li>\n</ul>\n<p>在编写 General 配置时可以参考以下内容，各个字段的作用都以注释的形式标注：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">port:</span> <span class=\"number\">7890</span> <span class=\"comment\"># HTTP端口</span></span><br><span class=\"line\"><span class=\"attr\">socks-port:</span> <span class=\"number\">7891</span> <span class=\"comment\"># SOCKS5端口</span></span><br><span class=\"line\"><span class=\"attr\">redir-port:</span> <span class=\"number\">7892</span> <span class=\"comment\"># Linux和macOS的重定向端口</span></span><br><span class=\"line\"><span class=\"attr\">mixed:</span> <span class=\"number\">7893</span> <span class=\"comment\"># 混合端口</span></span><br><span class=\"line\"><span class=\"attr\">allow-lan:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 仅在设置allow-lan为true时适用</span></span><br><span class=\"line\"><span class=\"comment\"># &quot;*&quot;: 绑定所有IP地址</span></span><br><span class=\"line\"><span class=\"comment\"># 192.168.122.11: 绑定单个IPv4地址</span></span><br><span class=\"line\"><span class=\"comment\"># &quot;[aaaa::a8aa:ff:fe09:57d8]&quot;: 绑定单个IPv6地址</span></span><br><span class=\"line\"><span class=\"attr\">bind-address:</span> <span class=\"string\">&quot;*&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Rule / Global/ Direct（默认为Rule）</span></span><br><span class=\"line\"><span class=\"attr\">mode:</span> <span class=\"string\">Rule</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将日志级别设置为stdout（默认为info）</span></span><br><span class=\"line\"><span class=\"comment\"># info / warning / error / debug / silent</span></span><br><span class=\"line\"><span class=\"attr\">log-level:</span> <span class=\"string\">info</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">external-controller:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"string\">:9090</span> <span class=\"comment\"># Clash的RESTful API</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 您可以将静态Web资源（如clash-dashboard）放入一个目录，并且Clash将在`$&#123;API&#125;/ui`中提供服务</span></span><br><span class=\"line\"><span class=\"comment\"># 输入是相对于配置目录的相对路径或绝对路径</span></span><br><span class=\"line\"><span class=\"attr\">external-ui:</span> <span class=\"string\">&quot;path/to/local/clash-dashboard&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">secret:</span> <span class=\"string\">&quot;&quot;</span> <span class=\"comment\"># RESTful API的密钥（可选）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">experimental:</span> <span class=\"comment\"># 实验性功能</span></span><br><span class=\"line\">  <span class=\"attr\">ignore-resolve-fail:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 忽略DNS解析失败，默认值为true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 本地SOCKS5/HTTP(S)服务器的身份验证</span></span><br><span class=\"line\"><span class=\"attr\">authentication:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">&quot;user1:pass1&quot;</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">&quot;user2:pass2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实验性主机，支持通配符（例如*.clash.dev 甚至*.foo.*.example.com）</span></span><br><span class=\"line\"><span class=\"comment\"># 静态域比通配符域具有更高的优先级（foo.example.com &gt; *.example.com）</span></span><br><span class=\"line\"><span class=\"attr\">hosts:</span></span><br><span class=\"line\">  <span class=\"string\">&#x27;*.clash.dev&#x27;</span><span class=\"string\">:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">  <span class=\"attr\">&#x27;alpha.clash.dev&#x27;:</span> <span class=\"string\">&#x27;::1&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">dns:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 设置为true以启用DNS（默认为false）</span></span><br><span class=\"line\">  <span class=\"attr\">ipv6:</span> <span class=\"literal\">false</span> <span class=\"comment\"># 默认为false</span></span><br><span class=\"line\">  <span class=\"attr\">listen:</span> <span class=\"number\">0.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span><span class=\"string\">:53</span></span><br><span class=\"line\">  <span class=\"attr\">enhanced-mode:</span> <span class=\"string\">fake-ip</span> <span class=\"comment\"># 或redir-host</span></span><br><span class=\"line\">  <span class=\"attr\">fake-ip-range:</span> <span class=\"number\">198.18</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"string\">/16</span> <span class=\"comment\"># 如果不知道是什么，请勿更改</span></span><br><span class=\"line\">  <span class=\"attr\">nameserver:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"number\">114.114</span><span class=\"number\">.114</span><span class=\"number\">.114</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">tcp://1.1.1.1</span></span><br><span class=\"line\">  <span class=\"attr\">fallback:</span> <span class=\"comment\"># 与nameserver并发请求，当GEOIP国家不是CN时使用fallback</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">tls://dns.rubyfish.cn:853</span> <span class=\"comment\"># DNS over TLS</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">https://1.1.1.1/dns-query</span> <span class=\"comment\"># DNS over HTTPS</span></span><br><span class=\"line\">  <span class=\"attr\">fallback-filter:</span></span><br><span class=\"line\">    <span class=\"attr\">geoip:</span> <span class=\"literal\">true</span> <span class=\"comment\"># 默认</span></span><br><span class=\"line\">    <span class=\"attr\">ipcidr:</span> <span class=\"comment\"># 这些子网中的IP将被视为污染</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">240.0</span><span class=\"number\">.0</span><span class=\"number\">.0</span><span class=\"string\">/4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Proxy-配置\"><a href=\"#Proxy-配置\" class=\"headerlink\" title=\"Proxy 配置\"></a>Proxy 配置</h3><p>Proxy 配置以及 Proxy Group 配置就是 Clash 控制流量出站的主要配置。</p>\n<p>Proxy 配置用于指定 Clash 连接代理服务器的相关信息。这包括代理服务器的地址、端口、类型等信息。通过正确配置这一部分，Clash 可以根据你的需求将流量转发到不同的代理服务器。例如，你可以设置多个代理节点，并为它们指定不同的类型，如 <strong><code>ss</code><strong>、</strong><code>vmess</code><strong>、</strong><code>socks5</code><strong>、</strong><code>http</code></strong> 和 **<code>snell</code>**。</p>\n<p>配置 Proxy 部分时可以参考以下内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">proxy:</span></span><br><span class=\"line\">  <span class=\"comment\"># shadowsocks</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;ss1&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">ss</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">chacha20-ietf-poly1305</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">&quot;password&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># udp: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;ss2&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">ss</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">chacha20-ietf-poly1305</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">&quot;password&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">plugin:</span> <span class=\"string\">v2ray-plugin</span></span><br><span class=\"line\">    <span class=\"attr\">plugin-opts:</span></span><br><span class=\"line\">      <span class=\"attr\">mode:</span> <span class=\"string\">websocket</span></span><br><span class=\"line\">      <span class=\"comment\"># tls: true</span></span><br><span class=\"line\">      <span class=\"comment\"># skip-cert-verify: true</span></span><br><span class=\"line\">      <span class=\"comment\"># host: bing.com</span></span><br><span class=\"line\">      <span class=\"comment\"># path: &quot;/&quot;</span></span><br><span class=\"line\">      <span class=\"comment\"># mux: true</span></span><br><span class=\"line\">      <span class=\"comment\"># headers:</span></span><br><span class=\"line\">      <span class=\"comment\">#   custom: value</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># vmess</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;vmess&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">vmess</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">uuid:</span> <span class=\"string\">uuid</span></span><br><span class=\"line\">    <span class=\"attr\">alterid:</span> <span class=\"number\">32</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">auto</span></span><br><span class=\"line\">    <span class=\"comment\"># udp: true</span></span><br><span class=\"line\">    <span class=\"comment\"># tls: true</span></span><br><span class=\"line\">    <span class=\"comment\"># skip-cert-verify: true</span></span><br><span class=\"line\">    <span class=\"comment\"># network: ws</span></span><br><span class=\"line\">    <span class=\"comment\"># ws-path: /path</span></span><br><span class=\"line\">    <span class=\"comment\"># ws-headers:</span></span><br><span class=\"line\">    <span class=\"comment\">#   host: v2ray.com</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># socks5</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;socks&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">socks5</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"comment\"># username: username</span></span><br><span class=\"line\">    <span class=\"comment\"># password: password</span></span><br><span class=\"line\">    <span class=\"comment\"># tls: true</span></span><br><span class=\"line\">    <span class=\"comment\"># skip-cert-verify: true</span></span><br><span class=\"line\">    <span class=\"comment\"># udp: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># http</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;http&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">http</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"comment\"># username: username</span></span><br><span class=\"line\">    <span class=\"comment\"># password: password</span></span><br><span class=\"line\">    <span class=\"comment\"># tls: true</span></span><br><span class=\"line\">    <span class=\"comment\"># skip-cert-verify: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># snell</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;snell&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">snell</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">44046</span></span><br><span class=\"line\">    <span class=\"attr\">psk:</span> <span class=\"string\">yourpsk</span></span><br><span class=\"line\">    <span class=\"comment\"># obfs-opts:</span></span><br><span class=\"line\">    <span class=\"comment\">#   mode: http</span></span><br><span class=\"line\">    <span class=\"comment\">#   host: bing.com</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Proxy-Group-配置\"><a href=\"#Proxy-Group-配置\" class=\"headerlink\" title=\"Proxy Group 配置\"></a>Proxy Group 配置</h3><p>proxy group 配置部分的作用是定义策略组，这些策略组可以在规则中使用来决定网络请求通过哪个代理节点。策略组允许你根据不同的场景和需求，组合和管理多个代理节点。例如，你可以创建一个策略组来自动选择延迟最低的节点，或者创建一个策略组来手动选择特定的节点。</p>\n<p>配置 Proxy Group 部分时可以参考以下内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">proxy-group:</span></span><br><span class=\"line\">  <span class=\"comment\"># url-test 通过测试访问 URL 的速度来选择使用哪个代理。</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;auto&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">url-test</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vmess1</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">300</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># fallback 通过优先级选择可用的策略。可用性通过访问 URL 来测试，就像自动 url-test 组一样。</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;fallback-auto&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">fallback</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vmess1</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">300</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># load-balance: 相同 eTLD 的请求将在同一个代理上拨号。</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;load-balance&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">load-balance</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vmess1</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&#x27;http://www.gstatic.com/generate_204&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">300</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># select 用于选择代理或代理组</span></span><br><span class=\"line\">  <span class=\"comment\"># 您可以使用 RESTful API 切换代理，推荐在 GUI 中使用。</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Proxy</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">select</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ss2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">vmess1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">auto</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Rule-配置\"><a href=\"#Rule-配置\" class=\"headerlink\" title=\"Rule 配置\"></a>Rule 配置</h3><p>Rule 配置部分的作用是定义网络请求的匹配规则，以决定哪些请求应该被代理、直连或拒绝。这些规则基于请求的不同属性，如域名、IP 地址、端口号或地理位置来匹配流量。</p>\n<p>配置 Rule 部分时可以参考以下内容：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">rule:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">domain-suffix,google.com,[策略组的名称]</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">domain-keyword,google,[策略组的名称]</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">domain,google.com,[策略组的名称]</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">domain-suffix,ad.com,REJECT</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">ip-cidr,127.0.0.0/8,DIRECT</span></span><br><span class=\"line\">  <span class=\"comment\"># rename source-ip-cidr and would remove after prerelease</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">src-ip-cidr,192.168.1.201/32,DIRECT</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">geoip,CN,DIRECT</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">dst-port,80,DIRECT</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">src-port,7777,DIRECT</span></span><br><span class=\"line\">  <span class=\"comment\"># final would remove after prerelease</span></span><br><span class=\"line\">  <span class=\"comment\"># you also can use `final,Proxy` or `final,,Proxy` now</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">match,[策略组的名称]</span></span><br></pre></td></tr></table></figure>\n\n<p>后面会详细介绍每一种可用的规则，后面再细看。</p>\n<h2 id=\"Inbound-入站协议\"><a href=\"#Inbound-入站协议\" class=\"headerlink\" title=\"Inbound 入站协议\"></a>Inbound 入站协议</h2><ul>\n<li>SOCKS5</li>\n<li>HTTP(S)</li>\n<li>Redirect TCP</li>\n<li>TProxy TCP</li>\n<li>TProxy UDP</li>\n<li>Linux TUN 设备（仅 Premium 版本）</li>\n</ul>\n<p><a href=\"https://www.txthinking.com/talks/articles/socks5-and-http-proxy.article\">一口气搞明白有点奇怪的 Socks 5 协议以及 HTTP 代理</a></p>\n<p>入站协议中主要就是对 SOCKS5 和 HTTP 做区分，三种透明代理后面单独说。</p>\n<p>SOCKS5 代理提供全面的网络协议支持，支持认证、更安全，同时支持 UDP 协议，以及提供了较好的性能和兼容性。HTTP 代理则仅能代理 HTTP 和 HTTPS 协议的流量，通常用于网页浏览，它可以高效地缓存数据，降低带宽消耗，但不适用于所有网络协议。</p>\n<p>一般浏览网页的话配个 HTTP 代理就行，其他情况直接 SOCKS5。</p>\n<h2 id=\"Outbound-出站-Proxy\"><a href=\"#Outbound-出站-Proxy\" class=\"headerlink\" title=\"Outbound 出站 Proxy\"></a>Outbound 出站 Proxy</h2><p>Clash 出站种类较多，且各自使用场景不同。前面讲过了配置文件的写法，可以把 Clash 出站分为 Proxy 和 Proxy Group 两种，这里也分开介绍。</p>\n<h3 id=\"Shadowsocks-ShadowsocksR\"><a href=\"#Shadowsocks-ShadowsocksR\" class=\"headerlink\" title=\"Shadowsocks&#x2F;ShadowsocksR\"></a>Shadowsocks&#x2F;ShadowsocksR</h3><p><a href=\"https://itlanyan.com/on-fuck-gfw-again/\">Shadowsocks&#x2F;SS教程 - tlanyan</a></p>\n<p><strong>Shadowsocks</strong> 是一个基于 SOCKS5 协议的加密代理，它使用各种加密方法来保护数据流。Clash 支持的 Shadowsocks 加密方法包括：</p>\n<table>\n<thead>\n<tr>\n<th>系列</th>\n<th>加密方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AEAD</td>\n<td>aes-128-gcm, aes-192-gcm, aes-256-gcm, chacha20-ietf-poly1305, xchacha20-ietf-poly1305</td>\n</tr>\n<tr>\n<td>流式</td>\n<td>aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20</td>\n</tr>\n<tr>\n<td>块式</td>\n<td>aes-128-ctr, aes-192-ctr, aes-256-ctr</td>\n</tr>\n</tbody></table>\n<p>此外，Clash 还支持 Shadowsocks 的插件，如 obfs 和 v2ray-plugin，这些插件可以提供额外的混淆功能，进一步增强隐私保护。</p>\n<p><strong>ShadowsocksR</strong> 是 Shadowsocks 的一个扩展版本，它增加了更多的混淆和协议选项，以提高抗审查能力。Clash 支持的 ShadowsocksR 加密方法和混淆方法包括：</p>\n<table>\n<thead>\n<tr>\n<th>系列</th>\n<th>加密方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>流式</td>\n<td>aes-128-cfb, aes-192-cfb, aes-256-cfb, rc4-md5, chacha20-ietf, xchacha20</td>\n</tr>\n</tbody></table>\n<p>一般情况下，我们现在各种平台的订阅基本都是默认的 ss 协议。</p>\n<p>补充个小趣闻，ssr 协议在其发展过程中引起了一些争议。最初，ssr 项目因为违反 GPL 许可证而受到批评。原开发者对此表示不满，因为这违反了开源项目的基本原则。后来，ssr 项目改为采用与 ss 相同的 GPL、Apache 许可证、MIT 许可证等多重自由软件许可协议，缓解了部分争议。</p>\n<h3 id=\"Vmess\"><a href=\"#Vmess\" class=\"headerlink\" title=\"Vmess\"></a>Vmess</h3><p><strong>VMess</strong> 是一个无状态的加密通信协议，且所有数据都通过 TCP 传输。</p>\n<p>每当 VMess 客户端发起请求时，服务器会判断是否来自合法客户端。如果验证通过，请求就会被转发。之后，获得的响应会被发送回客户端。VMess 使用非对称格式，客户端的请求和服务器的响应格式不同。</p>\n<p>Clash 支持以下 Vmess 的加密方法:</p>\n<ul>\n<li>auto：自动选择，默认值。</li>\n<li>aes-128-gcm：推荐在 PC 上使用。它是一种高效的加密算法，通常用于需要高吞吐量的应用。</li>\n<li>chacha20-poly1305：推荐在移动设备上使用。它适用于那些没有硬件AES 加速的设备，因为它在软件实现中更快。</li>\n<li>none</li>\n</ul>\n<h3 id=\"SOCKS5\"><a href=\"#SOCKS5\" class=\"headerlink\" title=\"SOCKS5\"></a>SOCKS5</h3><h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><h3 id=\"Snell\"><a href=\"#Snell\" class=\"headerlink\" title=\"Snell\"></a>Snell</h3><p>Clash 也集成了对 Snell 的支持。</p>\n<p><strong>Snell</strong> 是一种精简的加密代理协议，由 Surge 团队开发，也是一种较为经典的反审查协议。它的设计初衷是为了提供极致的性能和简单的配置过程，同时支持 UDP over TCP中继。此外，Snell 是单一二进制文件，零依赖（除了glibc），这也使得 Snell 易于部署和维护。<br>该协议的使用场景主要集中在需要绕过网络审查、保护隐私和数据加密的环境中。由于其高性能和简单配置的特点，Snell适用于个人用户和小型企业，尤其是在网络审查较为严格的地区。</p>\n<p>小提示，Snell@v4 没有提供向下兼容，需要客户端服务端均进行升级。</p>\n<p>想知道更多相关知识去看这个 gitbook：<a href=\"https://manual.nssurge.com/others/snell.html\">https://manual.nssurge.com/others/snell.html</a></p>\n<h3 id=\"Trojan\"><a href=\"#Trojan\" class=\"headerlink\" title=\"Trojan\"></a>Trojan</h3><p>Clash 内置了对流行协议 Trojan 的支持。</p>\n<p><strong>Trojan</strong> 是近几年才兴起的网络工具，特点同样是确保数据传输的安全性和隐私性。但与传统的 ss&#x2F;ssr 不同的是，ss&#x2F;ssr 保证数据传输安全的手段是加密混淆，而 Trojan 的思路是将流量伪装成最常见的 HTTPS 流量。</p>\n<p><a href=\"https://itlanyan.com/trojan-tutorial/\">trojan教程 - tlanyan</a></p>\n<h2 id=\"Outbound-出站-Proxy-Groups\"><a href=\"#Outbound-出站-Proxy-Groups\" class=\"headerlink\" title=\"Outbound 出站 Proxy Groups\"></a>Outbound 出站 Proxy Groups</h2><p>Proxy Groups 策略组用于根据不同策略分发规则传递过来的请求，其可以直接被规则引用，也可以被其他策略组引用，而最上级策略组被规则引用。</p>\n<h3 id=\"Relay-中继\"><a href=\"#Relay-中继\" class=\"headerlink\" title=\"Relay 中继\"></a>Relay 中继</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Relay:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;US-JP Relay&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">relay</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;US-Proxy&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;JP-Proxy&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>适用于当用户需要将流量通过特定的国家或地区进行中继时。比如用户想要访问仅限日本的内容，但同时想要通过美国的代理增加匿名性。</p>\n<h3 id=\"URL-Test-延迟测试\"><a href=\"#URL-Test-延迟测试\" class=\"headerlink\" title=\"URL-Test 延迟测试\"></a>URL-Test 延迟测试</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Url-Test:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Fastest-Proxy&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">url-test</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-A&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-B&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&quot;http://www.gstatic.com/generate_204&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">600</span></span><br></pre></td></tr></table></figure>\n\n<p>自动选择延迟最低的代理服务器。比如用户在进行在线游戏或视频会议时，需要确保连接是最快的。</p>\n<h3 id=\"Fallback-可用性测试\"><a href=\"#Fallback-可用性测试\" class=\"headerlink\" title=\"Fallback 可用性测试\"></a>Fallback 可用性测试</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Fallback:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Available-Proxy&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">fallback</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-A&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-B&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">&quot;http://www.gstatic.com/generate_204&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">interval:</span> <span class=\"number\">600</span></span><br></pre></td></tr></table></figure>\n\n<p>确保总是有一个可用的代理服务器。比如用户在进行重要的网络操作，如在线交易，需要确保不会因为代理服务器的问题而中断。</p>\n<h3 id=\"Load-Balance-负载均衡\"><a href=\"#Load-Balance-负载均衡\" class=\"headerlink\" title=\"Load-Balance 负载均衡\"></a>Load-Balance 负载均衡</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Load-Balance:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Balance-Group&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">load-balance</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-A&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-B&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">sticky-session:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>当用户想要在多个代理服务器之间分配负载时。比如用户在下载大文件或进行多线程下载时，可以平均分配流量以优化速度。</p>\n<h3 id=\"Select-手动选择\"><a href=\"#Select-手动选择\" class=\"headerlink\" title=\"Select 手动选择\"></a>Select 手动选择</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Select:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Manual-Select&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">select</span></span><br><span class=\"line\">    <span class=\"attr\">proxies:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-A&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;Proxy-B&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">interface-name:</span> <span class=\"string\">&quot;en0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>最常用，平常在 Clash 里点点点切换代理服务器的时候基本都是在用 Select 策略组。</p>\n<p>适用于用户想要完全控制选择哪个代理服务器。比如用户根据不同的网络活动（如流媒体、游戏或工作）手动切换代理服务器。</p>\n<h3 id=\"DIRECT-直连出站\"><a href=\"#DIRECT-直连出站\" class=\"headerlink\" title=\"DIRECT 直连出站\"></a>DIRECT 直连出站</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Direct:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;Direct-Connection&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">direct</span></span><br><span class=\"line\">    <span class=\"attr\">interface-name:</span> <span class=\"string\">&quot;en0&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Outbound-出站-Proxy-Providers\"><a href=\"#Outbound-出站-Proxy-Providers\" class=\"headerlink\" title=\"Outbound 出站 Proxy Providers\"></a>Outbound 出站 Proxy Providers</h2><p>前面介绍了 Clash 出站时的 Proxy 和 Proxy Groups，单独的机场订阅链接这两个就够用了。一般情况下是配置文件中配置一串 Proxy，然后 Proxy Groups 中配置一个 Select 策略供用户自行选择，额外再配置几个 url-test 用于实现自动选择和流量监测。</p>\n<p>但如果我们有多个机场链接，现在想编写一个统一的配置文件，流畅地在多个订阅之间切换代理服务器，应该怎么做？刚开始的想法可能是 cv 硬编码进去，但这种实现方案比较臃肿。幸好，Clash Premium Core 已经支持了 <strong>Proxy Providers</strong>，实现提供在线规则集，可以通过托管链接获取节点信息，避免了硬编码。</p>\n<p>一个可供参考的使用示范如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># config.yaml</span></span><br><span class=\"line\"><span class=\"attr\">proxy-providers:</span></span><br><span class=\"line\">  <span class=\"attr\">test:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">file</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">/test.yaml</span></span><br><span class=\"line\">    <span class=\"attr\">health-check:</span></span><br><span class=\"line\">      <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"attr\">interval:</span> <span class=\"number\">36000</span></span><br><span class=\"line\">      <span class=\"attr\">url:</span> <span class=\"string\">http://www.gstatic.com/generate_204</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># test.yaml</span></span><br><span class=\"line\"><span class=\"attr\">proxies:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;ss1&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">ss</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">chacha20-ietf-poly1305</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">&quot;password&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;ss2&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">ss</span></span><br><span class=\"line\">    <span class=\"attr\">server:</span> <span class=\"string\">server</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">443</span></span><br><span class=\"line\">    <span class=\"attr\">cipher:</span> <span class=\"string\">chacha20-ietf-poly1305</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">&quot;password&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">plugin:</span> <span class=\"string\">obfs</span></span><br><span class=\"line\">    <span class=\"attr\">plugin-opts:</span></span><br><span class=\"line\">      <span class=\"attr\">mode:</span> <span class=\"string\">tls</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://www.10101.io/2020/02/12/use-clash-proxy-provider-with-subconverter\">Clash proxy-provider 搭配 subconverter 使用小记 - 方寸间</a></p>\n<h2 id=\"Rules-规则\"><a href=\"#Rules-规则\" class=\"headerlink\" title=\"Rules 规则\"></a>Rules 规则</h2><p>规则是 Clash 的精华部分，也是一份配置文档中最为冗长的部分。打开你现在使用的订阅链接配置文件，几千行的配置信息中，可能只有前几十行是出入站配置，剩下的所有都是 rules 规则。</p>\n<p>一条规则的基本格式如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 类型,参数,策略(,no-resolve)</span></span><br><span class=\"line\"><span class=\"string\">TYPE,ARGUMENT,POLICY(,no-resolve)</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>no-resolve</code> 选项是可选的, 它用于跳过规则的 DNS 解析。当你想要使用 <code>GEOIP</code>、<code>IP-CIDR</code>、<code>IP-CIDR6</code>、<code>SCRIPT</code> 规则，但又不想立即将域名解析为 IP 地址时，这个选项就很有用了。<br>Clash 可用的规则类型其实不多，感觉自己也讲不出什么新点，但不写在着文章里感觉又不完整，索性 cv 了<a href=\"https://clash.wiki/configuration/rules.html#%E8%A7%84%E5%88%99%E7%B1%BB%E5%9E%8B\">这份文档</a>，就稍微改了下格式，推荐去原文档看。</p>\n<h3 id=\"DOMAIN-域名\"><a href=\"#DOMAIN-域名\" class=\"headerlink\" title=\"DOMAIN 域名\"></a>DOMAIN 域名</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">DOMAIN,www.google.com,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将 <code>www.google.com</code> 路由到 <code>policy</code>。</p>\n<h3 id=\"DOMAIN-SUFFIX-域名后缀\"><a href=\"#DOMAIN-SUFFIX-域名后缀\" class=\"headerlink\" title=\"DOMAIN-SUFFIX 域名后缀\"></a>DOMAIN-SUFFIX 域名后缀</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">DOMAIN-SUFFIX,youtube.com,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何以 <code>youtube.com</code> 结尾的域名路由到 <code>policy</code>。在这种情况下，<code>www.youtube.com</code> 和 <code>foo.bar.youtube.com</code> 都将路由到 <code>policy</code>。</p>\n<h3 id=\"DOMAIN-KEYWORD-域名关键字\"><a href=\"#DOMAIN-KEYWORD-域名关键字\" class=\"headerlink\" title=\"DOMAIN-KEYWORD 域名关键字\"></a>DOMAIN-KEYWORD 域名关键字</h3><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">DOMAIN-KEYWORD,google,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何包含 <code>google</code> 关键字的域名路由到 <code>policy</code>。在这种情况下，<code>www.google.com</code> 或 <code>googleapis.com</code> 都将路由到 <code>policy</code>。</p>\n<h3 id=\"GEOIP-IP地理位置-国家代码\"><a href=\"#GEOIP-IP地理位置-国家代码\" class=\"headerlink\" title=\"GEOIP IP地理位置 (国家代码)\"></a>GEOIP IP地理位置 (国家代码)</h3><p>GEOIP 规则用于根据数据包的目标 IP 地址的<strong>国家代码</strong>路由数据包，Clash 使用 <a href=\"https://dev.maxmind.com/geoip/geoip2/geolite2/\"><strong>MaxMind GeoLite2</strong></a> 数据库来实现这一功能。使用这种规则时，Clash 将域名解析为 IP 地址，然后查找 IP 地址的国家代码。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">GEOIP,CN,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标 IP 地址为中国的数据包路由到 <code>policy</code>。</p>\n<h3 id=\"IP-CIDR-IPv4地址段\"><a href=\"#IP-CIDR-IPv4地址段\" class=\"headerlink\" title=\"IP-CIDR IPv4地址段\"></a>IP-CIDR IPv4地址段</h3><p>IP-CIDR 规则用于根据数据包的<strong>目标 IPv4 地址</strong>路由数据包。使用这种规则时, Clash 将域名解析为 IPv4 地址。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">IP-CIDR,127.0.0.0/8,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标 IP 地址为 <code>127.0.0.0/8</code> 的数据包路由到 <code>DIRECT</code>。</p>\n<h3 id=\"IP-CIDR6-IPv6地址段\"><a href=\"#IP-CIDR6-IPv6地址段\" class=\"headerlink\" title=\"IP-CIDR6 IPv6地址段\"></a>IP-CIDR6 IPv6地址段</h3><p>IP-CIDR6 规则用于根据数据包的<strong>目标 IPv6 地址</strong>路由数据包。使用这种规则时, Clash 将域名解析为 IPv6 地址。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">IP-CIDR6,2620:0:2d0:200::7/32,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标 IP 地址为 <code>2620:0:2d0:200::7/32</code> 的数据包路由到 <code>policy</code>。</p>\n<h3 id=\"SRC-IP-CIDR-源IP段地址\"><a href=\"#SRC-IP-CIDR-源IP段地址\" class=\"headerlink\" title=\"SRC-IP-CIDR 源IP段地址\"></a>SRC-IP-CIDR 源IP段地址</h3><p>SRC-IP-CIDR 规则用于根据数据包的<strong>源 IPv4 地址</strong>路由数据包。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">SRC-IP-CIDR,192.168.1.201/32,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何源 IP 地址为 <code>192.168.1.201/32</code> 的数据包路由到 <code>DIRECT</code>。</p>\n<h3 id=\"SRC-PORT-源端口\"><a href=\"#SRC-PORT-源端口\" class=\"headerlink\" title=\"SRC-PORT 源端口\"></a>SRC-PORT 源端口</h3><p>SRC-PORT 规则用于根据数据包的<strong>源端口</strong>路由数据包。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">SRC-PORT,80,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何源端口为 <code>80</code> 的数据包路由到 <code>policy</code>。</p>\n<h3 id=\"DST-PORT-目标端口\"><a href=\"#DST-PORT-目标端口\" class=\"headerlink\" title=\"DST-PORT 目标端口\"></a>DST-PORT 目标端口</h3><p>DST-PORT 规则用于根据数据包的<strong>目标端口</strong>路由数据包。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">DST-PORT,80,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标端口为 <code>80</code> 的数据包路由到 <code>policy</code>。</p>\n<h3 id=\"PROCESS-NAME-源进程名\"><a href=\"#PROCESS-NAME-源进程名\" class=\"headerlink\" title=\"PROCESS-NAME 源进程名\"></a>PROCESS-NAME 源进程名</h3><p>PROCESS-NAME 规则用于根据发送数据包的进程名称路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">PROCESS-NAME,nc,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何来自进程 <code>nc</code> 的数据包路由到 <code>DIRECT</code>。</p>\n<h3 id=\"PROCESS-PATH-源进程路径\"><a href=\"#PROCESS-PATH-源进程路径\" class=\"headerlink\" title=\"PROCESS-PATH 源进程路径\"></a>PROCESS-PATH 源进程路径</h3><p>PROCESS-PATH 规则用于根据发送数据包的进程路径路由数据包。目前仅支持 macOS、Linux、FreeBSD 和 Windows。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">PROCESS-PATH,/usr/local/bin/nc,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何来自路径为 <code>/usr/local/bin/nc</code> 的进程的数据包路由到 <code>DIRECT</code>。</p>\n<h3 id=\"IPSET-IP集\"><a href=\"#IPSET-IP集\" class=\"headerlink\" title=\"IPSET IP集\"></a>IPSET IP集</h3><p>IPSET 规则用于根据 IP 集匹配并路由数据包. 根据 <a href=\"https://ipset.netfilter.org/\"><strong>IPSET 的官方网站</strong></a> 的介绍:</p>\n<blockquote>\n<p>IP 集是 Linux 内核中的一个框架, 可以通过 ipset 程序进行管理。根据类型，IP 集可以存储 IP 地址、网络、 (TCP&#x2F;UDP) 端口号、MAC 地址、接口名称或它们以某种方式的组合，以确保在集合中匹配条目时具有闪电般的速度。</p>\n</blockquote>\n<p>因此, 此功能仅在 Linux 上工作, 并且需要安装 <code>ipset</code>。使用此规则时, Clash 将解析域名以获取 IP 地址, 然后查找 IP 地址是否在 IP 集中. 如果要跳过 DNS 解析, 请使用 <strong><code>no-resolve</code></strong> 选项.</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">IPSET,chnroute,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将任何目标 IP 地址在 IP 集 <code>chnroute</code> 中的数据包路由到 <code>policy</code>.</p>\n<h3 id=\"RULE-SET-规则集\"><a href=\"#RULE-SET-规则集\" class=\"headerlink\" title=\"RULE-SET 规则集\"></a>RULE-SET 规则集</h3><p>此功能仅在 <a href=\"https://clash.wiki/premium/introduction.html\"><strong>Premium 版本</strong></a> 中可用。</p>\n<p>RULE-SET 规则用于根据 <a href=\"https://clash.wiki/premium/rule-providers.html\"><strong>Rule Providers 规则集</strong></a> 的结果路由数据包。当 Clash 使用此规则时，它会从指定的 Rule Providers 规则集中加载规则，然后将数据包与规则进行匹配。 如果数据包与任何规则匹配，则将数据包路由到指定的策略, 否则跳过此规则。</p>\n<p>使用 RULE-SET 时，当规则集的类型为 IPCIDR ，Clash 将解析域名以获取 IP 地址。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">RULE-SET,my-rule-provider,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>从 <code>my-rule-provider</code> 加载所有规则。</p>\n<h3 id=\"SCRIPT-脚本\"><a href=\"#SCRIPT-脚本\" class=\"headerlink\" title=\"SCRIPT 脚本\"></a>SCRIPT 脚本</h3><p>此功能仅在 <a href=\"https://clash.wiki/premium/introduction.html\"><strong>Premium 版本</strong></a> 中可用。</p>\n<p>SCRIPT 规则用于根据脚本的结果路由数据包。当 Clash 使用此规则时，它会执行指定的脚本，然后将数据包路由到脚本的输出。使用 SCRIPT 时，Clash 将解析域名以获取 IP 地址。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">SCRIPT,script-path,DIRECT</span></span><br></pre></td></tr></table></figure>\n\n<p>将数据包路由到脚本 <code>script-path</code> 的输出.</p>\n<h3 id=\"MATCH-全匹配\"><a href=\"#MATCH-全匹配\" class=\"headerlink\" title=\"MATCH 全匹配\"></a>MATCH 全匹配</h3><p>MATCH 规则用于路由剩余的数据包。该规则是<strong>必需</strong>的，通常用作最后一条规则。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">MATCH,policy</span></span><br></pre></td></tr></table></figure>\n\n<p>将剩余的数据包路由到 <code>policy</code>。</p>\n<h2 id=\"透明代理\"><a href=\"#透明代理\" class=\"headerlink\" title=\"透明代理\"></a>透明代理</h2><h3 id=\"tproxy\"><a href=\"#tproxy\" class=\"headerlink\" title=\"tproxy\"></a>tproxy</h3><p>参考：<a href=\"https://www.zhaohuabing.com/learning-linux/docs/tproxy/\">tproxy（透明代理）</a></p>\n<p>tproxy 即 transparent（透明） proxy。这里的 transparent（透明）有两层含义：</p>\n<ol>\n<li>代理对于 client 是透明的，client 端无需进行任何配置。即无需修改请求地址，也无需采用代理协议和代理服务器进行协商。与之相对比的是 socks 代理或者 http 代理，需要在 client 端设置代理的地址，在发起请求时也需要通过代理协议告知代理服务器其需要访问的真实地址。</li>\n<li>代理对于 server 是透明的，server 端看到的是 client 端的地址，而不是 proxy 的地址</li>\n</ol>\n<p>这么说可能不够直观，通过下面这张图看会比较好，后者为透明代理，可以清晰地看到 client 发出请求的目的 IP 就是目标服务器的 IP：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240613024955.png\" alt=\"20240613024955\"></p>\n<p>从上面的描述能看出来，因为透明代理是在网络层面实现的，实现了全局代理的效果，所以无需在每个应用程序中配置，简化了操作，也在一定程度上增强了代理的隐蔽性。</p>\n<p>但由于客户端请求数据包的目的地址不是代理服务器，因此需要通过路由和 iptables 规则（Clash 实现，无需用户手动操作）将客户端的请求发送给代理服务器处理。</p>\n<h3 id=\"redirect\"><a href=\"#redirect\" class=\"headerlink\" title=\"redirect\"></a>redirect</h3><p>redirect 是另一种实现透明代理的方式。redirect 透明代理主要用于 TCP 流量，是通过修改数据包的目的端口来实现的。这种方法不需要像 tproxy 那样在网络层面进行操作，而是在传输层上实现的。</p>\n<p>以下是 Clash 基于 redirect 实现透明代理的过程：</p>\n<ol>\n<li>当客户端发起一个 TCP 连接时，iptables 规会捕获到这个连接请求；</li>\n<li>根据设置的规则，iptables 会将这个连接的目的端口重定向到 Clash 监听的端口上；</li>\n<li>Clash 接收到这个连接后，根据内部的规则处理，然后将流量转发到真正的目标服务器。</li>\n</ol>\n<p>使用 redirect 的优点是配置相对简单，特别是在不支持 tproxy 的系统上。它可以直接在 iptables 中设置，无需对操作系统的网络栈进行复杂的配置。这使得 redirect 成为一个在简单场景下快速部署透明代理的好选择。</p>\n"},{"title":"图像纹理特征提取：灰度共生矩阵","date":"2024-06-15T16:00:00.000Z","author":"ma5hr00m","_content":"\n数字图像处理的拓展内容，上课时被分配了“图像检索及 AI 应用”，想搞个小实践水水念 PPT 的时间，就稍微研究下图像纹理特征分析，也顺带写篇博客。\n\n## 图像检索发展\n\n在 Web2.0 时代，互联网中的信息量爆炸性增长，其中自然包含了很多图片。在 Twitter、FaceBook 等各种社交媒体平台，每月用户上传的图片数量都在 10 亿上下，而以淘宝、亚马逊为代表的电子商务平台，其后台存储的图片数量更是以百亿记。面对如此浩瀚且包含了丰富视觉信息的图片，如何从中精准快速地检索出我们想要的图片，已经成为了多媒体信息检索技术研究的热点。\n\n### 基于文本的图像检索技术 TBIR\n\n按发展顺序，可先后分为基于文本的图像检索技术（TBIR, Text Based Image Retrieval）和基于内容的图像检索技术（CBIR, Content Based Image Retrieval），前者可以理解为人工/半人工给图片打 tag，然后检索时根据 tag 匹配度检索图片，后者则是正经的使用计算机通过公式化的流程分析图片特征，然后实现以图搜图。\n\n先说 TBIR，这种技术好用吗？确实好用，因为实现难度不高，甚至你自己建立个数据库，给自己收藏的图片打 tag，然写个根据 tag 的搜索功能，这就算是一种 TBIR 的实现。而且因为是通过人工的方式给图像信息打 tag，而用户也是人，这样检索图像的准确率比较高。\n\n但从上述的简单流程就能看出，TBIR 也有一些明显的缺陷：给图片标注文本信息需要人工的介入，如果图像数据很庞大，就会耗费大量人力物力，这使得其无法被用于大规模的图像数据；同时也是因为人工的介入，导致标注信息时难免混入一些标注者的主观考量，同一张图片你很难让两个人给出完全一致的 tag 列表，这就会导致检索时的不准确。再另一方面，很多用户本身也没法做到精确描述自己需要的图片信息，比如下面这张图：\n\n![image-20240616145916690](https://img.ma5hr00m.top/blog/image-20240616145916690.png)\n\n你可能很喜欢这种风格，然后你打开了 Pinterest，接下来应该搜索什么关键词来描述这种风格呢？经验丰富的标注者可以使用 `LowPoly` 精准描述这种风格，但多数用户不能，这问题不是 TBIR 能解决的，毕竟连用户都不知道要搜什么，检索能力再强也没用。\n\n### 基于内容的图像检索技术 CBIR\n\n所以，在 1992 年，美国国家科学基金会就图像数据库管理系统新发展方向达成一致共识，表示索引图像信息的最有效方式应该是基于图像内容自身的。自此，基于内容的图像检索技术便逐步建立起来，并在近十多年里得到了迅速的发展。\n\n典型的 CBIR 框架如下，大致可总结为三个阶段：\n\n1. **特征提取**：计算机分析图像数据库中的每张图片，提取出颜色、纹理、形状等低层次视觉特征，并将这些特征转化为特征向量存储在图像特征库中。\n2. **查询处理**：当用户提交一张查询图像时，系统会用相同的方法提取其特征。\n3. **相似性度量与排序输出**：系统将查询图像的特征向量与特征库中的向量进行比较，根据相似性度量准则计算相似度，并将结果按相似度高低排序输出。\n\n![image-20240616150943134](https://img.ma5hr00m.top/blog/image-20240616150943134.png)\n\nCBIR 将标注图片、分析图片、检索图片的工作全部交给计算机，客服了 TBIR 的不足，极大地提高了检索效率以及可使用图像检索技术的规模。但也带来了一个问题：计算机不是人类，它很难理解高层语义，所以其图像特征的描述与人类存在语义鸿沟。\n\n这“高层语义”指的是人类对图像内容的抽象理解，比如识别图像中的场景或情感。这些含义通常超出了简单的视觉特征所能表达的范围，你可以使用“可爱”这种描述搜索出毛茸茸的小猫小狗，计算机很难办到，因为计算机无法直接理解“可爱”是什么，**语义鸿沟是无法消除的**，它只能通过一些额外的手段来弥补这种鸿沟。比如在实现图像检索时就预先告知计算机，“可爱”这种特征可以拆解为“多毛”、“眼睛在面部占比大”、“头身比低”等一系列特征，然后再将这些特征一步步分解，直到转化为计算机可以理解的图像视觉特征，比如纹理、颜色、形状等。\n\n但经过这一道道的转化，图像检索的准确率就会无可避免的下降，然后就需要再通过其他额外手段弥补这种缺陷。这就导致了 CBIR 虽然在很大程度解放了人力，但实现起来比较困难。\n\nTBIR 和 CBIR 在现代都得到了广泛应用。分别别举一个贴近生活的案例：常见的图片素材库，比如 Pinterest 和 花瓣网，都主要依靠 TBIR 技术；电子商务方面比如淘宝的拍立淘，就是主要基于 CBIR 技术。\n\n然后呢，随着 AI 技术大力发展，人们发现可以和图像检索技术结合使用，现代图像检索技术与 AI 的结合主要涉及到深度学习等新技术的研究和应用。深度学习可以自动学习和提取图像中的特征，处理更复杂的场景和任务。例如，深度神经网络能够自动提取图像特征进行分类，生成对抗网络（GAN）可以生成相似图片扩展数据集，自编码器可用于降噪和去模糊等。\n\n## 图像通用视觉特征\n\n图像特征的提取与表达是 CBIR 的基础。广义上讲，图像的特征包括基于文本的特征和视觉特征，前者在数据库系统和信息检索领域已有深入研究，这里只介绍后者。\n\n而视觉特征又可以分为两类：通用视觉特征和领域相关视觉特征。通用视觉特征就是我们肉眼所能看到的基本信息，适用于所有类型的图像；而领域相关视觉特征则依赖于特定领域的知识，如面部或指纹特征。不同的表达方法可以从不同角度描述一个特征，并没有所谓的“最佳”表达方式。\n\n通用视觉特征包括我们最常用的三种对图像的描述方式：色彩、纹理与形状。\n\n### 颜色特征\n\n颜色特征是在图像检索中应用最为广泛的视觉特征，主要原因在于颜色往往和图像中所包含的 物体或场景十分相关。此外，与其他的视觉特征相比，颜色特征对图像本身的尺寸、方向、视角的依赖性较小，从而具有较高的鲁棒性。\n\n### 纹理特征\n\n纹理特征是一种不依赖于颜色或亮度的反映图像中同质现象的视觉特征。它是所有物体表面共有的内在特性，例如云彩、树木、砖、织物等都有各自的纹理特征。纹理特征包含了物体表面结构组织排列的重要信息以及它们与周围环境的联系。正因为如此，纹理特征在 CBIR 中得到了广泛的应用。纹理特征具有四大特点：\n\n- 局部序列性重复\n- 非随机排列\n- 区域内均匀统一\n- 旋转不变性\n\n它通过像素及其周围空间邻域的灰度分布来表现局部纹理信息，并通过不同程度上的重复性展现全局纹理信息。纹理特征在模式匹配中具有优势，因为它是基于区域的统计计算，不容易受局部偏差影响。在检索纹理图像时，纹理特征可以有效区分粗细、疏密等差异较大的纹理，但在纹理之间差异不明显时，可能无法准确反映人眼的视觉感知。一些虚假纹理，如水中倒影或金属面反射造成的影响，可能会误导检索结果。\n\n### 形状特征\n\n物体和区域的形状是图像表达和图像检索中的另一重要的特征。但不同于颜色或纹理等底层特 征，形状特征的表达必须以对图像中物体或区域的划分为基础。由于当前的技术无法做到准确而鲁棒的自动图像分割，图像检索中的形状特征只能用于某些特殊应用，在这些应用中图像包含的物体 或区域可以直接获得。另一方面，由于人们对物体形状的变换、旋转和缩放主观上不太敏感，合适 的形状特征必须满足对变换、旋转和缩放无关，这对形状相似度的计算也带来了难度。\n\n## 纹理特征提取：灰度共生矩阵\n\n灰度共生矩阵（Gray-level Co-occurrence Matrix, GLCM）是计算机视觉领域常用的分析图像纹理特征的一种统计方法。\n\n> GLCM 本质上是一种矩阵，但我们通常会使用 GLCM 指代基于这种矩阵的分析方法。\n\nGLCM 的概念在 1973 年由 Haralick 等人首次提出，目的是描述图像的纹理特征。因为纹理是由灰度分布在空间位置上反复出现而形成的，所以在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。GLCM 就是用来描述这种空间相关性的，这也是“共生”这个词的意义。所以说 GLCM 描述的从来不是单个像素，而是成对的像素之间的关系。与之相对的，灰度直方图（Grayscale Image Histogram，GIH）则可以看做是对单个像素的统计与描述，并不涉及灰度间的关联关系。\n\n```matlab\nimg = imread('test.jpg');\n\ngrayImg = rgb2gray(img);\n\nglcm = graycomatrix(grayImg);\n\nfigure;\n\nsubplot(1,2,1), imshow(img), title('Original Image');\nsubplot(1,2,2), imshow(glcm,[]), title('GLCM');\n```\n\n可以使用以上 MATLAB 代码，获取一张普通的 jpg 图片的 GLCM 并进行对比：\n\n![image-20240616231003383](https://img.ma5hr00m.top/blog/image-20240616231003383.png)\n\n### 计算方法\n\n1. 确定量化级数：根据图像的灰度级别，创建一个方阵，通常是 256x256；\n2. 定义邻域关系：选择像素对的方向（水平、垂直、对角等）和距离（步长）；\n3. 统计频次：遍历图像，对于每个像素对`(i,j)`，如果它们的灰度级满足所定义的邻域关系，则在 GLCM 矩阵中相应位置`(i,j)`的值加一；\n4. 计算概率：将GLCM矩阵中的每个元素除以总次数，得到每种关联模式出现的概率。\n\nOk，明白了计算方法，我们就可以尝试自己写个 demo 出来试试成果哩。MatLab 我用得实在是不熟（平成确实没有使用场景），所以接下来的代码是使用 python 完成的。思路也很清晰，使用 `PIL` 读取图像并转化为灰度图像，然后使用 `numpy` 计算并创建对应的灰度共生矩阵图像，最后使用 `matplotlib` 库对原图以及灰度共生矩阵图像进行一个展示：\n\n```python\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\n\n# 读取图片并转换为灰度图像\ndef read_image(file_name):\n    return np.array(Image.open(file_name).convert('L'))\n\n# 创建灰度共生矩阵\ndef create_glcm(image, d=1, theta=0):\n    max_gray_level = 256\n    glcm = np.zeros((max_gray_level, max_gray_level))\n    rows, cols = image.shape\n\n    for i in range(rows):\n        for j in range(cols - d):\n            rows_value = image[i][j]\n            cols_value = image[i][j + d] if theta == 0 else image[i + d][j]\n            glcm[rows_value][cols_value] += 1\n\n    return glcm\n\ndef main():\n    image_a = read_image('a.jpg')\n    glcm_a = create_glcm(image_a)\n\n    plt.figure(figsize=(10, 5))\n\n    plt.subplot(1, 2, 1)\n    plt.imshow(image_a, cmap='gray')\n    plt.title('Original Image')\n    plt.axis('off')\n\n    plt.subplot(1, 2, 2)\n    plt.imshow(glcm_a, cmap='gray')\n    plt.title('GLCM of Image')\n    plt.axis('off')\n\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### 特征\n\n前面说了，GLCM 严格说是一种用于描述图像纹理特征的二维矩阵。这个矩阵每行或每列代表不同灰度级别的出现关系，对角线表示相邻像素灰度一致性。对每行进行累加可得到一个 256 维向量，表示原图中每个灰度级别像素的出现次数，类似灰度直方图。全元素求和等于总像素个数减去步长乘以跳跃次数。其不一定对称，因为 `(1,3)` 和 `(3,1)` 表示不同灰度关系。这种特殊的矩阵具有四个特性，分别是：\n\n1. 对比度：用于度量矩阵值的分布和局部变化，反应图像的清晰度和纹理的沟纹深浅。对比度越大，影像越清晰。计算公式如下，其中 `i`、`j` 为共生矩阵中的坐标索引，`P(i,j)` 为该位置的灰度值（对于共生矩阵来说就是某种灰度关联关系出现的次数）：\n\n   \\[Con = \\sum_{i}^{} \\sum_{j}^{} (i-j)^{2}P(i,j)\\]\n\n2. 能量：灰度共生矩阵元素值的平方和，称其为能量，也叫第二角力矩（Angular Second Moment, ASM）。反应了图像灰度分布均匀程度和纹理粗细度。如果其较大，则表明图像中存在一种较为均一和规则变化的纹理模式。计算公式如下：\n\n   \\[Asm = \\sum_{i}^{} \\sum_{j}^{} P(i,j)^{2}\\]\n\n3. 熵：在灰度共生矩阵中表示图像的信息量。当共生矩阵中元素分布较为分散时，熵较大。它表示了图像中纹理的非均匀程度或者复杂程度。计算公式如下：\n\n   \\[Ent = \\sum_{i}^{} \\sum_{j}^{} P(i,j)logP(i,j)\\]\n\n4. 相关度：度量灰度共生矩阵元素在行或列方向上的相似程度（Inverse Different Moment）。其值反应了图像中局部灰度相关性。当矩阵元素均匀相等时，相关度较大，反之较小。计算公式如下：\n\n   \\[IDM = \\sum_{i}^{} \\sum_{j}^{} \\frac{P(i,j)}{1+(i-j)^{2}}\\]\n\n虽然我们掌握了四种特性值的计算方法，可以用文本数值对图像的纹理特征进行表示了，但还是有不方便的地方，将两组图像的纹理特征进行对比时，如果两项特性值高、两项特性值低该怎么办？这就需要归一化处理。对 GLCM 进行归一化处理的主要目的是消除图像大小、对比度等因素对特征计算的影响，从而使得特征更具有普适性和可比性。这样做的好处包括：\n\nGLCM 的归一化主要包括两种常见的方法：\n\n- 将 GLCM 矩阵中的元素值除以 GLCM 矩阵中所有元素值的和，使得归一化后的 GLCM 矩阵中所有元素之和为1\n- 将 GLCM 矩阵中的元素值除以 GLCM 矩阵中元素值的平方和的平方根，使得归一化后的 GLCM 矩阵中元素值的平方和为1。\n\n进行归一化处理后得到的数值一般被称为 **规范化纹理特征**，我们可以使用该值对图像之间的纹理特征进行一个就更加具象的对比。\n\n### 进一步实践\n\n掌握了以上内容，现在我们可以做一个更加贴近现实的实践了。我准备了三张图片，有两张是动物的皮毛，还有一张是爬行动物的鳞甲图（下面这张图是实验结果的一部分，三张图片原图是彩图，不过对实验没什么影响）：\n\n![image-20240617003235838](https://img.ma5hr00m.top/blog/image-20240617003235838.png)\n\n使用 Python 分别计算三张图片的灰度共生矩阵，然后计算四项特征值，再进行归一化处理，最后根据规范化纹理特征判断哪两张图像的纹理特征更接近。因为代码里很多内容是在调用函数、输出结果以及展示图片，所以不全贴出来，只展示部分核心代码，也就是做计算提取图像纹理特征那块，完整代码上传到了我的一个存储学校作业的 GitHub 仓库中，位于“数字图像处理”目录下，也包括了三张示范图片，可以自行前往查看。\n\n以下为核心函数代码：\n\n```python\n# 读取图片并转换为灰度图像\ndef read_image(file_name):\n    return np.array(Image.open(file_name).convert('L'))\n\n# 创建灰度共生矩阵\ndef create_glcm(image, d=1, theta=0):\n    max_gray_level = 256\n    glcm = np.zeros((max_gray_level, max_gray_level))\n    rows, cols = image.shape\n\n    for i in range(rows):\n        for j in range(cols - d):\n            rows_value = image[i][j]\n            cols_value = image[i][j + d] if theta == 0 else image[i + d][j]\n            glcm[rows_value][cols_value] += 1\n\n    return glcm\n\n# 计算特征值\ndef calculate_features(glcm):\n    contrast = np.sum(np.square(np.arange(glcm.shape[0]) - np.arange(glcm.shape[1])) * glcm)\n    energy = np.sum(np.square(glcm))\n    entropy = -np.sum(glcm * np.ma.log(glcm).filled(0))\n    inverse_diff_moment = np.sum(glcm / (1 + np.square(np.arange(glcm.shape[0]) - np.arange(glcm.shape[1]))))\n\n    return contrast, energy, entropy, inverse_diff_moment\n\n# 归一化处理\ndef normalize_features(features):\n    normalized_features = (features - np.mean(features)) / np.std(features)\n    return normalized_features\n```\n\n运行结果，轻松得出 a 与 b 更加相似的结论：\n\n![image-20240617003516465](https://img.ma5hr00m.top/blog/image-20240617003516465.png)\n\n## 阅读文档\n\n- https://github.com/scikit-image/skimage-tutorials\n- https://leovan.me/cn/2022/01/content-based-image-retrieval/\n- https://www.cs.cmu.edu/~juny/Prof/papers/Part2-CBIR.pdf\n- [特征提取——纹理特征-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1934204)\n\n- [GLCM 灰度共生矩阵与 Haralick 特征-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2219407)\n- [纹理特征提取方法：LBP, 灰度共生矩阵-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1010272)\n- http://zhaoxuhui.top/blog/2022/03/15/gray-level-co-occurence-matrix.html","source":"_posts/glcm.md","raw":"---\ntitle: 图像纹理特征提取：灰度共生矩阵\ndate: 2024/6/16\nauthor: ma5hr00m\ncategories:\n- Digital Image Processing\n---\n\n数字图像处理的拓展内容，上课时被分配了“图像检索及 AI 应用”，想搞个小实践水水念 PPT 的时间，就稍微研究下图像纹理特征分析，也顺带写篇博客。\n\n## 图像检索发展\n\n在 Web2.0 时代，互联网中的信息量爆炸性增长，其中自然包含了很多图片。在 Twitter、FaceBook 等各种社交媒体平台，每月用户上传的图片数量都在 10 亿上下，而以淘宝、亚马逊为代表的电子商务平台，其后台存储的图片数量更是以百亿记。面对如此浩瀚且包含了丰富视觉信息的图片，如何从中精准快速地检索出我们想要的图片，已经成为了多媒体信息检索技术研究的热点。\n\n### 基于文本的图像检索技术 TBIR\n\n按发展顺序，可先后分为基于文本的图像检索技术（TBIR, Text Based Image Retrieval）和基于内容的图像检索技术（CBIR, Content Based Image Retrieval），前者可以理解为人工/半人工给图片打 tag，然后检索时根据 tag 匹配度检索图片，后者则是正经的使用计算机通过公式化的流程分析图片特征，然后实现以图搜图。\n\n先说 TBIR，这种技术好用吗？确实好用，因为实现难度不高，甚至你自己建立个数据库，给自己收藏的图片打 tag，然写个根据 tag 的搜索功能，这就算是一种 TBIR 的实现。而且因为是通过人工的方式给图像信息打 tag，而用户也是人，这样检索图像的准确率比较高。\n\n但从上述的简单流程就能看出，TBIR 也有一些明显的缺陷：给图片标注文本信息需要人工的介入，如果图像数据很庞大，就会耗费大量人力物力，这使得其无法被用于大规模的图像数据；同时也是因为人工的介入，导致标注信息时难免混入一些标注者的主观考量，同一张图片你很难让两个人给出完全一致的 tag 列表，这就会导致检索时的不准确。再另一方面，很多用户本身也没法做到精确描述自己需要的图片信息，比如下面这张图：\n\n![image-20240616145916690](https://img.ma5hr00m.top/blog/image-20240616145916690.png)\n\n你可能很喜欢这种风格，然后你打开了 Pinterest，接下来应该搜索什么关键词来描述这种风格呢？经验丰富的标注者可以使用 `LowPoly` 精准描述这种风格，但多数用户不能，这问题不是 TBIR 能解决的，毕竟连用户都不知道要搜什么，检索能力再强也没用。\n\n### 基于内容的图像检索技术 CBIR\n\n所以，在 1992 年，美国国家科学基金会就图像数据库管理系统新发展方向达成一致共识，表示索引图像信息的最有效方式应该是基于图像内容自身的。自此，基于内容的图像检索技术便逐步建立起来，并在近十多年里得到了迅速的发展。\n\n典型的 CBIR 框架如下，大致可总结为三个阶段：\n\n1. **特征提取**：计算机分析图像数据库中的每张图片，提取出颜色、纹理、形状等低层次视觉特征，并将这些特征转化为特征向量存储在图像特征库中。\n2. **查询处理**：当用户提交一张查询图像时，系统会用相同的方法提取其特征。\n3. **相似性度量与排序输出**：系统将查询图像的特征向量与特征库中的向量进行比较，根据相似性度量准则计算相似度，并将结果按相似度高低排序输出。\n\n![image-20240616150943134](https://img.ma5hr00m.top/blog/image-20240616150943134.png)\n\nCBIR 将标注图片、分析图片、检索图片的工作全部交给计算机，客服了 TBIR 的不足，极大地提高了检索效率以及可使用图像检索技术的规模。但也带来了一个问题：计算机不是人类，它很难理解高层语义，所以其图像特征的描述与人类存在语义鸿沟。\n\n这“高层语义”指的是人类对图像内容的抽象理解，比如识别图像中的场景或情感。这些含义通常超出了简单的视觉特征所能表达的范围，你可以使用“可爱”这种描述搜索出毛茸茸的小猫小狗，计算机很难办到，因为计算机无法直接理解“可爱”是什么，**语义鸿沟是无法消除的**，它只能通过一些额外的手段来弥补这种鸿沟。比如在实现图像检索时就预先告知计算机，“可爱”这种特征可以拆解为“多毛”、“眼睛在面部占比大”、“头身比低”等一系列特征，然后再将这些特征一步步分解，直到转化为计算机可以理解的图像视觉特征，比如纹理、颜色、形状等。\n\n但经过这一道道的转化，图像检索的准确率就会无可避免的下降，然后就需要再通过其他额外手段弥补这种缺陷。这就导致了 CBIR 虽然在很大程度解放了人力，但实现起来比较困难。\n\nTBIR 和 CBIR 在现代都得到了广泛应用。分别别举一个贴近生活的案例：常见的图片素材库，比如 Pinterest 和 花瓣网，都主要依靠 TBIR 技术；电子商务方面比如淘宝的拍立淘，就是主要基于 CBIR 技术。\n\n然后呢，随着 AI 技术大力发展，人们发现可以和图像检索技术结合使用，现代图像检索技术与 AI 的结合主要涉及到深度学习等新技术的研究和应用。深度学习可以自动学习和提取图像中的特征，处理更复杂的场景和任务。例如，深度神经网络能够自动提取图像特征进行分类，生成对抗网络（GAN）可以生成相似图片扩展数据集，自编码器可用于降噪和去模糊等。\n\n## 图像通用视觉特征\n\n图像特征的提取与表达是 CBIR 的基础。广义上讲，图像的特征包括基于文本的特征和视觉特征，前者在数据库系统和信息检索领域已有深入研究，这里只介绍后者。\n\n而视觉特征又可以分为两类：通用视觉特征和领域相关视觉特征。通用视觉特征就是我们肉眼所能看到的基本信息，适用于所有类型的图像；而领域相关视觉特征则依赖于特定领域的知识，如面部或指纹特征。不同的表达方法可以从不同角度描述一个特征，并没有所谓的“最佳”表达方式。\n\n通用视觉特征包括我们最常用的三种对图像的描述方式：色彩、纹理与形状。\n\n### 颜色特征\n\n颜色特征是在图像检索中应用最为广泛的视觉特征，主要原因在于颜色往往和图像中所包含的 物体或场景十分相关。此外，与其他的视觉特征相比，颜色特征对图像本身的尺寸、方向、视角的依赖性较小，从而具有较高的鲁棒性。\n\n### 纹理特征\n\n纹理特征是一种不依赖于颜色或亮度的反映图像中同质现象的视觉特征。它是所有物体表面共有的内在特性，例如云彩、树木、砖、织物等都有各自的纹理特征。纹理特征包含了物体表面结构组织排列的重要信息以及它们与周围环境的联系。正因为如此，纹理特征在 CBIR 中得到了广泛的应用。纹理特征具有四大特点：\n\n- 局部序列性重复\n- 非随机排列\n- 区域内均匀统一\n- 旋转不变性\n\n它通过像素及其周围空间邻域的灰度分布来表现局部纹理信息，并通过不同程度上的重复性展现全局纹理信息。纹理特征在模式匹配中具有优势，因为它是基于区域的统计计算，不容易受局部偏差影响。在检索纹理图像时，纹理特征可以有效区分粗细、疏密等差异较大的纹理，但在纹理之间差异不明显时，可能无法准确反映人眼的视觉感知。一些虚假纹理，如水中倒影或金属面反射造成的影响，可能会误导检索结果。\n\n### 形状特征\n\n物体和区域的形状是图像表达和图像检索中的另一重要的特征。但不同于颜色或纹理等底层特 征，形状特征的表达必须以对图像中物体或区域的划分为基础。由于当前的技术无法做到准确而鲁棒的自动图像分割，图像检索中的形状特征只能用于某些特殊应用，在这些应用中图像包含的物体 或区域可以直接获得。另一方面，由于人们对物体形状的变换、旋转和缩放主观上不太敏感，合适 的形状特征必须满足对变换、旋转和缩放无关，这对形状相似度的计算也带来了难度。\n\n## 纹理特征提取：灰度共生矩阵\n\n灰度共生矩阵（Gray-level Co-occurrence Matrix, GLCM）是计算机视觉领域常用的分析图像纹理特征的一种统计方法。\n\n> GLCM 本质上是一种矩阵，但我们通常会使用 GLCM 指代基于这种矩阵的分析方法。\n\nGLCM 的概念在 1973 年由 Haralick 等人首次提出，目的是描述图像的纹理特征。因为纹理是由灰度分布在空间位置上反复出现而形成的，所以在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。GLCM 就是用来描述这种空间相关性的，这也是“共生”这个词的意义。所以说 GLCM 描述的从来不是单个像素，而是成对的像素之间的关系。与之相对的，灰度直方图（Grayscale Image Histogram，GIH）则可以看做是对单个像素的统计与描述，并不涉及灰度间的关联关系。\n\n```matlab\nimg = imread('test.jpg');\n\ngrayImg = rgb2gray(img);\n\nglcm = graycomatrix(grayImg);\n\nfigure;\n\nsubplot(1,2,1), imshow(img), title('Original Image');\nsubplot(1,2,2), imshow(glcm,[]), title('GLCM');\n```\n\n可以使用以上 MATLAB 代码，获取一张普通的 jpg 图片的 GLCM 并进行对比：\n\n![image-20240616231003383](https://img.ma5hr00m.top/blog/image-20240616231003383.png)\n\n### 计算方法\n\n1. 确定量化级数：根据图像的灰度级别，创建一个方阵，通常是 256x256；\n2. 定义邻域关系：选择像素对的方向（水平、垂直、对角等）和距离（步长）；\n3. 统计频次：遍历图像，对于每个像素对`(i,j)`，如果它们的灰度级满足所定义的邻域关系，则在 GLCM 矩阵中相应位置`(i,j)`的值加一；\n4. 计算概率：将GLCM矩阵中的每个元素除以总次数，得到每种关联模式出现的概率。\n\nOk，明白了计算方法，我们就可以尝试自己写个 demo 出来试试成果哩。MatLab 我用得实在是不熟（平成确实没有使用场景），所以接下来的代码是使用 python 完成的。思路也很清晰，使用 `PIL` 读取图像并转化为灰度图像，然后使用 `numpy` 计算并创建对应的灰度共生矩阵图像，最后使用 `matplotlib` 库对原图以及灰度共生矩阵图像进行一个展示：\n\n```python\nimport numpy as np\nfrom PIL import Image\nimport matplotlib.pyplot as plt\n\n# 读取图片并转换为灰度图像\ndef read_image(file_name):\n    return np.array(Image.open(file_name).convert('L'))\n\n# 创建灰度共生矩阵\ndef create_glcm(image, d=1, theta=0):\n    max_gray_level = 256\n    glcm = np.zeros((max_gray_level, max_gray_level))\n    rows, cols = image.shape\n\n    for i in range(rows):\n        for j in range(cols - d):\n            rows_value = image[i][j]\n            cols_value = image[i][j + d] if theta == 0 else image[i + d][j]\n            glcm[rows_value][cols_value] += 1\n\n    return glcm\n\ndef main():\n    image_a = read_image('a.jpg')\n    glcm_a = create_glcm(image_a)\n\n    plt.figure(figsize=(10, 5))\n\n    plt.subplot(1, 2, 1)\n    plt.imshow(image_a, cmap='gray')\n    plt.title('Original Image')\n    plt.axis('off')\n\n    plt.subplot(1, 2, 2)\n    plt.imshow(glcm_a, cmap='gray')\n    plt.title('GLCM of Image')\n    plt.axis('off')\n\n    plt.show()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### 特征\n\n前面说了，GLCM 严格说是一种用于描述图像纹理特征的二维矩阵。这个矩阵每行或每列代表不同灰度级别的出现关系，对角线表示相邻像素灰度一致性。对每行进行累加可得到一个 256 维向量，表示原图中每个灰度级别像素的出现次数，类似灰度直方图。全元素求和等于总像素个数减去步长乘以跳跃次数。其不一定对称，因为 `(1,3)` 和 `(3,1)` 表示不同灰度关系。这种特殊的矩阵具有四个特性，分别是：\n\n1. 对比度：用于度量矩阵值的分布和局部变化，反应图像的清晰度和纹理的沟纹深浅。对比度越大，影像越清晰。计算公式如下，其中 `i`、`j` 为共生矩阵中的坐标索引，`P(i,j)` 为该位置的灰度值（对于共生矩阵来说就是某种灰度关联关系出现的次数）：\n\n   \\[Con = \\sum_{i}^{} \\sum_{j}^{} (i-j)^{2}P(i,j)\\]\n\n2. 能量：灰度共生矩阵元素值的平方和，称其为能量，也叫第二角力矩（Angular Second Moment, ASM）。反应了图像灰度分布均匀程度和纹理粗细度。如果其较大，则表明图像中存在一种较为均一和规则变化的纹理模式。计算公式如下：\n\n   \\[Asm = \\sum_{i}^{} \\sum_{j}^{} P(i,j)^{2}\\]\n\n3. 熵：在灰度共生矩阵中表示图像的信息量。当共生矩阵中元素分布较为分散时，熵较大。它表示了图像中纹理的非均匀程度或者复杂程度。计算公式如下：\n\n   \\[Ent = \\sum_{i}^{} \\sum_{j}^{} P(i,j)logP(i,j)\\]\n\n4. 相关度：度量灰度共生矩阵元素在行或列方向上的相似程度（Inverse Different Moment）。其值反应了图像中局部灰度相关性。当矩阵元素均匀相等时，相关度较大，反之较小。计算公式如下：\n\n   \\[IDM = \\sum_{i}^{} \\sum_{j}^{} \\frac{P(i,j)}{1+(i-j)^{2}}\\]\n\n虽然我们掌握了四种特性值的计算方法，可以用文本数值对图像的纹理特征进行表示了，但还是有不方便的地方，将两组图像的纹理特征进行对比时，如果两项特性值高、两项特性值低该怎么办？这就需要归一化处理。对 GLCM 进行归一化处理的主要目的是消除图像大小、对比度等因素对特征计算的影响，从而使得特征更具有普适性和可比性。这样做的好处包括：\n\nGLCM 的归一化主要包括两种常见的方法：\n\n- 将 GLCM 矩阵中的元素值除以 GLCM 矩阵中所有元素值的和，使得归一化后的 GLCM 矩阵中所有元素之和为1\n- 将 GLCM 矩阵中的元素值除以 GLCM 矩阵中元素值的平方和的平方根，使得归一化后的 GLCM 矩阵中元素值的平方和为1。\n\n进行归一化处理后得到的数值一般被称为 **规范化纹理特征**，我们可以使用该值对图像之间的纹理特征进行一个就更加具象的对比。\n\n### 进一步实践\n\n掌握了以上内容，现在我们可以做一个更加贴近现实的实践了。我准备了三张图片，有两张是动物的皮毛，还有一张是爬行动物的鳞甲图（下面这张图是实验结果的一部分，三张图片原图是彩图，不过对实验没什么影响）：\n\n![image-20240617003235838](https://img.ma5hr00m.top/blog/image-20240617003235838.png)\n\n使用 Python 分别计算三张图片的灰度共生矩阵，然后计算四项特征值，再进行归一化处理，最后根据规范化纹理特征判断哪两张图像的纹理特征更接近。因为代码里很多内容是在调用函数、输出结果以及展示图片，所以不全贴出来，只展示部分核心代码，也就是做计算提取图像纹理特征那块，完整代码上传到了我的一个存储学校作业的 GitHub 仓库中，位于“数字图像处理”目录下，也包括了三张示范图片，可以自行前往查看。\n\n以下为核心函数代码：\n\n```python\n# 读取图片并转换为灰度图像\ndef read_image(file_name):\n    return np.array(Image.open(file_name).convert('L'))\n\n# 创建灰度共生矩阵\ndef create_glcm(image, d=1, theta=0):\n    max_gray_level = 256\n    glcm = np.zeros((max_gray_level, max_gray_level))\n    rows, cols = image.shape\n\n    for i in range(rows):\n        for j in range(cols - d):\n            rows_value = image[i][j]\n            cols_value = image[i][j + d] if theta == 0 else image[i + d][j]\n            glcm[rows_value][cols_value] += 1\n\n    return glcm\n\n# 计算特征值\ndef calculate_features(glcm):\n    contrast = np.sum(np.square(np.arange(glcm.shape[0]) - np.arange(glcm.shape[1])) * glcm)\n    energy = np.sum(np.square(glcm))\n    entropy = -np.sum(glcm * np.ma.log(glcm).filled(0))\n    inverse_diff_moment = np.sum(glcm / (1 + np.square(np.arange(glcm.shape[0]) - np.arange(glcm.shape[1]))))\n\n    return contrast, energy, entropy, inverse_diff_moment\n\n# 归一化处理\ndef normalize_features(features):\n    normalized_features = (features - np.mean(features)) / np.std(features)\n    return normalized_features\n```\n\n运行结果，轻松得出 a 与 b 更加相似的结论：\n\n![image-20240617003516465](https://img.ma5hr00m.top/blog/image-20240617003516465.png)\n\n## 阅读文档\n\n- https://github.com/scikit-image/skimage-tutorials\n- https://leovan.me/cn/2022/01/content-based-image-retrieval/\n- https://www.cs.cmu.edu/~juny/Prof/papers/Part2-CBIR.pdf\n- [特征提取——纹理特征-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1934204)\n\n- [GLCM 灰度共生矩阵与 Haralick 特征-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2219407)\n- [纹理特征提取方法：LBP, 灰度共生矩阵-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1010272)\n- http://zhaoxuhui.top/blog/2022/03/15/gray-level-co-occurence-matrix.html","slug":"glcm","published":1,"updated":"2024-06-16T16:39:00.281Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap3000if4lybsx89lvc","content":"<p>数字图像处理的拓展内容，上课时被分配了“图像检索及 AI 应用”，想搞个小实践水水念 PPT 的时间，就稍微研究下图像纹理特征分析，也顺带写篇博客。</p>\n<h2 id=\"图像检索发展\"><a href=\"#图像检索发展\" class=\"headerlink\" title=\"图像检索发展\"></a>图像检索发展</h2><p>在 Web2.0 时代，互联网中的信息量爆炸性增长，其中自然包含了很多图片。在 Twitter、FaceBook 等各种社交媒体平台，每月用户上传的图片数量都在 10 亿上下，而以淘宝、亚马逊为代表的电子商务平台，其后台存储的图片数量更是以百亿记。面对如此浩瀚且包含了丰富视觉信息的图片，如何从中精准快速地检索出我们想要的图片，已经成为了多媒体信息检索技术研究的热点。</p>\n<h3 id=\"基于文本的图像检索技术-TBIR\"><a href=\"#基于文本的图像检索技术-TBIR\" class=\"headerlink\" title=\"基于文本的图像检索技术 TBIR\"></a>基于文本的图像检索技术 TBIR</h3><p>按发展顺序，可先后分为基于文本的图像检索技术（TBIR, Text Based Image Retrieval）和基于内容的图像检索技术（CBIR, Content Based Image Retrieval），前者可以理解为人工&#x2F;半人工给图片打 tag，然后检索时根据 tag 匹配度检索图片，后者则是正经的使用计算机通过公式化的流程分析图片特征，然后实现以图搜图。</p>\n<p>先说 TBIR，这种技术好用吗？确实好用，因为实现难度不高，甚至你自己建立个数据库，给自己收藏的图片打 tag，然写个根据 tag 的搜索功能，这就算是一种 TBIR 的实现。而且因为是通过人工的方式给图像信息打 tag，而用户也是人，这样检索图像的准确率比较高。</p>\n<p>但从上述的简单流程就能看出，TBIR 也有一些明显的缺陷：给图片标注文本信息需要人工的介入，如果图像数据很庞大，就会耗费大量人力物力，这使得其无法被用于大规模的图像数据；同时也是因为人工的介入，导致标注信息时难免混入一些标注者的主观考量，同一张图片你很难让两个人给出完全一致的 tag 列表，这就会导致检索时的不准确。再另一方面，很多用户本身也没法做到精确描述自己需要的图片信息，比如下面这张图：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240616145916690.png\" alt=\"image-20240616145916690\"></p>\n<p>你可能很喜欢这种风格，然后你打开了 Pinterest，接下来应该搜索什么关键词来描述这种风格呢？经验丰富的标注者可以使用 <code>LowPoly</code> 精准描述这种风格，但多数用户不能，这问题不是 TBIR 能解决的，毕竟连用户都不知道要搜什么，检索能力再强也没用。</p>\n<h3 id=\"基于内容的图像检索技术-CBIR\"><a href=\"#基于内容的图像检索技术-CBIR\" class=\"headerlink\" title=\"基于内容的图像检索技术 CBIR\"></a>基于内容的图像检索技术 CBIR</h3><p>所以，在 1992 年，美国国家科学基金会就图像数据库管理系统新发展方向达成一致共识，表示索引图像信息的最有效方式应该是基于图像内容自身的。自此，基于内容的图像检索技术便逐步建立起来，并在近十多年里得到了迅速的发展。</p>\n<p>典型的 CBIR 框架如下，大致可总结为三个阶段：</p>\n<ol>\n<li><strong>特征提取</strong>：计算机分析图像数据库中的每张图片，提取出颜色、纹理、形状等低层次视觉特征，并将这些特征转化为特征向量存储在图像特征库中。</li>\n<li><strong>查询处理</strong>：当用户提交一张查询图像时，系统会用相同的方法提取其特征。</li>\n<li><strong>相似性度量与排序输出</strong>：系统将查询图像的特征向量与特征库中的向量进行比较，根据相似性度量准则计算相似度，并将结果按相似度高低排序输出。</li>\n</ol>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240616150943134.png\" alt=\"image-20240616150943134\"></p>\n<p>CBIR 将标注图片、分析图片、检索图片的工作全部交给计算机，客服了 TBIR 的不足，极大地提高了检索效率以及可使用图像检索技术的规模。但也带来了一个问题：计算机不是人类，它很难理解高层语义，所以其图像特征的描述与人类存在语义鸿沟。</p>\n<p>这“高层语义”指的是人类对图像内容的抽象理解，比如识别图像中的场景或情感。这些含义通常超出了简单的视觉特征所能表达的范围，你可以使用“可爱”这种描述搜索出毛茸茸的小猫小狗，计算机很难办到，因为计算机无法直接理解“可爱”是什么，<strong>语义鸿沟是无法消除的</strong>，它只能通过一些额外的手段来弥补这种鸿沟。比如在实现图像检索时就预先告知计算机，“可爱”这种特征可以拆解为“多毛”、“眼睛在面部占比大”、“头身比低”等一系列特征，然后再将这些特征一步步分解，直到转化为计算机可以理解的图像视觉特征，比如纹理、颜色、形状等。</p>\n<p>但经过这一道道的转化，图像检索的准确率就会无可避免的下降，然后就需要再通过其他额外手段弥补这种缺陷。这就导致了 CBIR 虽然在很大程度解放了人力，但实现起来比较困难。</p>\n<p>TBIR 和 CBIR 在现代都得到了广泛应用。分别别举一个贴近生活的案例：常见的图片素材库，比如 Pinterest 和 花瓣网，都主要依靠 TBIR 技术；电子商务方面比如淘宝的拍立淘，就是主要基于 CBIR 技术。</p>\n<p>然后呢，随着 AI 技术大力发展，人们发现可以和图像检索技术结合使用，现代图像检索技术与 AI 的结合主要涉及到深度学习等新技术的研究和应用。深度学习可以自动学习和提取图像中的特征，处理更复杂的场景和任务。例如，深度神经网络能够自动提取图像特征进行分类，生成对抗网络（GAN）可以生成相似图片扩展数据集，自编码器可用于降噪和去模糊等。</p>\n<h2 id=\"图像通用视觉特征\"><a href=\"#图像通用视觉特征\" class=\"headerlink\" title=\"图像通用视觉特征\"></a>图像通用视觉特征</h2><p>图像特征的提取与表达是 CBIR 的基础。广义上讲，图像的特征包括基于文本的特征和视觉特征，前者在数据库系统和信息检索领域已有深入研究，这里只介绍后者。</p>\n<p>而视觉特征又可以分为两类：通用视觉特征和领域相关视觉特征。通用视觉特征就是我们肉眼所能看到的基本信息，适用于所有类型的图像；而领域相关视觉特征则依赖于特定领域的知识，如面部或指纹特征。不同的表达方法可以从不同角度描述一个特征，并没有所谓的“最佳”表达方式。</p>\n<p>通用视觉特征包括我们最常用的三种对图像的描述方式：色彩、纹理与形状。</p>\n<h3 id=\"颜色特征\"><a href=\"#颜色特征\" class=\"headerlink\" title=\"颜色特征\"></a>颜色特征</h3><p>颜色特征是在图像检索中应用最为广泛的视觉特征，主要原因在于颜色往往和图像中所包含的 物体或场景十分相关。此外，与其他的视觉特征相比，颜色特征对图像本身的尺寸、方向、视角的依赖性较小，从而具有较高的鲁棒性。</p>\n<h3 id=\"纹理特征\"><a href=\"#纹理特征\" class=\"headerlink\" title=\"纹理特征\"></a>纹理特征</h3><p>纹理特征是一种不依赖于颜色或亮度的反映图像中同质现象的视觉特征。它是所有物体表面共有的内在特性，例如云彩、树木、砖、织物等都有各自的纹理特征。纹理特征包含了物体表面结构组织排列的重要信息以及它们与周围环境的联系。正因为如此，纹理特征在 CBIR 中得到了广泛的应用。纹理特征具有四大特点：</p>\n<ul>\n<li>局部序列性重复</li>\n<li>非随机排列</li>\n<li>区域内均匀统一</li>\n<li>旋转不变性</li>\n</ul>\n<p>它通过像素及其周围空间邻域的灰度分布来表现局部纹理信息，并通过不同程度上的重复性展现全局纹理信息。纹理特征在模式匹配中具有优势，因为它是基于区域的统计计算，不容易受局部偏差影响。在检索纹理图像时，纹理特征可以有效区分粗细、疏密等差异较大的纹理，但在纹理之间差异不明显时，可能无法准确反映人眼的视觉感知。一些虚假纹理，如水中倒影或金属面反射造成的影响，可能会误导检索结果。</p>\n<h3 id=\"形状特征\"><a href=\"#形状特征\" class=\"headerlink\" title=\"形状特征\"></a>形状特征</h3><p>物体和区域的形状是图像表达和图像检索中的另一重要的特征。但不同于颜色或纹理等底层特 征，形状特征的表达必须以对图像中物体或区域的划分为基础。由于当前的技术无法做到准确而鲁棒的自动图像分割，图像检索中的形状特征只能用于某些特殊应用，在这些应用中图像包含的物体 或区域可以直接获得。另一方面，由于人们对物体形状的变换、旋转和缩放主观上不太敏感，合适 的形状特征必须满足对变换、旋转和缩放无关，这对形状相似度的计算也带来了难度。</p>\n<h2 id=\"纹理特征提取：灰度共生矩阵\"><a href=\"#纹理特征提取：灰度共生矩阵\" class=\"headerlink\" title=\"纹理特征提取：灰度共生矩阵\"></a>纹理特征提取：灰度共生矩阵</h2><p>灰度共生矩阵（Gray-level Co-occurrence Matrix, GLCM）是计算机视觉领域常用的分析图像纹理特征的一种统计方法。</p>\n<blockquote>\n<p>GLCM 本质上是一种矩阵，但我们通常会使用 GLCM 指代基于这种矩阵的分析方法。</p>\n</blockquote>\n<p>GLCM 的概念在 1973 年由 Haralick 等人首次提出，目的是描述图像的纹理特征。因为纹理是由灰度分布在空间位置上反复出现而形成的，所以在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。GLCM 就是用来描述这种空间相关性的，这也是“共生”这个词的意义。所以说 GLCM 描述的从来不是单个像素，而是成对的像素之间的关系。与之相对的，灰度直方图（Grayscale Image Histogram，GIH）则可以看做是对单个像素的统计与描述，并不涉及灰度间的关联关系。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img = imread(<span class=\"string\">&#x27;test.jpg&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">grayImg = rgb2gray(img);</span><br><span class=\"line\"></span><br><span class=\"line\">glcm = graycomatrix(grayImg);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>), imshow(img), title(<span class=\"string\">&#x27;Original Image&#x27;</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>), imshow(glcm,[]), title(<span class=\"string\">&#x27;GLCM&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可以使用以上 MATLAB 代码，获取一张普通的 jpg 图片的 GLCM 并进行对比：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240616231003383.png\" alt=\"image-20240616231003383\"></p>\n<h3 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h3><ol>\n<li>确定量化级数：根据图像的灰度级别，创建一个方阵，通常是 256x256；</li>\n<li>定义邻域关系：选择像素对的方向（水平、垂直、对角等）和距离（步长）；</li>\n<li>统计频次：遍历图像，对于每个像素对<code>(i,j)</code>，如果它们的灰度级满足所定义的邻域关系，则在 GLCM 矩阵中相应位置<code>(i,j)</code>的值加一；</li>\n<li>计算概率：将GLCM矩阵中的每个元素除以总次数，得到每种关联模式出现的概率。</li>\n</ol>\n<p>Ok，明白了计算方法，我们就可以尝试自己写个 demo 出来试试成果哩。MatLab 我用得实在是不熟（平成确实没有使用场景），所以接下来的代码是使用 python 完成的。思路也很清晰，使用 <code>PIL</code> 读取图像并转化为灰度图像，然后使用 <code>numpy</code> 计算并创建对应的灰度共生矩阵图像，最后使用 <code>matplotlib</code> 库对原图以及灰度共生矩阵图像进行一个展示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取图片并转换为灰度图像</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">read_image</span>(<span class=\"params\">file_name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.array(Image.<span class=\"built_in\">open</span>(file_name).convert(<span class=\"string\">&#x27;L&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建灰度共生矩阵</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">create_glcm</span>(<span class=\"params\">image, d=<span class=\"number\">1</span>, theta=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    max_gray_level = <span class=\"number\">256</span></span><br><span class=\"line\">    glcm = np.zeros((max_gray_level, max_gray_level))</span><br><span class=\"line\">    rows, cols = image.shape</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(rows):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(cols - d):</span><br><span class=\"line\">            rows_value = image[i][j]</span><br><span class=\"line\">            cols_value = image[i][j + d] <span class=\"keyword\">if</span> theta == <span class=\"number\">0</span> <span class=\"keyword\">else</span> image[i + d][j]</span><br><span class=\"line\">            glcm[rows_value][cols_value] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> glcm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    image_a = read_image(<span class=\"string\">&#x27;a.jpg&#x27;</span>)</span><br><span class=\"line\">    glcm_a = create_glcm(image_a)</span><br><span class=\"line\"></span><br><span class=\"line\">    plt.figure(figsize=(<span class=\"number\">10</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    plt.imshow(image_a, cmap=<span class=\"string\">&#x27;gray&#x27;</span>)</span><br><span class=\"line\">    plt.title(<span class=\"string\">&#x27;Original Image&#x27;</span>)</span><br><span class=\"line\">    plt.axis(<span class=\"string\">&#x27;off&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    plt.imshow(glcm_a, cmap=<span class=\"string\">&#x27;gray&#x27;</span>)</span><br><span class=\"line\">    plt.title(<span class=\"string\">&#x27;GLCM of Image&#x27;</span>)</span><br><span class=\"line\">    plt.axis(<span class=\"string\">&#x27;off&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><p>前面说了，GLCM 严格说是一种用于描述图像纹理特征的二维矩阵。这个矩阵每行或每列代表不同灰度级别的出现关系，对角线表示相邻像素灰度一致性。对每行进行累加可得到一个 256 维向量，表示原图中每个灰度级别像素的出现次数，类似灰度直方图。全元素求和等于总像素个数减去步长乘以跳跃次数。其不一定对称，因为 <code>(1,3)</code> 和 <code>(3,1)</code> 表示不同灰度关系。这种特殊的矩阵具有四个特性，分别是：</p>\n<ol>\n<li><p>对比度：用于度量矩阵值的分布和局部变化，反应图像的清晰度和纹理的沟纹深浅。对比度越大，影像越清晰。计算公式如下，其中 <code>i</code>、<code>j</code> 为共生矩阵中的坐标索引，<code>P(i,j)</code> 为该位置的灰度值（对于共生矩阵来说就是某种灰度关联关系出现的次数）：</p>\n<p>[Con &#x3D; \\sum_{i}^{} \\sum_{j}^{} (i-j)^{2}P(i,j)]</p>\n</li>\n<li><p>能量：灰度共生矩阵元素值的平方和，称其为能量，也叫第二角力矩（Angular Second Moment, ASM）。反应了图像灰度分布均匀程度和纹理粗细度。如果其较大，则表明图像中存在一种较为均一和规则变化的纹理模式。计算公式如下：</p>\n<p>[Asm &#x3D; \\sum_{i}^{} \\sum_{j}^{} P(i,j)^{2}]</p>\n</li>\n<li><p>熵：在灰度共生矩阵中表示图像的信息量。当共生矩阵中元素分布较为分散时，熵较大。它表示了图像中纹理的非均匀程度或者复杂程度。计算公式如下：</p>\n<p>[Ent &#x3D; \\sum_{i}^{} \\sum_{j}^{} P(i,j)logP(i,j)]</p>\n</li>\n<li><p>相关度：度量灰度共生矩阵元素在行或列方向上的相似程度（Inverse Different Moment）。其值反应了图像中局部灰度相关性。当矩阵元素均匀相等时，相关度较大，反之较小。计算公式如下：</p>\n<p>[IDM &#x3D; \\sum_{i}^{} \\sum_{j}^{} \\frac{P(i,j)}{1+(i-j)^{2}}]</p>\n</li>\n</ol>\n<p>虽然我们掌握了四种特性值的计算方法，可以用文本数值对图像的纹理特征进行表示了，但还是有不方便的地方，将两组图像的纹理特征进行对比时，如果两项特性值高、两项特性值低该怎么办？这就需要归一化处理。对 GLCM 进行归一化处理的主要目的是消除图像大小、对比度等因素对特征计算的影响，从而使得特征更具有普适性和可比性。这样做的好处包括：</p>\n<p>GLCM 的归一化主要包括两种常见的方法：</p>\n<ul>\n<li>将 GLCM 矩阵中的元素值除以 GLCM 矩阵中所有元素值的和，使得归一化后的 GLCM 矩阵中所有元素之和为1</li>\n<li>将 GLCM 矩阵中的元素值除以 GLCM 矩阵中元素值的平方和的平方根，使得归一化后的 GLCM 矩阵中元素值的平方和为1。</li>\n</ul>\n<p>进行归一化处理后得到的数值一般被称为 <strong>规范化纹理特征</strong>，我们可以使用该值对图像之间的纹理特征进行一个就更加具象的对比。</p>\n<h3 id=\"进一步实践\"><a href=\"#进一步实践\" class=\"headerlink\" title=\"进一步实践\"></a>进一步实践</h3><p>掌握了以上内容，现在我们可以做一个更加贴近现实的实践了。我准备了三张图片，有两张是动物的皮毛，还有一张是爬行动物的鳞甲图（下面这张图是实验结果的一部分，三张图片原图是彩图，不过对实验没什么影响）：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240617003235838.png\" alt=\"image-20240617003235838\"></p>\n<p>使用 Python 分别计算三张图片的灰度共生矩阵，然后计算四项特征值，再进行归一化处理，最后根据规范化纹理特征判断哪两张图像的纹理特征更接近。因为代码里很多内容是在调用函数、输出结果以及展示图片，所以不全贴出来，只展示部分核心代码，也就是做计算提取图像纹理特征那块，完整代码上传到了我的一个存储学校作业的 GitHub 仓库中，位于“数字图像处理”目录下，也包括了三张示范图片，可以自行前往查看。</p>\n<p>以下为核心函数代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 读取图片并转换为灰度图像</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">read_image</span>(<span class=\"params\">file_name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.array(Image.<span class=\"built_in\">open</span>(file_name).convert(<span class=\"string\">&#x27;L&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建灰度共生矩阵</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">create_glcm</span>(<span class=\"params\">image, d=<span class=\"number\">1</span>, theta=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    max_gray_level = <span class=\"number\">256</span></span><br><span class=\"line\">    glcm = np.zeros((max_gray_level, max_gray_level))</span><br><span class=\"line\">    rows, cols = image.shape</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(rows):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(cols - d):</span><br><span class=\"line\">            rows_value = image[i][j]</span><br><span class=\"line\">            cols_value = image[i][j + d] <span class=\"keyword\">if</span> theta == <span class=\"number\">0</span> <span class=\"keyword\">else</span> image[i + d][j]</span><br><span class=\"line\">            glcm[rows_value][cols_value] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> glcm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算特征值</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_features</span>(<span class=\"params\">glcm</span>):</span><br><span class=\"line\">    contrast = np.<span class=\"built_in\">sum</span>(np.square(np.arange(glcm.shape[<span class=\"number\">0</span>]) - np.arange(glcm.shape[<span class=\"number\">1</span>])) * glcm)</span><br><span class=\"line\">    energy = np.<span class=\"built_in\">sum</span>(np.square(glcm))</span><br><span class=\"line\">    entropy = -np.<span class=\"built_in\">sum</span>(glcm * np.ma.log(glcm).filled(<span class=\"number\">0</span>))</span><br><span class=\"line\">    inverse_diff_moment = np.<span class=\"built_in\">sum</span>(glcm / (<span class=\"number\">1</span> + np.square(np.arange(glcm.shape[<span class=\"number\">0</span>]) - np.arange(glcm.shape[<span class=\"number\">1</span>]))))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> contrast, energy, entropy, inverse_diff_moment</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 归一化处理</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">normalize_features</span>(<span class=\"params\">features</span>):</span><br><span class=\"line\">    normalized_features = (features - np.mean(features)) / np.std(features)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> normalized_features</span><br></pre></td></tr></table></figure>\n\n<p>运行结果，轻松得出 a 与 b 更加相似的结论：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240617003516465.png\" alt=\"image-20240617003516465\"></p>\n<h2 id=\"阅读文档\"><a href=\"#阅读文档\" class=\"headerlink\" title=\"阅读文档\"></a>阅读文档</h2><ul>\n<li><p><a href=\"https://github.com/scikit-image/skimage-tutorials\">https://github.com/scikit-image/skimage-tutorials</a></p>\n</li>\n<li><p><a href=\"https://leovan.me/cn/2022/01/content-based-image-retrieval/\">https://leovan.me/cn/2022/01/content-based-image-retrieval/</a></p>\n</li>\n<li><p><a href=\"https://www.cs.cmu.edu/~juny/Prof/papers/Part2-CBIR.pdf\">https://www.cs.cmu.edu/~juny/Prof/papers/Part2-CBIR.pdf</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/article/1934204\">特征提取——纹理特征-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/article/2219407\">GLCM 灰度共生矩阵与 Haralick 特征-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/article/1010272\">纹理特征提取方法：LBP, 灰度共生矩阵-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n</li>\n<li><p><a href=\"http://zhaoxuhui.top/blog/2022/03/15/gray-level-co-occurence-matrix.html\">http://zhaoxuhui.top/blog/2022/03/15/gray-level-co-occurence-matrix.html</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<p>数字图像处理的拓展内容，上课时被分配了“图像检索及 AI 应用”，想搞个小实践水水念 PPT 的时间，就稍微研究下图像纹理特征分析，也顺带写篇博客。</p>\n<h2 id=\"图像检索发展\"><a href=\"#图像检索发展\" class=\"headerlink\" title=\"图像检索发展\"></a>图像检索发展</h2><p>在 Web2.0 时代，互联网中的信息量爆炸性增长，其中自然包含了很多图片。在 Twitter、FaceBook 等各种社交媒体平台，每月用户上传的图片数量都在 10 亿上下，而以淘宝、亚马逊为代表的电子商务平台，其后台存储的图片数量更是以百亿记。面对如此浩瀚且包含了丰富视觉信息的图片，如何从中精准快速地检索出我们想要的图片，已经成为了多媒体信息检索技术研究的热点。</p>\n<h3 id=\"基于文本的图像检索技术-TBIR\"><a href=\"#基于文本的图像检索技术-TBIR\" class=\"headerlink\" title=\"基于文本的图像检索技术 TBIR\"></a>基于文本的图像检索技术 TBIR</h3><p>按发展顺序，可先后分为基于文本的图像检索技术（TBIR, Text Based Image Retrieval）和基于内容的图像检索技术（CBIR, Content Based Image Retrieval），前者可以理解为人工&#x2F;半人工给图片打 tag，然后检索时根据 tag 匹配度检索图片，后者则是正经的使用计算机通过公式化的流程分析图片特征，然后实现以图搜图。</p>\n<p>先说 TBIR，这种技术好用吗？确实好用，因为实现难度不高，甚至你自己建立个数据库，给自己收藏的图片打 tag，然写个根据 tag 的搜索功能，这就算是一种 TBIR 的实现。而且因为是通过人工的方式给图像信息打 tag，而用户也是人，这样检索图像的准确率比较高。</p>\n<p>但从上述的简单流程就能看出，TBIR 也有一些明显的缺陷：给图片标注文本信息需要人工的介入，如果图像数据很庞大，就会耗费大量人力物力，这使得其无法被用于大规模的图像数据；同时也是因为人工的介入，导致标注信息时难免混入一些标注者的主观考量，同一张图片你很难让两个人给出完全一致的 tag 列表，这就会导致检索时的不准确。再另一方面，很多用户本身也没法做到精确描述自己需要的图片信息，比如下面这张图：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240616145916690.png\" alt=\"image-20240616145916690\"></p>\n<p>你可能很喜欢这种风格，然后你打开了 Pinterest，接下来应该搜索什么关键词来描述这种风格呢？经验丰富的标注者可以使用 <code>LowPoly</code> 精准描述这种风格，但多数用户不能，这问题不是 TBIR 能解决的，毕竟连用户都不知道要搜什么，检索能力再强也没用。</p>\n<h3 id=\"基于内容的图像检索技术-CBIR\"><a href=\"#基于内容的图像检索技术-CBIR\" class=\"headerlink\" title=\"基于内容的图像检索技术 CBIR\"></a>基于内容的图像检索技术 CBIR</h3><p>所以，在 1992 年，美国国家科学基金会就图像数据库管理系统新发展方向达成一致共识，表示索引图像信息的最有效方式应该是基于图像内容自身的。自此，基于内容的图像检索技术便逐步建立起来，并在近十多年里得到了迅速的发展。</p>\n<p>典型的 CBIR 框架如下，大致可总结为三个阶段：</p>\n<ol>\n<li><strong>特征提取</strong>：计算机分析图像数据库中的每张图片，提取出颜色、纹理、形状等低层次视觉特征，并将这些特征转化为特征向量存储在图像特征库中。</li>\n<li><strong>查询处理</strong>：当用户提交一张查询图像时，系统会用相同的方法提取其特征。</li>\n<li><strong>相似性度量与排序输出</strong>：系统将查询图像的特征向量与特征库中的向量进行比较，根据相似性度量准则计算相似度，并将结果按相似度高低排序输出。</li>\n</ol>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240616150943134.png\" alt=\"image-20240616150943134\"></p>\n<p>CBIR 将标注图片、分析图片、检索图片的工作全部交给计算机，客服了 TBIR 的不足，极大地提高了检索效率以及可使用图像检索技术的规模。但也带来了一个问题：计算机不是人类，它很难理解高层语义，所以其图像特征的描述与人类存在语义鸿沟。</p>\n<p>这“高层语义”指的是人类对图像内容的抽象理解，比如识别图像中的场景或情感。这些含义通常超出了简单的视觉特征所能表达的范围，你可以使用“可爱”这种描述搜索出毛茸茸的小猫小狗，计算机很难办到，因为计算机无法直接理解“可爱”是什么，<strong>语义鸿沟是无法消除的</strong>，它只能通过一些额外的手段来弥补这种鸿沟。比如在实现图像检索时就预先告知计算机，“可爱”这种特征可以拆解为“多毛”、“眼睛在面部占比大”、“头身比低”等一系列特征，然后再将这些特征一步步分解，直到转化为计算机可以理解的图像视觉特征，比如纹理、颜色、形状等。</p>\n<p>但经过这一道道的转化，图像检索的准确率就会无可避免的下降，然后就需要再通过其他额外手段弥补这种缺陷。这就导致了 CBIR 虽然在很大程度解放了人力，但实现起来比较困难。</p>\n<p>TBIR 和 CBIR 在现代都得到了广泛应用。分别别举一个贴近生活的案例：常见的图片素材库，比如 Pinterest 和 花瓣网，都主要依靠 TBIR 技术；电子商务方面比如淘宝的拍立淘，就是主要基于 CBIR 技术。</p>\n<p>然后呢，随着 AI 技术大力发展，人们发现可以和图像检索技术结合使用，现代图像检索技术与 AI 的结合主要涉及到深度学习等新技术的研究和应用。深度学习可以自动学习和提取图像中的特征，处理更复杂的场景和任务。例如，深度神经网络能够自动提取图像特征进行分类，生成对抗网络（GAN）可以生成相似图片扩展数据集，自编码器可用于降噪和去模糊等。</p>\n<h2 id=\"图像通用视觉特征\"><a href=\"#图像通用视觉特征\" class=\"headerlink\" title=\"图像通用视觉特征\"></a>图像通用视觉特征</h2><p>图像特征的提取与表达是 CBIR 的基础。广义上讲，图像的特征包括基于文本的特征和视觉特征，前者在数据库系统和信息检索领域已有深入研究，这里只介绍后者。</p>\n<p>而视觉特征又可以分为两类：通用视觉特征和领域相关视觉特征。通用视觉特征就是我们肉眼所能看到的基本信息，适用于所有类型的图像；而领域相关视觉特征则依赖于特定领域的知识，如面部或指纹特征。不同的表达方法可以从不同角度描述一个特征，并没有所谓的“最佳”表达方式。</p>\n<p>通用视觉特征包括我们最常用的三种对图像的描述方式：色彩、纹理与形状。</p>\n<h3 id=\"颜色特征\"><a href=\"#颜色特征\" class=\"headerlink\" title=\"颜色特征\"></a>颜色特征</h3><p>颜色特征是在图像检索中应用最为广泛的视觉特征，主要原因在于颜色往往和图像中所包含的 物体或场景十分相关。此外，与其他的视觉特征相比，颜色特征对图像本身的尺寸、方向、视角的依赖性较小，从而具有较高的鲁棒性。</p>\n<h3 id=\"纹理特征\"><a href=\"#纹理特征\" class=\"headerlink\" title=\"纹理特征\"></a>纹理特征</h3><p>纹理特征是一种不依赖于颜色或亮度的反映图像中同质现象的视觉特征。它是所有物体表面共有的内在特性，例如云彩、树木、砖、织物等都有各自的纹理特征。纹理特征包含了物体表面结构组织排列的重要信息以及它们与周围环境的联系。正因为如此，纹理特征在 CBIR 中得到了广泛的应用。纹理特征具有四大特点：</p>\n<ul>\n<li>局部序列性重复</li>\n<li>非随机排列</li>\n<li>区域内均匀统一</li>\n<li>旋转不变性</li>\n</ul>\n<p>它通过像素及其周围空间邻域的灰度分布来表现局部纹理信息，并通过不同程度上的重复性展现全局纹理信息。纹理特征在模式匹配中具有优势，因为它是基于区域的统计计算，不容易受局部偏差影响。在检索纹理图像时，纹理特征可以有效区分粗细、疏密等差异较大的纹理，但在纹理之间差异不明显时，可能无法准确反映人眼的视觉感知。一些虚假纹理，如水中倒影或金属面反射造成的影响，可能会误导检索结果。</p>\n<h3 id=\"形状特征\"><a href=\"#形状特征\" class=\"headerlink\" title=\"形状特征\"></a>形状特征</h3><p>物体和区域的形状是图像表达和图像检索中的另一重要的特征。但不同于颜色或纹理等底层特 征，形状特征的表达必须以对图像中物体或区域的划分为基础。由于当前的技术无法做到准确而鲁棒的自动图像分割，图像检索中的形状特征只能用于某些特殊应用，在这些应用中图像包含的物体 或区域可以直接获得。另一方面，由于人们对物体形状的变换、旋转和缩放主观上不太敏感，合适 的形状特征必须满足对变换、旋转和缩放无关，这对形状相似度的计算也带来了难度。</p>\n<h2 id=\"纹理特征提取：灰度共生矩阵\"><a href=\"#纹理特征提取：灰度共生矩阵\" class=\"headerlink\" title=\"纹理特征提取：灰度共生矩阵\"></a>纹理特征提取：灰度共生矩阵</h2><p>灰度共生矩阵（Gray-level Co-occurrence Matrix, GLCM）是计算机视觉领域常用的分析图像纹理特征的一种统计方法。</p>\n<blockquote>\n<p>GLCM 本质上是一种矩阵，但我们通常会使用 GLCM 指代基于这种矩阵的分析方法。</p>\n</blockquote>\n<p>GLCM 的概念在 1973 年由 Haralick 等人首次提出，目的是描述图像的纹理特征。因为纹理是由灰度分布在空间位置上反复出现而形成的，所以在图像空间中相隔某距离的两像素之间会存在一定的灰度关系，即图像中灰度的空间相关特性。GLCM 就是用来描述这种空间相关性的，这也是“共生”这个词的意义。所以说 GLCM 描述的从来不是单个像素，而是成对的像素之间的关系。与之相对的，灰度直方图（Grayscale Image Histogram，GIH）则可以看做是对单个像素的统计与描述，并不涉及灰度间的关联关系。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img = imread(<span class=\"string\">&#x27;test.jpg&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">grayImg = rgb2gray(img);</span><br><span class=\"line\"></span><br><span class=\"line\">glcm = graycomatrix(grayImg);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">figure</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>), imshow(img), title(<span class=\"string\">&#x27;Original Image&#x27;</span>);</span><br><span class=\"line\">subplot(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>), imshow(glcm,[]), title(<span class=\"string\">&#x27;GLCM&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可以使用以上 MATLAB 代码，获取一张普通的 jpg 图片的 GLCM 并进行对比：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240616231003383.png\" alt=\"image-20240616231003383\"></p>\n<h3 id=\"计算方法\"><a href=\"#计算方法\" class=\"headerlink\" title=\"计算方法\"></a>计算方法</h3><ol>\n<li>确定量化级数：根据图像的灰度级别，创建一个方阵，通常是 256x256；</li>\n<li>定义邻域关系：选择像素对的方向（水平、垂直、对角等）和距离（步长）；</li>\n<li>统计频次：遍历图像，对于每个像素对<code>(i,j)</code>，如果它们的灰度级满足所定义的邻域关系，则在 GLCM 矩阵中相应位置<code>(i,j)</code>的值加一；</li>\n<li>计算概率：将GLCM矩阵中的每个元素除以总次数，得到每种关联模式出现的概率。</li>\n</ol>\n<p>Ok，明白了计算方法，我们就可以尝试自己写个 demo 出来试试成果哩。MatLab 我用得实在是不熟（平成确实没有使用场景），所以接下来的代码是使用 python 完成的。思路也很清晰，使用 <code>PIL</code> 读取图像并转化为灰度图像，然后使用 <code>numpy</code> 计算并创建对应的灰度共生矩阵图像，最后使用 <code>matplotlib</code> 库对原图以及灰度共生矩阵图像进行一个展示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取图片并转换为灰度图像</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">read_image</span>(<span class=\"params\">file_name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.array(Image.<span class=\"built_in\">open</span>(file_name).convert(<span class=\"string\">&#x27;L&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建灰度共生矩阵</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">create_glcm</span>(<span class=\"params\">image, d=<span class=\"number\">1</span>, theta=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    max_gray_level = <span class=\"number\">256</span></span><br><span class=\"line\">    glcm = np.zeros((max_gray_level, max_gray_level))</span><br><span class=\"line\">    rows, cols = image.shape</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(rows):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(cols - d):</span><br><span class=\"line\">            rows_value = image[i][j]</span><br><span class=\"line\">            cols_value = image[i][j + d] <span class=\"keyword\">if</span> theta == <span class=\"number\">0</span> <span class=\"keyword\">else</span> image[i + d][j]</span><br><span class=\"line\">            glcm[rows_value][cols_value] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> glcm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    image_a = read_image(<span class=\"string\">&#x27;a.jpg&#x27;</span>)</span><br><span class=\"line\">    glcm_a = create_glcm(image_a)</span><br><span class=\"line\"></span><br><span class=\"line\">    plt.figure(figsize=(<span class=\"number\">10</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    plt.imshow(image_a, cmap=<span class=\"string\">&#x27;gray&#x27;</span>)</span><br><span class=\"line\">    plt.title(<span class=\"string\">&#x27;Original Image&#x27;</span>)</span><br><span class=\"line\">    plt.axis(<span class=\"string\">&#x27;off&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    plt.subplot(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    plt.imshow(glcm_a, cmap=<span class=\"string\">&#x27;gray&#x27;</span>)</span><br><span class=\"line\">    plt.title(<span class=\"string\">&#x27;GLCM of Image&#x27;</span>)</span><br><span class=\"line\">    plt.axis(<span class=\"string\">&#x27;off&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><p>前面说了，GLCM 严格说是一种用于描述图像纹理特征的二维矩阵。这个矩阵每行或每列代表不同灰度级别的出现关系，对角线表示相邻像素灰度一致性。对每行进行累加可得到一个 256 维向量，表示原图中每个灰度级别像素的出现次数，类似灰度直方图。全元素求和等于总像素个数减去步长乘以跳跃次数。其不一定对称，因为 <code>(1,3)</code> 和 <code>(3,1)</code> 表示不同灰度关系。这种特殊的矩阵具有四个特性，分别是：</p>\n<ol>\n<li><p>对比度：用于度量矩阵值的分布和局部变化，反应图像的清晰度和纹理的沟纹深浅。对比度越大，影像越清晰。计算公式如下，其中 <code>i</code>、<code>j</code> 为共生矩阵中的坐标索引，<code>P(i,j)</code> 为该位置的灰度值（对于共生矩阵来说就是某种灰度关联关系出现的次数）：</p>\n<p>[Con &#x3D; \\sum_{i}^{} \\sum_{j}^{} (i-j)^{2}P(i,j)]</p>\n</li>\n<li><p>能量：灰度共生矩阵元素值的平方和，称其为能量，也叫第二角力矩（Angular Second Moment, ASM）。反应了图像灰度分布均匀程度和纹理粗细度。如果其较大，则表明图像中存在一种较为均一和规则变化的纹理模式。计算公式如下：</p>\n<p>[Asm &#x3D; \\sum_{i}^{} \\sum_{j}^{} P(i,j)^{2}]</p>\n</li>\n<li><p>熵：在灰度共生矩阵中表示图像的信息量。当共生矩阵中元素分布较为分散时，熵较大。它表示了图像中纹理的非均匀程度或者复杂程度。计算公式如下：</p>\n<p>[Ent &#x3D; \\sum_{i}^{} \\sum_{j}^{} P(i,j)logP(i,j)]</p>\n</li>\n<li><p>相关度：度量灰度共生矩阵元素在行或列方向上的相似程度（Inverse Different Moment）。其值反应了图像中局部灰度相关性。当矩阵元素均匀相等时，相关度较大，反之较小。计算公式如下：</p>\n<p>[IDM &#x3D; \\sum_{i}^{} \\sum_{j}^{} \\frac{P(i,j)}{1+(i-j)^{2}}]</p>\n</li>\n</ol>\n<p>虽然我们掌握了四种特性值的计算方法，可以用文本数值对图像的纹理特征进行表示了，但还是有不方便的地方，将两组图像的纹理特征进行对比时，如果两项特性值高、两项特性值低该怎么办？这就需要归一化处理。对 GLCM 进行归一化处理的主要目的是消除图像大小、对比度等因素对特征计算的影响，从而使得特征更具有普适性和可比性。这样做的好处包括：</p>\n<p>GLCM 的归一化主要包括两种常见的方法：</p>\n<ul>\n<li>将 GLCM 矩阵中的元素值除以 GLCM 矩阵中所有元素值的和，使得归一化后的 GLCM 矩阵中所有元素之和为1</li>\n<li>将 GLCM 矩阵中的元素值除以 GLCM 矩阵中元素值的平方和的平方根，使得归一化后的 GLCM 矩阵中元素值的平方和为1。</li>\n</ul>\n<p>进行归一化处理后得到的数值一般被称为 <strong>规范化纹理特征</strong>，我们可以使用该值对图像之间的纹理特征进行一个就更加具象的对比。</p>\n<h3 id=\"进一步实践\"><a href=\"#进一步实践\" class=\"headerlink\" title=\"进一步实践\"></a>进一步实践</h3><p>掌握了以上内容，现在我们可以做一个更加贴近现实的实践了。我准备了三张图片，有两张是动物的皮毛，还有一张是爬行动物的鳞甲图（下面这张图是实验结果的一部分，三张图片原图是彩图，不过对实验没什么影响）：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240617003235838.png\" alt=\"image-20240617003235838\"></p>\n<p>使用 Python 分别计算三张图片的灰度共生矩阵，然后计算四项特征值，再进行归一化处理，最后根据规范化纹理特征判断哪两张图像的纹理特征更接近。因为代码里很多内容是在调用函数、输出结果以及展示图片，所以不全贴出来，只展示部分核心代码，也就是做计算提取图像纹理特征那块，完整代码上传到了我的一个存储学校作业的 GitHub 仓库中，位于“数字图像处理”目录下，也包括了三张示范图片，可以自行前往查看。</p>\n<p>以下为核心函数代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 读取图片并转换为灰度图像</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">read_image</span>(<span class=\"params\">file_name</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.array(Image.<span class=\"built_in\">open</span>(file_name).convert(<span class=\"string\">&#x27;L&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建灰度共生矩阵</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">create_glcm</span>(<span class=\"params\">image, d=<span class=\"number\">1</span>, theta=<span class=\"number\">0</span></span>):</span><br><span class=\"line\">    max_gray_level = <span class=\"number\">256</span></span><br><span class=\"line\">    glcm = np.zeros((max_gray_level, max_gray_level))</span><br><span class=\"line\">    rows, cols = image.shape</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(rows):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(cols - d):</span><br><span class=\"line\">            rows_value = image[i][j]</span><br><span class=\"line\">            cols_value = image[i][j + d] <span class=\"keyword\">if</span> theta == <span class=\"number\">0</span> <span class=\"keyword\">else</span> image[i + d][j]</span><br><span class=\"line\">            glcm[rows_value][cols_value] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> glcm</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算特征值</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_features</span>(<span class=\"params\">glcm</span>):</span><br><span class=\"line\">    contrast = np.<span class=\"built_in\">sum</span>(np.square(np.arange(glcm.shape[<span class=\"number\">0</span>]) - np.arange(glcm.shape[<span class=\"number\">1</span>])) * glcm)</span><br><span class=\"line\">    energy = np.<span class=\"built_in\">sum</span>(np.square(glcm))</span><br><span class=\"line\">    entropy = -np.<span class=\"built_in\">sum</span>(glcm * np.ma.log(glcm).filled(<span class=\"number\">0</span>))</span><br><span class=\"line\">    inverse_diff_moment = np.<span class=\"built_in\">sum</span>(glcm / (<span class=\"number\">1</span> + np.square(np.arange(glcm.shape[<span class=\"number\">0</span>]) - np.arange(glcm.shape[<span class=\"number\">1</span>]))))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> contrast, energy, entropy, inverse_diff_moment</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 归一化处理</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">normalize_features</span>(<span class=\"params\">features</span>):</span><br><span class=\"line\">    normalized_features = (features - np.mean(features)) / np.std(features)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> normalized_features</span><br></pre></td></tr></table></figure>\n\n<p>运行结果，轻松得出 a 与 b 更加相似的结论：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/image-20240617003516465.png\" alt=\"image-20240617003516465\"></p>\n<h2 id=\"阅读文档\"><a href=\"#阅读文档\" class=\"headerlink\" title=\"阅读文档\"></a>阅读文档</h2><ul>\n<li><p><a href=\"https://github.com/scikit-image/skimage-tutorials\">https://github.com/scikit-image/skimage-tutorials</a></p>\n</li>\n<li><p><a href=\"https://leovan.me/cn/2022/01/content-based-image-retrieval/\">https://leovan.me/cn/2022/01/content-based-image-retrieval/</a></p>\n</li>\n<li><p><a href=\"https://www.cs.cmu.edu/~juny/Prof/papers/Part2-CBIR.pdf\">https://www.cs.cmu.edu/~juny/Prof/papers/Part2-CBIR.pdf</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/article/1934204\">特征提取——纹理特征-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/article/2219407\">GLCM 灰度共生矩阵与 Haralick 特征-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/article/1010272\">纹理特征提取方法：LBP, 灰度共生矩阵-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>\n</li>\n<li><p><a href=\"http://zhaoxuhui.top/blog/2022/03/15/gray-level-co-occurence-matrix.html\">http://zhaoxuhui.top/blog/2022/03/15/gray-level-co-occurence-matrix.html</a></p>\n</li>\n</ul>\n"},{"title":"Java 运行原理","date":"2023-08-31T16:00:00.000Z","author":"ma5hr00m","_content":"\n`Java` 代码从编写到运行，流程如下：\n\n1. Java 源程序（.java文件）经过 *编译器* 编译，变成 Java 字节码；\n2. Java 字节码经过 *JVM* 解释执行，传递给解释器；\n3. *解释器* 将字节码翻译成合适的机器码，在机器中运行；\n\n这省略了很多细节，我想要相对详细地了解 Java 代码从编写到运行的过程中经历了什么。\n如果你也感兴趣的话，可以接着往下看。\n\n![20230927135500](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927135500.png)\n\n## 前置知识 🚀\n\n### JDK - Java开发工具包\nJDK（*Java Development Kit*）是 Java 开发工具包，提供了 Java 开发环境和运行环境。    \nJDK 包含了 JRE，同时还包含了编译器（javac）和其他开发工具，用于开发、编译、调试和运行 Java 程序。\n\n### JRE - Java运行环境\nJRE（*Java Runtime Environment*）是 Java 运行时环境，它包含了 Java 虚拟机（JVM）以及运行 Java 程序所需的核心类库和支持文件。  \nJRE 提供了 Java 程序的运行环境，可以执行已经编译好的 Java 字节码。\n\n### JVM - Java虚拟机\nJVM（*Java Virtual Machine*）Java 程序的执行环境。JVM 介于 Java 编译器和 OS 之间，利用软件方法实现了一个虚拟的计算机，可以解释和执行 Java 字节码。  \nJava 程序在 JVM 上运行，通过 JVM 实现跨平台的特性，这是因为在不同操作系统上的 JVM 都能够执行相同的 Java 字节码。\n\n\n## 编译源代码 ✒\n开发者主要做的是编写 Java 源文件（*source file*），通常以 `.java` 结尾。但文件中的代源码（*source code*）是给开发者阅读的，而不是机器，源文件不能直接运行。\n\n比如，我们用 Java 编写了一段 HelloWorld 代码：\n\n```java\n// HelloWorld.java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\n💡我们使用 javac（*java编译器*，JDK中携带）编译这个源文件，将其转化以 `.class` 结尾为 Java 字节码文件。\n\n```bash\njavac HelloWorld.java\n# output: HelloWorld.class\n```\n> 编译器是一种将高级语言代码转化为低级语言代码的程序。\n\n### javac 编译 Java 源码\njavac 将 Java 源代码作为输入，进行词法分析、语法分析和语义分析等过程，最终生成对应的字节码文件。流程如下：\n\n1. *词法分析*  \n  javac 首先读取源文件的字符流，并将其分解为一系列的词素（*token*）。词素是源代码中的最小语法单位，如关键字、标识符、操作符和常量等。  \n  该过程的结果是得到规范化的 token 流。\n\n2. *语法分析*  \n  javac 对 token 流进行分析，并根据语法规则构建语法树（*Syntax Tree*）。语法树表示源代码的结构和层次关系。  \n  该过程的结果是得到一个符合 Java 语言规定的抽象语法树。\n\n3. *语义分析*  \n  编译器对语法树进行进一步处理，检查代码是否符合语言的语义规则。它会验证变量的声明和使用、类型匹配、函数调用等语义相关的问题，并生成符号表（Symbol Table）来管理变量和函数的信息。  \n  该过程的结果是生成一个经过简化的抽象语法树，更加接近字节码。\n\n4. *字节码生成*  \n  将经过简化的抽象语法树生成符合 JVM 规范的字节码。\n\n编译阶段的报错，统称为编译期错误，不会继续生成 .class 文件。\n\n### 反编译\n我们可以使用编译器将高级语言代码编译为低级语言代码，自然也可以使用反编译工具将已编译的代码转化为未编译的状代码\n\nJava反编译（*Java Decompilation*）是指将 Java 字节码文件转换回 Java 源代码的过程。JDK 中与 javac 相对的反编译器是 javap，可以使用 javap 来反编译 .class 文件。\n我们可以使用 javap 反编译刚生成的 HelloWorld.class，看看会获得什么：\n\n```bash\njavap -c HelloWorld\n```\n\n我们可以看到反编译的结果：\n\n```java\nCompiled from \"HelloWorld.java\"\npublic class HelloWorld {\n  public HelloWorld();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: ldc           #13                 // String Hello, World!\n       5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n       8: return\n}\n```\n\n### 字节码\nJava 源代码经过虚拟机编译器编译后产生的文件（即扩展为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。\n\n## JVM 📝\n我们已经获得了 .class 字节码文件，来看看它是如何在 JVM 中运行。\n\n### 类加载\n💡JVM 中的类加载器（*类加载子系统*）负责定位并加载类文件，可以分为以下三个小阶段：\n\n1. ***加载 Loading***  \n  加载是类加载的第一个阶段。JVM 会根据类的全限定名（*Fully Qualified Name*）查找并读取类的字节码文件，\n  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，\n  然后在 Java 堆内存中生成一个代表这个类的 *java.lang.Class* 实例，作为方法区中这个类的各种数据的访问入口。\n\n2. ***链接 Linking***  \n  链接是类加载的第二个阶段。JVM 会对加载的类进行一些准备工作，包括以下三步：\n    - 验证：验证字节码的正确性和安全性，检查类的结构、字段和方法的引用是否有效；\n    - 准备：为类的静态变量分配内存空间，并设置默认初始值；\n    - 解析：将符号引用转化为直接引用，即将类、字段和方法的符号引用解析为内存地址引用。\n\n3. ***初始化 Initialization***  \n  初始化是类加载的最后一个阶段。JVM 会执行类的静态代码块并对静态变量的赋值操作。  \n  初始化阶段是类加载过程中最耗时的阶段，它需要确保类的静态资源正确初始化，并且只会执行一次。直到这一步，才会真正开始执行开发者编写的 java 代码。\n\n> 阅读文章以了解类加载的更多内容：[Java 类加载机制](https://zhuanlan.zhihu.com/p/25228545)\n\n### 执行引擎\n💡执行引擎负责解释或编译字节码为机器码，并执行。\n\nJVM 执行引擎是 JVM 核心组成部分之一。它负责将字节码指令解释/编译为 *对应平台* 上的机器指令，这是 Java 跨平台特性的关键。\n\n![20230927180316](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927180316.png)\n\n执行引擎的主要有以下工作：\n\n1. *字节码验证 Bytecode Verification*  \n  JVM 首先会对内存中的字节码进行验证，以确保它的结构和语义是正确的。字节码验证是为了防止恶意代码或错误的字节码破坏 JVM 的安全和稳定性。\n\n2. *解释/编译*  \n  JVM 有两种方式将字节码转化为机器码，但通常混用：\n     - *解释执行*  \n      JVM 使用解释器（*Interpreter*）逐行读取字节码，并将其转换为机器码，然后由处理器执行。解释执行的优点是简单、跨平台，缺点是效率低下，因为每次执行都需要重新解释。  \n     - *编译执行*  \n      JVM 使用即时编译器（*Just-In-Time Compiler*）将字节码转化为机器码，并将其缓存起来，以便下次直接执行。编译执行的优点是效率高，缺点是需要额外的编译时间和内存空间。  \n     - *混合模式*  \n      为了兼顾解释执行和编译执行的优势，JVM通常会采用混合模式（Mixed Mode），即对于频繁执行的热点代码，使用编译执行，对于不常执行的冷代码，使用解释执行。这样可以提高程序的整体性能。\n\n3. *执行机器码 Execution*  \n  经过解释/编译后，字节码被转化为平台特定的机器码。JVM 会将机器码加载到处理器中执行，实现程序的功能。\n\n到此，我们的 Java 源代码就经过了从编写到执行整个过程。\n\n### JVM生命周期\nJVM 在 Java 程序开始运行时运行，结束时也随之结束。\n\n一个 Java 程序对应一个 JVM 进程。\n\nJVM 中有两种线程：\n- *守护线程*  \n  JVM 自用，如垃圾回收（*GC*）\n- *普通进程*  \n  一般 Java 程序的线程\n\n## 参考\n- [Java JVM 运行机制及基本原理](https://zhuanlan.zhihu.com/p/25713880)\n- [Java 的运行原理](https://www.cnblogs.com/o-andy-o/archive/2012/04/11/2442109.html)\n- [javac 源码笔记与简单的编译原理](https://rensifei.site/2017/03/javac/)","source":"_posts/how_java_run.md","raw":"---\ntitle: Java 运行原理\ndate: 2023/09/01\nauthor: ma5hr00m\ncategories:\n- Java\n---\n\n`Java` 代码从编写到运行，流程如下：\n\n1. Java 源程序（.java文件）经过 *编译器* 编译，变成 Java 字节码；\n2. Java 字节码经过 *JVM* 解释执行，传递给解释器；\n3. *解释器* 将字节码翻译成合适的机器码，在机器中运行；\n\n这省略了很多细节，我想要相对详细地了解 Java 代码从编写到运行的过程中经历了什么。\n如果你也感兴趣的话，可以接着往下看。\n\n![20230927135500](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927135500.png)\n\n## 前置知识 🚀\n\n### JDK - Java开发工具包\nJDK（*Java Development Kit*）是 Java 开发工具包，提供了 Java 开发环境和运行环境。    \nJDK 包含了 JRE，同时还包含了编译器（javac）和其他开发工具，用于开发、编译、调试和运行 Java 程序。\n\n### JRE - Java运行环境\nJRE（*Java Runtime Environment*）是 Java 运行时环境，它包含了 Java 虚拟机（JVM）以及运行 Java 程序所需的核心类库和支持文件。  \nJRE 提供了 Java 程序的运行环境，可以执行已经编译好的 Java 字节码。\n\n### JVM - Java虚拟机\nJVM（*Java Virtual Machine*）Java 程序的执行环境。JVM 介于 Java 编译器和 OS 之间，利用软件方法实现了一个虚拟的计算机，可以解释和执行 Java 字节码。  \nJava 程序在 JVM 上运行，通过 JVM 实现跨平台的特性，这是因为在不同操作系统上的 JVM 都能够执行相同的 Java 字节码。\n\n\n## 编译源代码 ✒\n开发者主要做的是编写 Java 源文件（*source file*），通常以 `.java` 结尾。但文件中的代源码（*source code*）是给开发者阅读的，而不是机器，源文件不能直接运行。\n\n比如，我们用 Java 编写了一段 HelloWorld 代码：\n\n```java\n// HelloWorld.java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n```\n\n💡我们使用 javac（*java编译器*，JDK中携带）编译这个源文件，将其转化以 `.class` 结尾为 Java 字节码文件。\n\n```bash\njavac HelloWorld.java\n# output: HelloWorld.class\n```\n> 编译器是一种将高级语言代码转化为低级语言代码的程序。\n\n### javac 编译 Java 源码\njavac 将 Java 源代码作为输入，进行词法分析、语法分析和语义分析等过程，最终生成对应的字节码文件。流程如下：\n\n1. *词法分析*  \n  javac 首先读取源文件的字符流，并将其分解为一系列的词素（*token*）。词素是源代码中的最小语法单位，如关键字、标识符、操作符和常量等。  \n  该过程的结果是得到规范化的 token 流。\n\n2. *语法分析*  \n  javac 对 token 流进行分析，并根据语法规则构建语法树（*Syntax Tree*）。语法树表示源代码的结构和层次关系。  \n  该过程的结果是得到一个符合 Java 语言规定的抽象语法树。\n\n3. *语义分析*  \n  编译器对语法树进行进一步处理，检查代码是否符合语言的语义规则。它会验证变量的声明和使用、类型匹配、函数调用等语义相关的问题，并生成符号表（Symbol Table）来管理变量和函数的信息。  \n  该过程的结果是生成一个经过简化的抽象语法树，更加接近字节码。\n\n4. *字节码生成*  \n  将经过简化的抽象语法树生成符合 JVM 规范的字节码。\n\n编译阶段的报错，统称为编译期错误，不会继续生成 .class 文件。\n\n### 反编译\n我们可以使用编译器将高级语言代码编译为低级语言代码，自然也可以使用反编译工具将已编译的代码转化为未编译的状代码\n\nJava反编译（*Java Decompilation*）是指将 Java 字节码文件转换回 Java 源代码的过程。JDK 中与 javac 相对的反编译器是 javap，可以使用 javap 来反编译 .class 文件。\n我们可以使用 javap 反编译刚生成的 HelloWorld.class，看看会获得什么：\n\n```bash\njavap -c HelloWorld\n```\n\n我们可以看到反编译的结果：\n\n```java\nCompiled from \"HelloWorld.java\"\npublic class HelloWorld {\n  public HelloWorld();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;\n       3: ldc           #13                 // String Hello, World!\n       5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n       8: return\n}\n```\n\n### 字节码\nJava 源代码经过虚拟机编译器编译后产生的文件（即扩展为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。\n\n## JVM 📝\n我们已经获得了 .class 字节码文件，来看看它是如何在 JVM 中运行。\n\n### 类加载\n💡JVM 中的类加载器（*类加载子系统*）负责定位并加载类文件，可以分为以下三个小阶段：\n\n1. ***加载 Loading***  \n  加载是类加载的第一个阶段。JVM 会根据类的全限定名（*Fully Qualified Name*）查找并读取类的字节码文件，\n  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，\n  然后在 Java 堆内存中生成一个代表这个类的 *java.lang.Class* 实例，作为方法区中这个类的各种数据的访问入口。\n\n2. ***链接 Linking***  \n  链接是类加载的第二个阶段。JVM 会对加载的类进行一些准备工作，包括以下三步：\n    - 验证：验证字节码的正确性和安全性，检查类的结构、字段和方法的引用是否有效；\n    - 准备：为类的静态变量分配内存空间，并设置默认初始值；\n    - 解析：将符号引用转化为直接引用，即将类、字段和方法的符号引用解析为内存地址引用。\n\n3. ***初始化 Initialization***  \n  初始化是类加载的最后一个阶段。JVM 会执行类的静态代码块并对静态变量的赋值操作。  \n  初始化阶段是类加载过程中最耗时的阶段，它需要确保类的静态资源正确初始化，并且只会执行一次。直到这一步，才会真正开始执行开发者编写的 java 代码。\n\n> 阅读文章以了解类加载的更多内容：[Java 类加载机制](https://zhuanlan.zhihu.com/p/25228545)\n\n### 执行引擎\n💡执行引擎负责解释或编译字节码为机器码，并执行。\n\nJVM 执行引擎是 JVM 核心组成部分之一。它负责将字节码指令解释/编译为 *对应平台* 上的机器指令，这是 Java 跨平台特性的关键。\n\n![20230927180316](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927180316.png)\n\n执行引擎的主要有以下工作：\n\n1. *字节码验证 Bytecode Verification*  \n  JVM 首先会对内存中的字节码进行验证，以确保它的结构和语义是正确的。字节码验证是为了防止恶意代码或错误的字节码破坏 JVM 的安全和稳定性。\n\n2. *解释/编译*  \n  JVM 有两种方式将字节码转化为机器码，但通常混用：\n     - *解释执行*  \n      JVM 使用解释器（*Interpreter*）逐行读取字节码，并将其转换为机器码，然后由处理器执行。解释执行的优点是简单、跨平台，缺点是效率低下，因为每次执行都需要重新解释。  \n     - *编译执行*  \n      JVM 使用即时编译器（*Just-In-Time Compiler*）将字节码转化为机器码，并将其缓存起来，以便下次直接执行。编译执行的优点是效率高，缺点是需要额外的编译时间和内存空间。  \n     - *混合模式*  \n      为了兼顾解释执行和编译执行的优势，JVM通常会采用混合模式（Mixed Mode），即对于频繁执行的热点代码，使用编译执行，对于不常执行的冷代码，使用解释执行。这样可以提高程序的整体性能。\n\n3. *执行机器码 Execution*  \n  经过解释/编译后，字节码被转化为平台特定的机器码。JVM 会将机器码加载到处理器中执行，实现程序的功能。\n\n到此，我们的 Java 源代码就经过了从编写到执行整个过程。\n\n### JVM生命周期\nJVM 在 Java 程序开始运行时运行，结束时也随之结束。\n\n一个 Java 程序对应一个 JVM 进程。\n\nJVM 中有两种线程：\n- *守护线程*  \n  JVM 自用，如垃圾回收（*GC*）\n- *普通进程*  \n  一般 Java 程序的线程\n\n## 参考\n- [Java JVM 运行机制及基本原理](https://zhuanlan.zhihu.com/p/25713880)\n- [Java 的运行原理](https://www.cnblogs.com/o-andy-o/archive/2012/04/11/2442109.html)\n- [javac 源码笔记与简单的编译原理](https://rensifei.site/2017/03/javac/)","slug":"how_java_run","published":1,"updated":"2024-06-09T12:56:05.055Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap3000kf4lyabvt4jyl","content":"<p><code>Java</code> 代码从编写到运行，流程如下：</p>\n<ol>\n<li>Java 源程序（.java文件）经过 <em>编译器</em> 编译，变成 Java 字节码；</li>\n<li>Java 字节码经过 <em>JVM</em> 解释执行，传递给解释器；</li>\n<li><em>解释器</em> 将字节码翻译成合适的机器码，在机器中运行；</li>\n</ol>\n<p>这省略了很多细节，我想要相对详细地了解 Java 代码从编写到运行的过程中经历了什么。<br>如果你也感兴趣的话，可以接着往下看。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927135500.png\" alt=\"20230927135500\"></p>\n<h2 id=\"前置知识-🚀\"><a href=\"#前置知识-🚀\" class=\"headerlink\" title=\"前置知识 🚀\"></a>前置知识 🚀</h2><h3 id=\"JDK-Java开发工具包\"><a href=\"#JDK-Java开发工具包\" class=\"headerlink\" title=\"JDK - Java开发工具包\"></a>JDK - Java开发工具包</h3><p>JDK（<em>Java Development Kit</em>）是 Java 开发工具包，提供了 Java 开发环境和运行环境。<br>JDK 包含了 JRE，同时还包含了编译器（javac）和其他开发工具，用于开发、编译、调试和运行 Java 程序。</p>\n<h3 id=\"JRE-Java运行环境\"><a href=\"#JRE-Java运行环境\" class=\"headerlink\" title=\"JRE - Java运行环境\"></a>JRE - Java运行环境</h3><p>JRE（<em>Java Runtime Environment</em>）是 Java 运行时环境，它包含了 Java 虚拟机（JVM）以及运行 Java 程序所需的核心类库和支持文件。<br>JRE 提供了 Java 程序的运行环境，可以执行已经编译好的 Java 字节码。</p>\n<h3 id=\"JVM-Java虚拟机\"><a href=\"#JVM-Java虚拟机\" class=\"headerlink\" title=\"JVM - Java虚拟机\"></a>JVM - Java虚拟机</h3><p>JVM（<em>Java Virtual Machine</em>）Java 程序的执行环境。JVM 介于 Java 编译器和 OS 之间，利用软件方法实现了一个虚拟的计算机，可以解释和执行 Java 字节码。<br>Java 程序在 JVM 上运行，通过 JVM 实现跨平台的特性，这是因为在不同操作系统上的 JVM 都能够执行相同的 Java 字节码。</p>\n<h2 id=\"编译源代码-✒\"><a href=\"#编译源代码-✒\" class=\"headerlink\" title=\"编译源代码 ✒\"></a>编译源代码 ✒</h2><p>开发者主要做的是编写 Java 源文件（<em>source file</em>），通常以 <code>.java</code> 结尾。但文件中的代源码（<em>source code</em>）是给开发者阅读的，而不是机器，源文件不能直接运行。</p>\n<p>比如，我们用 Java 编写了一段 HelloWorld 代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello, World!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>💡我们使用 javac（<em>java编译器</em>，JDK中携带）编译这个源文件，将其转化以 <code>.class</code> 结尾为 Java 字节码文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac HelloWorld.java</span><br><span class=\"line\"><span class=\"comment\"># output: HelloWorld.class</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>编译器是一种将高级语言代码转化为低级语言代码的程序。</p>\n</blockquote>\n<h3 id=\"javac-编译-Java-源码\"><a href=\"#javac-编译-Java-源码\" class=\"headerlink\" title=\"javac 编译 Java 源码\"></a>javac 编译 Java 源码</h3><p>javac 将 Java 源代码作为输入，进行词法分析、语法分析和语义分析等过程，最终生成对应的字节码文件。流程如下：</p>\n<ol>\n<li><p><em>词法分析</em><br>  javac 首先读取源文件的字符流，并将其分解为一系列的词素（<em>token</em>）。词素是源代码中的最小语法单位，如关键字、标识符、操作符和常量等。<br>  该过程的结果是得到规范化的 token 流。</p>\n</li>\n<li><p><em>语法分析</em><br>  javac 对 token 流进行分析，并根据语法规则构建语法树（<em>Syntax Tree</em>）。语法树表示源代码的结构和层次关系。<br>  该过程的结果是得到一个符合 Java 语言规定的抽象语法树。</p>\n</li>\n<li><p><em>语义分析</em><br>  编译器对语法树进行进一步处理，检查代码是否符合语言的语义规则。它会验证变量的声明和使用、类型匹配、函数调用等语义相关的问题，并生成符号表（Symbol Table）来管理变量和函数的信息。<br>  该过程的结果是生成一个经过简化的抽象语法树，更加接近字节码。</p>\n</li>\n<li><p><em>字节码生成</em><br>  将经过简化的抽象语法树生成符合 JVM 规范的字节码。</p>\n</li>\n</ol>\n<p>编译阶段的报错，统称为编译期错误，不会继续生成 .class 文件。</p>\n<h3 id=\"反编译\"><a href=\"#反编译\" class=\"headerlink\" title=\"反编译\"></a>反编译</h3><p>我们可以使用编译器将高级语言代码编译为低级语言代码，自然也可以使用反编译工具将已编译的代码转化为未编译的状代码</p>\n<p>Java反编译（<em>Java Decompilation</em>）是指将 Java 字节码文件转换回 Java 源代码的过程。JDK 中与 javac 相对的反编译器是 javap，可以使用 javap 来反编译 .class 文件。<br>我们可以使用 javap 反编译刚生成的 HelloWorld.class，看看会获得什么：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javap -c HelloWorld</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到反编译的结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">&quot;HelloWorld.java&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">HelloWorld</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(java.lang.String[])</span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: getstatic     #<span class=\"number\">7</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">       <span class=\"number\">3</span>: ldc           #<span class=\"number\">13</span>                 <span class=\"comment\">// String Hello, World!</span></span><br><span class=\"line\">       <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">15</span>                 <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">       <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字节码\"><a href=\"#字节码\" class=\"headerlink\" title=\"字节码\"></a>字节码</h3><p>Java 源代码经过虚拟机编译器编译后产生的文件（即扩展为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>\n<h2 id=\"JVM-📝\"><a href=\"#JVM-📝\" class=\"headerlink\" title=\"JVM 📝\"></a>JVM 📝</h2><p>我们已经获得了 .class 字节码文件，来看看它是如何在 JVM 中运行。</p>\n<h3 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h3><p>💡JVM 中的类加载器（<em>类加载子系统</em>）负责定位并加载类文件，可以分为以下三个小阶段：</p>\n<ol>\n<li><p><em><strong>加载 Loading</strong></em><br>  加载是类加载的第一个阶段。JVM 会根据类的全限定名（<em>Fully Qualified Name</em>）查找并读取类的字节码文件，<br>  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，<br>  然后在 Java 堆内存中生成一个代表这个类的 <em>java.lang.Class</em> 实例，作为方法区中这个类的各种数据的访问入口。</p>\n</li>\n<li><p><em><strong>链接 Linking</strong></em><br>  链接是类加载的第二个阶段。JVM 会对加载的类进行一些准备工作，包括以下三步：</p>\n<ul>\n<li>验证：验证字节码的正确性和安全性，检查类的结构、字段和方法的引用是否有效；</li>\n<li>准备：为类的静态变量分配内存空间，并设置默认初始值；</li>\n<li>解析：将符号引用转化为直接引用，即将类、字段和方法的符号引用解析为内存地址引用。</li>\n</ul>\n</li>\n<li><p><em><strong>初始化 Initialization</strong></em><br>  初始化是类加载的最后一个阶段。JVM 会执行类的静态代码块并对静态变量的赋值操作。<br>  初始化阶段是类加载过程中最耗时的阶段，它需要确保类的静态资源正确初始化，并且只会执行一次。直到这一步，才会真正开始执行开发者编写的 java 代码。</p>\n</li>\n</ol>\n<blockquote>\n<p>阅读文章以了解类加载的更多内容：<a href=\"https://zhuanlan.zhihu.com/p/25228545\">Java 类加载机制</a></p>\n</blockquote>\n<h3 id=\"执行引擎\"><a href=\"#执行引擎\" class=\"headerlink\" title=\"执行引擎\"></a>执行引擎</h3><p>💡执行引擎负责解释或编译字节码为机器码，并执行。</p>\n<p>JVM 执行引擎是 JVM 核心组成部分之一。它负责将字节码指令解释&#x2F;编译为 <em>对应平台</em> 上的机器指令，这是 Java 跨平台特性的关键。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927180316.png\" alt=\"20230927180316\"></p>\n<p>执行引擎的主要有以下工作：</p>\n<ol>\n<li><p><em>字节码验证 Bytecode Verification</em><br>  JVM 首先会对内存中的字节码进行验证，以确保它的结构和语义是正确的。字节码验证是为了防止恶意代码或错误的字节码破坏 JVM 的安全和稳定性。</p>\n</li>\n<li><p><em>解释&#x2F;编译</em><br>  JVM 有两种方式将字节码转化为机器码，但通常混用：</p>\n<ul>\n<li><em>解释执行</em><br>   JVM 使用解释器（<em>Interpreter</em>）逐行读取字节码，并将其转换为机器码，然后由处理器执行。解释执行的优点是简单、跨平台，缺点是效率低下，因为每次执行都需要重新解释。  </li>\n<li><em>编译执行</em><br>   JVM 使用即时编译器（<em>Just-In-Time Compiler</em>）将字节码转化为机器码，并将其缓存起来，以便下次直接执行。编译执行的优点是效率高，缺点是需要额外的编译时间和内存空间。  </li>\n<li><em>混合模式</em><br>   为了兼顾解释执行和编译执行的优势，JVM通常会采用混合模式（Mixed Mode），即对于频繁执行的热点代码，使用编译执行，对于不常执行的冷代码，使用解释执行。这样可以提高程序的整体性能。</li>\n</ul>\n</li>\n<li><p><em>执行机器码 Execution</em><br>  经过解释&#x2F;编译后，字节码被转化为平台特定的机器码。JVM 会将机器码加载到处理器中执行，实现程序的功能。</p>\n</li>\n</ol>\n<p>到此，我们的 Java 源代码就经过了从编写到执行整个过程。</p>\n<h3 id=\"JVM生命周期\"><a href=\"#JVM生命周期\" class=\"headerlink\" title=\"JVM生命周期\"></a>JVM生命周期</h3><p>JVM 在 Java 程序开始运行时运行，结束时也随之结束。</p>\n<p>一个 Java 程序对应一个 JVM 进程。</p>\n<p>JVM 中有两种线程：</p>\n<ul>\n<li><em>守护线程</em><br>JVM 自用，如垃圾回收（<em>GC</em>）</li>\n<li><em>普通进程</em><br>一般 Java 程序的线程</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25713880\">Java JVM 运行机制及基本原理</a></li>\n<li><a href=\"https://www.cnblogs.com/o-andy-o/archive/2012/04/11/2442109.html\">Java 的运行原理</a></li>\n<li><a href=\"https://rensifei.site/2017/03/javac/\">javac 源码笔记与简单的编译原理</a></li>\n</ul>\n","excerpt":"","more":"<p><code>Java</code> 代码从编写到运行，流程如下：</p>\n<ol>\n<li>Java 源程序（.java文件）经过 <em>编译器</em> 编译，变成 Java 字节码；</li>\n<li>Java 字节码经过 <em>JVM</em> 解释执行，传递给解释器；</li>\n<li><em>解释器</em> 将字节码翻译成合适的机器码，在机器中运行；</li>\n</ol>\n<p>这省略了很多细节，我想要相对详细地了解 Java 代码从编写到运行的过程中经历了什么。<br>如果你也感兴趣的话，可以接着往下看。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927135500.png\" alt=\"20230927135500\"></p>\n<h2 id=\"前置知识-🚀\"><a href=\"#前置知识-🚀\" class=\"headerlink\" title=\"前置知识 🚀\"></a>前置知识 🚀</h2><h3 id=\"JDK-Java开发工具包\"><a href=\"#JDK-Java开发工具包\" class=\"headerlink\" title=\"JDK - Java开发工具包\"></a>JDK - Java开发工具包</h3><p>JDK（<em>Java Development Kit</em>）是 Java 开发工具包，提供了 Java 开发环境和运行环境。<br>JDK 包含了 JRE，同时还包含了编译器（javac）和其他开发工具，用于开发、编译、调试和运行 Java 程序。</p>\n<h3 id=\"JRE-Java运行环境\"><a href=\"#JRE-Java运行环境\" class=\"headerlink\" title=\"JRE - Java运行环境\"></a>JRE - Java运行环境</h3><p>JRE（<em>Java Runtime Environment</em>）是 Java 运行时环境，它包含了 Java 虚拟机（JVM）以及运行 Java 程序所需的核心类库和支持文件。<br>JRE 提供了 Java 程序的运行环境，可以执行已经编译好的 Java 字节码。</p>\n<h3 id=\"JVM-Java虚拟机\"><a href=\"#JVM-Java虚拟机\" class=\"headerlink\" title=\"JVM - Java虚拟机\"></a>JVM - Java虚拟机</h3><p>JVM（<em>Java Virtual Machine</em>）Java 程序的执行环境。JVM 介于 Java 编译器和 OS 之间，利用软件方法实现了一个虚拟的计算机，可以解释和执行 Java 字节码。<br>Java 程序在 JVM 上运行，通过 JVM 实现跨平台的特性，这是因为在不同操作系统上的 JVM 都能够执行相同的 Java 字节码。</p>\n<h2 id=\"编译源代码-✒\"><a href=\"#编译源代码-✒\" class=\"headerlink\" title=\"编译源代码 ✒\"></a>编译源代码 ✒</h2><p>开发者主要做的是编写 Java 源文件（<em>source file</em>），通常以 <code>.java</code> 结尾。但文件中的代源码（<em>source code</em>）是给开发者阅读的，而不是机器，源文件不能直接运行。</p>\n<p>比如，我们用 Java 编写了一段 HelloWorld 代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello, World!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>💡我们使用 javac（<em>java编译器</em>，JDK中携带）编译这个源文件，将其转化以 <code>.class</code> 结尾为 Java 字节码文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac HelloWorld.java</span><br><span class=\"line\"><span class=\"comment\"># output: HelloWorld.class</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>编译器是一种将高级语言代码转化为低级语言代码的程序。</p>\n</blockquote>\n<h3 id=\"javac-编译-Java-源码\"><a href=\"#javac-编译-Java-源码\" class=\"headerlink\" title=\"javac 编译 Java 源码\"></a>javac 编译 Java 源码</h3><p>javac 将 Java 源代码作为输入，进行词法分析、语法分析和语义分析等过程，最终生成对应的字节码文件。流程如下：</p>\n<ol>\n<li><p><em>词法分析</em><br>  javac 首先读取源文件的字符流，并将其分解为一系列的词素（<em>token</em>）。词素是源代码中的最小语法单位，如关键字、标识符、操作符和常量等。<br>  该过程的结果是得到规范化的 token 流。</p>\n</li>\n<li><p><em>语法分析</em><br>  javac 对 token 流进行分析，并根据语法规则构建语法树（<em>Syntax Tree</em>）。语法树表示源代码的结构和层次关系。<br>  该过程的结果是得到一个符合 Java 语言规定的抽象语法树。</p>\n</li>\n<li><p><em>语义分析</em><br>  编译器对语法树进行进一步处理，检查代码是否符合语言的语义规则。它会验证变量的声明和使用、类型匹配、函数调用等语义相关的问题，并生成符号表（Symbol Table）来管理变量和函数的信息。<br>  该过程的结果是生成一个经过简化的抽象语法树，更加接近字节码。</p>\n</li>\n<li><p><em>字节码生成</em><br>  将经过简化的抽象语法树生成符合 JVM 规范的字节码。</p>\n</li>\n</ol>\n<p>编译阶段的报错，统称为编译期错误，不会继续生成 .class 文件。</p>\n<h3 id=\"反编译\"><a href=\"#反编译\" class=\"headerlink\" title=\"反编译\"></a>反编译</h3><p>我们可以使用编译器将高级语言代码编译为低级语言代码，自然也可以使用反编译工具将已编译的代码转化为未编译的状代码</p>\n<p>Java反编译（<em>Java Decompilation</em>）是指将 Java 字节码文件转换回 Java 源代码的过程。JDK 中与 javac 相对的反编译器是 javap，可以使用 javap 来反编译 .class 文件。<br>我们可以使用 javap 反编译刚生成的 HelloWorld.class，看看会获得什么：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javap -c HelloWorld</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到反编译的结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">&quot;HelloWorld.java&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">HelloWorld</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial #<span class=\"number\">1</span>                  <span class=\"comment\">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(java.lang.String[])</span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: getstatic     #<span class=\"number\">7</span>                  <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">       <span class=\"number\">3</span>: ldc           #<span class=\"number\">13</span>                 <span class=\"comment\">// String Hello, World!</span></span><br><span class=\"line\">       <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">15</span>                 <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">       <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字节码\"><a href=\"#字节码\" class=\"headerlink\" title=\"字节码\"></a>字节码</h3><p>Java 源代码经过虚拟机编译器编译后产生的文件（即扩展为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>\n<h2 id=\"JVM-📝\"><a href=\"#JVM-📝\" class=\"headerlink\" title=\"JVM 📝\"></a>JVM 📝</h2><p>我们已经获得了 .class 字节码文件，来看看它是如何在 JVM 中运行。</p>\n<h3 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h3><p>💡JVM 中的类加载器（<em>类加载子系统</em>）负责定位并加载类文件，可以分为以下三个小阶段：</p>\n<ol>\n<li><p><em><strong>加载 Loading</strong></em><br>  加载是类加载的第一个阶段。JVM 会根据类的全限定名（<em>Fully Qualified Name</em>）查找并读取类的字节码文件，<br>  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，<br>  然后在 Java 堆内存中生成一个代表这个类的 <em>java.lang.Class</em> 实例，作为方法区中这个类的各种数据的访问入口。</p>\n</li>\n<li><p><em><strong>链接 Linking</strong></em><br>  链接是类加载的第二个阶段。JVM 会对加载的类进行一些准备工作，包括以下三步：</p>\n<ul>\n<li>验证：验证字节码的正确性和安全性，检查类的结构、字段和方法的引用是否有效；</li>\n<li>准备：为类的静态变量分配内存空间，并设置默认初始值；</li>\n<li>解析：将符号引用转化为直接引用，即将类、字段和方法的符号引用解析为内存地址引用。</li>\n</ul>\n</li>\n<li><p><em><strong>初始化 Initialization</strong></em><br>  初始化是类加载的最后一个阶段。JVM 会执行类的静态代码块并对静态变量的赋值操作。<br>  初始化阶段是类加载过程中最耗时的阶段，它需要确保类的静态资源正确初始化，并且只会执行一次。直到这一步，才会真正开始执行开发者编写的 java 代码。</p>\n</li>\n</ol>\n<blockquote>\n<p>阅读文章以了解类加载的更多内容：<a href=\"https://zhuanlan.zhihu.com/p/25228545\">Java 类加载机制</a></p>\n</blockquote>\n<h3 id=\"执行引擎\"><a href=\"#执行引擎\" class=\"headerlink\" title=\"执行引擎\"></a>执行引擎</h3><p>💡执行引擎负责解释或编译字节码为机器码，并执行。</p>\n<p>JVM 执行引擎是 JVM 核心组成部分之一。它负责将字节码指令解释&#x2F;编译为 <em>对应平台</em> 上的机器指令，这是 Java 跨平台特性的关键。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230927180316.png\" alt=\"20230927180316\"></p>\n<p>执行引擎的主要有以下工作：</p>\n<ol>\n<li><p><em>字节码验证 Bytecode Verification</em><br>  JVM 首先会对内存中的字节码进行验证，以确保它的结构和语义是正确的。字节码验证是为了防止恶意代码或错误的字节码破坏 JVM 的安全和稳定性。</p>\n</li>\n<li><p><em>解释&#x2F;编译</em><br>  JVM 有两种方式将字节码转化为机器码，但通常混用：</p>\n<ul>\n<li><em>解释执行</em><br>   JVM 使用解释器（<em>Interpreter</em>）逐行读取字节码，并将其转换为机器码，然后由处理器执行。解释执行的优点是简单、跨平台，缺点是效率低下，因为每次执行都需要重新解释。  </li>\n<li><em>编译执行</em><br>   JVM 使用即时编译器（<em>Just-In-Time Compiler</em>）将字节码转化为机器码，并将其缓存起来，以便下次直接执行。编译执行的优点是效率高，缺点是需要额外的编译时间和内存空间。  </li>\n<li><em>混合模式</em><br>   为了兼顾解释执行和编译执行的优势，JVM通常会采用混合模式（Mixed Mode），即对于频繁执行的热点代码，使用编译执行，对于不常执行的冷代码，使用解释执行。这样可以提高程序的整体性能。</li>\n</ul>\n</li>\n<li><p><em>执行机器码 Execution</em><br>  经过解释&#x2F;编译后，字节码被转化为平台特定的机器码。JVM 会将机器码加载到处理器中执行，实现程序的功能。</p>\n</li>\n</ol>\n<p>到此，我们的 Java 源代码就经过了从编写到执行整个过程。</p>\n<h3 id=\"JVM生命周期\"><a href=\"#JVM生命周期\" class=\"headerlink\" title=\"JVM生命周期\"></a>JVM生命周期</h3><p>JVM 在 Java 程序开始运行时运行，结束时也随之结束。</p>\n<p>一个 Java 程序对应一个 JVM 进程。</p>\n<p>JVM 中有两种线程：</p>\n<ul>\n<li><em>守护线程</em><br>JVM 自用，如垃圾回收（<em>GC</em>）</li>\n<li><em>普通进程</em><br>一般 Java 程序的线程</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/25713880\">Java JVM 运行机制及基本原理</a></li>\n<li><a href=\"https://www.cnblogs.com/o-andy-o/archive/2012/04/11/2442109.html\">Java 的运行原理</a></li>\n<li><a href=\"https://rensifei.site/2017/03/javac/\">javac 源码笔记与简单的编译原理</a></li>\n</ul>\n"},{"title":"HTML 不常用标签及 <head> 优化","date":"2023-10-21T16:00:00.000Z","author":"ma5hr00m","_content":"\n阿菇最近倾向于用原生三件套做 Web 开发，想尽可能少地依赖三方库。\n\n或许没什么必要，因为封装好的东西用起来确实爽快。但造轮子确实也有造轮子的快乐。不可辩解的是，阿菇对前端项目中乱糟糟的配置文件以及 `node_modules` 感到厌烦，即使在开发过程中用了 `File Nesting Updater` 这样简化目录结构的插件。\n\n掌握一定 Web 开发基础后再回过头来学习，能发现之前没注意到的有趣知识，可以再做记录。\n\n以下内容有很多代码片段，光说没意思，自己 copy 后修修改改看看效果！\n可以在这个在线平台实验：[HTML/CSS/JS 在线工具](https://c.runoob.com/front-end/61/)\n\n## HTML 元素\nWeb 前端开发者经常使用语义化元素：既能提高 HTML 的可读性，也能减少写 CSS 命名的烦恼，还有利于 SEO 优化，好处多多。\n\n当然也可以 `<div>` 一把嗦，方便的很（类比后端编写 API 时 `POST` 一把嗦）。\n很多老网站都是这么做的，比如我们做网站备案时用的 [互联网网站安全管理服务平台](https://www.beian.gov.cn/)，清一色的 `<div>` 标签。\n\n除了常用的 `<header>`、`<main>` 等规划网页布局的元素，`<em>`、`<br>` 等用于规划文本布局的元素，还有一些有趣的语义化标签。\n我觉得以后能用上，也打算去用，这里就做个记录。\n\n### `<abbr>`\n文本缩写元素，同时提供了一个 `title` 属性值，可以实现鼠标 hover 时显示具体内容：\n```html\n<p>\n  <abbr title=\"HyperText Markup Language\">HTML</abbr> is fun!\n</p>\n```\n\n### `<address>`\n提供个人或组织的联系方式，仅表达了额外的语义信息。\n```html\n<address>\n  <a href=\"mailto:jim@rock.com\">jim@rock.com</a><br />\n  <a href=\"tel:+13115552368\">(311) 555-2368</a>\n</address>\n```\n\n### `<bdi>`\n双向文本隔离元素，`dir` 属性不继承父元素，即被该元素包裹的内容方向不受父元素的影响，比如：\n```html\n<p dir=\"rtl\">\n  This arabic word <bdi>ARABIC_PLACEHOLDER</bdi> is automatically displayed\n  right-to-left.\n</p>\n```\n\n### `<bdo>`\n双向文本替代元素，可以改写文本的方向，而不需要编写 CSS 样式。\n\n自带的 `dir` 属性有两个可选值：\n- `ltr` - 左到右\n- `rtl` - 右到左\n```html\n<p>\n  <bdo dir=\"rtl\">This text will go right to left.</bdo>\n</p>\n```\n\n### `<caption>`\nHTML 表格标题元素，常作为 `<table>` 的第一个子元素出现。\n\n仅支持全局属性，要改变样式需要用 CSS 的 `caption-side` 或者 `text-align`。\n```html\n<table>\n  <caption>\n    表格名称和值\n  </caption>\n  <tbody>\n    <tr>\n      <th scope=\"col\">名称</th>\n      <th scope=\"col\">HEX</th>\n      <th scope=\"col\">HSLa</th>\n      <th scope=\"col\">RGBa</th>\n    </tr>\n    <tr>\n      <th scope=\"row\">Teal</th>\n      <td><code>#51F6F6</code></td>\n      <td><code>hsla(180, 90%, 64%, 1)</code></td>\n      <td><code>rgba(81, 246, 246, 1)</code></td>\n    </tr>\n    <tr>\n      <th scope=\"row\">Goldenrod</th>\n      <td><code>#F6BC57</code></td>\n      <td><code>hsla(38, 90%, 65%, 1)</code></td>\n      <td><code>rgba(246, 188, 87, 1)</code></td>\n    </tr>\n  </tbody>\n</table>\n```\n\n### `<cite>`\nHTML 引用元素，表示一个作品的引用，且必须包含作品的标题。\n\n与之类似的有 `<blackquote>` 和 `<q>` 元素的 `cite` 属性，值一般为引用链接。\n```html\n<figure>\n  <blockquote>\n    <p>It was a bright cold day in April, and the clocks were striking thirteen.</p>\n  </blockquote>\n  <figcaption>\n    First sentence in <cite><a href=\"http://www.george-orwell.org/1984/0.html\">Nineteen Eighty-Four</a></cite> by George\n    Orwell (Part 1, Chapter 1).\n  </figcaption>\n</figure>\n```\n\n### `<data>`\n将一个指定内容和机器可读的翻译联系在一起。但是，如果内容是与时间或者日期相关的，则一定要使用 `<time>`。\n\n`value` 属性为标签内容所对应的数据。\n```html\n<ul>\n  <li><data value=\"398\">迷你番茄酱</data></li>\n  <li><data value=\"399\">巨无霸番茄酱</data></li>\n  <li><data value=\"400\">超级巨无霸番茄酱</data></li>\n</ul>\n```\n\n### `<datalist>`\n类似输入框，但使用 `<option>` 提供了一些默认可选项。\n```html\n<datalist id=\"ice-cream-flavors\">\n  <option value=\"Chocolate\"></option>\n  <option value=\"Coconut\"></option>\n  <option value=\"Mint\"></option>\n  <option value=\"Strawberry\"></option>\n  <option value=\"Vanilla\"></option>\n</datalist>\n```\n\n### `<dfn>`\nHTML 定义元素，一般结合前文的 `<addr>` 使用。\n```html\n<dfn>\n  <abbr title=\"World-Wide Web\">WWW</abbr>\n</dfn>\n```\n\n### `<dialog>`\n对话框元素，一般用于实现一个独立的交互式组件。\n```html\n<!-- Simple modal dialog containing a form -->\n<dialog id=\"favDialog\">\n  <form method=\"dialog\">\n    <p>\n      <label\n        >Favorite animal:\n        <select>\n          <option value=\"default\">Choose…</option>\n          <option>Brine shrimp</option>\n          <option>Red panda</option>\n          <option>Spider monkey</option>\n        </select>\n      </label>\n    </p>\n    <div>\n      <button value=\"cancel\">Cancel</button>\n      <button id=\"confirmBtn\" value=\"default\">Confirm</button>\n    </div>\n  </form>\n</dialog>\n<p>\n  <button id=\"updateDetails\">Update details</button>\n</p>\n<output></output>\n```\n\n对应的 `JavaScript` 代码：\n```javascript\nconst updateButton = document.getElementById(\"updateDetails\");\nconst favDialog = document.getElementById(\"favDialog\");\nconst outputBox = document.querySelector(\"output\");\nconst selectEl = favDialog.querySelector(\"select\");\nconst confirmBtn = favDialog.querySelector(\"#confirmBtn\");\n\n// If a browser doesn't support the dialog, then hide the\n// dialog contents by default.\nif (typeof favDialog.showModal !== \"function\") {\n  favDialog.hidden = true;\n  /* a fallback script to allow this dialog/form to function\n     for legacy browsers that do not support <dialog>\n     could be provided here.\n  */\n}\n// \"Update details\" button opens the <dialog> modally\nupdateButton.addEventListener(\"click\", () => {\n  if (typeof favDialog.showModal === \"function\") {\n    favDialog.showModal();\n  } else {\n    outputBox.value =\n      \"Sorry, the <dialog> API is not supported by this browser.\";\n  }\n});\n// \"Favorite animal\" input sets the value of the submit button\nselectEl.addEventListener(\"change\", (e) => {\n  confirmBtn.value = selectEl.value;\n});\n// \"Confirm\" button of form triggers \"close\" on dialog because of [method=\"dialog\"]\nfavDialog.addEventListener(\"close\", () => {\n  outputBox.value = `${\n    favDialog.returnValue\n  } button clicked - ${new Date().toString()}`;\n});\n```\n\n使用该元素时应当注意搭配 `autofocus` 属性，为用户在弹出的对话框中自动选择一个合适的焦点。\n```html\n<input name=\"q\" autofocus />\n```\n\n### `<details> and <summary>`\n详细信息展开元素，很有用，二者搭配使用，灵活性远超下拉列表元素。\n```html\n<!-- 默认展开 <details open> -->\n<!-- <summary> 设置 list-style: none; 可以隐藏黑三角标志 -->\n<details>\n  <summary>Details</summary>\n  Something small enough to escape casual notice.\n</details>\n```\n\n但没有内置的方法和属性可以添加状态转换时的动画效果。\n\n### `<fieldset> and <legend>`\n用于对表单中的控制元素进行分组（也包括 label 元素）。\n```html\n<form>\n  <fieldset>\n    <legend>Choose your favorite monster</legend>\n\n    <input type=\"radio\" id=\"kraken\" name=\"monster\" value=\"K\" />\n    <label for=\"kraken\">Kraken</label><br />\n\n    <input type=\"radio\" id=\"sasquatch\" name=\"monster\" value=\"S\" />\n    <label for=\"sasquatch\">Sasquatch</label><br />\n\n    <input type=\"radio\" id=\"mothman\" name=\"monster\" value=\"M\" />\n    <label for=\"mothman\">Mothman</label>\n  </fieldset>\n</form>\n```\n\n死去的 tkinter 记忆开始攻击阿菇……\n\n可以设置 `disabled` 属性，这会使得其子组件无法使用，提交表单时也不会携带对应数据。\n\n### `<hgroup>`\n代表文档标题和与标题相关联的内容，它将一个 `<h1>`–`<h6>` 元素与一个或多个 `<p>` 元素组合在一起。实现主标题副标题会很方便。\n```html\n<hgroup>\n  <h1>Frankenstein</h1>\n  <p>Or: The Modern Prometheus</p>\n</hgroup>\n```\n\n### `<kbd>`\nHTML 键盘输入元素用于表示用户输入，它将产生一个行内元素，以浏览器的默认 `monospace` 字体显示。\n```html\n<p>Save the document by pressing <kbd>Ctrl</kbd> + <kbd>S</kbd></p>\n```\n\n### `<meter>`\n用来显示已知范围的标量值或者分数值。\n```html\n<label for=\"fuel\">Fuel level:</label>\n<meter id=\"fuel\" min=\"0\" max=\"100\" low=\"33\" high=\"66\" optimum=\"80\" value=\"50\">at 50/100</meter>\n```\n\n自带了很多属性：[here](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meter#%E5%B1%9E%E6%80%A7)\n\n### `<noscript>`\n如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在该元素中定义脚本未被执行时的替代内容。`XSS` 有时候会利用这个元素。\n```html\n<noscript>\n  <!-- anchor linking to external file -->\n  <a href=\"http://www.mozilla.com/\">External Link</a>\n</noscript>\n<p>Rocks!</p>\n```\n\n### `<picture> and <source>`\n通过包含零或多个 `<source>` 元素和一个 `<img>` 元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 `<source>` 元素，如果没有匹配的，就选择 `<img>` 元素的 `src` 属性中的 URL。然后，所选图像呈现在 `<img>` 元素占据的空间中。\n```html\n<!--Change the browser window width to see the image change.-->\n\n<picture>\n  <source srcset=\"/media/cc0-images/surfer-240-200.jpg\" media=\"(orientation: portrait)\" />\n  <img src=\"/media/cc0-images/painted-hand-298-332.jpg\" alt=\"\" />\n</picture>\n```\n\n自带了一些属性：[here](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/picture#%E5%B1%9E%E6%80%A7)\n\n### `<progress>`\n进度指示元素，用来做进度条。\n```html\n<label for=\"file\">File progress:</label>\n<progress id=\"file\" max=\"100\" value=\"70\">70%</progress>\n```\n\n## HTML属性\n### `accesskey`\n为当前元素提供一个快捷键，属性值为一个可打印字符。\n\n但这个属性问题比较多：与系统快捷键冲突、指意不明、意外激活……能不用还是别用，但还是要知道一下。\n```html\n<p>\n  If you need to relax, press the <strong><u>S</u></strong>tress reliever!\n</p>\n<button accesskey=\"s\">Stress reliever</button>\n```\n\n### `autocomplete`\n允许 web 开发人员指定用户代理是否有权限在填写表单字段值时提供自动帮助，并指导浏览器填写该字段的预期信息类型。\n\n可选的属性值比较多，参考：[autocomplete](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/autocomplete).\n我常用的是 `off`, 即禁止用户代理提供历史可选值（因为我觉得这很影响页面美观性）。\n```html\n<label for=\"firstName\">First Name:</label>\n<input name=\"firstName\" id=\"firstName\" type=\"text\" autocomplete=\"given-name\" />\n\n<label for=\"lastName\">Last Name:</label>\n<input name=\"lastName\" id=\"lastName\" type=\"text\" autocomplete=\"family-name\" />\n\n<label for=\"email\">Email:</label>\n<input name=\"email\" id=\"email\" type=\"email\" autocomplete=\"off\" />\n```\n\n### `autofocus`\n上文中提到过，可以在页面加载时使当前元素自动获得用户焦点。\n\n### `contenteditable`\n枚举属性，表示元素是否可被用户编辑，属性值为 `true` 或者 `false`。\n```html\n<blockquote contenteditable=\"true\">\n  <p>Edit this content to add your own quote</p>\n</blockquote>\n```\n\n### `inert`\n一个有趣的布尔属性，可以使本身及其所有子元素的用户交互事件被浏览器忽略，包括鼠标、键盘、焦点等事件。可以适当精简代码，增强可读性。\n```html\n<p inert>\n  <a href=\"https://example.com\">Click</a>\n</p>\n```\n\n### `spellcheck`\n枚举属性，表示元素是否会对用户输入的值做拼写检查，属性值为 `true` 或 `false`.\n\n### `translate`\n枚举属性。规定制定元素是否需要翻译，属性值为 `yes` 或 `no`.\n```html\n<footer>\n  <small>© 2020 <span translate=\"no\">BrandName</span></small>\n</footer>\n```\n\n## `<head>`元素顺序\n编写 HTML 的 `<head>` 元素时，元素建议遵循以下顺序，可以提高网页性能：\n1. preconnect\n2. script-async\n3. css-contains-@ import\n4. sync-js\n5. sync-css\n6. preload\n7. script-defer\n8. prefetch / prerender\n9. seo-relative\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n  <head>\n    <!-- preconnect -->\n    <link rel=\"preconnect\" href=\"https://cdn.example.com\">\n    <!-- script-async -->\n    <script async src=\"https://cdn.example.com/js/analytics.js\"></script>\n    <!-- css-contains-@ import -->\n    <style>\n      @import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');\n    </style>\n    <!-- sync-js -->\n    <script src=\"js/main.js\"></script>\n    <!-- sync-css -->\n    <link rel=\"stylesheet\" href=\"css/styles.css\">\n    <!-- preload -->\n    <link rel=\"preload\" href=\"img/background.jpg\" as=\"image\">\n    <!-- script-defer -->\n    <script defer src=\"js/interactive.js\"></script>\n    <!-- prefetch / prerender -->\n    <link rel=\"prefetch\" href=\"about.html\">\n    <link rel=\"prerender\" href=\"contact.html\">\n    <!-- seo-relative -->\n    <link rel=\"canonical\" href=\"/index.html\">\n    <!-- Other SEO related tags -->\n    <meta charset=\"UTF-8\">\n    <title>我的网站</title>\n    <meta name=\"description\" content=\"这是我的网站的描述。\">\n  </head>\n  <body>\n      <!-- 页面内容 -->\n  </body>\n</html>\n```\n\n我们可以使用 `capo.js` 工具，对 `<head>` 中的元素进行标注，快速识别和优化性能问题。GitHub 仓库地址：[capo.js](https://github.com/rviscomi/capo.js).\n\n同时，官方还提供了对应的浏览器插件：[Capo: get your ﹤𝚑𝚎𝚊𝚍﹥ in order](https://chrome.google.com/webstore/detail/capo-get-your-%EF%B9%A4%F0%9D%9A%91%F0%9D%9A%8E%F0%9D%9A%8A%F0%9D%9A%8D%EF%B9%A5/ohabpnaccigjhkkebjofhpmebofgpbeb?utm_source=ext_sidebar&hl=zh-CN),\n这个插件可以直观地展示当前 Web 页面 `<head>` 中各元素加载用时的真实顺序以及排序后的顺序。\n\n![插件使用演示](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231006101948.png)\n\n## 叨叨叨\nHTML 译为 *超文本标记语言*，与 Markdown 更相似而非 Golang 等编程语言。它的作用是定义网页内容的含义和结构。相比 CSS 和 JavaScript，我对 HTML 的重视程度一直不够，现在看来可以改变一下思想，HTML 其实才是一个网页的基石。\n\n## 参考\n- [HTML - MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML)\n- [新浪微博 - Barret李靖](https://weibo.com/1812166904/NbGRFCRtU)","source":"_posts/html_relearn.md","raw":"---\ntitle: HTML 不常用标签及 <head> 优化\ndate: 2023/10/22\nauthor: ma5hr00m\ncategories:\n- HTML\n---\n\n阿菇最近倾向于用原生三件套做 Web 开发，想尽可能少地依赖三方库。\n\n或许没什么必要，因为封装好的东西用起来确实爽快。但造轮子确实也有造轮子的快乐。不可辩解的是，阿菇对前端项目中乱糟糟的配置文件以及 `node_modules` 感到厌烦，即使在开发过程中用了 `File Nesting Updater` 这样简化目录结构的插件。\n\n掌握一定 Web 开发基础后再回过头来学习，能发现之前没注意到的有趣知识，可以再做记录。\n\n以下内容有很多代码片段，光说没意思，自己 copy 后修修改改看看效果！\n可以在这个在线平台实验：[HTML/CSS/JS 在线工具](https://c.runoob.com/front-end/61/)\n\n## HTML 元素\nWeb 前端开发者经常使用语义化元素：既能提高 HTML 的可读性，也能减少写 CSS 命名的烦恼，还有利于 SEO 优化，好处多多。\n\n当然也可以 `<div>` 一把嗦，方便的很（类比后端编写 API 时 `POST` 一把嗦）。\n很多老网站都是这么做的，比如我们做网站备案时用的 [互联网网站安全管理服务平台](https://www.beian.gov.cn/)，清一色的 `<div>` 标签。\n\n除了常用的 `<header>`、`<main>` 等规划网页布局的元素，`<em>`、`<br>` 等用于规划文本布局的元素，还有一些有趣的语义化标签。\n我觉得以后能用上，也打算去用，这里就做个记录。\n\n### `<abbr>`\n文本缩写元素，同时提供了一个 `title` 属性值，可以实现鼠标 hover 时显示具体内容：\n```html\n<p>\n  <abbr title=\"HyperText Markup Language\">HTML</abbr> is fun!\n</p>\n```\n\n### `<address>`\n提供个人或组织的联系方式，仅表达了额外的语义信息。\n```html\n<address>\n  <a href=\"mailto:jim@rock.com\">jim@rock.com</a><br />\n  <a href=\"tel:+13115552368\">(311) 555-2368</a>\n</address>\n```\n\n### `<bdi>`\n双向文本隔离元素，`dir` 属性不继承父元素，即被该元素包裹的内容方向不受父元素的影响，比如：\n```html\n<p dir=\"rtl\">\n  This arabic word <bdi>ARABIC_PLACEHOLDER</bdi> is automatically displayed\n  right-to-left.\n</p>\n```\n\n### `<bdo>`\n双向文本替代元素，可以改写文本的方向，而不需要编写 CSS 样式。\n\n自带的 `dir` 属性有两个可选值：\n- `ltr` - 左到右\n- `rtl` - 右到左\n```html\n<p>\n  <bdo dir=\"rtl\">This text will go right to left.</bdo>\n</p>\n```\n\n### `<caption>`\nHTML 表格标题元素，常作为 `<table>` 的第一个子元素出现。\n\n仅支持全局属性，要改变样式需要用 CSS 的 `caption-side` 或者 `text-align`。\n```html\n<table>\n  <caption>\n    表格名称和值\n  </caption>\n  <tbody>\n    <tr>\n      <th scope=\"col\">名称</th>\n      <th scope=\"col\">HEX</th>\n      <th scope=\"col\">HSLa</th>\n      <th scope=\"col\">RGBa</th>\n    </tr>\n    <tr>\n      <th scope=\"row\">Teal</th>\n      <td><code>#51F6F6</code></td>\n      <td><code>hsla(180, 90%, 64%, 1)</code></td>\n      <td><code>rgba(81, 246, 246, 1)</code></td>\n    </tr>\n    <tr>\n      <th scope=\"row\">Goldenrod</th>\n      <td><code>#F6BC57</code></td>\n      <td><code>hsla(38, 90%, 65%, 1)</code></td>\n      <td><code>rgba(246, 188, 87, 1)</code></td>\n    </tr>\n  </tbody>\n</table>\n```\n\n### `<cite>`\nHTML 引用元素，表示一个作品的引用，且必须包含作品的标题。\n\n与之类似的有 `<blackquote>` 和 `<q>` 元素的 `cite` 属性，值一般为引用链接。\n```html\n<figure>\n  <blockquote>\n    <p>It was a bright cold day in April, and the clocks were striking thirteen.</p>\n  </blockquote>\n  <figcaption>\n    First sentence in <cite><a href=\"http://www.george-orwell.org/1984/0.html\">Nineteen Eighty-Four</a></cite> by George\n    Orwell (Part 1, Chapter 1).\n  </figcaption>\n</figure>\n```\n\n### `<data>`\n将一个指定内容和机器可读的翻译联系在一起。但是，如果内容是与时间或者日期相关的，则一定要使用 `<time>`。\n\n`value` 属性为标签内容所对应的数据。\n```html\n<ul>\n  <li><data value=\"398\">迷你番茄酱</data></li>\n  <li><data value=\"399\">巨无霸番茄酱</data></li>\n  <li><data value=\"400\">超级巨无霸番茄酱</data></li>\n</ul>\n```\n\n### `<datalist>`\n类似输入框，但使用 `<option>` 提供了一些默认可选项。\n```html\n<datalist id=\"ice-cream-flavors\">\n  <option value=\"Chocolate\"></option>\n  <option value=\"Coconut\"></option>\n  <option value=\"Mint\"></option>\n  <option value=\"Strawberry\"></option>\n  <option value=\"Vanilla\"></option>\n</datalist>\n```\n\n### `<dfn>`\nHTML 定义元素，一般结合前文的 `<addr>` 使用。\n```html\n<dfn>\n  <abbr title=\"World-Wide Web\">WWW</abbr>\n</dfn>\n```\n\n### `<dialog>`\n对话框元素，一般用于实现一个独立的交互式组件。\n```html\n<!-- Simple modal dialog containing a form -->\n<dialog id=\"favDialog\">\n  <form method=\"dialog\">\n    <p>\n      <label\n        >Favorite animal:\n        <select>\n          <option value=\"default\">Choose…</option>\n          <option>Brine shrimp</option>\n          <option>Red panda</option>\n          <option>Spider monkey</option>\n        </select>\n      </label>\n    </p>\n    <div>\n      <button value=\"cancel\">Cancel</button>\n      <button id=\"confirmBtn\" value=\"default\">Confirm</button>\n    </div>\n  </form>\n</dialog>\n<p>\n  <button id=\"updateDetails\">Update details</button>\n</p>\n<output></output>\n```\n\n对应的 `JavaScript` 代码：\n```javascript\nconst updateButton = document.getElementById(\"updateDetails\");\nconst favDialog = document.getElementById(\"favDialog\");\nconst outputBox = document.querySelector(\"output\");\nconst selectEl = favDialog.querySelector(\"select\");\nconst confirmBtn = favDialog.querySelector(\"#confirmBtn\");\n\n// If a browser doesn't support the dialog, then hide the\n// dialog contents by default.\nif (typeof favDialog.showModal !== \"function\") {\n  favDialog.hidden = true;\n  /* a fallback script to allow this dialog/form to function\n     for legacy browsers that do not support <dialog>\n     could be provided here.\n  */\n}\n// \"Update details\" button opens the <dialog> modally\nupdateButton.addEventListener(\"click\", () => {\n  if (typeof favDialog.showModal === \"function\") {\n    favDialog.showModal();\n  } else {\n    outputBox.value =\n      \"Sorry, the <dialog> API is not supported by this browser.\";\n  }\n});\n// \"Favorite animal\" input sets the value of the submit button\nselectEl.addEventListener(\"change\", (e) => {\n  confirmBtn.value = selectEl.value;\n});\n// \"Confirm\" button of form triggers \"close\" on dialog because of [method=\"dialog\"]\nfavDialog.addEventListener(\"close\", () => {\n  outputBox.value = `${\n    favDialog.returnValue\n  } button clicked - ${new Date().toString()}`;\n});\n```\n\n使用该元素时应当注意搭配 `autofocus` 属性，为用户在弹出的对话框中自动选择一个合适的焦点。\n```html\n<input name=\"q\" autofocus />\n```\n\n### `<details> and <summary>`\n详细信息展开元素，很有用，二者搭配使用，灵活性远超下拉列表元素。\n```html\n<!-- 默认展开 <details open> -->\n<!-- <summary> 设置 list-style: none; 可以隐藏黑三角标志 -->\n<details>\n  <summary>Details</summary>\n  Something small enough to escape casual notice.\n</details>\n```\n\n但没有内置的方法和属性可以添加状态转换时的动画效果。\n\n### `<fieldset> and <legend>`\n用于对表单中的控制元素进行分组（也包括 label 元素）。\n```html\n<form>\n  <fieldset>\n    <legend>Choose your favorite monster</legend>\n\n    <input type=\"radio\" id=\"kraken\" name=\"monster\" value=\"K\" />\n    <label for=\"kraken\">Kraken</label><br />\n\n    <input type=\"radio\" id=\"sasquatch\" name=\"monster\" value=\"S\" />\n    <label for=\"sasquatch\">Sasquatch</label><br />\n\n    <input type=\"radio\" id=\"mothman\" name=\"monster\" value=\"M\" />\n    <label for=\"mothman\">Mothman</label>\n  </fieldset>\n</form>\n```\n\n死去的 tkinter 记忆开始攻击阿菇……\n\n可以设置 `disabled` 属性，这会使得其子组件无法使用，提交表单时也不会携带对应数据。\n\n### `<hgroup>`\n代表文档标题和与标题相关联的内容，它将一个 `<h1>`–`<h6>` 元素与一个或多个 `<p>` 元素组合在一起。实现主标题副标题会很方便。\n```html\n<hgroup>\n  <h1>Frankenstein</h1>\n  <p>Or: The Modern Prometheus</p>\n</hgroup>\n```\n\n### `<kbd>`\nHTML 键盘输入元素用于表示用户输入，它将产生一个行内元素，以浏览器的默认 `monospace` 字体显示。\n```html\n<p>Save the document by pressing <kbd>Ctrl</kbd> + <kbd>S</kbd></p>\n```\n\n### `<meter>`\n用来显示已知范围的标量值或者分数值。\n```html\n<label for=\"fuel\">Fuel level:</label>\n<meter id=\"fuel\" min=\"0\" max=\"100\" low=\"33\" high=\"66\" optimum=\"80\" value=\"50\">at 50/100</meter>\n```\n\n自带了很多属性：[here](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meter#%E5%B1%9E%E6%80%A7)\n\n### `<noscript>`\n如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在该元素中定义脚本未被执行时的替代内容。`XSS` 有时候会利用这个元素。\n```html\n<noscript>\n  <!-- anchor linking to external file -->\n  <a href=\"http://www.mozilla.com/\">External Link</a>\n</noscript>\n<p>Rocks!</p>\n```\n\n### `<picture> and <source>`\n通过包含零或多个 `<source>` 元素和一个 `<img>` 元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子 `<source>` 元素，如果没有匹配的，就选择 `<img>` 元素的 `src` 属性中的 URL。然后，所选图像呈现在 `<img>` 元素占据的空间中。\n```html\n<!--Change the browser window width to see the image change.-->\n\n<picture>\n  <source srcset=\"/media/cc0-images/surfer-240-200.jpg\" media=\"(orientation: portrait)\" />\n  <img src=\"/media/cc0-images/painted-hand-298-332.jpg\" alt=\"\" />\n</picture>\n```\n\n自带了一些属性：[here](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/picture#%E5%B1%9E%E6%80%A7)\n\n### `<progress>`\n进度指示元素，用来做进度条。\n```html\n<label for=\"file\">File progress:</label>\n<progress id=\"file\" max=\"100\" value=\"70\">70%</progress>\n```\n\n## HTML属性\n### `accesskey`\n为当前元素提供一个快捷键，属性值为一个可打印字符。\n\n但这个属性问题比较多：与系统快捷键冲突、指意不明、意外激活……能不用还是别用，但还是要知道一下。\n```html\n<p>\n  If you need to relax, press the <strong><u>S</u></strong>tress reliever!\n</p>\n<button accesskey=\"s\">Stress reliever</button>\n```\n\n### `autocomplete`\n允许 web 开发人员指定用户代理是否有权限在填写表单字段值时提供自动帮助，并指导浏览器填写该字段的预期信息类型。\n\n可选的属性值比较多，参考：[autocomplete](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/autocomplete).\n我常用的是 `off`, 即禁止用户代理提供历史可选值（因为我觉得这很影响页面美观性）。\n```html\n<label for=\"firstName\">First Name:</label>\n<input name=\"firstName\" id=\"firstName\" type=\"text\" autocomplete=\"given-name\" />\n\n<label for=\"lastName\">Last Name:</label>\n<input name=\"lastName\" id=\"lastName\" type=\"text\" autocomplete=\"family-name\" />\n\n<label for=\"email\">Email:</label>\n<input name=\"email\" id=\"email\" type=\"email\" autocomplete=\"off\" />\n```\n\n### `autofocus`\n上文中提到过，可以在页面加载时使当前元素自动获得用户焦点。\n\n### `contenteditable`\n枚举属性，表示元素是否可被用户编辑，属性值为 `true` 或者 `false`。\n```html\n<blockquote contenteditable=\"true\">\n  <p>Edit this content to add your own quote</p>\n</blockquote>\n```\n\n### `inert`\n一个有趣的布尔属性，可以使本身及其所有子元素的用户交互事件被浏览器忽略，包括鼠标、键盘、焦点等事件。可以适当精简代码，增强可读性。\n```html\n<p inert>\n  <a href=\"https://example.com\">Click</a>\n</p>\n```\n\n### `spellcheck`\n枚举属性，表示元素是否会对用户输入的值做拼写检查，属性值为 `true` 或 `false`.\n\n### `translate`\n枚举属性。规定制定元素是否需要翻译，属性值为 `yes` 或 `no`.\n```html\n<footer>\n  <small>© 2020 <span translate=\"no\">BrandName</span></small>\n</footer>\n```\n\n## `<head>`元素顺序\n编写 HTML 的 `<head>` 元素时，元素建议遵循以下顺序，可以提高网页性能：\n1. preconnect\n2. script-async\n3. css-contains-@ import\n4. sync-js\n5. sync-css\n6. preload\n7. script-defer\n8. prefetch / prerender\n9. seo-relative\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh\">\n  <head>\n    <!-- preconnect -->\n    <link rel=\"preconnect\" href=\"https://cdn.example.com\">\n    <!-- script-async -->\n    <script async src=\"https://cdn.example.com/js/analytics.js\"></script>\n    <!-- css-contains-@ import -->\n    <style>\n      @import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');\n    </style>\n    <!-- sync-js -->\n    <script src=\"js/main.js\"></script>\n    <!-- sync-css -->\n    <link rel=\"stylesheet\" href=\"css/styles.css\">\n    <!-- preload -->\n    <link rel=\"preload\" href=\"img/background.jpg\" as=\"image\">\n    <!-- script-defer -->\n    <script defer src=\"js/interactive.js\"></script>\n    <!-- prefetch / prerender -->\n    <link rel=\"prefetch\" href=\"about.html\">\n    <link rel=\"prerender\" href=\"contact.html\">\n    <!-- seo-relative -->\n    <link rel=\"canonical\" href=\"/index.html\">\n    <!-- Other SEO related tags -->\n    <meta charset=\"UTF-8\">\n    <title>我的网站</title>\n    <meta name=\"description\" content=\"这是我的网站的描述。\">\n  </head>\n  <body>\n      <!-- 页面内容 -->\n  </body>\n</html>\n```\n\n我们可以使用 `capo.js` 工具，对 `<head>` 中的元素进行标注，快速识别和优化性能问题。GitHub 仓库地址：[capo.js](https://github.com/rviscomi/capo.js).\n\n同时，官方还提供了对应的浏览器插件：[Capo: get your ﹤𝚑𝚎𝚊𝚍﹥ in order](https://chrome.google.com/webstore/detail/capo-get-your-%EF%B9%A4%F0%9D%9A%91%F0%9D%9A%8E%F0%9D%9A%8A%F0%9D%9A%8D%EF%B9%A5/ohabpnaccigjhkkebjofhpmebofgpbeb?utm_source=ext_sidebar&hl=zh-CN),\n这个插件可以直观地展示当前 Web 页面 `<head>` 中各元素加载用时的真实顺序以及排序后的顺序。\n\n![插件使用演示](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231006101948.png)\n\n## 叨叨叨\nHTML 译为 *超文本标记语言*，与 Markdown 更相似而非 Golang 等编程语言。它的作用是定义网页内容的含义和结构。相比 CSS 和 JavaScript，我对 HTML 的重视程度一直不够，现在看来可以改变一下思想，HTML 其实才是一个网页的基石。\n\n## 参考\n- [HTML - MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML)\n- [新浪微博 - Barret李靖](https://weibo.com/1812166904/NbGRFCRtU)","slug":"html_relearn","published":1,"updated":"2024-06-09T12:55:47.483Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap4000nf4lyg0t08wxm","content":"<p>阿菇最近倾向于用原生三件套做 Web 开发，想尽可能少地依赖三方库。</p>\n<p>或许没什么必要，因为封装好的东西用起来确实爽快。但造轮子确实也有造轮子的快乐。不可辩解的是，阿菇对前端项目中乱糟糟的配置文件以及 <code>node_modules</code> 感到厌烦，即使在开发过程中用了 <code>File Nesting Updater</code> 这样简化目录结构的插件。</p>\n<p>掌握一定 Web 开发基础后再回过头来学习，能发现之前没注意到的有趣知识，可以再做记录。</p>\n<p>以下内容有很多代码片段，光说没意思，自己 copy 后修修改改看看效果！<br>可以在这个在线平台实验：<a href=\"https://c.runoob.com/front-end/61/\">HTML&#x2F;CSS&#x2F;JS 在线工具</a></p>\n<h2 id=\"HTML-元素\"><a href=\"#HTML-元素\" class=\"headerlink\" title=\"HTML 元素\"></a>HTML 元素</h2><p>Web 前端开发者经常使用语义化元素：既能提高 HTML 的可读性，也能减少写 CSS 命名的烦恼，还有利于 SEO 优化，好处多多。</p>\n<p>当然也可以 <code>&lt;div&gt;</code> 一把嗦，方便的很（类比后端编写 API 时 <code>POST</code> 一把嗦）。<br>很多老网站都是这么做的，比如我们做网站备案时用的 <a href=\"https://www.beian.gov.cn/\">互联网网站安全管理服务平台</a>，清一色的 <code>&lt;div&gt;</code> 标签。</p>\n<p>除了常用的 <code>&lt;header&gt;</code>、<code>&lt;main&gt;</code> 等规划网页布局的元素，<code>&lt;em&gt;</code>、<code>&lt;br&gt;</code> 等用于规划文本布局的元素，还有一些有趣的语义化标签。<br>我觉得以后能用上，也打算去用，这里就做个记录。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"&lt;abbr&gt;\"></a><code>&lt;abbr&gt;</code></h3><p>文本缩写元素，同时提供了一个 <code>title</code> 属性值，可以实现鼠标 hover 时显示具体内容：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">abbr</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;HyperText Markup Language&quot;</span>&gt;</span>HTML<span class=\"tag\">&lt;/<span class=\"name\">abbr</span>&gt;</span> is fun!</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"&lt;address&gt;\"></a><code>&lt;address&gt;</code></h3><p>提供个人或组织的联系方式，仅表达了额外的语义信息。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">address</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:jim@rock.com&quot;</span>&gt;</span>jim@rock.com<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;tel:+13115552368&quot;</span>&gt;</span>(311) 555-2368<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">address</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"&lt;bdi&gt;\"></a><code>&lt;bdi&gt;</code></h3><p>双向文本隔离元素，<code>dir</code> 属性不继承父元素，即被该元素包裹的内容方向不受父元素的影响，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">dir</span>=<span class=\"string\">&quot;rtl&quot;</span>&gt;</span></span><br><span class=\"line\">  This arabic word <span class=\"tag\">&lt;<span class=\"name\">bdi</span>&gt;</span>ARABIC_PLACEHOLDER<span class=\"tag\">&lt;/<span class=\"name\">bdi</span>&gt;</span> is automatically displayed</span><br><span class=\"line\">  right-to-left.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"&lt;bdo&gt;\"></a><code>&lt;bdo&gt;</code></h3><p>双向文本替代元素，可以改写文本的方向，而不需要编写 CSS 样式。</p>\n<p>自带的 <code>dir</code> 属性有两个可选值：</p>\n<ul>\n<li><code>ltr</code> - 左到右</li>\n<li><code>rtl</code> - 右到左<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bdo</span> <span class=\"attr\">dir</span>=<span class=\"string\">&quot;rtl&quot;</span>&gt;</span>This text will go right to left.<span class=\"tag\">&lt;/<span class=\"name\">bdo</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"&lt;caption&gt;\"></a><code>&lt;caption&gt;</code></h3><p>HTML 表格标题元素，常作为 <code>&lt;table&gt;</code> 的第一个子元素出现。</p>\n<p>仅支持全局属性，要改变样式需要用 CSS 的 <code>caption-side</code> 或者 <code>text-align</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">caption</span>&gt;</span></span><br><span class=\"line\">    表格名称和值</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">caption</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;col&quot;</span>&gt;</span>名称<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;col&quot;</span>&gt;</span>HEX<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;col&quot;</span>&gt;</span>HSLa<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;col&quot;</span>&gt;</span>RGBa<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;row&quot;</span>&gt;</span>Teal<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>#51F6F6<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>hsla(180, 90%, 64%, 1)<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>rgba(81, 246, 246, 1)<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;row&quot;</span>&gt;</span>Goldenrod<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>#F6BC57<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>hsla(38, 90%, 65%, 1)<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>rgba(246, 188, 87, 1)<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"&lt;cite&gt;\"></a><code>&lt;cite&gt;</code></h3><p>HTML 引用元素，表示一个作品的引用，且必须包含作品的标题。</p>\n<p>与之类似的有 <code>&lt;blackquote&gt;</code> 和 <code>&lt;q&gt;</code> 元素的 <code>cite</code> 属性，值一般为引用链接。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">figure</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">blockquote</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>It was a bright cold day in April, and the clocks were striking thirteen.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">blockquote</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">figcaption</span>&gt;</span></span><br><span class=\"line\">    First sentence in <span class=\"tag\">&lt;<span class=\"name\">cite</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://www.george-orwell.org/1984/0.html&quot;</span>&gt;</span>Nineteen Eighty-Four<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">cite</span>&gt;</span> by George</span><br><span class=\"line\">    Orwell (Part 1, Chapter 1).</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">figcaption</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"&lt;data&gt;\"></a><code>&lt;data&gt;</code></h3><p>将一个指定内容和机器可读的翻译联系在一起。但是，如果内容是与时间或者日期相关的，则一定要使用 <code>&lt;time&gt;</code>。</p>\n<p><code>value</code> 属性为标签内容所对应的数据。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;398&quot;</span>&gt;</span>迷你番茄酱<span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;399&quot;</span>&gt;</span>巨无霸番茄酱<span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;400&quot;</span>&gt;</span>超级巨无霸番茄酱<span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-7\"><a href=\"#-7\" class=\"headerlink\" title=\"&lt;datalist&gt;\"></a><code>&lt;datalist&gt;</code></h3><p>类似输入框，但使用 <code>&lt;option&gt;</code> 提供了一些默认可选项。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">datalist</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;ice-cream-flavors&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Chocolate&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Coconut&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Mint&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Strawberry&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Vanilla&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-8\"><a href=\"#-8\" class=\"headerlink\" title=\"&lt;dfn&gt;\"></a><code>&lt;dfn&gt;</code></h3><p>HTML 定义元素，一般结合前文的 <code>&lt;addr&gt;</code> 使用。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dfn</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">abbr</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;World-Wide Web&quot;</span>&gt;</span>WWW<span class=\"tag\">&lt;/<span class=\"name\">abbr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dfn</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-9\"><a href=\"#-9\" class=\"headerlink\" title=\"&lt;dialog&gt;\"></a><code>&lt;dialog&gt;</code></h3><p>对话框元素，一般用于实现一个独立的交互式组件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Simple modal dialog containing a form --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;favDialog&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;dialog&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">label</span></span></span><br><span class=\"line\"><span class=\"tag\">        &gt;</span>Favorite animal:</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;default&quot;</span>&gt;</span>Choose…<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>Brine shrimp<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>Red panda<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>Spider monkey<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;cancel&quot;</span>&gt;</span>Cancel<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;confirmBtn&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;default&quot;</span>&gt;</span>Confirm<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;updateDetails&quot;</span>&gt;</span>Update details<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">output</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">output</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对应的 <code>JavaScript</code> 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> updateButton = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;updateDetails&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> favDialog = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;favDialog&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> outputBox = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;output&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> selectEl = favDialog.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;select&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> confirmBtn = favDialog.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;#confirmBtn&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If a browser doesn&#x27;t support the dialog, then hide the</span></span><br><span class=\"line\"><span class=\"comment\">// dialog contents by default.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> favDialog.<span class=\"property\">showModal</span> !== <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">  favDialog.<span class=\"property\">hidden</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* a fallback script to allow this dialog/form to function</span></span><br><span class=\"line\"><span class=\"comment\">     for legacy browsers that do not support &lt;dialog&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     could be provided here.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;Update details&quot; button opens the &lt;dialog&gt; modally</span></span><br><span class=\"line\">updateButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> favDialog.<span class=\"property\">showModal</span> === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">    favDialog.<span class=\"title function_\">showModal</span>();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    outputBox.<span class=\"property\">value</span> =</span><br><span class=\"line\">      <span class=\"string\">&quot;Sorry, the &lt;dialog&gt; API is not supported by this browser.&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// &quot;Favorite animal&quot; input sets the value of the submit button</span></span><br><span class=\"line\">selectEl.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;change&quot;</span>, <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  confirmBtn.<span class=\"property\">value</span> = selectEl.<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// &quot;Confirm&quot; button of form triggers &quot;close&quot; on dialog because of [method=&quot;dialog&quot;]</span></span><br><span class=\"line\">favDialog.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;close&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  outputBox.<span class=\"property\">value</span> = <span class=\"string\">`<span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">    favDialog.returnValue</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">  &#125;</span> button clicked - <span class=\"subst\">$&#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toString()&#125;</span>`</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用该元素时应当注意搭配 <code>autofocus</code> 属性，为用户在弹出的对话框中自动选择一个合适的焦点。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;q&quot;</span> <span class=\"attr\">autofocus</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"and\"><a href=\"#and\" class=\"headerlink\" title=\"&lt;details&gt; and &lt;summary&gt;\"></a><code>&lt;details&gt; and &lt;summary&gt;</code></h3><p>详细信息展开元素，很有用，二者搭配使用，灵活性远超下拉列表元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 默认展开 &lt;details open&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;summary&gt; 设置 list-style: none; 可以隐藏黑三角标志 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">details</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">summary</span>&gt;</span>Details<span class=\"tag\">&lt;/<span class=\"name\">summary</span>&gt;</span></span><br><span class=\"line\">  Something small enough to escape casual notice.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">details</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但没有内置的方法和属性可以添加状态转换时的动画效果。</p>\n<h3 id=\"and-1\"><a href=\"#and-1\" class=\"headerlink\" title=\"&lt;fieldset&gt; and &lt;legend&gt;\"></a><code>&lt;fieldset&gt; and &lt;legend&gt;</code></h3><p>用于对表单中的控制元素进行分组（也包括 label 元素）。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span>Choose your favorite monster<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;kraken&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;monster&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;K&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;kraken&quot;</span>&gt;</span>Kraken<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sasquatch&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;monster&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;S&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;sasquatch&quot;</span>&gt;</span>Sasquatch<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;mothman&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;monster&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;M&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;mothman&quot;</span>&gt;</span>Mothman<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>死去的 tkinter 记忆开始攻击阿菇……</p>\n<p>可以设置 <code>disabled</code> 属性，这会使得其子组件无法使用，提交表单时也不会携带对应数据。</p>\n<h3 id=\"-10\"><a href=\"#-10\" class=\"headerlink\" title=\"&lt;hgroup&gt;\"></a><code>&lt;hgroup&gt;</code></h3><p>代表文档标题和与标题相关联的内容，它将一个 <code>&lt;h1&gt;</code>–<code>&lt;h6&gt;</code> 元素与一个或多个 <code>&lt;p&gt;</code> 元素组合在一起。实现主标题副标题会很方便。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hgroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Frankenstein<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Or: The Modern Prometheus<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hgroup</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-11\"><a href=\"#-11\" class=\"headerlink\" title=\"&lt;kbd&gt;\"></a><code>&lt;kbd&gt;</code></h3><p>HTML 键盘输入元素用于表示用户输入，它将产生一个行内元素，以浏览器的默认 <code>monospace</code> 字体显示。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Save the document by pressing <span class=\"tag\">&lt;<span class=\"name\">kbd</span>&gt;</span>Ctrl<span class=\"tag\">&lt;/<span class=\"name\">kbd</span>&gt;</span> + <span class=\"tag\">&lt;<span class=\"name\">kbd</span>&gt;</span>S<span class=\"tag\">&lt;/<span class=\"name\">kbd</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-12\"><a href=\"#-12\" class=\"headerlink\" title=\"&lt;meter&gt;\"></a><code>&lt;meter&gt;</code></h3><p>用来显示已知范围的标量值或者分数值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;fuel&quot;</span>&gt;</span>Fuel level:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meter</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fuel&quot;</span> <span class=\"attr\">min</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">max</span>=<span class=\"string\">&quot;100&quot;</span> <span class=\"attr\">low</span>=<span class=\"string\">&quot;33&quot;</span> <span class=\"attr\">high</span>=<span class=\"string\">&quot;66&quot;</span> <span class=\"attr\">optimum</span>=<span class=\"string\">&quot;80&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;50&quot;</span>&gt;</span>at 50/100<span class=\"tag\">&lt;/<span class=\"name\">meter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>自带了很多属性：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meter#%E5%B1%9E%E6%80%A7\">here</a></p>\n<h3 id=\"-13\"><a href=\"#-13\" class=\"headerlink\" title=\"&lt;noscript&gt;\"></a><code>&lt;noscript&gt;</code></h3><p>如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在该元素中定义脚本未被执行时的替代内容。<code>XSS</code> 有时候会利用这个元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">noscript</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- anchor linking to external file --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://www.mozilla.com/&quot;</span>&gt;</span>External Link<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">noscript</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Rocks!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"and-2\"><a href=\"#and-2\" class=\"headerlink\" title=\"&lt;picture&gt; and &lt;source&gt;\"></a><code>&lt;picture&gt; and &lt;source&gt;</code></h3><p>通过包含零或多个 <code>&lt;source&gt;</code> 元素和一个 <code>&lt;img&gt;</code> 元素来为不同的显示&#x2F;设备场景提供图像版本。浏览器会选择最匹配的子 <code>&lt;source&gt;</code> 元素，如果没有匹配的，就选择 <code>&lt;img&gt;</code> 元素的 <code>src</code> 属性中的 URL。然后，所选图像呈现在 <code>&lt;img&gt;</code> 元素占据的空间中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--Change the browser window width to see the image change.--&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">picture</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">srcset</span>=<span class=\"string\">&quot;/media/cc0-images/surfer-240-200.jpg&quot;</span> <span class=\"attr\">media</span>=<span class=\"string\">&quot;(orientation: portrait)&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;/media/cc0-images/painted-hand-298-332.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>自带了一些属性：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/picture#%E5%B1%9E%E6%80%A7\">here</a></p>\n<h3 id=\"-14\"><a href=\"#-14\" class=\"headerlink\" title=\"&lt;progress&gt;\"></a><code>&lt;progress&gt;</code></h3><p>进度指示元素，用来做进度条。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;file&quot;</span>&gt;</span>File progress:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">progress</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;file&quot;</span> <span class=\"attr\">max</span>=<span class=\"string\">&quot;100&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;70&quot;</span>&gt;</span>70%<span class=\"tag\">&lt;/<span class=\"name\">progress</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HTML属性\"><a href=\"#HTML属性\" class=\"headerlink\" title=\"HTML属性\"></a>HTML属性</h2><h3 id=\"accesskey\"><a href=\"#accesskey\" class=\"headerlink\" title=\"accesskey\"></a><code>accesskey</code></h3><p>为当前元素提供一个快捷键，属性值为一个可打印字符。</p>\n<p>但这个属性问题比较多：与系统快捷键冲突、指意不明、意外激活……能不用还是别用，但还是要知道一下。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  If you need to relax, press the <span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">u</span>&gt;</span>S<span class=\"tag\">&lt;/<span class=\"name\">u</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span>tress reliever!</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">accesskey</span>=<span class=\"string\">&quot;s&quot;</span>&gt;</span>Stress reliever<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"autocomplete\"><a href=\"#autocomplete\" class=\"headerlink\" title=\"autocomplete\"></a><code>autocomplete</code></h3><p>允许 web 开发人员指定用户代理是否有权限在填写表单字段值时提供自动帮助，并指导浏览器填写该字段的预期信息类型。</p>\n<p>可选的属性值比较多，参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/autocomplete\">autocomplete</a>.<br>我常用的是 <code>off</code>, 即禁止用户代理提供历史可选值（因为我觉得这很影响页面美观性）。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;firstName&quot;</span>&gt;</span>First Name:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;firstName&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;firstName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">autocomplete</span>=<span class=\"string\">&quot;given-name&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;lastName&quot;</span>&gt;</span>Last Name:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;lastName&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;lastName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">autocomplete</span>=<span class=\"string\">&quot;family-name&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;email&quot;</span>&gt;</span>Email:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">autocomplete</span>=<span class=\"string\">&quot;off&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"autofocus\"><a href=\"#autofocus\" class=\"headerlink\" title=\"autofocus\"></a><code>autofocus</code></h3><p>上文中提到过，可以在页面加载时使当前元素自动获得用户焦点。</p>\n<h3 id=\"contenteditable\"><a href=\"#contenteditable\" class=\"headerlink\" title=\"contenteditable\"></a><code>contenteditable</code></h3><p>枚举属性，表示元素是否可被用户编辑，属性值为 <code>true</code> 或者 <code>false</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">blockquote</span> <span class=\"attr\">contenteditable</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Edit this content to add your own quote<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"inert\"><a href=\"#inert\" class=\"headerlink\" title=\"inert\"></a><code>inert</code></h3><p>一个有趣的布尔属性，可以使本身及其所有子元素的用户交互事件被浏览器忽略，包括鼠标、键盘、焦点等事件。可以适当精简代码，增强可读性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">inert</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://example.com&quot;</span>&gt;</span>Click<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"spellcheck\"><a href=\"#spellcheck\" class=\"headerlink\" title=\"spellcheck\"></a><code>spellcheck</code></h3><p>枚举属性，表示元素是否会对用户输入的值做拼写检查，属性值为 <code>true</code> 或 <code>false</code>.</p>\n<h3 id=\"translate\"><a href=\"#translate\" class=\"headerlink\" title=\"translate\"></a><code>translate</code></h3><p>枚举属性。规定制定元素是否需要翻译，属性值为 <code>yes</code> 或 <code>no</code>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">small</span>&gt;</span>© 2020 <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">translate</span>=<span class=\"string\">&quot;no&quot;</span>&gt;</span>BrandName<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">small</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元素顺序\"><a href=\"#元素顺序\" class=\"headerlink\" title=\"&lt;head&gt;元素顺序\"></a><code>&lt;head&gt;</code>元素顺序</h2><p>编写 HTML 的 <code>&lt;head&gt;</code> 元素时，元素建议遵循以下顺序，可以提高网页性能：</p>\n<ol>\n<li>preconnect</li>\n<li>script-async</li>\n<li>css-contains-@ import</li>\n<li>sync-js</li>\n<li>sync-css</li>\n<li>preload</li>\n<li>script-defer</li>\n<li>prefetch &#x2F; prerender</li>\n<li>seo-relative</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;zh&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- preconnect --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;preconnect&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://cdn.example.com&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- script-async --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.example.com/js/analytics.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- css-contains-@ import --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"keyword\">@import</span> url(<span class=\"string\">&#x27;https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-css\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- sync-js --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;js/main.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- sync-css --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;css/styles.css&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- preload --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;preload&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;img/background.jpg&quot;</span> <span class=\"attr\">as</span>=<span class=\"string\">&quot;image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- script-defer --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;js/interactive.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- prefetch / prerender --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;prefetch&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;about.html&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;prerender&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;contact.html&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- seo-relative --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;canonical&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/index.html&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Other SEO related tags --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>我的网站<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;description&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;这是我的网站的描述。&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 页面内容 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以使用 <code>capo.js</code> 工具，对 <code>&lt;head&gt;</code> 中的元素进行标注，快速识别和优化性能问题。GitHub 仓库地址：<a href=\"https://github.com/rviscomi/capo.js\">capo.js</a>.</p>\n<p>同时，官方还提供了对应的浏览器插件：<a href=\"https://chrome.google.com/webstore/detail/capo-get-your-%EF%B9%A4%F0%9D%9A%91%F0%9D%9A%8E%F0%9D%9A%8A%F0%9D%9A%8D%EF%B9%A5/ohabpnaccigjhkkebjofhpmebofgpbeb?utm_source=ext_sidebar&hl=zh-CN\">Capo: get your ﹤𝚑𝚎𝚊𝚍﹥ in order</a>,<br>这个插件可以直观地展示当前 Web 页面 <code>&lt;head&gt;</code> 中各元素加载用时的真实顺序以及排序后的顺序。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231006101948.png\" alt=\"插件使用演示\"></p>\n<h2 id=\"叨叨叨\"><a href=\"#叨叨叨\" class=\"headerlink\" title=\"叨叨叨\"></a>叨叨叨</h2><p>HTML 译为 <em>超文本标记语言</em>，与 Markdown 更相似而非 Golang 等编程语言。它的作用是定义网页内容的含义和结构。相比 CSS 和 JavaScript，我对 HTML 的重视程度一直不够，现在看来可以改变一下思想，HTML 其实才是一个网页的基石。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML\">HTML - MDN</a></li>\n<li><a href=\"https://weibo.com/1812166904/NbGRFCRtU\">新浪微博 - Barret李靖</a></li>\n</ul>\n","excerpt":"","more":"<p>阿菇最近倾向于用原生三件套做 Web 开发，想尽可能少地依赖三方库。</p>\n<p>或许没什么必要，因为封装好的东西用起来确实爽快。但造轮子确实也有造轮子的快乐。不可辩解的是，阿菇对前端项目中乱糟糟的配置文件以及 <code>node_modules</code> 感到厌烦，即使在开发过程中用了 <code>File Nesting Updater</code> 这样简化目录结构的插件。</p>\n<p>掌握一定 Web 开发基础后再回过头来学习，能发现之前没注意到的有趣知识，可以再做记录。</p>\n<p>以下内容有很多代码片段，光说没意思，自己 copy 后修修改改看看效果！<br>可以在这个在线平台实验：<a href=\"https://c.runoob.com/front-end/61/\">HTML&#x2F;CSS&#x2F;JS 在线工具</a></p>\n<h2 id=\"HTML-元素\"><a href=\"#HTML-元素\" class=\"headerlink\" title=\"HTML 元素\"></a>HTML 元素</h2><p>Web 前端开发者经常使用语义化元素：既能提高 HTML 的可读性，也能减少写 CSS 命名的烦恼，还有利于 SEO 优化，好处多多。</p>\n<p>当然也可以 <code>&lt;div&gt;</code> 一把嗦，方便的很（类比后端编写 API 时 <code>POST</code> 一把嗦）。<br>很多老网站都是这么做的，比如我们做网站备案时用的 <a href=\"https://www.beian.gov.cn/\">互联网网站安全管理服务平台</a>，清一色的 <code>&lt;div&gt;</code> 标签。</p>\n<p>除了常用的 <code>&lt;header&gt;</code>、<code>&lt;main&gt;</code> 等规划网页布局的元素，<code>&lt;em&gt;</code>、<code>&lt;br&gt;</code> 等用于规划文本布局的元素，还有一些有趣的语义化标签。<br>我觉得以后能用上，也打算去用，这里就做个记录。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"&lt;abbr&gt;\"></a><code>&lt;abbr&gt;</code></h3><p>文本缩写元素，同时提供了一个 <code>title</code> 属性值，可以实现鼠标 hover 时显示具体内容：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">abbr</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;HyperText Markup Language&quot;</span>&gt;</span>HTML<span class=\"tag\">&lt;/<span class=\"name\">abbr</span>&gt;</span> is fun!</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"&lt;address&gt;\"></a><code>&lt;address&gt;</code></h3><p>提供个人或组织的联系方式，仅表达了额外的语义信息。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">address</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;mailto:jim@rock.com&quot;</span>&gt;</span>jim@rock.com<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;tel:+13115552368&quot;</span>&gt;</span>(311) 555-2368<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">address</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-2\"><a href=\"#-2\" class=\"headerlink\" title=\"&lt;bdi&gt;\"></a><code>&lt;bdi&gt;</code></h3><p>双向文本隔离元素，<code>dir</code> 属性不继承父元素，即被该元素包裹的内容方向不受父元素的影响，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">dir</span>=<span class=\"string\">&quot;rtl&quot;</span>&gt;</span></span><br><span class=\"line\">  This arabic word <span class=\"tag\">&lt;<span class=\"name\">bdi</span>&gt;</span>ARABIC_PLACEHOLDER<span class=\"tag\">&lt;/<span class=\"name\">bdi</span>&gt;</span> is automatically displayed</span><br><span class=\"line\">  right-to-left.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-3\"><a href=\"#-3\" class=\"headerlink\" title=\"&lt;bdo&gt;\"></a><code>&lt;bdo&gt;</code></h3><p>双向文本替代元素，可以改写文本的方向，而不需要编写 CSS 样式。</p>\n<p>自带的 <code>dir</code> 属性有两个可选值：</p>\n<ul>\n<li><code>ltr</code> - 左到右</li>\n<li><code>rtl</code> - 右到左<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">bdo</span> <span class=\"attr\">dir</span>=<span class=\"string\">&quot;rtl&quot;</span>&gt;</span>This text will go right to left.<span class=\"tag\">&lt;/<span class=\"name\">bdo</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"-4\"><a href=\"#-4\" class=\"headerlink\" title=\"&lt;caption&gt;\"></a><code>&lt;caption&gt;</code></h3><p>HTML 表格标题元素，常作为 <code>&lt;table&gt;</code> 的第一个子元素出现。</p>\n<p>仅支持全局属性，要改变样式需要用 CSS 的 <code>caption-side</code> 或者 <code>text-align</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">caption</span>&gt;</span></span><br><span class=\"line\">    表格名称和值</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">caption</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;col&quot;</span>&gt;</span>名称<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;col&quot;</span>&gt;</span>HEX<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;col&quot;</span>&gt;</span>HSLa<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;col&quot;</span>&gt;</span>RGBa<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;row&quot;</span>&gt;</span>Teal<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>#51F6F6<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>hsla(180, 90%, 64%, 1)<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>rgba(81, 246, 246, 1)<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">scope</span>=<span class=\"string\">&quot;row&quot;</span>&gt;</span>Goldenrod<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>#F6BC57<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>hsla(38, 90%, 65%, 1)<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>rgba(246, 188, 87, 1)<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-5\"><a href=\"#-5\" class=\"headerlink\" title=\"&lt;cite&gt;\"></a><code>&lt;cite&gt;</code></h3><p>HTML 引用元素，表示一个作品的引用，且必须包含作品的标题。</p>\n<p>与之类似的有 <code>&lt;blackquote&gt;</code> 和 <code>&lt;q&gt;</code> 元素的 <code>cite</code> 属性，值一般为引用链接。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">figure</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">blockquote</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>It was a bright cold day in April, and the clocks were striking thirteen.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">blockquote</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">figcaption</span>&gt;</span></span><br><span class=\"line\">    First sentence in <span class=\"tag\">&lt;<span class=\"name\">cite</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://www.george-orwell.org/1984/0.html&quot;</span>&gt;</span>Nineteen Eighty-Four<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">cite</span>&gt;</span> by George</span><br><span class=\"line\">    Orwell (Part 1, Chapter 1).</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">figcaption</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-6\"><a href=\"#-6\" class=\"headerlink\" title=\"&lt;data&gt;\"></a><code>&lt;data&gt;</code></h3><p>将一个指定内容和机器可读的翻译联系在一起。但是，如果内容是与时间或者日期相关的，则一定要使用 <code>&lt;time&gt;</code>。</p>\n<p><code>value</code> 属性为标签内容所对应的数据。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;398&quot;</span>&gt;</span>迷你番茄酱<span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;399&quot;</span>&gt;</span>巨无霸番茄酱<span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;400&quot;</span>&gt;</span>超级巨无霸番茄酱<span class=\"tag\">&lt;/<span class=\"name\">data</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-7\"><a href=\"#-7\" class=\"headerlink\" title=\"&lt;datalist&gt;\"></a><code>&lt;datalist&gt;</code></h3><p>类似输入框，但使用 <code>&lt;option&gt;</code> 提供了一些默认可选项。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">datalist</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;ice-cream-flavors&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Chocolate&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Coconut&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Mint&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Strawberry&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;Vanilla&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-8\"><a href=\"#-8\" class=\"headerlink\" title=\"&lt;dfn&gt;\"></a><code>&lt;dfn&gt;</code></h3><p>HTML 定义元素，一般结合前文的 <code>&lt;addr&gt;</code> 使用。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dfn</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">abbr</span> <span class=\"attr\">title</span>=<span class=\"string\">&quot;World-Wide Web&quot;</span>&gt;</span>WWW<span class=\"tag\">&lt;/<span class=\"name\">abbr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dfn</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-9\"><a href=\"#-9\" class=\"headerlink\" title=\"&lt;dialog&gt;\"></a><code>&lt;dialog&gt;</code></h3><p>对话框元素，一般用于实现一个独立的交互式组件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Simple modal dialog containing a form --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dialog</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;favDialog&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;dialog&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">label</span></span></span><br><span class=\"line\"><span class=\"tag\">        &gt;</span>Favorite animal:</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;default&quot;</span>&gt;</span>Choose…<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>Brine shrimp<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>Red panda<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>Spider monkey<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;cancel&quot;</span>&gt;</span>Cancel<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;confirmBtn&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;default&quot;</span>&gt;</span>Confirm<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;updateDetails&quot;</span>&gt;</span>Update details<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">output</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">output</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>对应的 <code>JavaScript</code> 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> updateButton = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;updateDetails&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> favDialog = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;favDialog&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> outputBox = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;output&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> selectEl = favDialog.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;select&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> confirmBtn = favDialog.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;#confirmBtn&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// If a browser doesn&#x27;t support the dialog, then hide the</span></span><br><span class=\"line\"><span class=\"comment\">// dialog contents by default.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> favDialog.<span class=\"property\">showModal</span> !== <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">  favDialog.<span class=\"property\">hidden</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">/* a fallback script to allow this dialog/form to function</span></span><br><span class=\"line\"><span class=\"comment\">     for legacy browsers that do not support &lt;dialog&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     could be provided here.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;Update details&quot; button opens the &lt;dialog&gt; modally</span></span><br><span class=\"line\">updateButton.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;click&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> favDialog.<span class=\"property\">showModal</span> === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">    favDialog.<span class=\"title function_\">showModal</span>();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    outputBox.<span class=\"property\">value</span> =</span><br><span class=\"line\">      <span class=\"string\">&quot;Sorry, the &lt;dialog&gt; API is not supported by this browser.&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// &quot;Favorite animal&quot; input sets the value of the submit button</span></span><br><span class=\"line\">selectEl.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;change&quot;</span>, <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  confirmBtn.<span class=\"property\">value</span> = selectEl.<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// &quot;Confirm&quot; button of form triggers &quot;close&quot; on dialog because of [method=&quot;dialog&quot;]</span></span><br><span class=\"line\">favDialog.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;close&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  outputBox.<span class=\"property\">value</span> = <span class=\"string\">`<span class=\"subst\">$&#123;</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">    favDialog.returnValue</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">  &#125;</span> button clicked - <span class=\"subst\">$&#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().toString()&#125;</span>`</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用该元素时应当注意搭配 <code>autofocus</code> 属性，为用户在弹出的对话框中自动选择一个合适的焦点。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;q&quot;</span> <span class=\"attr\">autofocus</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"and\"><a href=\"#and\" class=\"headerlink\" title=\"&lt;details&gt; and &lt;summary&gt;\"></a><code>&lt;details&gt; and &lt;summary&gt;</code></h3><p>详细信息展开元素，很有用，二者搭配使用，灵活性远超下拉列表元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 默认展开 &lt;details open&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;summary&gt; 设置 list-style: none; 可以隐藏黑三角标志 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">details</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">summary</span>&gt;</span>Details<span class=\"tag\">&lt;/<span class=\"name\">summary</span>&gt;</span></span><br><span class=\"line\">  Something small enough to escape casual notice.</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">details</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但没有内置的方法和属性可以添加状态转换时的动画效果。</p>\n<h3 id=\"and-1\"><a href=\"#and-1\" class=\"headerlink\" title=\"&lt;fieldset&gt; and &lt;legend&gt;\"></a><code>&lt;fieldset&gt; and &lt;legend&gt;</code></h3><p>用于对表单中的控制元素进行分组（也包括 label 元素）。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span>Choose your favorite monster<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;kraken&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;monster&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;K&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;kraken&quot;</span>&gt;</span>Kraken<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sasquatch&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;monster&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;S&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;sasquatch&quot;</span>&gt;</span>Sasquatch<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;mothman&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;monster&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;M&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;mothman&quot;</span>&gt;</span>Mothman<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>死去的 tkinter 记忆开始攻击阿菇……</p>\n<p>可以设置 <code>disabled</code> 属性，这会使得其子组件无法使用，提交表单时也不会携带对应数据。</p>\n<h3 id=\"-10\"><a href=\"#-10\" class=\"headerlink\" title=\"&lt;hgroup&gt;\"></a><code>&lt;hgroup&gt;</code></h3><p>代表文档标题和与标题相关联的内容，它将一个 <code>&lt;h1&gt;</code>–<code>&lt;h6&gt;</code> 元素与一个或多个 <code>&lt;p&gt;</code> 元素组合在一起。实现主标题副标题会很方便。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hgroup</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Frankenstein<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Or: The Modern Prometheus<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">hgroup</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-11\"><a href=\"#-11\" class=\"headerlink\" title=\"&lt;kbd&gt;\"></a><code>&lt;kbd&gt;</code></h3><p>HTML 键盘输入元素用于表示用户输入，它将产生一个行内元素，以浏览器的默认 <code>monospace</code> 字体显示。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Save the document by pressing <span class=\"tag\">&lt;<span class=\"name\">kbd</span>&gt;</span>Ctrl<span class=\"tag\">&lt;/<span class=\"name\">kbd</span>&gt;</span> + <span class=\"tag\">&lt;<span class=\"name\">kbd</span>&gt;</span>S<span class=\"tag\">&lt;/<span class=\"name\">kbd</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"-12\"><a href=\"#-12\" class=\"headerlink\" title=\"&lt;meter&gt;\"></a><code>&lt;meter&gt;</code></h3><p>用来显示已知范围的标量值或者分数值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;fuel&quot;</span>&gt;</span>Fuel level:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meter</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;fuel&quot;</span> <span class=\"attr\">min</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">max</span>=<span class=\"string\">&quot;100&quot;</span> <span class=\"attr\">low</span>=<span class=\"string\">&quot;33&quot;</span> <span class=\"attr\">high</span>=<span class=\"string\">&quot;66&quot;</span> <span class=\"attr\">optimum</span>=<span class=\"string\">&quot;80&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;50&quot;</span>&gt;</span>at 50/100<span class=\"tag\">&lt;/<span class=\"name\">meter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>自带了很多属性：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meter#%E5%B1%9E%E6%80%A7\">here</a></p>\n<h3 id=\"-13\"><a href=\"#-13\" class=\"headerlink\" title=\"&lt;noscript&gt;\"></a><code>&lt;noscript&gt;</code></h3><p>如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在该元素中定义脚本未被执行时的替代内容。<code>XSS</code> 有时候会利用这个元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">noscript</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- anchor linking to external file --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;http://www.mozilla.com/&quot;</span>&gt;</span>External Link<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">noscript</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Rocks!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"and-2\"><a href=\"#and-2\" class=\"headerlink\" title=\"&lt;picture&gt; and &lt;source&gt;\"></a><code>&lt;picture&gt; and &lt;source&gt;</code></h3><p>通过包含零或多个 <code>&lt;source&gt;</code> 元素和一个 <code>&lt;img&gt;</code> 元素来为不同的显示&#x2F;设备场景提供图像版本。浏览器会选择最匹配的子 <code>&lt;source&gt;</code> 元素，如果没有匹配的，就选择 <code>&lt;img&gt;</code> 元素的 <code>src</code> 属性中的 URL。然后，所选图像呈现在 <code>&lt;img&gt;</code> 元素占据的空间中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--Change the browser window width to see the image change.--&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">picture</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">srcset</span>=<span class=\"string\">&quot;/media/cc0-images/surfer-240-200.jpg&quot;</span> <span class=\"attr\">media</span>=<span class=\"string\">&quot;(orientation: portrait)&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;/media/cc0-images/painted-hand-298-332.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>自带了一些属性：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/picture#%E5%B1%9E%E6%80%A7\">here</a></p>\n<h3 id=\"-14\"><a href=\"#-14\" class=\"headerlink\" title=\"&lt;progress&gt;\"></a><code>&lt;progress&gt;</code></h3><p>进度指示元素，用来做进度条。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;file&quot;</span>&gt;</span>File progress:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">progress</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;file&quot;</span> <span class=\"attr\">max</span>=<span class=\"string\">&quot;100&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;70&quot;</span>&gt;</span>70%<span class=\"tag\">&lt;/<span class=\"name\">progress</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HTML属性\"><a href=\"#HTML属性\" class=\"headerlink\" title=\"HTML属性\"></a>HTML属性</h2><h3 id=\"accesskey\"><a href=\"#accesskey\" class=\"headerlink\" title=\"accesskey\"></a><code>accesskey</code></h3><p>为当前元素提供一个快捷键，属性值为一个可打印字符。</p>\n<p>但这个属性问题比较多：与系统快捷键冲突、指意不明、意外激活……能不用还是别用，但还是要知道一下。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  If you need to relax, press the <span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">u</span>&gt;</span>S<span class=\"tag\">&lt;/<span class=\"name\">u</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span>tress reliever!</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">accesskey</span>=<span class=\"string\">&quot;s&quot;</span>&gt;</span>Stress reliever<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"autocomplete\"><a href=\"#autocomplete\" class=\"headerlink\" title=\"autocomplete\"></a><code>autocomplete</code></h3><p>允许 web 开发人员指定用户代理是否有权限在填写表单字段值时提供自动帮助，并指导浏览器填写该字段的预期信息类型。</p>\n<p>可选的属性值比较多，参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/autocomplete\">autocomplete</a>.<br>我常用的是 <code>off</code>, 即禁止用户代理提供历史可选值（因为我觉得这很影响页面美观性）。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;firstName&quot;</span>&gt;</span>First Name:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;firstName&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;firstName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">autocomplete</span>=<span class=\"string\">&quot;given-name&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;lastName&quot;</span>&gt;</span>Last Name:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;lastName&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;lastName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">autocomplete</span>=<span class=\"string\">&quot;family-name&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;email&quot;</span>&gt;</span>Email:<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">autocomplete</span>=<span class=\"string\">&quot;off&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"autofocus\"><a href=\"#autofocus\" class=\"headerlink\" title=\"autofocus\"></a><code>autofocus</code></h3><p>上文中提到过，可以在页面加载时使当前元素自动获得用户焦点。</p>\n<h3 id=\"contenteditable\"><a href=\"#contenteditable\" class=\"headerlink\" title=\"contenteditable\"></a><code>contenteditable</code></h3><p>枚举属性，表示元素是否可被用户编辑，属性值为 <code>true</code> 或者 <code>false</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">blockquote</span> <span class=\"attr\">contenteditable</span>=<span class=\"string\">&quot;true&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Edit this content to add your own quote<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"inert\"><a href=\"#inert\" class=\"headerlink\" title=\"inert\"></a><code>inert</code></h3><p>一个有趣的布尔属性，可以使本身及其所有子元素的用户交互事件被浏览器忽略，包括鼠标、键盘、焦点等事件。可以适当精简代码，增强可读性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">inert</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://example.com&quot;</span>&gt;</span>Click<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"spellcheck\"><a href=\"#spellcheck\" class=\"headerlink\" title=\"spellcheck\"></a><code>spellcheck</code></h3><p>枚举属性，表示元素是否会对用户输入的值做拼写检查，属性值为 <code>true</code> 或 <code>false</code>.</p>\n<h3 id=\"translate\"><a href=\"#translate\" class=\"headerlink\" title=\"translate\"></a><code>translate</code></h3><p>枚举属性。规定制定元素是否需要翻译，属性值为 <code>yes</code> 或 <code>no</code>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">small</span>&gt;</span>© 2020 <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">translate</span>=<span class=\"string\">&quot;no&quot;</span>&gt;</span>BrandName<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">small</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元素顺序\"><a href=\"#元素顺序\" class=\"headerlink\" title=\"&lt;head&gt;元素顺序\"></a><code>&lt;head&gt;</code>元素顺序</h2><p>编写 HTML 的 <code>&lt;head&gt;</code> 元素时，元素建议遵循以下顺序，可以提高网页性能：</p>\n<ol>\n<li>preconnect</li>\n<li>script-async</li>\n<li>css-contains-@ import</li>\n<li>sync-js</li>\n<li>sync-css</li>\n<li>preload</li>\n<li>script-defer</li>\n<li>prefetch &#x2F; prerender</li>\n<li>seo-relative</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;zh&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- preconnect --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;preconnect&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://cdn.example.com&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- script-async --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.example.com/js/analytics.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- css-contains-@ import --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"keyword\">@import</span> url(<span class=\"string\">&#x27;https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-css\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- sync-js --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;js/main.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- sync-css --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;stylesheet&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;css/styles.css&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- preload --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;preload&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;img/background.jpg&quot;</span> <span class=\"attr\">as</span>=<span class=\"string\">&quot;image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- script-defer --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;js/interactive.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- prefetch / prerender --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;prefetch&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;about.html&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;prerender&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;contact.html&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- seo-relative --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">&quot;canonical&quot;</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/index.html&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Other SEO related tags --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>我的网站<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;description&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;这是我的网站的描述。&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 页面内容 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以使用 <code>capo.js</code> 工具，对 <code>&lt;head&gt;</code> 中的元素进行标注，快速识别和优化性能问题。GitHub 仓库地址：<a href=\"https://github.com/rviscomi/capo.js\">capo.js</a>.</p>\n<p>同时，官方还提供了对应的浏览器插件：<a href=\"https://chrome.google.com/webstore/detail/capo-get-your-%EF%B9%A4%F0%9D%9A%91%F0%9D%9A%8E%F0%9D%9A%8A%F0%9D%9A%8D%EF%B9%A5/ohabpnaccigjhkkebjofhpmebofgpbeb?utm_source=ext_sidebar&hl=zh-CN\">Capo: get your ﹤𝚑𝚎𝚊𝚍﹥ in order</a>,<br>这个插件可以直观地展示当前 Web 页面 <code>&lt;head&gt;</code> 中各元素加载用时的真实顺序以及排序后的顺序。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231006101948.png\" alt=\"插件使用演示\"></p>\n<h2 id=\"叨叨叨\"><a href=\"#叨叨叨\" class=\"headerlink\" title=\"叨叨叨\"></a>叨叨叨</h2><p>HTML 译为 <em>超文本标记语言</em>，与 Markdown 更相似而非 Golang 等编程语言。它的作用是定义网页内容的含义和结构。相比 CSS 和 JavaScript，我对 HTML 的重视程度一直不够，现在看来可以改变一下思想，HTML 其实才是一个网页的基石。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML\">HTML - MDN</a></li>\n<li><a href=\"https://weibo.com/1812166904/NbGRFCRtU\">新浪微博 - Barret李靖</a></li>\n</ul>\n"},{"title":"JavaScript 混淆与反混淆","date":"2024-02-11T16:00:00.000Z","author":"ma5hr00m","_content":"\n## Obfuscation 混淆\n\nJavaScript 混淆（Obfuscation）是指通过一系列技术手段，使 JS 代码变得难以理解和分析，增加代码的复杂性和混淆度，阻碍逆向工程和代码盗用。实际上就是一种保护 JS 代码的手段。\n\n那为什么我们需要保护 JS 代码呢 🤔️\n\nJS 最早被设计出来就是为了在客户端运行，直接以源码的形式传递给客户端，如果不做处理则完全公开透明，任何人都可以读、分析、复制、盗用，甚至篡改源码与数据，这是网站开发者不愿意看到的。\n\n### 起源\n\n早期的 JS 代码承担功能少，逻辑简单且体积小，不需要保护。但随着技术的发展，JS 承担的功能越来越多， 文件体积增大。为了优化用户体验，开发者们想了很多办法去减小 JS 文件体积，以加快 HTTP 传输速度。JS 压缩（Minification）技术应运而生。\n\n常见的 JS 压缩手段很多，比如：\n\n- 删除 JS 代码中的空格、换行与注释；\n- 替换 JS 代码中的局部变量名；\n- 合并 JS 文件；\n- ……\n\n压缩工具开发的初衷是减小 JS 文件体积，但 JS 代码经过压缩替换后，其可读性也大大降低，间接起到了保护代码的作用。但是后来主流浏览器的开发者工具都提供了格式化代码的功能，压缩技术所能提供的安全保护收效甚微。于是专门保护 JS 代码的技术：JS 加密和 JS 混淆。\n\n> 本文不会介绍 JS 加密技术，只需要知道这两种技术相辅相成，不预先进行混淆的 JS 加密没有意义。\n\n### 常见混淆手段\n\n- 变量名/函数名的替换，通过将有意义的变量名和函数名替换为随机生成的名称。\n\n    ```JavaScript\n    /*\n    function calculateArea(radius) {\n      return Math.PI * radius * radius;\n    }\n    console.log(calculateArea(5));\n    */\n    function _0x2d8f05(_0x4b083b) {\n      return Math.PI * _0x4b083b * _0x4b083b;\n    }\n    console.log(_0x2d8f05(5));\n    ```\n\n- 字符串混淆，将代码中的字符串替换为编码或加密的形式，可以防止字符串被轻易读取。\n\n    ```JavaScript\n    // console.log(\"Hello, world!\");\n    console.log(\"\\x48\\x65\\x6c\\x6c\\x6f\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x21\");\n    ```\n\n- 控制流混淆，改变代码的执行顺序或结构。例如，可以使用条件语句和循环语句来替换简单的赋值操作。\n\n    ```JavaScript\n    /*\n    let a = 1;\n    let b = 2;\n    let c = a + b;\n    console.log(c);\n    */\n    let a = 1;\n    let b = 2;\n    let c;\n    if (a === 1) {\n      if (b === 2) {\n        c = a + b;\n      }\n    }\n    console.log(c);\n    ```\n\n- 死代码插入，即在源码插入一些不会被执行的代码。\n\n    ```JavaScript\n    /*\n    let a = 1;\n    let b = 2;\n    let c = a + b;\n    console.log(c);\n    */\n    let a = 1;\n    let b = 2;\n    if (false) {\n      console.log(a - b);\n    }\n    let c = a + b;\n    console.log(c);\n    ```\n\n- 代码转换，将代码转换为等价的，但更难理解的形式。\n\n    ```JavaScript\n    /*\n    let a = 1;\n    let b = 2;\n    let c = a + b;\n    console.log(c);\n    */\n    let a = 1;\n    let b = 2;\n    let c = a - (-b);\n    console.log(c);\n    ```\n\n### 常见反调试手段\n\n实现防止他人调试、动态分析自己的代码，我们可以预先在代码中做处理，防止用户调试代码。\n\n- 无限 debugger。比如写个定时器死循环禁止调试。\n\n    ```JavaScript\n    var c = new RegExp(\"1\");\n    c.toString = function () {\n        alert(\"检测到调试\")\n        setInterval(function() {\n            debugger\n        }, 1000);\n    }\n    console.log(c);\n    ```\n\n- 内存耗尽。更隐蔽的反调试手段，代码运行造成的内存占用会越来越大，很快会使浏览器崩溃。\n\n    ```JavaScript\n    var startTime = new Date();\n    debugger;\n    var endTime = new Date();\n    var isDev = endTime - startTime > 100;\n    var stack = [];\n    \n    if (isDev) {\n        while (true) {\n            stack.push(this);\n            console.log(stack.length, this);\n        }\n    }\n    ```\n\n- 检测函数、对象属性修改。攻击者在调试的时，经常会把防护的函数删除，或者把检测数据对象进行篡改。可以检测函数内容，在原型上设置禁止修改。\n\n    ```JavaScript\n    function eval() {\n        [native code]\n    }\n    \n    window.eval = function(str) {\n        console.log(\"[native code]\");\n    };\n    \n    window.eval = function(str) {\n    };\n    \n    window.eval.toString = function() {\n        return `function eval() {[native code]}`\n    };\n    \n    function hijacked(fun) {\n        return \"prototype\" in fun || fun.toString().replace(/\\n|\\s/g, \"\") != \"function\" + fun.name + \"() {[nativecode]}\";\n    }\n    ```\n\n### 前端开发中的混淆\n\n在 Web 前端开发中，开发者会对代码进行压缩和混淆，对代码进行优化，并提高安全性。已经有很多成熟的工具可以使用，比如 [UglifyJS](https://github.com/mishoo/UglifyJS) 和 [JavaScript Obfuscator](https://github.com/javascript-obfuscator/javascript-obfuscator)。\n\n混淆通常在项目的构建过程中进行。例如，我们使用 Vite 作为模块打包工具，就可以在 vite 的配置文件中添加UglifyJS 插件。这样，在每次构建项目时，UglifyJS就会自动对你的代码进行混淆。\n\n先安装插件。\n\n```Bash\nnpm install vite-plugin-uglify --save-dev\n```\n\n然后在配置文件中添加该插件。\n\n```JavaScript\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport VitePluginUglify from 'vite-plugin-uglify'\n\nexport default defineConfig({\n  plugins: [\n    vue(),\n    VitePluginUglify()\n  ]\n})\n```\n\n在这个配置文件中，`VitePluginUglify`被添加到了`plugins`数组中，所以在构建过程中，Vite 会自动使用`vite-plugin-uglify`对代码进行混淆。\n\n### 在线混淆工具\n\n有些站点提供了在线混淆的功能，比如 [Free JavaScript Obfuscator](https://javascriptobfuscator.dev/)，提供 JS 代码即可得到混淆后的结果。这个站点的混淆基于上面提到的 [JavaScript Obfuscator](https://github.com/javascript-obfuscator/javascript-obfuscator) 实现。\n\n```JavaScript\nfunction fibonacci(n) {\n  let fib = [0, 1];\n  for (let i = 2; i <= n; i++) {\n    fib[i] = fib[i - 1] + fib[i - 2];\n  }\n  return fib;\n}\n\n// the first 10 numbers in the Fibonacci sequence\nconsole.log(fibonacci(10));\n```\n\n以上代码的作用是计算斐波那契数列的前 10 个值并打印出来，经过混淆可得以下内容，可读性肉眼可见的降低：\n\n```JavaScript\nconst _0x323128=_0x5512;(function(_0x589643,_0x5459af){const _0x1b79b8=_0x5512,_0x3e96ed=_0x589643();while(!![]){try{const _0x1fb1b3=-parseInt(_0x1b79b8(0x1f1))/0x1*(-parseInt(_0x1b79b8(0x1ea))/0x2)+-parseInt(_0x1b79b8(0x1ec))/0x3*(parseInt(_0x1b79b8(0x1f3))/0x4)+-parseInt(_0x1b79b8(0x1ed))/0x5*(parseInt(_0x1b79b8(0x1f2))/0x6)+-parseInt(_0x1b79b8(0x1e8))/0x7+parseInt(_0x1b79b8(0x1e9))/0x8*(-parseInt(_0x1b79b8(0x1f4))/0x9)+parseInt(_0x1b79b8(0x1f0))/0xa+-parseInt(_0x1b79b8(0x1ef))/0xb*(-parseInt(_0x1b79b8(0x1ee))/0xc);if(_0x1fb1b3===_0x5459af)break;else _0x3e96ed['push'](_0x3e96ed['shift']());}catch(_0x56184c){_0x3e96ed['push'](_0x3e96ed['shift']());}}}(_0x138e,0xdf35a));function _0x138e(){const _0x3a0863=['354072hRaVAZ','9mNckCh','1622341lDdscp','2787864kenYBK','546362IExhCV','log','3fofuVm','1946005vlrFyq','516IsqKpc','725241tPbpzZ','316200mzqtLe','1mgkmrs','24Zwposp'];_0x138e=function(){return _0x3a0863;};return _0x138e();}function fibonacci(_0x1b3125){let _0x9e88df=[0x0,0x1];for(let _0x406b50=0x2;_0x406b50<=_0x1b3125;_0x406b50++){_0x9e88df[_0x406b50]=_0x9e88df[_0x406b50-0x1]+_0x9e88df[_0x406b50-0x2];}return _0x9e88df;}function _0x5512(_0x2d5465,_0x1d0a2f){const _0x138ec4=_0x138e();return _0x5512=function(_0x5512ef,_0x5e1f2e){_0x5512ef=_0x5512ef-0x1e8;let _0x4be64a=_0x138ec4[_0x5512ef];return _0x4be64a;},_0x5512(_0x2d5465,_0x1d0a2f);}console[_0x323128(0x1eb)](fibonacci(0xa));\n```\n\n## Deobfuscator 反混淆\n\nJS 反混淆（Deobfuscator ）是指对经过混淆处理的代码进行还原和解析，以恢复其可读性。Deobfuscator 可以通过对代码进行静态分析和动态分析等方式来实现。需要注意的是，Obfuscation 只能降低可读性，不能完全避免逆向攻击，而 Deobfuscator 也并不能完全还原混淆过的代码。\n\n只要耐心分析，多数混淆过的 JS 已然能还原出来。\n\n### 在线反混淆工具\n\n反混淆要有些趁手的工具。最常用的是浏览器自带的开发者工具，其次是一些转换混淆过的代码的工具。以下网站提供在线反混淆 JS 代码的功能：\n\n- [javascript-deobfuscator](https://seosniffer.com/javascript-deobfuscator)\n- [Raz1ner JavaScript Deobfuscator](https://dev-coco.github.io/Online-Tools/JavaScript-Deobfuscator.html)\n- [synchrony deobuscator](https://deobfuscate.relative.im/)\n- [js-beauty](https://beautifier.io/)\n\n以我们经过混淆的代码为例，丢进上述第一个网站，可以得到以下反混淆过的代码：\n\n```JavaScript\nfunction fibonacci(jayandre) {\n  let ramonita = [0, 1];\n  for (let ancel = 2; ancel <= jayandre; ancel++) {\n    ramonita[ancel] = ramonita[ancel - 1] + ramonita[ancel - 2];\n  }\n  return ramonita;\n}\nconsole.log(fibonacci(10));\n```\n\n原本的逻辑已经较为清晰的展现了。当然也有一些库能用来反混淆本地 JS 文件，这里不多做介绍，感觉在线工具就够用了。\n\n### 开发者工具\n\n上面的反混淆站点只是辅助，真反混淆还得靠浏览器自带的开发者工具。接下来以chrome浏览器为例讲讲怎么用。\n\n在反混淆过程中，我们主要使用源代码（Source）和网络（Network）这两个模块。Network 用于查找我们进行用户操作时调用了哪些 API，在调用 API 前后运行了哪些 JS 文件；Source 提供了网站整体的 JS 代码及静态资源，我们的反混淆分析工作主要就在这里进行。\n\n在 Source 模块中，默认`ctrl+shift+p`可以开启开发者工具的命令行，我们可以找到两个“搜索”工具，分别对应“全局搜索”和“在当前文件中搜索”，很适合查找指定字段。\n\n![20240222095405](https://img.ma5hr00m.top/blog/20240222095405.png)\n\n开发者工具提供了替换（Override）功能，开启本地替换选项，上传自己的目录，然后选中浏览器中指定 JS 文件，做出修改后`ctrl+s`保存，即可将源文件保存到我们自己的目录中，之后对文件做出的修改可以直接替换对应的原文件，这样就能方便的修改浏览器端 JS 文件。\n\n![20240222095414](https://img.ma5hr00m.top/blog/20240222095414.png)\n\n剩下的就是动调了，后面会举例子解释。\n\n### 静/动态调试\n\n先做个区分，逆网页的 JS 代码更多得是在开发者工具中做动调的。\n\n- 静态调试：静态调试是通过分析代码的结构和逻辑来理解其功能。这种方法不需要运行代码，只需要对代码进行分析和理解。例如，可以通过反汇编工具将二进制的可执行文件翻译成汇编代码，通过对代码的分析来破解软件。\n- 动态调试：动态调试则是在代码运行时进行的。通过设置断点，单步执行，观察变量的值变化等方式，来理解代码的运行过程和逻辑。动态调试可以有效应对多数混淆措施，从中还原出运行逻辑，是逆向分析的关键手段。前面说的反调试便是阻拦动态调试。\n\n## 实战\n\n### 百度翻译接口\n\n未登录状态下翻译字符串，观察 Network 可以找到`/v2transapi` POST 请求报文，其 payload 中表单的 `query`字段即为我们输入待翻译的字符串。\n\n![20240222095423](https://img.ma5hr00m.top/blog/20240222095423.png)\n\n刷新页面多次翻译，发现只有`sign`字段的值在随`query`一直变化，`transtype`的值会根据触发翻译的方式在`realtime`和`enter`之间切换，其它字段值保持不变。我们接下来的任务就是分析`sign`字段的值是怎么来的。\n\n为了搞清楚`sign`是如何生成的，我们需要在 Sources 模块中全局搜索`sign`字段。但因为`sign`本身是一个常见的字段，我们很容易定位到其他与表单无关的地方。这里有一个小技巧，为了获得参数相关代码，我们可以搜索`sign:`或者`sign=`，以尽量避免定位到无关代码。\n\n在 Sources 模块中全局搜索`sign:`，定位到很多文件，根据文件名和文件内容，可以判断最有可能在 index.36217dc5.js 文件中，而该文件中出现了 6 处`sign:`相关代码，依次打断点并执行翻译操作，发现只会在 25800 行处的`sign: b(e);`处停下：\n\n![20240222095432](https://img.ma5hr00m.top/blog/20240222095432.png)\n\n单步步进，可以发现参数 t 值即为传入的字符串：\n\n![20240222095443](https://img.ma5hr00m.top/blog/20240222095443.png)\n\n把这段函数抽离出来，写到一个 main.js 文件中，调用该函数并运行：\n\n```JavaScript\nb = function(t) {\n  var o, i = t.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g);\n  if (null === i) {\n    var a = t.length;\n    a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(Math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n  } else {\n    for (var s = t.split(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/), c = 0, u = s.length, l = []; c < u; c++)\n      \"\" !== s[c] && l.push.apply(l, function(t) {\n        if (Array.isArray(t))\n          return e(t)\n      }(o = s[c].split(\"\")) || function(t) {\n        if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"])\n          return Array.from(t)\n      }(o) || function(t, n) {\n        if (t) {\n          if (\"string\" == typeof t)\n            return e(t, n);\n          var r = Object.prototype.toString.call(t).slice(8, -1);\n          return \"Object\" === r && t.constructor && (r = t.constructor.name),\n          \"Map\" === r || \"Set\" === r ? Array.from(t) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0\n        }\n      }(o) || function() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\n      }()),\n      c !== u - 1 && l.push(i[c]);\n    var p = l.length;\n    p > 30 && (t = l.slice(0, 10).join(\"\") + l.slice(Math.floor(p / 2) - 5, Math.floor(p / 2) + 5).join(\"\") + l.slice(-10).join(\"\"))\n  }\n  for (var d = \"\".concat(String.fromCharCode(103)).concat(String.fromCharCode(116)).concat(String.fromCharCode(107)), h = (null !== r ? r : (r = window[d] || \"\") || \"\").split(\".\"), f = Number(h[0]) || 0, m = Number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n    var _ = t.charCodeAt(v);\n    _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charCodeAt(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charCodeAt(++v)),\n    g[y++] = _ >> 18 | 240,\n    g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n    g[y++] = _ >> 6 & 63 | 128),\n    g[y++] = 63 & _ | 128)\n  }\n  for (var b = f, w = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(97)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(54)), k = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(51)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(98)) + \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(102)), x = 0; x < g.length; x++)\n    b = n(b += g[x], w);\n  return b = n(b, k),\n  (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n  \"\".concat((b %= 1e6).toString(), \".\").concat(b ^ f)\n}\n\nconst query = \"abandon\";\nconsole.log(b(query))\n```\n\n运行时报错，提示`r`未定义。在继续动调去找`r`是什么。步进调试到这一步时，发现`r`被赋值为`window[d]`，即 \"320305.131321201\"，在此之前其值一直为null。\n\n![20240222095453](https://img.ma5hr00m.top/blog/20240222095453.png)\n\n我们可以发现`d`的值为`gtk`。我们本地是通过 Node.js 运行 JS 脚本，没有`window[]`这种 Web API，所以直接将`320305.131321201`硬编码进去。在此运行脚本，又会提示缺少`n`函数：\n\n![20240222095459](https://img.ma5hr00m.top/blog/20240222095459.png)\n\n我们在面板中找到`n`函数，光标悬浮于上方可直接跳转到函数声明的地方：\n\n![20240222095511](https://img.ma5hr00m.top/blog/20240222095511.png)\n\n找到`n`函数后将其添加到 JS 脚本中，再次运行，即可得到结果`103339.356506`，这与我们在 Network 模块中查看到的`sign`值相同。\n\n最终脚本如下，输入`query`的值即可得到请求`/v2transapi`所需的 payload：\n\n```JavaScript\n/**\n * function to generate sign\n */\nn = function (t, e) {\n  for (var n = 0; n < e.length - 2; n += 3) {\n      var r = e.charAt(n + 2);\n      r = \"a\" <= r ? r.charCodeAt(0) - 87 : Number(r),\n      r = \"+\" === e.charAt(n + 1) ? t >>> r : t << r,\n      t = \"+\" === e.charAt(n) ? t + r & 4294967295 : t ^ r\n  }\n  return t\n}\n\nb = function(t) {\n  var o, i = t.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g);\n  if (null === i) {\n    var a = t.length;\n    a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(Math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n  } else {\n    for (var s = t.split(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/), c = 0, u = s.length, l = []; c < u; c++)\n      \"\" !== s[c] && l.push.apply(l, function(t) {\n        if (Array.isArray(t))\n          return e(t)\n      }(o = s[c].split(\"\")) || function(t) {\n        if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"])\n          return Array.from(t)\n      }(o) || function(t, n) {\n        if (t) {\n          if (\"string\" == typeof t)\n            return e(t, n);\n          var r = Object.prototype.toString.call(t).slice(8, -1);\n          return \"Object\" === r && t.constructor && (r = t.constructor.name),\n          \"Map\" === r || \"Set\" === r ? Array.from(t) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0\n        }\n      }(o) || function() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\n      }()),\n      c !== u - 1 && l.push(i[c]);\n    var p = l.length;\n    p > 30 && (t = l.slice(0, 10).join(\"\") + l.slice(Math.floor(p / 2) - 5, Math.floor(p / 2) + 5).join(\"\") + l.slice(-10).join(\"\"))\n  }\n  for (var d = \"\".concat(String.fromCharCode(103)).concat(String.fromCharCode(116)).concat(String.fromCharCode(107)), h = (r = \"320305.131321201\").split(\".\"), f = Number(h[0]) || 0, m = Number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n    var _ = t.charCodeAt(v);\n    _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charCodeAt(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charCodeAt(++v)),\n    g[y++] = _ >> 18 | 240,\n    g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n    g[y++] = _ >> 6 & 63 | 128),\n    g[y++] = 63 & _ | 128)\n  }\n  for (var b = f, w = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(97)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(54)), k = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(51)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(98)) + \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(102)), x = 0; x < g.length; x++)\n    b = n(b += g[x], w);\n  return b = n(b, k),\n  (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n  \"\".concat((b %= 1e6).toString(), \".\").concat(b ^ f)\n}\n\n/**\n * test\n */\nconst query = \"abandon\";\nconsole.log(`from=en&to=zh&query=${query}&simple_means_flag=3&sign=${b(query)}&token=14025658070b41f40739347cef0ec62a&domain=common&ts=1708512893507`)\n```\n\n### 掘金登录接口\n\n登录时抓包，可以得到对`/passport/web/user/login`接口的请求报文：\n\n```\n# GET 查询字符串参数\naid: 2608\naccount_sdk_source: web\nsdk_version: 2.2.6\nverifyFp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79\nfp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79\nsign: d9116c9cae3fcdf848f1288e1850eb2a489a4e23ece930692912a8bc155d89ec\nqs: 6466666a706b715a76616e5a766a7077666029646c612963752976616e5a736077766c6a6b297360776c637c4375\n\n# POST 表单参数\nmix_mode: 1\naccount: 34363d3336373d3d343c3c\npassword: 343736343736343736\nfixed_mix_mode: 1\n```\n\n流程其实大差不差，就是搜参数、打断点、慢慢动调，基本都能找出来。掘金登录只需要 POST 表单参数正确即可，GET 参数不对也能过。以上参数中，会动态变化的只有`sign`、`account`和`password`，其中 GET 参数`sign`即使删掉也能过登录验证。\n\n具体过程不再贴图展示，这里直接提供获取 POST 表单参数的脚本，感兴趣的可以尝试去逆一下`sign`是如何生成的，难度比逆`account`和`password`要高一些：\n\n```JavaScript\n/**\n * raw data\n */\nconst account = '00000000000'\nconst password = '1q2w3e'\n\n/**\n * handle account and password\n */\nvar T = function(e) {\n  var t, n = [];\n  if (void 0 === e)\n    return \"\";\n  t = function(e) {\n    for (var t, n = e.toString(), r = [], a = 0; a < n.length; a++)\n      0 <= (t = n.charCodeAt(a)) && t <= 127 ? r.push(t) : 128 <= t && t <= 2047 ? (r.push(192 | 31 & t >> 6),\n      r.push(128 | 63 & t)) : (2048 <= t && t <= 55295 || 57344 <= t && t <= 65535) && (r.push(224 | 15 & t >> 12),\n      r.push(128 | 63 & t >> 6),\n      r.push(128 | 63 & t));\n    for (var i = 0; i < r.length; i++)\n      r[i] &= 255;\n    return r\n  }(e);\n  for (var r = 0, a = t.length; r < a; ++r)\n    n.push((5 ^ t[r]).toString(16));\n  return n.join(\"\")\n}\n\n/**\n * obtain the post form\n */\nconst postForm = `mix_mode=1&account=${T(account)}&password=${T(password)}&fixed_mix_mode=1`\nconsole.log(postForm)\n```\n\n### HGAME2024 2048*16\n\nBaiMeow 师傅的题，HGAME2024 Week1 结束后不方便提供复现环境。题目考察了禁用 F12、反调试、JS 反混淆，比较全面。这里提一嘴。\n\n## 参阅文章\n\n- [Javascript加密混淆](https://lizh.gitbook.io/knowledge/research/javascript-jia-mi-hun-xiao#hun-xiao-cha-jian)，by 前端知识库\n- [js混淆与反混淆](https://ek1ng.com/jsobuscation.html)，by ek1ng","source":"_posts/js-obfuscation-deobfuscation.md","raw":"---\ntitle: JavaScript 混淆与反混淆\ndate: 2024/2/12\nauthor: ma5hr00m\ncategories:\n- JavaScript\n---\n\n## Obfuscation 混淆\n\nJavaScript 混淆（Obfuscation）是指通过一系列技术手段，使 JS 代码变得难以理解和分析，增加代码的复杂性和混淆度，阻碍逆向工程和代码盗用。实际上就是一种保护 JS 代码的手段。\n\n那为什么我们需要保护 JS 代码呢 🤔️\n\nJS 最早被设计出来就是为了在客户端运行，直接以源码的形式传递给客户端，如果不做处理则完全公开透明，任何人都可以读、分析、复制、盗用，甚至篡改源码与数据，这是网站开发者不愿意看到的。\n\n### 起源\n\n早期的 JS 代码承担功能少，逻辑简单且体积小，不需要保护。但随着技术的发展，JS 承担的功能越来越多， 文件体积增大。为了优化用户体验，开发者们想了很多办法去减小 JS 文件体积，以加快 HTTP 传输速度。JS 压缩（Minification）技术应运而生。\n\n常见的 JS 压缩手段很多，比如：\n\n- 删除 JS 代码中的空格、换行与注释；\n- 替换 JS 代码中的局部变量名；\n- 合并 JS 文件；\n- ……\n\n压缩工具开发的初衷是减小 JS 文件体积，但 JS 代码经过压缩替换后，其可读性也大大降低，间接起到了保护代码的作用。但是后来主流浏览器的开发者工具都提供了格式化代码的功能，压缩技术所能提供的安全保护收效甚微。于是专门保护 JS 代码的技术：JS 加密和 JS 混淆。\n\n> 本文不会介绍 JS 加密技术，只需要知道这两种技术相辅相成，不预先进行混淆的 JS 加密没有意义。\n\n### 常见混淆手段\n\n- 变量名/函数名的替换，通过将有意义的变量名和函数名替换为随机生成的名称。\n\n    ```JavaScript\n    /*\n    function calculateArea(radius) {\n      return Math.PI * radius * radius;\n    }\n    console.log(calculateArea(5));\n    */\n    function _0x2d8f05(_0x4b083b) {\n      return Math.PI * _0x4b083b * _0x4b083b;\n    }\n    console.log(_0x2d8f05(5));\n    ```\n\n- 字符串混淆，将代码中的字符串替换为编码或加密的形式，可以防止字符串被轻易读取。\n\n    ```JavaScript\n    // console.log(\"Hello, world!\");\n    console.log(\"\\x48\\x65\\x6c\\x6c\\x6f\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x21\");\n    ```\n\n- 控制流混淆，改变代码的执行顺序或结构。例如，可以使用条件语句和循环语句来替换简单的赋值操作。\n\n    ```JavaScript\n    /*\n    let a = 1;\n    let b = 2;\n    let c = a + b;\n    console.log(c);\n    */\n    let a = 1;\n    let b = 2;\n    let c;\n    if (a === 1) {\n      if (b === 2) {\n        c = a + b;\n      }\n    }\n    console.log(c);\n    ```\n\n- 死代码插入，即在源码插入一些不会被执行的代码。\n\n    ```JavaScript\n    /*\n    let a = 1;\n    let b = 2;\n    let c = a + b;\n    console.log(c);\n    */\n    let a = 1;\n    let b = 2;\n    if (false) {\n      console.log(a - b);\n    }\n    let c = a + b;\n    console.log(c);\n    ```\n\n- 代码转换，将代码转换为等价的，但更难理解的形式。\n\n    ```JavaScript\n    /*\n    let a = 1;\n    let b = 2;\n    let c = a + b;\n    console.log(c);\n    */\n    let a = 1;\n    let b = 2;\n    let c = a - (-b);\n    console.log(c);\n    ```\n\n### 常见反调试手段\n\n实现防止他人调试、动态分析自己的代码，我们可以预先在代码中做处理，防止用户调试代码。\n\n- 无限 debugger。比如写个定时器死循环禁止调试。\n\n    ```JavaScript\n    var c = new RegExp(\"1\");\n    c.toString = function () {\n        alert(\"检测到调试\")\n        setInterval(function() {\n            debugger\n        }, 1000);\n    }\n    console.log(c);\n    ```\n\n- 内存耗尽。更隐蔽的反调试手段，代码运行造成的内存占用会越来越大，很快会使浏览器崩溃。\n\n    ```JavaScript\n    var startTime = new Date();\n    debugger;\n    var endTime = new Date();\n    var isDev = endTime - startTime > 100;\n    var stack = [];\n    \n    if (isDev) {\n        while (true) {\n            stack.push(this);\n            console.log(stack.length, this);\n        }\n    }\n    ```\n\n- 检测函数、对象属性修改。攻击者在调试的时，经常会把防护的函数删除，或者把检测数据对象进行篡改。可以检测函数内容，在原型上设置禁止修改。\n\n    ```JavaScript\n    function eval() {\n        [native code]\n    }\n    \n    window.eval = function(str) {\n        console.log(\"[native code]\");\n    };\n    \n    window.eval = function(str) {\n    };\n    \n    window.eval.toString = function() {\n        return `function eval() {[native code]}`\n    };\n    \n    function hijacked(fun) {\n        return \"prototype\" in fun || fun.toString().replace(/\\n|\\s/g, \"\") != \"function\" + fun.name + \"() {[nativecode]}\";\n    }\n    ```\n\n### 前端开发中的混淆\n\n在 Web 前端开发中，开发者会对代码进行压缩和混淆，对代码进行优化，并提高安全性。已经有很多成熟的工具可以使用，比如 [UglifyJS](https://github.com/mishoo/UglifyJS) 和 [JavaScript Obfuscator](https://github.com/javascript-obfuscator/javascript-obfuscator)。\n\n混淆通常在项目的构建过程中进行。例如，我们使用 Vite 作为模块打包工具，就可以在 vite 的配置文件中添加UglifyJS 插件。这样，在每次构建项目时，UglifyJS就会自动对你的代码进行混淆。\n\n先安装插件。\n\n```Bash\nnpm install vite-plugin-uglify --save-dev\n```\n\n然后在配置文件中添加该插件。\n\n```JavaScript\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport VitePluginUglify from 'vite-plugin-uglify'\n\nexport default defineConfig({\n  plugins: [\n    vue(),\n    VitePluginUglify()\n  ]\n})\n```\n\n在这个配置文件中，`VitePluginUglify`被添加到了`plugins`数组中，所以在构建过程中，Vite 会自动使用`vite-plugin-uglify`对代码进行混淆。\n\n### 在线混淆工具\n\n有些站点提供了在线混淆的功能，比如 [Free JavaScript Obfuscator](https://javascriptobfuscator.dev/)，提供 JS 代码即可得到混淆后的结果。这个站点的混淆基于上面提到的 [JavaScript Obfuscator](https://github.com/javascript-obfuscator/javascript-obfuscator) 实现。\n\n```JavaScript\nfunction fibonacci(n) {\n  let fib = [0, 1];\n  for (let i = 2; i <= n; i++) {\n    fib[i] = fib[i - 1] + fib[i - 2];\n  }\n  return fib;\n}\n\n// the first 10 numbers in the Fibonacci sequence\nconsole.log(fibonacci(10));\n```\n\n以上代码的作用是计算斐波那契数列的前 10 个值并打印出来，经过混淆可得以下内容，可读性肉眼可见的降低：\n\n```JavaScript\nconst _0x323128=_0x5512;(function(_0x589643,_0x5459af){const _0x1b79b8=_0x5512,_0x3e96ed=_0x589643();while(!![]){try{const _0x1fb1b3=-parseInt(_0x1b79b8(0x1f1))/0x1*(-parseInt(_0x1b79b8(0x1ea))/0x2)+-parseInt(_0x1b79b8(0x1ec))/0x3*(parseInt(_0x1b79b8(0x1f3))/0x4)+-parseInt(_0x1b79b8(0x1ed))/0x5*(parseInt(_0x1b79b8(0x1f2))/0x6)+-parseInt(_0x1b79b8(0x1e8))/0x7+parseInt(_0x1b79b8(0x1e9))/0x8*(-parseInt(_0x1b79b8(0x1f4))/0x9)+parseInt(_0x1b79b8(0x1f0))/0xa+-parseInt(_0x1b79b8(0x1ef))/0xb*(-parseInt(_0x1b79b8(0x1ee))/0xc);if(_0x1fb1b3===_0x5459af)break;else _0x3e96ed['push'](_0x3e96ed['shift']());}catch(_0x56184c){_0x3e96ed['push'](_0x3e96ed['shift']());}}}(_0x138e,0xdf35a));function _0x138e(){const _0x3a0863=['354072hRaVAZ','9mNckCh','1622341lDdscp','2787864kenYBK','546362IExhCV','log','3fofuVm','1946005vlrFyq','516IsqKpc','725241tPbpzZ','316200mzqtLe','1mgkmrs','24Zwposp'];_0x138e=function(){return _0x3a0863;};return _0x138e();}function fibonacci(_0x1b3125){let _0x9e88df=[0x0,0x1];for(let _0x406b50=0x2;_0x406b50<=_0x1b3125;_0x406b50++){_0x9e88df[_0x406b50]=_0x9e88df[_0x406b50-0x1]+_0x9e88df[_0x406b50-0x2];}return _0x9e88df;}function _0x5512(_0x2d5465,_0x1d0a2f){const _0x138ec4=_0x138e();return _0x5512=function(_0x5512ef,_0x5e1f2e){_0x5512ef=_0x5512ef-0x1e8;let _0x4be64a=_0x138ec4[_0x5512ef];return _0x4be64a;},_0x5512(_0x2d5465,_0x1d0a2f);}console[_0x323128(0x1eb)](fibonacci(0xa));\n```\n\n## Deobfuscator 反混淆\n\nJS 反混淆（Deobfuscator ）是指对经过混淆处理的代码进行还原和解析，以恢复其可读性。Deobfuscator 可以通过对代码进行静态分析和动态分析等方式来实现。需要注意的是，Obfuscation 只能降低可读性，不能完全避免逆向攻击，而 Deobfuscator 也并不能完全还原混淆过的代码。\n\n只要耐心分析，多数混淆过的 JS 已然能还原出来。\n\n### 在线反混淆工具\n\n反混淆要有些趁手的工具。最常用的是浏览器自带的开发者工具，其次是一些转换混淆过的代码的工具。以下网站提供在线反混淆 JS 代码的功能：\n\n- [javascript-deobfuscator](https://seosniffer.com/javascript-deobfuscator)\n- [Raz1ner JavaScript Deobfuscator](https://dev-coco.github.io/Online-Tools/JavaScript-Deobfuscator.html)\n- [synchrony deobuscator](https://deobfuscate.relative.im/)\n- [js-beauty](https://beautifier.io/)\n\n以我们经过混淆的代码为例，丢进上述第一个网站，可以得到以下反混淆过的代码：\n\n```JavaScript\nfunction fibonacci(jayandre) {\n  let ramonita = [0, 1];\n  for (let ancel = 2; ancel <= jayandre; ancel++) {\n    ramonita[ancel] = ramonita[ancel - 1] + ramonita[ancel - 2];\n  }\n  return ramonita;\n}\nconsole.log(fibonacci(10));\n```\n\n原本的逻辑已经较为清晰的展现了。当然也有一些库能用来反混淆本地 JS 文件，这里不多做介绍，感觉在线工具就够用了。\n\n### 开发者工具\n\n上面的反混淆站点只是辅助，真反混淆还得靠浏览器自带的开发者工具。接下来以chrome浏览器为例讲讲怎么用。\n\n在反混淆过程中，我们主要使用源代码（Source）和网络（Network）这两个模块。Network 用于查找我们进行用户操作时调用了哪些 API，在调用 API 前后运行了哪些 JS 文件；Source 提供了网站整体的 JS 代码及静态资源，我们的反混淆分析工作主要就在这里进行。\n\n在 Source 模块中，默认`ctrl+shift+p`可以开启开发者工具的命令行，我们可以找到两个“搜索”工具，分别对应“全局搜索”和“在当前文件中搜索”，很适合查找指定字段。\n\n![20240222095405](https://img.ma5hr00m.top/blog/20240222095405.png)\n\n开发者工具提供了替换（Override）功能，开启本地替换选项，上传自己的目录，然后选中浏览器中指定 JS 文件，做出修改后`ctrl+s`保存，即可将源文件保存到我们自己的目录中，之后对文件做出的修改可以直接替换对应的原文件，这样就能方便的修改浏览器端 JS 文件。\n\n![20240222095414](https://img.ma5hr00m.top/blog/20240222095414.png)\n\n剩下的就是动调了，后面会举例子解释。\n\n### 静/动态调试\n\n先做个区分，逆网页的 JS 代码更多得是在开发者工具中做动调的。\n\n- 静态调试：静态调试是通过分析代码的结构和逻辑来理解其功能。这种方法不需要运行代码，只需要对代码进行分析和理解。例如，可以通过反汇编工具将二进制的可执行文件翻译成汇编代码，通过对代码的分析来破解软件。\n- 动态调试：动态调试则是在代码运行时进行的。通过设置断点，单步执行，观察变量的值变化等方式，来理解代码的运行过程和逻辑。动态调试可以有效应对多数混淆措施，从中还原出运行逻辑，是逆向分析的关键手段。前面说的反调试便是阻拦动态调试。\n\n## 实战\n\n### 百度翻译接口\n\n未登录状态下翻译字符串，观察 Network 可以找到`/v2transapi` POST 请求报文，其 payload 中表单的 `query`字段即为我们输入待翻译的字符串。\n\n![20240222095423](https://img.ma5hr00m.top/blog/20240222095423.png)\n\n刷新页面多次翻译，发现只有`sign`字段的值在随`query`一直变化，`transtype`的值会根据触发翻译的方式在`realtime`和`enter`之间切换，其它字段值保持不变。我们接下来的任务就是分析`sign`字段的值是怎么来的。\n\n为了搞清楚`sign`是如何生成的，我们需要在 Sources 模块中全局搜索`sign`字段。但因为`sign`本身是一个常见的字段，我们很容易定位到其他与表单无关的地方。这里有一个小技巧，为了获得参数相关代码，我们可以搜索`sign:`或者`sign=`，以尽量避免定位到无关代码。\n\n在 Sources 模块中全局搜索`sign:`，定位到很多文件，根据文件名和文件内容，可以判断最有可能在 index.36217dc5.js 文件中，而该文件中出现了 6 处`sign:`相关代码，依次打断点并执行翻译操作，发现只会在 25800 行处的`sign: b(e);`处停下：\n\n![20240222095432](https://img.ma5hr00m.top/blog/20240222095432.png)\n\n单步步进，可以发现参数 t 值即为传入的字符串：\n\n![20240222095443](https://img.ma5hr00m.top/blog/20240222095443.png)\n\n把这段函数抽离出来，写到一个 main.js 文件中，调用该函数并运行：\n\n```JavaScript\nb = function(t) {\n  var o, i = t.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g);\n  if (null === i) {\n    var a = t.length;\n    a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(Math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n  } else {\n    for (var s = t.split(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/), c = 0, u = s.length, l = []; c < u; c++)\n      \"\" !== s[c] && l.push.apply(l, function(t) {\n        if (Array.isArray(t))\n          return e(t)\n      }(o = s[c].split(\"\")) || function(t) {\n        if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"])\n          return Array.from(t)\n      }(o) || function(t, n) {\n        if (t) {\n          if (\"string\" == typeof t)\n            return e(t, n);\n          var r = Object.prototype.toString.call(t).slice(8, -1);\n          return \"Object\" === r && t.constructor && (r = t.constructor.name),\n          \"Map\" === r || \"Set\" === r ? Array.from(t) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0\n        }\n      }(o) || function() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\n      }()),\n      c !== u - 1 && l.push(i[c]);\n    var p = l.length;\n    p > 30 && (t = l.slice(0, 10).join(\"\") + l.slice(Math.floor(p / 2) - 5, Math.floor(p / 2) + 5).join(\"\") + l.slice(-10).join(\"\"))\n  }\n  for (var d = \"\".concat(String.fromCharCode(103)).concat(String.fromCharCode(116)).concat(String.fromCharCode(107)), h = (null !== r ? r : (r = window[d] || \"\") || \"\").split(\".\"), f = Number(h[0]) || 0, m = Number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n    var _ = t.charCodeAt(v);\n    _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charCodeAt(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charCodeAt(++v)),\n    g[y++] = _ >> 18 | 240,\n    g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n    g[y++] = _ >> 6 & 63 | 128),\n    g[y++] = 63 & _ | 128)\n  }\n  for (var b = f, w = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(97)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(54)), k = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(51)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(98)) + \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(102)), x = 0; x < g.length; x++)\n    b = n(b += g[x], w);\n  return b = n(b, k),\n  (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n  \"\".concat((b %= 1e6).toString(), \".\").concat(b ^ f)\n}\n\nconst query = \"abandon\";\nconsole.log(b(query))\n```\n\n运行时报错，提示`r`未定义。在继续动调去找`r`是什么。步进调试到这一步时，发现`r`被赋值为`window[d]`，即 \"320305.131321201\"，在此之前其值一直为null。\n\n![20240222095453](https://img.ma5hr00m.top/blog/20240222095453.png)\n\n我们可以发现`d`的值为`gtk`。我们本地是通过 Node.js 运行 JS 脚本，没有`window[]`这种 Web API，所以直接将`320305.131321201`硬编码进去。在此运行脚本，又会提示缺少`n`函数：\n\n![20240222095459](https://img.ma5hr00m.top/blog/20240222095459.png)\n\n我们在面板中找到`n`函数，光标悬浮于上方可直接跳转到函数声明的地方：\n\n![20240222095511](https://img.ma5hr00m.top/blog/20240222095511.png)\n\n找到`n`函数后将其添加到 JS 脚本中，再次运行，即可得到结果`103339.356506`，这与我们在 Network 模块中查看到的`sign`值相同。\n\n最终脚本如下，输入`query`的值即可得到请求`/v2transapi`所需的 payload：\n\n```JavaScript\n/**\n * function to generate sign\n */\nn = function (t, e) {\n  for (var n = 0; n < e.length - 2; n += 3) {\n      var r = e.charAt(n + 2);\n      r = \"a\" <= r ? r.charCodeAt(0) - 87 : Number(r),\n      r = \"+\" === e.charAt(n + 1) ? t >>> r : t << r,\n      t = \"+\" === e.charAt(n) ? t + r & 4294967295 : t ^ r\n  }\n  return t\n}\n\nb = function(t) {\n  var o, i = t.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g);\n  if (null === i) {\n    var a = t.length;\n    a > 30 && (t = \"\".concat(t.substr(0, 10)).concat(t.substr(Math.floor(a / 2) - 5, 10)).concat(t.substr(-10, 10)))\n  } else {\n    for (var s = t.split(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/), c = 0, u = s.length, l = []; c < u; c++)\n      \"\" !== s[c] && l.push.apply(l, function(t) {\n        if (Array.isArray(t))\n          return e(t)\n      }(o = s[c].split(\"\")) || function(t) {\n        if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"])\n          return Array.from(t)\n      }(o) || function(t, n) {\n        if (t) {\n          if (\"string\" == typeof t)\n            return e(t, n);\n          var r = Object.prototype.toString.call(t).slice(8, -1);\n          return \"Object\" === r && t.constructor && (r = t.constructor.name),\n          \"Map\" === r || \"Set\" === r ? Array.from(t) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0\n        }\n      }(o) || function() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")\n      }()),\n      c !== u - 1 && l.push(i[c]);\n    var p = l.length;\n    p > 30 && (t = l.slice(0, 10).join(\"\") + l.slice(Math.floor(p / 2) - 5, Math.floor(p / 2) + 5).join(\"\") + l.slice(-10).join(\"\"))\n  }\n  for (var d = \"\".concat(String.fromCharCode(103)).concat(String.fromCharCode(116)).concat(String.fromCharCode(107)), h = (r = \"320305.131321201\").split(\".\"), f = Number(h[0]) || 0, m = Number(h[1]) || 0, g = [], y = 0, v = 0; v < t.length; v++) {\n    var _ = t.charCodeAt(v);\n    _ < 128 ? g[y++] = _ : (_ < 2048 ? g[y++] = _ >> 6 | 192 : (55296 == (64512 & _) && v + 1 < t.length && 56320 == (64512 & t.charCodeAt(v + 1)) ? (_ = 65536 + ((1023 & _) << 10) + (1023 & t.charCodeAt(++v)),\n    g[y++] = _ >> 18 | 240,\n    g[y++] = _ >> 12 & 63 | 128) : g[y++] = _ >> 12 | 224,\n    g[y++] = _ >> 6 & 63 | 128),\n    g[y++] = 63 & _ | 128)\n  }\n  for (var b = f, w = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(97)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(54)), k = \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(51)) + \"\".concat(String.fromCharCode(94)).concat(String.fromCharCode(43)).concat(String.fromCharCode(98)) + \"\".concat(String.fromCharCode(43)).concat(String.fromCharCode(45)).concat(String.fromCharCode(102)), x = 0; x < g.length; x++)\n    b = n(b += g[x], w);\n  return b = n(b, k),\n  (b ^= m) < 0 && (b = 2147483648 + (2147483647 & b)),\n  \"\".concat((b %= 1e6).toString(), \".\").concat(b ^ f)\n}\n\n/**\n * test\n */\nconst query = \"abandon\";\nconsole.log(`from=en&to=zh&query=${query}&simple_means_flag=3&sign=${b(query)}&token=14025658070b41f40739347cef0ec62a&domain=common&ts=1708512893507`)\n```\n\n### 掘金登录接口\n\n登录时抓包，可以得到对`/passport/web/user/login`接口的请求报文：\n\n```\n# GET 查询字符串参数\naid: 2608\naccount_sdk_source: web\nsdk_version: 2.2.6\nverifyFp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79\nfp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79\nsign: d9116c9cae3fcdf848f1288e1850eb2a489a4e23ece930692912a8bc155d89ec\nqs: 6466666a706b715a76616e5a766a7077666029646c612963752976616e5a736077766c6a6b297360776c637c4375\n\n# POST 表单参数\nmix_mode: 1\naccount: 34363d3336373d3d343c3c\npassword: 343736343736343736\nfixed_mix_mode: 1\n```\n\n流程其实大差不差，就是搜参数、打断点、慢慢动调，基本都能找出来。掘金登录只需要 POST 表单参数正确即可，GET 参数不对也能过。以上参数中，会动态变化的只有`sign`、`account`和`password`，其中 GET 参数`sign`即使删掉也能过登录验证。\n\n具体过程不再贴图展示，这里直接提供获取 POST 表单参数的脚本，感兴趣的可以尝试去逆一下`sign`是如何生成的，难度比逆`account`和`password`要高一些：\n\n```JavaScript\n/**\n * raw data\n */\nconst account = '00000000000'\nconst password = '1q2w3e'\n\n/**\n * handle account and password\n */\nvar T = function(e) {\n  var t, n = [];\n  if (void 0 === e)\n    return \"\";\n  t = function(e) {\n    for (var t, n = e.toString(), r = [], a = 0; a < n.length; a++)\n      0 <= (t = n.charCodeAt(a)) && t <= 127 ? r.push(t) : 128 <= t && t <= 2047 ? (r.push(192 | 31 & t >> 6),\n      r.push(128 | 63 & t)) : (2048 <= t && t <= 55295 || 57344 <= t && t <= 65535) && (r.push(224 | 15 & t >> 12),\n      r.push(128 | 63 & t >> 6),\n      r.push(128 | 63 & t));\n    for (var i = 0; i < r.length; i++)\n      r[i] &= 255;\n    return r\n  }(e);\n  for (var r = 0, a = t.length; r < a; ++r)\n    n.push((5 ^ t[r]).toString(16));\n  return n.join(\"\")\n}\n\n/**\n * obtain the post form\n */\nconst postForm = `mix_mode=1&account=${T(account)}&password=${T(password)}&fixed_mix_mode=1`\nconsole.log(postForm)\n```\n\n### HGAME2024 2048*16\n\nBaiMeow 师傅的题，HGAME2024 Week1 结束后不方便提供复现环境。题目考察了禁用 F12、反调试、JS 反混淆，比较全面。这里提一嘴。\n\n## 参阅文章\n\n- [Javascript加密混淆](https://lizh.gitbook.io/knowledge/research/javascript-jia-mi-hun-xiao#hun-xiao-cha-jian)，by 前端知识库\n- [js混淆与反混淆](https://ek1ng.com/jsobuscation.html)，by ek1ng","slug":"js-obfuscation-deobfuscation","published":1,"updated":"2024-06-09T12:55:21.238Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap4000pf4lyhxuy6cqo","content":"<h2 id=\"Obfuscation-混淆\"><a href=\"#Obfuscation-混淆\" class=\"headerlink\" title=\"Obfuscation 混淆\"></a>Obfuscation 混淆</h2><p>JavaScript 混淆（Obfuscation）是指通过一系列技术手段，使 JS 代码变得难以理解和分析，增加代码的复杂性和混淆度，阻碍逆向工程和代码盗用。实际上就是一种保护 JS 代码的手段。</p>\n<p>那为什么我们需要保护 JS 代码呢 🤔️</p>\n<p>JS 最早被设计出来就是为了在客户端运行，直接以源码的形式传递给客户端，如果不做处理则完全公开透明，任何人都可以读、分析、复制、盗用，甚至篡改源码与数据，这是网站开发者不愿意看到的。</p>\n<h3 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h3><p>早期的 JS 代码承担功能少，逻辑简单且体积小，不需要保护。但随着技术的发展，JS 承担的功能越来越多， 文件体积增大。为了优化用户体验，开发者们想了很多办法去减小 JS 文件体积，以加快 HTTP 传输速度。JS 压缩（Minification）技术应运而生。</p>\n<p>常见的 JS 压缩手段很多，比如：</p>\n<ul>\n<li>删除 JS 代码中的空格、换行与注释；</li>\n<li>替换 JS 代码中的局部变量名；</li>\n<li>合并 JS 文件；</li>\n<li>……</li>\n</ul>\n<p>压缩工具开发的初衷是减小 JS 文件体积，但 JS 代码经过压缩替换后，其可读性也大大降低，间接起到了保护代码的作用。但是后来主流浏览器的开发者工具都提供了格式化代码的功能，压缩技术所能提供的安全保护收效甚微。于是专门保护 JS 代码的技术：JS 加密和 JS 混淆。</p>\n<blockquote>\n<p>本文不会介绍 JS 加密技术，只需要知道这两种技术相辅相成，不预先进行混淆的 JS 加密没有意义。</p>\n</blockquote>\n<h3 id=\"常见混淆手段\"><a href=\"#常见混淆手段\" class=\"headerlink\" title=\"常见混淆手段\"></a>常见混淆手段</h3><ul>\n<li><p>变量名&#x2F;函数名的替换，通过将有意义的变量名和函数名替换为随机生成的名称。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">function calculateArea(radius) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  return Math.PI * radius * radius;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">console.log(calculateArea(5));</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">_0x2d8f05</span>(<span class=\"params\">_0x4b083b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * _0x4b083b * _0x4b083b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">_0x2d8f05</span>(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串混淆，将代码中的字符串替换为编码或加密的形式，可以防止字符串被轻易读取。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// console.log(&quot;Hello, world!&quot;);</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;\\x48\\x65\\x6c\\x6c\\x6f\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x21&quot;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>控制流混淆，改变代码的执行顺序或结构。例如，可以使用条件语句和循环语句来替换简单的赋值操作。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">let a = 1;</span></span><br><span class=\"line\"><span class=\"comment\">let b = 2;</span></span><br><span class=\"line\"><span class=\"comment\">let c = a + b;</span></span><br><span class=\"line\"><span class=\"comment\">console.log(c);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (b === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    c = a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>死代码插入，即在源码插入一些不会被执行的代码。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">let a = 1;</span></span><br><span class=\"line\"><span class=\"comment\">let b = 2;</span></span><br><span class=\"line\"><span class=\"comment\">let c = a + b;</span></span><br><span class=\"line\"><span class=\"comment\">console.log(c);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a - b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = a + b;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码转换，将代码转换为等价的，但更难理解的形式。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">let a = 1;</span></span><br><span class=\"line\"><span class=\"comment\">let b = 2;</span></span><br><span class=\"line\"><span class=\"comment\">let c = a + b;</span></span><br><span class=\"line\"><span class=\"comment\">console.log(c);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = a - (-b);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"常见反调试手段\"><a href=\"#常见反调试手段\" class=\"headerlink\" title=\"常见反调试手段\"></a>常见反调试手段</h3><p>实现防止他人调试、动态分析自己的代码，我们可以预先在代码中做处理，防止用户调试代码。</p>\n<ul>\n<li><p>无限 debugger。比如写个定时器死循环禁止调试。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">RegExp</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">c.<span class=\"property\">toString</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;检测到调试&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">setInterval</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">debugger</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>内存耗尽。更隐蔽的反调试手段，代码运行造成的内存占用会越来越大，很快会使浏览器崩溃。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> isDev = endTime - startTime &gt; <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> stack = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (isDev) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        stack.<span class=\"title function_\">push</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(stack.<span class=\"property\">length</span>, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>检测函数、对象属性修改。攻击者在调试的时，经常会把防护的函数删除，或者把检测数据对象进行篡改。可以检测函数内容，在原型上设置禁止修改。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">eval</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    [native code]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">eval</span> = <span class=\"keyword\">function</span>(<span class=\"params\">str</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;[native code]&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">eval</span> = <span class=\"keyword\">function</span>(<span class=\"params\">str</span>) &#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">eval</span>.<span class=\"property\">toString</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`function eval() &#123;[native code]&#125;`</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hijacked</span>(<span class=\"params\">fun</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;prototype&quot;</span> <span class=\"keyword\">in</span> fun || fun.<span class=\"title function_\">toString</span>().<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\n|\\s/g</span>, <span class=\"string\">&quot;&quot;</span>) != <span class=\"string\">&quot;function&quot;</span> + fun.<span class=\"property\">name</span> + <span class=\"string\">&quot;() &#123;[nativecode]&#125;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"前端开发中的混淆\"><a href=\"#前端开发中的混淆\" class=\"headerlink\" title=\"前端开发中的混淆\"></a>前端开发中的混淆</h3><p>在 Web 前端开发中，开发者会对代码进行压缩和混淆，对代码进行优化，并提高安全性。已经有很多成熟的工具可以使用，比如 <a href=\"https://github.com/mishoo/UglifyJS\">UglifyJS</a> 和 <a href=\"https://github.com/javascript-obfuscator/javascript-obfuscator\">JavaScript Obfuscator</a>。</p>\n<p>混淆通常在项目的构建过程中进行。例如，我们使用 Vite 作为模块打包工具，就可以在 vite 的配置文件中添加UglifyJS 插件。这样，在每次构建项目时，UglifyJS就会自动对你的代码进行混淆。</p>\n<p>先安装插件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vite-plugin-uglify --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>然后在配置文件中添加该插件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; defineConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vite&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> vue <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">VitePluginUglify</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vite-plugin-uglify&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"title function_\">vue</span>(),</span><br><span class=\"line\">    <span class=\"title class_\">VitePluginUglify</span>()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在这个配置文件中，<code>VitePluginUglify</code>被添加到了<code>plugins</code>数组中，所以在构建过程中，Vite 会自动使用<code>vite-plugin-uglify</code>对代码进行混淆。</p>\n<h3 id=\"在线混淆工具\"><a href=\"#在线混淆工具\" class=\"headerlink\" title=\"在线混淆工具\"></a>在线混淆工具</h3><p>有些站点提供了在线混淆的功能，比如 <a href=\"https://javascriptobfuscator.dev/\">Free JavaScript Obfuscator</a>，提供 JS 代码即可得到混淆后的结果。这个站点的混淆基于上面提到的 <a href=\"https://github.com/javascript-obfuscator/javascript-obfuscator\">JavaScript Obfuscator</a> 实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fibonacci</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fib = [<span class=\"number\">0</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    fib[i] = fib[i - <span class=\"number\">1</span>] + fib[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the first 10 numbers in the Fibonacci sequence</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">fibonacci</span>(<span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure>\n\n<p>以上代码的作用是计算斐波那契数列的前 10 个值并打印出来，经过混淆可得以下内容，可读性肉眼可见的降低：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _0x323128=_0x5512;(<span class=\"keyword\">function</span>(<span class=\"params\">_0x589643,_0x5459af</span>)&#123;<span class=\"keyword\">const</span> _0x1b79b8=_0x5512,_0x3e96ed=<span class=\"title function_\">_0x589643</span>();<span class=\"keyword\">while</span>(!![])&#123;<span class=\"keyword\">try</span>&#123;<span class=\"keyword\">const</span> _0x1fb1b3=-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f1</span>))/<span class=\"number\">0x1</span>*(-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ea</span>))/<span class=\"number\">0x2</span>)+-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ec</span>))/<span class=\"number\">0x3</span>*(<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f3</span>))/<span class=\"number\">0x4</span>)+-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ed</span>))/<span class=\"number\">0x5</span>*(<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f2</span>))/<span class=\"number\">0x6</span>)+-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1e8</span>))/<span class=\"number\">0x7</span>+<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1e9</span>))/<span class=\"number\">0x8</span>*(-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f4</span>))/<span class=\"number\">0x9</span>)+<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f0</span>))/<span class=\"number\">0xa</span>+-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ef</span>))/<span class=\"number\">0xb</span>*(-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ee</span>))/<span class=\"number\">0xc</span>);<span class=\"keyword\">if</span>(_0x1fb1b3===_0x5459af)<span class=\"keyword\">break</span>;<span class=\"keyword\">else</span> _0x3e96ed[<span class=\"string\">&#x27;push&#x27;</span>](_0x3e96ed[<span class=\"string\">&#x27;shift&#x27;</span>]());&#125;<span class=\"keyword\">catch</span>(_0x56184c)&#123;_0x3e96ed[<span class=\"string\">&#x27;push&#x27;</span>](_0x3e96ed[<span class=\"string\">&#x27;shift&#x27;</span>]());&#125;&#125;&#125;(_0x138e,<span class=\"number\">0xdf35a</span>));<span class=\"keyword\">function</span> <span class=\"title function_\">_0x138e</span>(<span class=\"params\"></span>)&#123;<span class=\"keyword\">const</span> _0x3a0863=[<span class=\"string\">&#x27;354072hRaVAZ&#x27;</span>,<span class=\"string\">&#x27;9mNckCh&#x27;</span>,<span class=\"string\">&#x27;1622341lDdscp&#x27;</span>,<span class=\"string\">&#x27;2787864kenYBK&#x27;</span>,<span class=\"string\">&#x27;546362IExhCV&#x27;</span>,<span class=\"string\">&#x27;log&#x27;</span>,<span class=\"string\">&#x27;3fofuVm&#x27;</span>,<span class=\"string\">&#x27;1946005vlrFyq&#x27;</span>,<span class=\"string\">&#x27;516IsqKpc&#x27;</span>,<span class=\"string\">&#x27;725241tPbpzZ&#x27;</span>,<span class=\"string\">&#x27;316200mzqtLe&#x27;</span>,<span class=\"string\">&#x27;1mgkmrs&#x27;</span>,<span class=\"string\">&#x27;24Zwposp&#x27;</span>];_0x138e=<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;<span class=\"keyword\">return</span> _0x3a0863;&#125;;<span class=\"keyword\">return</span> <span class=\"title function_\">_0x138e</span>();&#125;<span class=\"keyword\">function</span> <span class=\"title function_\">fibonacci</span>(<span class=\"params\">_0x1b3125</span>)&#123;<span class=\"keyword\">let</span> _0x9e88df=[<span class=\"number\">0x0</span>,<span class=\"number\">0x1</span>];<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> _0x406b50=<span class=\"number\">0x2</span>;_0x406b50&lt;=_0x1b3125;_0x406b50++)&#123;_0x9e88df[_0x406b50]=_0x9e88df[_0x406b50-<span class=\"number\">0x1</span>]+_0x9e88df[_0x406b50-<span class=\"number\">0x2</span>];&#125;<span class=\"keyword\">return</span> _0x9e88df;&#125;<span class=\"keyword\">function</span> <span class=\"title function_\">_0x5512</span>(<span class=\"params\">_0x2d5465,_0x1d0a2f</span>)&#123;<span class=\"keyword\">const</span> _0x138ec4=<span class=\"title function_\">_0x138e</span>();<span class=\"keyword\">return</span> _0x5512=<span class=\"keyword\">function</span>(<span class=\"params\">_0x5512ef,_0x5e1f2e</span>)&#123;_0x5512ef=_0x5512ef-<span class=\"number\">0x1e8</span>;<span class=\"keyword\">let</span> _0x4be64a=_0x138ec4[_0x5512ef];<span class=\"keyword\">return</span> _0x4be64a;&#125;,<span class=\"title function_\">_0x5512</span>(_0x2d5465,_0x1d0a2f);&#125;<span class=\"variable language_\">console</span>[<span class=\"title function_\">_0x323128</span>(<span class=\"number\">0x1eb</span>)](<span class=\"title function_\">fibonacci</span>(<span class=\"number\">0xa</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Deobfuscator-反混淆\"><a href=\"#Deobfuscator-反混淆\" class=\"headerlink\" title=\"Deobfuscator 反混淆\"></a>Deobfuscator 反混淆</h2><p>JS 反混淆（Deobfuscator ）是指对经过混淆处理的代码进行还原和解析，以恢复其可读性。Deobfuscator 可以通过对代码进行静态分析和动态分析等方式来实现。需要注意的是，Obfuscation 只能降低可读性，不能完全避免逆向攻击，而 Deobfuscator 也并不能完全还原混淆过的代码。</p>\n<p>只要耐心分析，多数混淆过的 JS 已然能还原出来。</p>\n<h3 id=\"在线反混淆工具\"><a href=\"#在线反混淆工具\" class=\"headerlink\" title=\"在线反混淆工具\"></a>在线反混淆工具</h3><p>反混淆要有些趁手的工具。最常用的是浏览器自带的开发者工具，其次是一些转换混淆过的代码的工具。以下网站提供在线反混淆 JS 代码的功能：</p>\n<ul>\n<li><a href=\"https://seosniffer.com/javascript-deobfuscator\">javascript-deobfuscator</a></li>\n<li><a href=\"https://dev-coco.github.io/Online-Tools/JavaScript-Deobfuscator.html\">Raz1ner JavaScript Deobfuscator</a></li>\n<li><a href=\"https://deobfuscate.relative.im/\">synchrony deobuscator</a></li>\n<li><a href=\"https://beautifier.io/\">js-beauty</a></li>\n</ul>\n<p>以我们经过混淆的代码为例，丢进上述第一个网站，可以得到以下反混淆过的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fibonacci</span>(<span class=\"params\">jayandre</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ramonita = [<span class=\"number\">0</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> ancel = <span class=\"number\">2</span>; ancel &lt;= jayandre; ancel++) &#123;</span><br><span class=\"line\">    ramonita[ancel] = ramonita[ancel - <span class=\"number\">1</span>] + ramonita[ancel - <span class=\"number\">2</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ramonita;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">fibonacci</span>(<span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure>\n\n<p>原本的逻辑已经较为清晰的展现了。当然也有一些库能用来反混淆本地 JS 文件，这里不多做介绍，感觉在线工具就够用了。</p>\n<h3 id=\"开发者工具\"><a href=\"#开发者工具\" class=\"headerlink\" title=\"开发者工具\"></a>开发者工具</h3><p>上面的反混淆站点只是辅助，真反混淆还得靠浏览器自带的开发者工具。接下来以chrome浏览器为例讲讲怎么用。</p>\n<p>在反混淆过程中，我们主要使用源代码（Source）和网络（Network）这两个模块。Network 用于查找我们进行用户操作时调用了哪些 API，在调用 API 前后运行了哪些 JS 文件；Source 提供了网站整体的 JS 代码及静态资源，我们的反混淆分析工作主要就在这里进行。</p>\n<p>在 Source 模块中，默认<code>ctrl+shift+p</code>可以开启开发者工具的命令行，我们可以找到两个“搜索”工具，分别对应“全局搜索”和“在当前文件中搜索”，很适合查找指定字段。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095405.png\" alt=\"20240222095405\"></p>\n<p>开发者工具提供了替换（Override）功能，开启本地替换选项，上传自己的目录，然后选中浏览器中指定 JS 文件，做出修改后<code>ctrl+s</code>保存，即可将源文件保存到我们自己的目录中，之后对文件做出的修改可以直接替换对应的原文件，这样就能方便的修改浏览器端 JS 文件。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095414.png\" alt=\"20240222095414\"></p>\n<p>剩下的就是动调了，后面会举例子解释。</p>\n<h3 id=\"静-动态调试\"><a href=\"#静-动态调试\" class=\"headerlink\" title=\"静&#x2F;动态调试\"></a>静&#x2F;动态调试</h3><p>先做个区分，逆网页的 JS 代码更多得是在开发者工具中做动调的。</p>\n<ul>\n<li>静态调试：静态调试是通过分析代码的结构和逻辑来理解其功能。这种方法不需要运行代码，只需要对代码进行分析和理解。例如，可以通过反汇编工具将二进制的可执行文件翻译成汇编代码，通过对代码的分析来破解软件。</li>\n<li>动态调试：动态调试则是在代码运行时进行的。通过设置断点，单步执行，观察变量的值变化等方式，来理解代码的运行过程和逻辑。动态调试可以有效应对多数混淆措施，从中还原出运行逻辑，是逆向分析的关键手段。前面说的反调试便是阻拦动态调试。</li>\n</ul>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"百度翻译接口\"><a href=\"#百度翻译接口\" class=\"headerlink\" title=\"百度翻译接口\"></a>百度翻译接口</h3><p>未登录状态下翻译字符串，观察 Network 可以找到<code>/v2transapi</code> POST 请求报文，其 payload 中表单的 <code>query</code>字段即为我们输入待翻译的字符串。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095423.png\" alt=\"20240222095423\"></p>\n<p>刷新页面多次翻译，发现只有<code>sign</code>字段的值在随<code>query</code>一直变化，<code>transtype</code>的值会根据触发翻译的方式在<code>realtime</code>和<code>enter</code>之间切换，其它字段值保持不变。我们接下来的任务就是分析<code>sign</code>字段的值是怎么来的。</p>\n<p>为了搞清楚<code>sign</code>是如何生成的，我们需要在 Sources 模块中全局搜索<code>sign</code>字段。但因为<code>sign</code>本身是一个常见的字段，我们很容易定位到其他与表单无关的地方。这里有一个小技巧，为了获得参数相关代码，我们可以搜索<code>sign:</code>或者<code>sign=</code>，以尽量避免定位到无关代码。</p>\n<p>在 Sources 模块中全局搜索<code>sign:</code>，定位到很多文件，根据文件名和文件内容，可以判断最有可能在 index.36217dc5.js 文件中，而该文件中出现了 6 处<code>sign:</code>相关代码，依次打断点并执行翻译操作，发现只会在 25800 行处的<code>sign: b(e);</code>处停下：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095432.png\" alt=\"20240222095432\"></p>\n<p>单步步进，可以发现参数 t 值即为传入的字符串：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095443.png\" alt=\"20240222095443\"></p>\n<p>把这段函数抽离出来，写到一个 main.js 文件中，调用该函数并运行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o, i = t.<span class=\"title function_\">match</span>(<span class=\"regexp\">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> === i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = t.<span class=\"property\">length</span>;</span><br><span class=\"line\">    a &gt; <span class=\"number\">30</span> &amp;&amp; (t = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(<span class=\"number\">0</span>, <span class=\"number\">10</span>)).<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(a / <span class=\"number\">2</span>) - <span class=\"number\">5</span>, <span class=\"number\">10</span>)).<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(-<span class=\"number\">10</span>, <span class=\"number\">10</span>)))</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> s = t.<span class=\"title function_\">split</span>(<span class=\"regexp\">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/</span>), c = <span class=\"number\">0</span>, u = s.<span class=\"property\">length</span>, l = []; c &lt; u; c++)</span><br><span class=\"line\">      <span class=\"string\">&quot;&quot;</span> !== s[c] &amp;&amp; l.<span class=\"property\">push</span>.<span class=\"title function_\">apply</span>(l, <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(t))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">e</span>(t)</span><br><span class=\"line\">      &#125;(o = s[c].<span class=\"title function_\">split</span>(<span class=\"string\">&quot;&quot;</span>)) || <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;undefined&quot;</span> != <span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span> &amp;&amp; <span class=\"literal\">null</span> != t[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>] || <span class=\"literal\">null</span> != t[<span class=\"string\">&quot;@@iterator&quot;</span>])</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(t)</span><br><span class=\"line\">      &#125;(o) || <span class=\"keyword\">function</span>(<span class=\"params\">t, n</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"string\">&quot;string&quot;</span> == <span class=\"keyword\">typeof</span> t)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">e</span>(t, n);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> r = <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(t).<span class=\"title function_\">slice</span>(<span class=\"number\">8</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">&quot;Object&quot;</span> === r &amp;&amp; t.<span class=\"property\">constructor</span> &amp;&amp; (r = t.<span class=\"property\">constructor</span>.<span class=\"property\">name</span>),</span><br><span class=\"line\">          <span class=\"string\">&quot;Map&quot;</span> === r || <span class=\"string\">&quot;Set&quot;</span> === r ? <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(t) : <span class=\"string\">&quot;Arguments&quot;</span> === r || <span class=\"regexp\">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.<span class=\"title function_\">test</span>(r) ? <span class=\"title function_\">e</span>(t, n) : <span class=\"keyword\">void</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;(o) || <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">&quot;Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span>)</span><br><span class=\"line\">      &#125;()),</span><br><span class=\"line\">      c !== u - <span class=\"number\">1</span> &amp;&amp; l.<span class=\"title function_\">push</span>(i[c]);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = l.<span class=\"property\">length</span>;</span><br><span class=\"line\">    p &gt; <span class=\"number\">30</span> &amp;&amp; (t = l.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">10</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>) + l.<span class=\"title function_\">slice</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(p / <span class=\"number\">2</span>) - <span class=\"number\">5</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(p / <span class=\"number\">2</span>) + <span class=\"number\">5</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>) + l.<span class=\"title function_\">slice</span>(-<span class=\"number\">10</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> d = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">103</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">116</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">107</span>)), h = (<span class=\"literal\">null</span> !== r ? r : (r = <span class=\"variable language_\">window</span>[d] || <span class=\"string\">&quot;&quot;</span>) || <span class=\"string\">&quot;&quot;</span>).<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>), f = <span class=\"title class_\">Number</span>(h[<span class=\"number\">0</span>]) || <span class=\"number\">0</span>, m = <span class=\"title class_\">Number</span>(h[<span class=\"number\">1</span>]) || <span class=\"number\">0</span>, g = [], y = <span class=\"number\">0</span>, v = <span class=\"number\">0</span>; v &lt; t.<span class=\"property\">length</span>; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _ = t.<span class=\"title function_\">charCodeAt</span>(v);</span><br><span class=\"line\">    _ &lt; <span class=\"number\">128</span> ? g[y++] = _ : (_ &lt; <span class=\"number\">2048</span> ? g[y++] = _ &gt;&gt; <span class=\"number\">6</span> | <span class=\"number\">192</span> : (<span class=\"number\">55296</span> == (<span class=\"number\">64512</span> &amp; _) &amp;&amp; v + <span class=\"number\">1</span> &lt; t.<span class=\"property\">length</span> &amp;&amp; <span class=\"number\">56320</span> == (<span class=\"number\">64512</span> &amp; t.<span class=\"title function_\">charCodeAt</span>(v + <span class=\"number\">1</span>)) ? (_ = <span class=\"number\">65536</span> + ((<span class=\"number\">1023</span> &amp; _) &lt;&lt; <span class=\"number\">10</span>) + (<span class=\"number\">1023</span> &amp; t.<span class=\"title function_\">charCodeAt</span>(++v)),</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">18</span> | <span class=\"number\">240</span>,</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">12</span> &amp; <span class=\"number\">63</span> | <span class=\"number\">128</span>) : g[y++] = _ &gt;&gt; <span class=\"number\">12</span> | <span class=\"number\">224</span>,</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">6</span> &amp; <span class=\"number\">63</span> | <span class=\"number\">128</span>),</span><br><span class=\"line\">    g[y++] = <span class=\"number\">63</span> &amp; _ | <span class=\"number\">128</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> b = f, w = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">97</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">94</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">54</span>)), k = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">51</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">94</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">98</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">102</span>)), x = <span class=\"number\">0</span>; x &lt; g.<span class=\"property\">length</span>; x++)</span><br><span class=\"line\">    b = <span class=\"title function_\">n</span>(b += g[x], w);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b = <span class=\"title function_\">n</span>(b, k),</span><br><span class=\"line\">  (b ^= m) &lt; <span class=\"number\">0</span> &amp;&amp; (b = <span class=\"number\">2147483648</span> + (<span class=\"number\">2147483647</span> &amp; b)),</span><br><span class=\"line\">  <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>((b %= <span class=\"number\">1e6</span>).<span class=\"title function_\">toString</span>(), <span class=\"string\">&quot;.&quot;</span>).<span class=\"title function_\">concat</span>(b ^ f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = <span class=\"string\">&quot;abandon&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">b</span>(query))</span><br></pre></td></tr></table></figure>\n\n<p>运行时报错，提示<code>r</code>未定义。在继续动调去找<code>r</code>是什么。步进调试到这一步时，发现<code>r</code>被赋值为<code>window[d]</code>，即 “320305.131321201”，在此之前其值一直为null。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095453.png\" alt=\"20240222095453\"></p>\n<p>我们可以发现<code>d</code>的值为<code>gtk</code>。我们本地是通过 Node.js 运行 JS 脚本，没有<code>window[]</code>这种 Web API，所以直接将<code>320305.131321201</code>硬编码进去。在此运行脚本，又会提示缺少<code>n</code>函数：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095459.png\" alt=\"20240222095459\"></p>\n<p>我们在面板中找到<code>n</code>函数，光标悬浮于上方可直接跳转到函数声明的地方：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095511.png\" alt=\"20240222095511\"></p>\n<p>找到<code>n</code>函数后将其添加到 JS 脚本中，再次运行，即可得到结果<code>103339.356506</code>，这与我们在 Network 模块中查看到的<code>sign</code>值相同。</p>\n<p>最终脚本如下，输入<code>query</code>的值即可得到请求<code>/v2transapi</code>所需的 payload：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * function to generate sign</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">n = <span class=\"keyword\">function</span> (<span class=\"params\">t, e</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n = <span class=\"number\">0</span>; n &lt; e.<span class=\"property\">length</span> - <span class=\"number\">2</span>; n += <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> r = e.<span class=\"title function_\">charAt</span>(n + <span class=\"number\">2</span>);</span><br><span class=\"line\">      r = <span class=\"string\">&quot;a&quot;</span> &lt;= r ? r.<span class=\"title function_\">charCodeAt</span>(<span class=\"number\">0</span>) - <span class=\"number\">87</span> : <span class=\"title class_\">Number</span>(r),</span><br><span class=\"line\">      r = <span class=\"string\">&quot;+&quot;</span> === e.<span class=\"title function_\">charAt</span>(n + <span class=\"number\">1</span>) ? t &gt;&gt;&gt; r : t &lt;&lt; r,</span><br><span class=\"line\">      t = <span class=\"string\">&quot;+&quot;</span> === e.<span class=\"title function_\">charAt</span>(n) ? t + r &amp; <span class=\"number\">4294967295</span> : t ^ r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">b = <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o, i = t.<span class=\"title function_\">match</span>(<span class=\"regexp\">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> === i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = t.<span class=\"property\">length</span>;</span><br><span class=\"line\">    a &gt; <span class=\"number\">30</span> &amp;&amp; (t = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(<span class=\"number\">0</span>, <span class=\"number\">10</span>)).<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(a / <span class=\"number\">2</span>) - <span class=\"number\">5</span>, <span class=\"number\">10</span>)).<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(-<span class=\"number\">10</span>, <span class=\"number\">10</span>)))</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> s = t.<span class=\"title function_\">split</span>(<span class=\"regexp\">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/</span>), c = <span class=\"number\">0</span>, u = s.<span class=\"property\">length</span>, l = []; c &lt; u; c++)</span><br><span class=\"line\">      <span class=\"string\">&quot;&quot;</span> !== s[c] &amp;&amp; l.<span class=\"property\">push</span>.<span class=\"title function_\">apply</span>(l, <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(t))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">e</span>(t)</span><br><span class=\"line\">      &#125;(o = s[c].<span class=\"title function_\">split</span>(<span class=\"string\">&quot;&quot;</span>)) || <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;undefined&quot;</span> != <span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span> &amp;&amp; <span class=\"literal\">null</span> != t[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>] || <span class=\"literal\">null</span> != t[<span class=\"string\">&quot;@@iterator&quot;</span>])</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(t)</span><br><span class=\"line\">      &#125;(o) || <span class=\"keyword\">function</span>(<span class=\"params\">t, n</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"string\">&quot;string&quot;</span> == <span class=\"keyword\">typeof</span> t)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">e</span>(t, n);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> r = <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(t).<span class=\"title function_\">slice</span>(<span class=\"number\">8</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">&quot;Object&quot;</span> === r &amp;&amp; t.<span class=\"property\">constructor</span> &amp;&amp; (r = t.<span class=\"property\">constructor</span>.<span class=\"property\">name</span>),</span><br><span class=\"line\">          <span class=\"string\">&quot;Map&quot;</span> === r || <span class=\"string\">&quot;Set&quot;</span> === r ? <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(t) : <span class=\"string\">&quot;Arguments&quot;</span> === r || <span class=\"regexp\">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.<span class=\"title function_\">test</span>(r) ? <span class=\"title function_\">e</span>(t, n) : <span class=\"keyword\">void</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;(o) || <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">&quot;Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span>)</span><br><span class=\"line\">      &#125;()),</span><br><span class=\"line\">      c !== u - <span class=\"number\">1</span> &amp;&amp; l.<span class=\"title function_\">push</span>(i[c]);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = l.<span class=\"property\">length</span>;</span><br><span class=\"line\">    p &gt; <span class=\"number\">30</span> &amp;&amp; (t = l.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">10</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>) + l.<span class=\"title function_\">slice</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(p / <span class=\"number\">2</span>) - <span class=\"number\">5</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(p / <span class=\"number\">2</span>) + <span class=\"number\">5</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>) + l.<span class=\"title function_\">slice</span>(-<span class=\"number\">10</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> d = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">103</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">116</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">107</span>)), h = (r = <span class=\"string\">&quot;320305.131321201&quot;</span>).<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>), f = <span class=\"title class_\">Number</span>(h[<span class=\"number\">0</span>]) || <span class=\"number\">0</span>, m = <span class=\"title class_\">Number</span>(h[<span class=\"number\">1</span>]) || <span class=\"number\">0</span>, g = [], y = <span class=\"number\">0</span>, v = <span class=\"number\">0</span>; v &lt; t.<span class=\"property\">length</span>; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _ = t.<span class=\"title function_\">charCodeAt</span>(v);</span><br><span class=\"line\">    _ &lt; <span class=\"number\">128</span> ? g[y++] = _ : (_ &lt; <span class=\"number\">2048</span> ? g[y++] = _ &gt;&gt; <span class=\"number\">6</span> | <span class=\"number\">192</span> : (<span class=\"number\">55296</span> == (<span class=\"number\">64512</span> &amp; _) &amp;&amp; v + <span class=\"number\">1</span> &lt; t.<span class=\"property\">length</span> &amp;&amp; <span class=\"number\">56320</span> == (<span class=\"number\">64512</span> &amp; t.<span class=\"title function_\">charCodeAt</span>(v + <span class=\"number\">1</span>)) ? (_ = <span class=\"number\">65536</span> + ((<span class=\"number\">1023</span> &amp; _) &lt;&lt; <span class=\"number\">10</span>) + (<span class=\"number\">1023</span> &amp; t.<span class=\"title function_\">charCodeAt</span>(++v)),</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">18</span> | <span class=\"number\">240</span>,</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">12</span> &amp; <span class=\"number\">63</span> | <span class=\"number\">128</span>) : g[y++] = _ &gt;&gt; <span class=\"number\">12</span> | <span class=\"number\">224</span>,</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">6</span> &amp; <span class=\"number\">63</span> | <span class=\"number\">128</span>),</span><br><span class=\"line\">    g[y++] = <span class=\"number\">63</span> &amp; _ | <span class=\"number\">128</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> b = f, w = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">97</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">94</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">54</span>)), k = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">51</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">94</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">98</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">102</span>)), x = <span class=\"number\">0</span>; x &lt; g.<span class=\"property\">length</span>; x++)</span><br><span class=\"line\">    b = <span class=\"title function_\">n</span>(b += g[x], w);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b = <span class=\"title function_\">n</span>(b, k),</span><br><span class=\"line\">  (b ^= m) &lt; <span class=\"number\">0</span> &amp;&amp; (b = <span class=\"number\">2147483648</span> + (<span class=\"number\">2147483647</span> &amp; b)),</span><br><span class=\"line\">  <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>((b %= <span class=\"number\">1e6</span>).<span class=\"title function_\">toString</span>(), <span class=\"string\">&quot;.&quot;</span>).<span class=\"title function_\">concat</span>(b ^ f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * test</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = <span class=\"string\">&quot;abandon&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`from=en&amp;to=zh&amp;query=<span class=\"subst\">$&#123;query&#125;</span>&amp;simple_means_flag=3&amp;sign=<span class=\"subst\">$&#123;b(query)&#125;</span>&amp;token=14025658070b41f40739347cef0ec62a&amp;domain=common&amp;ts=1708512893507`</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"掘金登录接口\"><a href=\"#掘金登录接口\" class=\"headerlink\" title=\"掘金登录接口\"></a>掘金登录接口</h3><p>登录时抓包，可以得到对<code>/passport/web/user/login</code>接口的请求报文：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># GET 查询字符串参数</span><br><span class=\"line\">aid: 2608</span><br><span class=\"line\">account_sdk_source: web</span><br><span class=\"line\">sdk_version: 2.2.6</span><br><span class=\"line\">verifyFp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79</span><br><span class=\"line\">fp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79</span><br><span class=\"line\">sign: d9116c9cae3fcdf848f1288e1850eb2a489a4e23ece930692912a8bc155d89ec</span><br><span class=\"line\">qs: 6466666a706b715a76616e5a766a7077666029646c612963752976616e5a736077766c6a6b297360776c637c4375</span><br><span class=\"line\"></span><br><span class=\"line\"># POST 表单参数</span><br><span class=\"line\">mix_mode: 1</span><br><span class=\"line\">account: 34363d3336373d3d343c3c</span><br><span class=\"line\">password: 343736343736343736</span><br><span class=\"line\">fixed_mix_mode: 1</span><br></pre></td></tr></table></figure>\n\n<p>流程其实大差不差，就是搜参数、打断点、慢慢动调，基本都能找出来。掘金登录只需要 POST 表单参数正确即可，GET 参数不对也能过。以上参数中，会动态变化的只有<code>sign</code>、<code>account</code>和<code>password</code>，其中 GET 参数<code>sign</code>即使删掉也能过登录验证。</p>\n<p>具体过程不再贴图展示，这里直接提供获取 POST 表单参数的脚本，感兴趣的可以尝试去逆一下<code>sign</code>是如何生成的，难度比逆<code>account</code>和<code>password</code>要高一些：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * raw data</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> account = <span class=\"string\">&#x27;00000000000&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> password = <span class=\"string\">&#x27;1q2w3e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * handle account and password</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> T = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t, n = [];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">void</span> <span class=\"number\">0</span> === e)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  t = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> t, n = e.<span class=\"title function_\">toString</span>(), r = [], a = <span class=\"number\">0</span>; a &lt; n.<span class=\"property\">length</span>; a++)</span><br><span class=\"line\">      <span class=\"number\">0</span> &lt;= (t = n.<span class=\"title function_\">charCodeAt</span>(a)) &amp;&amp; t &lt;= <span class=\"number\">127</span> ? r.<span class=\"title function_\">push</span>(t) : <span class=\"number\">128</span> &lt;= t &amp;&amp; t &lt;= <span class=\"number\">2047</span> ? (r.<span class=\"title function_\">push</span>(<span class=\"number\">192</span> | <span class=\"number\">31</span> &amp; t &gt;&gt; <span class=\"number\">6</span>),</span><br><span class=\"line\">      r.<span class=\"title function_\">push</span>(<span class=\"number\">128</span> | <span class=\"number\">63</span> &amp; t)) : (<span class=\"number\">2048</span> &lt;= t &amp;&amp; t &lt;= <span class=\"number\">55295</span> || <span class=\"number\">57344</span> &lt;= t &amp;&amp; t &lt;= <span class=\"number\">65535</span>) &amp;&amp; (r.<span class=\"title function_\">push</span>(<span class=\"number\">224</span> | <span class=\"number\">15</span> &amp; t &gt;&gt; <span class=\"number\">12</span>),</span><br><span class=\"line\">      r.<span class=\"title function_\">push</span>(<span class=\"number\">128</span> | <span class=\"number\">63</span> &amp; t &gt;&gt; <span class=\"number\">6</span>),</span><br><span class=\"line\">      r.<span class=\"title function_\">push</span>(<span class=\"number\">128</span> | <span class=\"number\">63</span> &amp; t));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; r.<span class=\"property\">length</span>; i++)</span><br><span class=\"line\">      r[i] &amp;= <span class=\"number\">255</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">  &#125;(e);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> r = <span class=\"number\">0</span>, a = t.<span class=\"property\">length</span>; r &lt; a; ++r)</span><br><span class=\"line\">    n.<span class=\"title function_\">push</span>((<span class=\"number\">5</span> ^ t[r]).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n.<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * obtain the post form</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> postForm = <span class=\"string\">`mix_mode=1&amp;account=<span class=\"subst\">$&#123;T(account)&#125;</span>&amp;password=<span class=\"subst\">$&#123;T(password)&#125;</span>&amp;fixed_mix_mode=1`</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(postForm)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HGAME2024-2048-16\"><a href=\"#HGAME2024-2048-16\" class=\"headerlink\" title=\"HGAME2024 2048*16\"></a>HGAME2024 2048*16</h3><p>BaiMeow 师傅的题，HGAME2024 Week1 结束后不方便提供复现环境。题目考察了禁用 F12、反调试、JS 反混淆，比较全面。这里提一嘴。</p>\n<h2 id=\"参阅文章\"><a href=\"#参阅文章\" class=\"headerlink\" title=\"参阅文章\"></a>参阅文章</h2><ul>\n<li><a href=\"https://lizh.gitbook.io/knowledge/research/javascript-jia-mi-hun-xiao#hun-xiao-cha-jian\">Javascript加密混淆</a>，by 前端知识库</li>\n<li><a href=\"https://ek1ng.com/jsobuscation.html\">js混淆与反混淆</a>，by ek1ng</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"Obfuscation-混淆\"><a href=\"#Obfuscation-混淆\" class=\"headerlink\" title=\"Obfuscation 混淆\"></a>Obfuscation 混淆</h2><p>JavaScript 混淆（Obfuscation）是指通过一系列技术手段，使 JS 代码变得难以理解和分析，增加代码的复杂性和混淆度，阻碍逆向工程和代码盗用。实际上就是一种保护 JS 代码的手段。</p>\n<p>那为什么我们需要保护 JS 代码呢 🤔️</p>\n<p>JS 最早被设计出来就是为了在客户端运行，直接以源码的形式传递给客户端，如果不做处理则完全公开透明，任何人都可以读、分析、复制、盗用，甚至篡改源码与数据，这是网站开发者不愿意看到的。</p>\n<h3 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h3><p>早期的 JS 代码承担功能少，逻辑简单且体积小，不需要保护。但随着技术的发展，JS 承担的功能越来越多， 文件体积增大。为了优化用户体验，开发者们想了很多办法去减小 JS 文件体积，以加快 HTTP 传输速度。JS 压缩（Minification）技术应运而生。</p>\n<p>常见的 JS 压缩手段很多，比如：</p>\n<ul>\n<li>删除 JS 代码中的空格、换行与注释；</li>\n<li>替换 JS 代码中的局部变量名；</li>\n<li>合并 JS 文件；</li>\n<li>……</li>\n</ul>\n<p>压缩工具开发的初衷是减小 JS 文件体积，但 JS 代码经过压缩替换后，其可读性也大大降低，间接起到了保护代码的作用。但是后来主流浏览器的开发者工具都提供了格式化代码的功能，压缩技术所能提供的安全保护收效甚微。于是专门保护 JS 代码的技术：JS 加密和 JS 混淆。</p>\n<blockquote>\n<p>本文不会介绍 JS 加密技术，只需要知道这两种技术相辅相成，不预先进行混淆的 JS 加密没有意义。</p>\n</blockquote>\n<h3 id=\"常见混淆手段\"><a href=\"#常见混淆手段\" class=\"headerlink\" title=\"常见混淆手段\"></a>常见混淆手段</h3><ul>\n<li><p>变量名&#x2F;函数名的替换，通过将有意义的变量名和函数名替换为随机生成的名称。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">function calculateArea(radius) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  return Math.PI * radius * radius;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">console.log(calculateArea(5));</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">_0x2d8f05</span>(<span class=\"params\">_0x4b083b</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"property\">PI</span> * _0x4b083b * _0x4b083b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">_0x2d8f05</span>(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串混淆，将代码中的字符串替换为编码或加密的形式，可以防止字符串被轻易读取。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// console.log(&quot;Hello, world!&quot;);</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;\\x48\\x65\\x6c\\x6c\\x6f\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x21&quot;</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>控制流混淆，改变代码的执行顺序或结构。例如，可以使用条件语句和循环语句来替换简单的赋值操作。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">let a = 1;</span></span><br><span class=\"line\"><span class=\"comment\">let b = 2;</span></span><br><span class=\"line\"><span class=\"comment\">let c = a + b;</span></span><br><span class=\"line\"><span class=\"comment\">console.log(c);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (b === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    c = a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>死代码插入，即在源码插入一些不会被执行的代码。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">let a = 1;</span></span><br><span class=\"line\"><span class=\"comment\">let b = 2;</span></span><br><span class=\"line\"><span class=\"comment\">let c = a + b;</span></span><br><span class=\"line\"><span class=\"comment\">console.log(c);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a - b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = a + b;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码转换，将代码转换为等价的，但更难理解的形式。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">let a = 1;</span></span><br><span class=\"line\"><span class=\"comment\">let b = 2;</span></span><br><span class=\"line\"><span class=\"comment\">let c = a + b;</span></span><br><span class=\"line\"><span class=\"comment\">console.log(c);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = a - (-b);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"常见反调试手段\"><a href=\"#常见反调试手段\" class=\"headerlink\" title=\"常见反调试手段\"></a>常见反调试手段</h3><p>实现防止他人调试、动态分析自己的代码，我们可以预先在代码中做处理，防止用户调试代码。</p>\n<ul>\n<li><p>无限 debugger。比如写个定时器死循环禁止调试。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">RegExp</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">c.<span class=\"property\">toString</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;检测到调试&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">setInterval</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">debugger</span></span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>内存耗尽。更隐蔽的反调试手段，代码运行造成的内存占用会越来越大，很快会使浏览器崩溃。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startTime = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">debugger</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> isDev = endTime - startTime &gt; <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> stack = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (isDev) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        stack.<span class=\"title function_\">push</span>(<span class=\"variable language_\">this</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(stack.<span class=\"property\">length</span>, <span class=\"variable language_\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>检测函数、对象属性修改。攻击者在调试的时，经常会把防护的函数删除，或者把检测数据对象进行篡改。可以检测函数内容，在原型上设置禁止修改。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">eval</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    [native code]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">eval</span> = <span class=\"keyword\">function</span>(<span class=\"params\">str</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;[native code]&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">eval</span> = <span class=\"keyword\">function</span>(<span class=\"params\">str</span>) &#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">eval</span>.<span class=\"property\">toString</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`function eval() &#123;[native code]&#125;`</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">hijacked</span>(<span class=\"params\">fun</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;prototype&quot;</span> <span class=\"keyword\">in</span> fun || fun.<span class=\"title function_\">toString</span>().<span class=\"title function_\">replace</span>(<span class=\"regexp\">/\\n|\\s/g</span>, <span class=\"string\">&quot;&quot;</span>) != <span class=\"string\">&quot;function&quot;</span> + fun.<span class=\"property\">name</span> + <span class=\"string\">&quot;() &#123;[nativecode]&#125;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"前端开发中的混淆\"><a href=\"#前端开发中的混淆\" class=\"headerlink\" title=\"前端开发中的混淆\"></a>前端开发中的混淆</h3><p>在 Web 前端开发中，开发者会对代码进行压缩和混淆，对代码进行优化，并提高安全性。已经有很多成熟的工具可以使用，比如 <a href=\"https://github.com/mishoo/UglifyJS\">UglifyJS</a> 和 <a href=\"https://github.com/javascript-obfuscator/javascript-obfuscator\">JavaScript Obfuscator</a>。</p>\n<p>混淆通常在项目的构建过程中进行。例如，我们使用 Vite 作为模块打包工具，就可以在 vite 的配置文件中添加UglifyJS 插件。这样，在每次构建项目时，UglifyJS就会自动对你的代码进行混淆。</p>\n<p>先安装插件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vite-plugin-uglify --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>然后在配置文件中添加该插件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; defineConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vite&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> vue <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">VitePluginUglify</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vite-plugin-uglify&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"title function_\">vue</span>(),</span><br><span class=\"line\">    <span class=\"title class_\">VitePluginUglify</span>()</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在这个配置文件中，<code>VitePluginUglify</code>被添加到了<code>plugins</code>数组中，所以在构建过程中，Vite 会自动使用<code>vite-plugin-uglify</code>对代码进行混淆。</p>\n<h3 id=\"在线混淆工具\"><a href=\"#在线混淆工具\" class=\"headerlink\" title=\"在线混淆工具\"></a>在线混淆工具</h3><p>有些站点提供了在线混淆的功能，比如 <a href=\"https://javascriptobfuscator.dev/\">Free JavaScript Obfuscator</a>，提供 JS 代码即可得到混淆后的结果。这个站点的混淆基于上面提到的 <a href=\"https://github.com/javascript-obfuscator/javascript-obfuscator\">JavaScript Obfuscator</a> 实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fibonacci</span>(<span class=\"params\">n</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fib = [<span class=\"number\">0</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    fib[i] = fib[i - <span class=\"number\">1</span>] + fib[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fib;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the first 10 numbers in the Fibonacci sequence</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">fibonacci</span>(<span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure>\n\n<p>以上代码的作用是计算斐波那契数列的前 10 个值并打印出来，经过混淆可得以下内容，可读性肉眼可见的降低：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> _0x323128=_0x5512;(<span class=\"keyword\">function</span>(<span class=\"params\">_0x589643,_0x5459af</span>)&#123;<span class=\"keyword\">const</span> _0x1b79b8=_0x5512,_0x3e96ed=<span class=\"title function_\">_0x589643</span>();<span class=\"keyword\">while</span>(!![])&#123;<span class=\"keyword\">try</span>&#123;<span class=\"keyword\">const</span> _0x1fb1b3=-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f1</span>))/<span class=\"number\">0x1</span>*(-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ea</span>))/<span class=\"number\">0x2</span>)+-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ec</span>))/<span class=\"number\">0x3</span>*(<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f3</span>))/<span class=\"number\">0x4</span>)+-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ed</span>))/<span class=\"number\">0x5</span>*(<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f2</span>))/<span class=\"number\">0x6</span>)+-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1e8</span>))/<span class=\"number\">0x7</span>+<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1e9</span>))/<span class=\"number\">0x8</span>*(-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f4</span>))/<span class=\"number\">0x9</span>)+<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1f0</span>))/<span class=\"number\">0xa</span>+-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ef</span>))/<span class=\"number\">0xb</span>*(-<span class=\"built_in\">parseInt</span>(<span class=\"title function_\">_0x1b79b8</span>(<span class=\"number\">0x1ee</span>))/<span class=\"number\">0xc</span>);<span class=\"keyword\">if</span>(_0x1fb1b3===_0x5459af)<span class=\"keyword\">break</span>;<span class=\"keyword\">else</span> _0x3e96ed[<span class=\"string\">&#x27;push&#x27;</span>](_0x3e96ed[<span class=\"string\">&#x27;shift&#x27;</span>]());&#125;<span class=\"keyword\">catch</span>(_0x56184c)&#123;_0x3e96ed[<span class=\"string\">&#x27;push&#x27;</span>](_0x3e96ed[<span class=\"string\">&#x27;shift&#x27;</span>]());&#125;&#125;&#125;(_0x138e,<span class=\"number\">0xdf35a</span>));<span class=\"keyword\">function</span> <span class=\"title function_\">_0x138e</span>(<span class=\"params\"></span>)&#123;<span class=\"keyword\">const</span> _0x3a0863=[<span class=\"string\">&#x27;354072hRaVAZ&#x27;</span>,<span class=\"string\">&#x27;9mNckCh&#x27;</span>,<span class=\"string\">&#x27;1622341lDdscp&#x27;</span>,<span class=\"string\">&#x27;2787864kenYBK&#x27;</span>,<span class=\"string\">&#x27;546362IExhCV&#x27;</span>,<span class=\"string\">&#x27;log&#x27;</span>,<span class=\"string\">&#x27;3fofuVm&#x27;</span>,<span class=\"string\">&#x27;1946005vlrFyq&#x27;</span>,<span class=\"string\">&#x27;516IsqKpc&#x27;</span>,<span class=\"string\">&#x27;725241tPbpzZ&#x27;</span>,<span class=\"string\">&#x27;316200mzqtLe&#x27;</span>,<span class=\"string\">&#x27;1mgkmrs&#x27;</span>,<span class=\"string\">&#x27;24Zwposp&#x27;</span>];_0x138e=<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;<span class=\"keyword\">return</span> _0x3a0863;&#125;;<span class=\"keyword\">return</span> <span class=\"title function_\">_0x138e</span>();&#125;<span class=\"keyword\">function</span> <span class=\"title function_\">fibonacci</span>(<span class=\"params\">_0x1b3125</span>)&#123;<span class=\"keyword\">let</span> _0x9e88df=[<span class=\"number\">0x0</span>,<span class=\"number\">0x1</span>];<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> _0x406b50=<span class=\"number\">0x2</span>;_0x406b50&lt;=_0x1b3125;_0x406b50++)&#123;_0x9e88df[_0x406b50]=_0x9e88df[_0x406b50-<span class=\"number\">0x1</span>]+_0x9e88df[_0x406b50-<span class=\"number\">0x2</span>];&#125;<span class=\"keyword\">return</span> _0x9e88df;&#125;<span class=\"keyword\">function</span> <span class=\"title function_\">_0x5512</span>(<span class=\"params\">_0x2d5465,_0x1d0a2f</span>)&#123;<span class=\"keyword\">const</span> _0x138ec4=<span class=\"title function_\">_0x138e</span>();<span class=\"keyword\">return</span> _0x5512=<span class=\"keyword\">function</span>(<span class=\"params\">_0x5512ef,_0x5e1f2e</span>)&#123;_0x5512ef=_0x5512ef-<span class=\"number\">0x1e8</span>;<span class=\"keyword\">let</span> _0x4be64a=_0x138ec4[_0x5512ef];<span class=\"keyword\">return</span> _0x4be64a;&#125;,<span class=\"title function_\">_0x5512</span>(_0x2d5465,_0x1d0a2f);&#125;<span class=\"variable language_\">console</span>[<span class=\"title function_\">_0x323128</span>(<span class=\"number\">0x1eb</span>)](<span class=\"title function_\">fibonacci</span>(<span class=\"number\">0xa</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Deobfuscator-反混淆\"><a href=\"#Deobfuscator-反混淆\" class=\"headerlink\" title=\"Deobfuscator 反混淆\"></a>Deobfuscator 反混淆</h2><p>JS 反混淆（Deobfuscator ）是指对经过混淆处理的代码进行还原和解析，以恢复其可读性。Deobfuscator 可以通过对代码进行静态分析和动态分析等方式来实现。需要注意的是，Obfuscation 只能降低可读性，不能完全避免逆向攻击，而 Deobfuscator 也并不能完全还原混淆过的代码。</p>\n<p>只要耐心分析，多数混淆过的 JS 已然能还原出来。</p>\n<h3 id=\"在线反混淆工具\"><a href=\"#在线反混淆工具\" class=\"headerlink\" title=\"在线反混淆工具\"></a>在线反混淆工具</h3><p>反混淆要有些趁手的工具。最常用的是浏览器自带的开发者工具，其次是一些转换混淆过的代码的工具。以下网站提供在线反混淆 JS 代码的功能：</p>\n<ul>\n<li><a href=\"https://seosniffer.com/javascript-deobfuscator\">javascript-deobfuscator</a></li>\n<li><a href=\"https://dev-coco.github.io/Online-Tools/JavaScript-Deobfuscator.html\">Raz1ner JavaScript Deobfuscator</a></li>\n<li><a href=\"https://deobfuscate.relative.im/\">synchrony deobuscator</a></li>\n<li><a href=\"https://beautifier.io/\">js-beauty</a></li>\n</ul>\n<p>以我们经过混淆的代码为例，丢进上述第一个网站，可以得到以下反混淆过的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fibonacci</span>(<span class=\"params\">jayandre</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ramonita = [<span class=\"number\">0</span>, <span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> ancel = <span class=\"number\">2</span>; ancel &lt;= jayandre; ancel++) &#123;</span><br><span class=\"line\">    ramonita[ancel] = ramonita[ancel - <span class=\"number\">1</span>] + ramonita[ancel - <span class=\"number\">2</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ramonita;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">fibonacci</span>(<span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure>\n\n<p>原本的逻辑已经较为清晰的展现了。当然也有一些库能用来反混淆本地 JS 文件，这里不多做介绍，感觉在线工具就够用了。</p>\n<h3 id=\"开发者工具\"><a href=\"#开发者工具\" class=\"headerlink\" title=\"开发者工具\"></a>开发者工具</h3><p>上面的反混淆站点只是辅助，真反混淆还得靠浏览器自带的开发者工具。接下来以chrome浏览器为例讲讲怎么用。</p>\n<p>在反混淆过程中，我们主要使用源代码（Source）和网络（Network）这两个模块。Network 用于查找我们进行用户操作时调用了哪些 API，在调用 API 前后运行了哪些 JS 文件；Source 提供了网站整体的 JS 代码及静态资源，我们的反混淆分析工作主要就在这里进行。</p>\n<p>在 Source 模块中，默认<code>ctrl+shift+p</code>可以开启开发者工具的命令行，我们可以找到两个“搜索”工具，分别对应“全局搜索”和“在当前文件中搜索”，很适合查找指定字段。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095405.png\" alt=\"20240222095405\"></p>\n<p>开发者工具提供了替换（Override）功能，开启本地替换选项，上传自己的目录，然后选中浏览器中指定 JS 文件，做出修改后<code>ctrl+s</code>保存，即可将源文件保存到我们自己的目录中，之后对文件做出的修改可以直接替换对应的原文件，这样就能方便的修改浏览器端 JS 文件。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095414.png\" alt=\"20240222095414\"></p>\n<p>剩下的就是动调了，后面会举例子解释。</p>\n<h3 id=\"静-动态调试\"><a href=\"#静-动态调试\" class=\"headerlink\" title=\"静&#x2F;动态调试\"></a>静&#x2F;动态调试</h3><p>先做个区分，逆网页的 JS 代码更多得是在开发者工具中做动调的。</p>\n<ul>\n<li>静态调试：静态调试是通过分析代码的结构和逻辑来理解其功能。这种方法不需要运行代码，只需要对代码进行分析和理解。例如，可以通过反汇编工具将二进制的可执行文件翻译成汇编代码，通过对代码的分析来破解软件。</li>\n<li>动态调试：动态调试则是在代码运行时进行的。通过设置断点，单步执行，观察变量的值变化等方式，来理解代码的运行过程和逻辑。动态调试可以有效应对多数混淆措施，从中还原出运行逻辑，是逆向分析的关键手段。前面说的反调试便是阻拦动态调试。</li>\n</ul>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"百度翻译接口\"><a href=\"#百度翻译接口\" class=\"headerlink\" title=\"百度翻译接口\"></a>百度翻译接口</h3><p>未登录状态下翻译字符串，观察 Network 可以找到<code>/v2transapi</code> POST 请求报文，其 payload 中表单的 <code>query</code>字段即为我们输入待翻译的字符串。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095423.png\" alt=\"20240222095423\"></p>\n<p>刷新页面多次翻译，发现只有<code>sign</code>字段的值在随<code>query</code>一直变化，<code>transtype</code>的值会根据触发翻译的方式在<code>realtime</code>和<code>enter</code>之间切换，其它字段值保持不变。我们接下来的任务就是分析<code>sign</code>字段的值是怎么来的。</p>\n<p>为了搞清楚<code>sign</code>是如何生成的，我们需要在 Sources 模块中全局搜索<code>sign</code>字段。但因为<code>sign</code>本身是一个常见的字段，我们很容易定位到其他与表单无关的地方。这里有一个小技巧，为了获得参数相关代码，我们可以搜索<code>sign:</code>或者<code>sign=</code>，以尽量避免定位到无关代码。</p>\n<p>在 Sources 模块中全局搜索<code>sign:</code>，定位到很多文件，根据文件名和文件内容，可以判断最有可能在 index.36217dc5.js 文件中，而该文件中出现了 6 处<code>sign:</code>相关代码，依次打断点并执行翻译操作，发现只会在 25800 行处的<code>sign: b(e);</code>处停下：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095432.png\" alt=\"20240222095432\"></p>\n<p>单步步进，可以发现参数 t 值即为传入的字符串：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095443.png\" alt=\"20240222095443\"></p>\n<p>把这段函数抽离出来，写到一个 main.js 文件中，调用该函数并运行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o, i = t.<span class=\"title function_\">match</span>(<span class=\"regexp\">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> === i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = t.<span class=\"property\">length</span>;</span><br><span class=\"line\">    a &gt; <span class=\"number\">30</span> &amp;&amp; (t = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(<span class=\"number\">0</span>, <span class=\"number\">10</span>)).<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(a / <span class=\"number\">2</span>) - <span class=\"number\">5</span>, <span class=\"number\">10</span>)).<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(-<span class=\"number\">10</span>, <span class=\"number\">10</span>)))</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> s = t.<span class=\"title function_\">split</span>(<span class=\"regexp\">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/</span>), c = <span class=\"number\">0</span>, u = s.<span class=\"property\">length</span>, l = []; c &lt; u; c++)</span><br><span class=\"line\">      <span class=\"string\">&quot;&quot;</span> !== s[c] &amp;&amp; l.<span class=\"property\">push</span>.<span class=\"title function_\">apply</span>(l, <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(t))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">e</span>(t)</span><br><span class=\"line\">      &#125;(o = s[c].<span class=\"title function_\">split</span>(<span class=\"string\">&quot;&quot;</span>)) || <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;undefined&quot;</span> != <span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span> &amp;&amp; <span class=\"literal\">null</span> != t[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>] || <span class=\"literal\">null</span> != t[<span class=\"string\">&quot;@@iterator&quot;</span>])</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(t)</span><br><span class=\"line\">      &#125;(o) || <span class=\"keyword\">function</span>(<span class=\"params\">t, n</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"string\">&quot;string&quot;</span> == <span class=\"keyword\">typeof</span> t)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">e</span>(t, n);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> r = <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(t).<span class=\"title function_\">slice</span>(<span class=\"number\">8</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">&quot;Object&quot;</span> === r &amp;&amp; t.<span class=\"property\">constructor</span> &amp;&amp; (r = t.<span class=\"property\">constructor</span>.<span class=\"property\">name</span>),</span><br><span class=\"line\">          <span class=\"string\">&quot;Map&quot;</span> === r || <span class=\"string\">&quot;Set&quot;</span> === r ? <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(t) : <span class=\"string\">&quot;Arguments&quot;</span> === r || <span class=\"regexp\">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.<span class=\"title function_\">test</span>(r) ? <span class=\"title function_\">e</span>(t, n) : <span class=\"keyword\">void</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;(o) || <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">&quot;Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span>)</span><br><span class=\"line\">      &#125;()),</span><br><span class=\"line\">      c !== u - <span class=\"number\">1</span> &amp;&amp; l.<span class=\"title function_\">push</span>(i[c]);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = l.<span class=\"property\">length</span>;</span><br><span class=\"line\">    p &gt; <span class=\"number\">30</span> &amp;&amp; (t = l.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">10</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>) + l.<span class=\"title function_\">slice</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(p / <span class=\"number\">2</span>) - <span class=\"number\">5</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(p / <span class=\"number\">2</span>) + <span class=\"number\">5</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>) + l.<span class=\"title function_\">slice</span>(-<span class=\"number\">10</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> d = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">103</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">116</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">107</span>)), h = (<span class=\"literal\">null</span> !== r ? r : (r = <span class=\"variable language_\">window</span>[d] || <span class=\"string\">&quot;&quot;</span>) || <span class=\"string\">&quot;&quot;</span>).<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>), f = <span class=\"title class_\">Number</span>(h[<span class=\"number\">0</span>]) || <span class=\"number\">0</span>, m = <span class=\"title class_\">Number</span>(h[<span class=\"number\">1</span>]) || <span class=\"number\">0</span>, g = [], y = <span class=\"number\">0</span>, v = <span class=\"number\">0</span>; v &lt; t.<span class=\"property\">length</span>; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _ = t.<span class=\"title function_\">charCodeAt</span>(v);</span><br><span class=\"line\">    _ &lt; <span class=\"number\">128</span> ? g[y++] = _ : (_ &lt; <span class=\"number\">2048</span> ? g[y++] = _ &gt;&gt; <span class=\"number\">6</span> | <span class=\"number\">192</span> : (<span class=\"number\">55296</span> == (<span class=\"number\">64512</span> &amp; _) &amp;&amp; v + <span class=\"number\">1</span> &lt; t.<span class=\"property\">length</span> &amp;&amp; <span class=\"number\">56320</span> == (<span class=\"number\">64512</span> &amp; t.<span class=\"title function_\">charCodeAt</span>(v + <span class=\"number\">1</span>)) ? (_ = <span class=\"number\">65536</span> + ((<span class=\"number\">1023</span> &amp; _) &lt;&lt; <span class=\"number\">10</span>) + (<span class=\"number\">1023</span> &amp; t.<span class=\"title function_\">charCodeAt</span>(++v)),</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">18</span> | <span class=\"number\">240</span>,</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">12</span> &amp; <span class=\"number\">63</span> | <span class=\"number\">128</span>) : g[y++] = _ &gt;&gt; <span class=\"number\">12</span> | <span class=\"number\">224</span>,</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">6</span> &amp; <span class=\"number\">63</span> | <span class=\"number\">128</span>),</span><br><span class=\"line\">    g[y++] = <span class=\"number\">63</span> &amp; _ | <span class=\"number\">128</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> b = f, w = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">97</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">94</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">54</span>)), k = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">51</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">94</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">98</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">102</span>)), x = <span class=\"number\">0</span>; x &lt; g.<span class=\"property\">length</span>; x++)</span><br><span class=\"line\">    b = <span class=\"title function_\">n</span>(b += g[x], w);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b = <span class=\"title function_\">n</span>(b, k),</span><br><span class=\"line\">  (b ^= m) &lt; <span class=\"number\">0</span> &amp;&amp; (b = <span class=\"number\">2147483648</span> + (<span class=\"number\">2147483647</span> &amp; b)),</span><br><span class=\"line\">  <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>((b %= <span class=\"number\">1e6</span>).<span class=\"title function_\">toString</span>(), <span class=\"string\">&quot;.&quot;</span>).<span class=\"title function_\">concat</span>(b ^ f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = <span class=\"string\">&quot;abandon&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">b</span>(query))</span><br></pre></td></tr></table></figure>\n\n<p>运行时报错，提示<code>r</code>未定义。在继续动调去找<code>r</code>是什么。步进调试到这一步时，发现<code>r</code>被赋值为<code>window[d]</code>，即 “320305.131321201”，在此之前其值一直为null。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095453.png\" alt=\"20240222095453\"></p>\n<p>我们可以发现<code>d</code>的值为<code>gtk</code>。我们本地是通过 Node.js 运行 JS 脚本，没有<code>window[]</code>这种 Web API，所以直接将<code>320305.131321201</code>硬编码进去。在此运行脚本，又会提示缺少<code>n</code>函数：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095459.png\" alt=\"20240222095459\"></p>\n<p>我们在面板中找到<code>n</code>函数，光标悬浮于上方可直接跳转到函数声明的地方：</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240222095511.png\" alt=\"20240222095511\"></p>\n<p>找到<code>n</code>函数后将其添加到 JS 脚本中，再次运行，即可得到结果<code>103339.356506</code>，这与我们在 Network 模块中查看到的<code>sign</code>值相同。</p>\n<p>最终脚本如下，输入<code>query</code>的值即可得到请求<code>/v2transapi</code>所需的 payload：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * function to generate sign</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">n = <span class=\"keyword\">function</span> (<span class=\"params\">t, e</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n = <span class=\"number\">0</span>; n &lt; e.<span class=\"property\">length</span> - <span class=\"number\">2</span>; n += <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> r = e.<span class=\"title function_\">charAt</span>(n + <span class=\"number\">2</span>);</span><br><span class=\"line\">      r = <span class=\"string\">&quot;a&quot;</span> &lt;= r ? r.<span class=\"title function_\">charCodeAt</span>(<span class=\"number\">0</span>) - <span class=\"number\">87</span> : <span class=\"title class_\">Number</span>(r),</span><br><span class=\"line\">      r = <span class=\"string\">&quot;+&quot;</span> === e.<span class=\"title function_\">charAt</span>(n + <span class=\"number\">1</span>) ? t &gt;&gt;&gt; r : t &lt;&lt; r,</span><br><span class=\"line\">      t = <span class=\"string\">&quot;+&quot;</span> === e.<span class=\"title function_\">charAt</span>(n) ? t + r &amp; <span class=\"number\">4294967295</span> : t ^ r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">b = <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o, i = t.<span class=\"title function_\">match</span>(<span class=\"regexp\">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> === i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = t.<span class=\"property\">length</span>;</span><br><span class=\"line\">    a &gt; <span class=\"number\">30</span> &amp;&amp; (t = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(<span class=\"number\">0</span>, <span class=\"number\">10</span>)).<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(a / <span class=\"number\">2</span>) - <span class=\"number\">5</span>, <span class=\"number\">10</span>)).<span class=\"title function_\">concat</span>(t.<span class=\"title function_\">substr</span>(-<span class=\"number\">10</span>, <span class=\"number\">10</span>)))</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> s = t.<span class=\"title function_\">split</span>(<span class=\"regexp\">/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/</span>), c = <span class=\"number\">0</span>, u = s.<span class=\"property\">length</span>, l = []; c &lt; u; c++)</span><br><span class=\"line\">      <span class=\"string\">&quot;&quot;</span> !== s[c] &amp;&amp; l.<span class=\"property\">push</span>.<span class=\"title function_\">apply</span>(l, <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(t))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title function_\">e</span>(t)</span><br><span class=\"line\">      &#125;(o = s[c].<span class=\"title function_\">split</span>(<span class=\"string\">&quot;&quot;</span>)) || <span class=\"keyword\">function</span>(<span class=\"params\">t</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;undefined&quot;</span> != <span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span> &amp;&amp; <span class=\"literal\">null</span> != t[<span class=\"title class_\">Symbol</span>.<span class=\"property\">iterator</span>] || <span class=\"literal\">null</span> != t[<span class=\"string\">&quot;@@iterator&quot;</span>])</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(t)</span><br><span class=\"line\">      &#125;(o) || <span class=\"keyword\">function</span>(<span class=\"params\">t, n</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"string\">&quot;string&quot;</span> == <span class=\"keyword\">typeof</span> t)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"title function_\">e</span>(t, n);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> r = <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">toString</span>.<span class=\"title function_\">call</span>(t).<span class=\"title function_\">slice</span>(<span class=\"number\">8</span>, -<span class=\"number\">1</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">&quot;Object&quot;</span> === r &amp;&amp; t.<span class=\"property\">constructor</span> &amp;&amp; (r = t.<span class=\"property\">constructor</span>.<span class=\"property\">name</span>),</span><br><span class=\"line\">          <span class=\"string\">&quot;Map&quot;</span> === r || <span class=\"string\">&quot;Set&quot;</span> === r ? <span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(t) : <span class=\"string\">&quot;Arguments&quot;</span> === r || <span class=\"regexp\">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.<span class=\"title function_\">test</span>(r) ? <span class=\"title function_\">e</span>(t, n) : <span class=\"keyword\">void</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;(o) || <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">&quot;Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.&quot;</span>)</span><br><span class=\"line\">      &#125;()),</span><br><span class=\"line\">      c !== u - <span class=\"number\">1</span> &amp;&amp; l.<span class=\"title function_\">push</span>(i[c]);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = l.<span class=\"property\">length</span>;</span><br><span class=\"line\">    p &gt; <span class=\"number\">30</span> &amp;&amp; (t = l.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>, <span class=\"number\">10</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>) + l.<span class=\"title function_\">slice</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(p / <span class=\"number\">2</span>) - <span class=\"number\">5</span>, <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(p / <span class=\"number\">2</span>) + <span class=\"number\">5</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>) + l.<span class=\"title function_\">slice</span>(-<span class=\"number\">10</span>).<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> d = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">103</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">116</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">107</span>)), h = (r = <span class=\"string\">&quot;320305.131321201&quot;</span>).<span class=\"title function_\">split</span>(<span class=\"string\">&quot;.&quot;</span>), f = <span class=\"title class_\">Number</span>(h[<span class=\"number\">0</span>]) || <span class=\"number\">0</span>, m = <span class=\"title class_\">Number</span>(h[<span class=\"number\">1</span>]) || <span class=\"number\">0</span>, g = [], y = <span class=\"number\">0</span>, v = <span class=\"number\">0</span>; v &lt; t.<span class=\"property\">length</span>; v++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _ = t.<span class=\"title function_\">charCodeAt</span>(v);</span><br><span class=\"line\">    _ &lt; <span class=\"number\">128</span> ? g[y++] = _ : (_ &lt; <span class=\"number\">2048</span> ? g[y++] = _ &gt;&gt; <span class=\"number\">6</span> | <span class=\"number\">192</span> : (<span class=\"number\">55296</span> == (<span class=\"number\">64512</span> &amp; _) &amp;&amp; v + <span class=\"number\">1</span> &lt; t.<span class=\"property\">length</span> &amp;&amp; <span class=\"number\">56320</span> == (<span class=\"number\">64512</span> &amp; t.<span class=\"title function_\">charCodeAt</span>(v + <span class=\"number\">1</span>)) ? (_ = <span class=\"number\">65536</span> + ((<span class=\"number\">1023</span> &amp; _) &lt;&lt; <span class=\"number\">10</span>) + (<span class=\"number\">1023</span> &amp; t.<span class=\"title function_\">charCodeAt</span>(++v)),</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">18</span> | <span class=\"number\">240</span>,</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">12</span> &amp; <span class=\"number\">63</span> | <span class=\"number\">128</span>) : g[y++] = _ &gt;&gt; <span class=\"number\">12</span> | <span class=\"number\">224</span>,</span><br><span class=\"line\">    g[y++] = _ &gt;&gt; <span class=\"number\">6</span> &amp; <span class=\"number\">63</span> | <span class=\"number\">128</span>),</span><br><span class=\"line\">    g[y++] = <span class=\"number\">63</span> &amp; _ | <span class=\"number\">128</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> b = f, w = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">97</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">94</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">54</span>)), k = <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">51</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">94</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">98</span>)) + <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">43</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">45</span>)).<span class=\"title function_\">concat</span>(<span class=\"title class_\">String</span>.<span class=\"title function_\">fromCharCode</span>(<span class=\"number\">102</span>)), x = <span class=\"number\">0</span>; x &lt; g.<span class=\"property\">length</span>; x++)</span><br><span class=\"line\">    b = <span class=\"title function_\">n</span>(b += g[x], w);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> b = <span class=\"title function_\">n</span>(b, k),</span><br><span class=\"line\">  (b ^= m) &lt; <span class=\"number\">0</span> &amp;&amp; (b = <span class=\"number\">2147483648</span> + (<span class=\"number\">2147483647</span> &amp; b)),</span><br><span class=\"line\">  <span class=\"string\">&quot;&quot;</span>.<span class=\"title function_\">concat</span>((b %= <span class=\"number\">1e6</span>).<span class=\"title function_\">toString</span>(), <span class=\"string\">&quot;.&quot;</span>).<span class=\"title function_\">concat</span>(b ^ f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * test</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> query = <span class=\"string\">&quot;abandon&quot;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`from=en&amp;to=zh&amp;query=<span class=\"subst\">$&#123;query&#125;</span>&amp;simple_means_flag=3&amp;sign=<span class=\"subst\">$&#123;b(query)&#125;</span>&amp;token=14025658070b41f40739347cef0ec62a&amp;domain=common&amp;ts=1708512893507`</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"掘金登录接口\"><a href=\"#掘金登录接口\" class=\"headerlink\" title=\"掘金登录接口\"></a>掘金登录接口</h3><p>登录时抓包，可以得到对<code>/passport/web/user/login</code>接口的请求报文：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># GET 查询字符串参数</span><br><span class=\"line\">aid: 2608</span><br><span class=\"line\">account_sdk_source: web</span><br><span class=\"line\">sdk_version: 2.2.6</span><br><span class=\"line\">verifyFp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79</span><br><span class=\"line\">fp: verify_lsom0d3u_s6mZvQBP_pamX_41TO_81V1_VRng2UjxFI79</span><br><span class=\"line\">sign: d9116c9cae3fcdf848f1288e1850eb2a489a4e23ece930692912a8bc155d89ec</span><br><span class=\"line\">qs: 6466666a706b715a76616e5a766a7077666029646c612963752976616e5a736077766c6a6b297360776c637c4375</span><br><span class=\"line\"></span><br><span class=\"line\"># POST 表单参数</span><br><span class=\"line\">mix_mode: 1</span><br><span class=\"line\">account: 34363d3336373d3d343c3c</span><br><span class=\"line\">password: 343736343736343736</span><br><span class=\"line\">fixed_mix_mode: 1</span><br></pre></td></tr></table></figure>\n\n<p>流程其实大差不差，就是搜参数、打断点、慢慢动调，基本都能找出来。掘金登录只需要 POST 表单参数正确即可，GET 参数不对也能过。以上参数中，会动态变化的只有<code>sign</code>、<code>account</code>和<code>password</code>，其中 GET 参数<code>sign</code>即使删掉也能过登录验证。</p>\n<p>具体过程不再贴图展示，这里直接提供获取 POST 表单参数的脚本，感兴趣的可以尝试去逆一下<code>sign</code>是如何生成的，难度比逆<code>account</code>和<code>password</code>要高一些：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * raw data</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> account = <span class=\"string\">&#x27;00000000000&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> password = <span class=\"string\">&#x27;1q2w3e&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * handle account and password</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> T = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t, n = [];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">void</span> <span class=\"number\">0</span> === e)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  t = <span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> t, n = e.<span class=\"title function_\">toString</span>(), r = [], a = <span class=\"number\">0</span>; a &lt; n.<span class=\"property\">length</span>; a++)</span><br><span class=\"line\">      <span class=\"number\">0</span> &lt;= (t = n.<span class=\"title function_\">charCodeAt</span>(a)) &amp;&amp; t &lt;= <span class=\"number\">127</span> ? r.<span class=\"title function_\">push</span>(t) : <span class=\"number\">128</span> &lt;= t &amp;&amp; t &lt;= <span class=\"number\">2047</span> ? (r.<span class=\"title function_\">push</span>(<span class=\"number\">192</span> | <span class=\"number\">31</span> &amp; t &gt;&gt; <span class=\"number\">6</span>),</span><br><span class=\"line\">      r.<span class=\"title function_\">push</span>(<span class=\"number\">128</span> | <span class=\"number\">63</span> &amp; t)) : (<span class=\"number\">2048</span> &lt;= t &amp;&amp; t &lt;= <span class=\"number\">55295</span> || <span class=\"number\">57344</span> &lt;= t &amp;&amp; t &lt;= <span class=\"number\">65535</span>) &amp;&amp; (r.<span class=\"title function_\">push</span>(<span class=\"number\">224</span> | <span class=\"number\">15</span> &amp; t &gt;&gt; <span class=\"number\">12</span>),</span><br><span class=\"line\">      r.<span class=\"title function_\">push</span>(<span class=\"number\">128</span> | <span class=\"number\">63</span> &amp; t &gt;&gt; <span class=\"number\">6</span>),</span><br><span class=\"line\">      r.<span class=\"title function_\">push</span>(<span class=\"number\">128</span> | <span class=\"number\">63</span> &amp; t));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; r.<span class=\"property\">length</span>; i++)</span><br><span class=\"line\">      r[i] &amp;= <span class=\"number\">255</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">  &#125;(e);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> r = <span class=\"number\">0</span>, a = t.<span class=\"property\">length</span>; r &lt; a; ++r)</span><br><span class=\"line\">    n.<span class=\"title function_\">push</span>((<span class=\"number\">5</span> ^ t[r]).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n.<span class=\"title function_\">join</span>(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * obtain the post form</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> postForm = <span class=\"string\">`mix_mode=1&amp;account=<span class=\"subst\">$&#123;T(account)&#125;</span>&amp;password=<span class=\"subst\">$&#123;T(password)&#125;</span>&amp;fixed_mix_mode=1`</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(postForm)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HGAME2024-2048-16\"><a href=\"#HGAME2024-2048-16\" class=\"headerlink\" title=\"HGAME2024 2048*16\"></a>HGAME2024 2048*16</h3><p>BaiMeow 师傅的题，HGAME2024 Week1 结束后不方便提供复现环境。题目考察了禁用 F12、反调试、JS 反混淆，比较全面。这里提一嘴。</p>\n<h2 id=\"参阅文章\"><a href=\"#参阅文章\" class=\"headerlink\" title=\"参阅文章\"></a>参阅文章</h2><ul>\n<li><a href=\"https://lizh.gitbook.io/knowledge/research/javascript-jia-mi-hun-xiao#hun-xiao-cha-jian\">Javascript加密混淆</a>，by 前端知识库</li>\n<li><a href=\"https://ek1ng.com/jsobuscation.html\">js混淆与反混淆</a>，by ek1ng</li>\n</ul>\n"},{"title":"JavaScript 原型链详解","date":"2024-02-13T16:00:00.000Z","author":"ma5hr00m","_content":"\n继续补档，发现这块内容其实蛮多的。后面估计还会有两篇（怎么还有两篇啊喂！），分别是 [JavaScript执行原理·补](#) 和 [JavaScript部分特性](#)，这周不知道能不能搞定。\n\n先看 JS 原型链吧。\n\n## JS 继承机制设计\n\n1994年，网景公司（Netscape）发布了 Navigator v0.9，轰动一时。但当时的网页不具备交互功能，数据的交互全部依赖服务器端，这浪费了时间与服务器资源。\n\n网景公司需要一种网页脚本语言实现用户与浏览器的互动，工程师 [Brendan Eich](https://brendaneich.com/) 负责该语言的开发。他认为这种语言不必复杂，只需进行一些简单操作即可，比如填写表单。\n\n可能是受当时面向对象编程（object-oriented programming）的影响，Brendan  设计的 JS 里面所有的数据类型都是对象（object）。他需要为 JS 设计一种机制把这些对象连接起来，即“继承”机制。\n\n> 继承允许子类继承父类的属性和方法，并且可以在子类中添加新的属性和方法，实现代码的重用和扩展性。\n\n出于设计的初衷，即“开发一种简单的网页脚本语言”，Brendan 没有选择给 JS 引入类（class）的概念，而是创造了基于原型链的继承机制。\n\n在 Java 等面向对象的语言中，一般是通过调用 class 的构造函数（construct）创建实例，如：\n\n```Java\nclass Dog {\n    public String name;\n    \n    public Dog(String name) {\n        this.name = name;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Dog dog = new Dog(\"Rover\");\n        System.out.println(dog.name); // Rover\n    }\n}\n```\n\nBrendam 为 JS 做了简化设计，直接对构造函数使用`new`创建实例：\n\n```JavaScript\nfunction Dog(name) {\n    this.name = name;\n}\n\nvar dog = new Dog(\"Rover\");\nconsole.log(dog.name) // Rover\n```\n\n这种设计避免了在 JS 中引入 class，但这引出一个问题：JS 的实例该如何共享属性和方法？基于构造函数创建的实例都是独立的副本。\n\n先看看 Java 是如何基于 class 实现属性和方法共享的：\n\n```Java\nclass Animal {\n    public void eat() {\n        System.out.println(\"Animal is eating\");\n    }\n}\n\nclass Dog extends Animal {\n    public void bark() {\n        System.out.println(\"Dog is barking\");\n    }\n}\n\nclass Cat extends Animal {\n    public void meow() {\n        System.out.println(\"Cat is meowing\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Dog myDog = new Dog();\n        Cat myCat = new Cat();\n        \n        myDog.eat(); // Animal is eating\n        myDog.bark(); // Dog is barking\n        myCat.eat(); // Animal is eating\n        myCat.meow(); // Cat is meowing\n    }\n}\n```\n\n在这个例子中，`Dog`和`Cat`子类继承了`Animal`父类的`eat()`方法，并分别添加了`bark()`和`meow()`方法，这种基于类实现的继承很顺畅也便于理解。\n\nJS 中没有 class，但这种需求切实存在。Brendan 通过为构造函数添加`prototype`属性解决这个问题。\n\n```JavaScript\nfunction Dog(name) {\n  this.name = name;\n}\n\nDog.prototype.bark = function() {\n    console.log(this.name)\n}\n\nvar dogA = new Dog(\"Rover\");\nvar dogB = new Dog(\"Fido\");\ndogA.bark(); // Rover\ndogB.bark(); // Fido\n```\n\n我们给构造函数`Dog`的`prototype`添加了`bark()`方法，这样做的话，基于`Dog`创建的实例都可以使用`bark()`方法，数据共享同理。\n\n那这是如何实现的呢，或者说，`prototype`是什么，为什么可以在多个实例之间共享属性及方法？这就是我们接下来要说的内容。\n\n在这里先丢一张图，接下来的内容可以搭配这张图一起看，相信这会对初学者理解 JS 原型链很有帮助：\n\n![img](https://wiki.wgpsec.org/images/js-prototype-chain-pollution/3.png)\n\n## prototype 原型\n\n在 JS 中，每个函数都有一个`prototype`属性，每个对象都有一个`__proto__`属性。\n\n函数的`prototype` 属性本质上是一个对象，它包含了通过这个函数作为构造函数（即使用 `new` 关键字）创建的所有实例所共享的属性和方法。\n\n而`__proto__`是所有对象都有的一个属性，它指向了创建这个对象的构造函数的`prototype`。也就是说，如果我们有`var dog = new Dog()`，那么`dog.__proto__`就是`Dog.prototype`。\n\n> “引用”是指一个变量或者对象指向内存中的一个位置，这个位置存储了某个值。这里也可以说`dog.__proto__`是`Dog.prototype`的一个引用。\n\n那么 JS 是如何通过`prototype`实现继承的呢？\n\n当我们试图访问一个对象的属性时，如果该对象本身没有这个属性，JS 就会去它的`__proto__`（也就是它的构造函数的`prototype`）中寻找。因为`prototype`本身也是一个对象，如果 JS 在`prototype`中也没有找到被访问的属性，那么它就会去`prototype`的`__proto__`中寻找，以此类推，直到找到这个属性或者到达原型链的末端`null`。\n\n通过这种方式，JS 就实现了它所需要的继承机制。这种通过对象的`__proto__`属性逐步向上查询的机制，就是我们所说的 JS 原型链。\n\n再拿这个例子做一次讲解：\n\n```JavaScript\nfunction Dog(name) {\n  this.name = name;\n}\n\nDog.prototype = {\n  \"species\": \"dog\",\n} \n  \nvar dog = new Dog('Rover');\n\nconsole.log(dog.name); // Rover\nconsole.log(dog.species); // dog\nconsole.log(dog.age); // undefined\nconsole.log(dog.__proto__.__proto__.__proto__); // null\n\nconsole.log(dog.__proto__ === Dog.prototype) // true\nconsole.log(Dog.prototype.__proto__ === Object.prototype) // true\nconsole.log(Object.prototype.__proto__) // null\n```\n\n调用`dog.name`时，JS 查找到`dog`实例有`name`属性，就返回`Rover`；\n\n调用`dog.species`时，JS 发现当前实例中没有该属性，就去`dog.__proto__`中查询，找到`species`属性并返回`dog`；\n\n调用`dog.age`时，JS 发现当前实例和当前实例的`__proto__`属性中都没有该属性，就再向上去寻找，也就到`Dog.prototype.__proto__`（即`Object.prototype`）中去寻找，已然没有找到，就继续向上找，但`Object.prototype.__proto__`是整条原型链的起点——`null`，JS 查找不到`age`属性，就会返回一个`undefined`；\n\n如果我们再向上查询一层，即尝试访问`dog.__proto__.__proto__.__proto__.__proto__`，会直接抛出报错，JS 定义`null`没有原型，yejiu1无法访问到它的`prototype`属性。\n\n## constructor 构造函数\n\n在 JS 中，每个函数对象还有一个特殊的属性叫做`constructor`。这个属性指向创建该对象的构造函数。当我们创建一个函数时，JS 会自动为该函数创建一个`prototype`对象，并且这个`prototype`对象包含一个指向该函数本身的`constructor`属性。\n\n当我们使用构造函数创建实例对象时，这些实例对象会继承构造函数的`prototype`对象，从而形成原型链。因此，通过`constructor`属性，实例对象就可以访问到创建它们的构造函数。\n\n直接把`constructor`当作反向`prototype`理解即可。以刚才的代码举例：\n\n```JavaScript\nconsole.log(Dog.prototype.constructor === Dog); // true\n```\n\n## 前端开发中的原型链\n\n### class 语法糖\n\n现在的 Web 前端开发中几乎不直接使用原型链了，JS 已经在 ES6（ECMAScript 2015）中引入了类（Class）的概念，因为这能使得面向对象编程更加直观。\n\n个人感觉这表示着 JS 与 Brendan Eich 当年所设想的“简单的客户端脚本语言”越走越偏了，但这也说明 JS 一直在蓬勃发展，活跃的社区生态让 JS 把它的触手伸向了互联网的角角落落，越来越多的开发者将 JS 变得愈来愈完善。\n\n但请注意，JS 的 class 在底层上仍然是基于原型链的，只是一种语法糖。\n\n```JavaScript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(this.name + ' makes a noise.');\n  }\n}\n\nlet animal = new Animal('Simba');\nanimal.speak(); // Outputs: \"Simba makes a noise.\"\n```\n\n以上代码是一个使用了 class 的 JS 示范，其基于原型链的版本如下：\n\n```JavaScript\nfunction Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function() {\n  console.log(this.name + ' makes a noise.');\n}\n\nlet animal = new Animal('Simba');\nanimal.speak(); // Outputs: \"Simba makes a noise.\"\n```\n\n这两个例子在功能上是相同的，但是它们的写法有所不同。class 语法提供了一种更清晰的方式来创建对象和处理继承。在 class 语法中，你可以直接在类定义内部声明方法，而在原型链中，你需要在原型对象上添加方法。\n\n### 性能影响\n\n我们前面说过，JS 在原型链中查找当前对象不存在的属性时，需要一级级的向上查找。如果我们要查找的属性在较深层的对象中，就会拖慢我们程序的运行速度；如果目标属性不存在中，JS 就会遍历整个原型链，这无疑会对程序的性能造成负面影响。\n\n此外，在遍历对象的属性时，原型链中的每个可枚举属性都将被枚举。如果我们想要检查一个对象是否具有某个属性，并且这个属性是直接定义在该对象上的，而不是定义在它的原型链上的，那么我们需要使用`hasOwnProperty`方法或`Object.hasOwn`方法。\n\n`hasOwnProperty`可以用来检查一个对象是否具有特定的自身属性（也就是该属性不是从原型链上继承来的）。这个方法是定义在`Object.prototype`上的，所以除非一个对象的原型链被设置为`null`（或者在原型链深层被覆盖），否则所有的对象都会继承这个方法。\n\n该方法的使用方法如下：\n\n```JavaScript\nlet obj = {\n    prop: 'value'\n};\nconsole.log(obj.hasOwnProperty('prop')); // 输出：true\n\nlet objWithNoProto = Object.create(null);\nconsole.log(objWithNoProto.hasOwnProperty); // 输出：undefined\n```\n\n此外，除非是为了与新的 JS 特性兼容，否则永远不应扩展原生原型。如果要使用 JS 原型链操作，也要对用户的输入进行严格校验，因为 JS 原型链有着独特的安全问题。\n\n## JS 原型链污染\n\n> JS 原型链污染推荐 phithon 大佬的 [深入理解 JavaScript Prototype 污染攻击](https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03)，以下`merge`示范代码就来自这篇文章。\n\n出于设计上的因素，JS 原型链操作容易产生独特的安全问题——JS 原型链污染。\n\n原理很简单，就是 JS 基于原型链实现的继承机制。如果我们能控制某个对象的原型，那我们就可以控制所有基于该原型创建的对象。以下是一个简单的示范案例：\n\n```JavaScript\n// 创建一个空对象 userA\nlet userA = {};\n\n// 给 userA 添加一个属性 isAdmin\nuserA.isAdmin = false;\nconsole.log(userA.isAdmin); // false\n\n// 现在我们想让所有用户都有这个属性，我们可以使用原型\nuserA.__proto__.isAdmin = true;\nconsole.log(userA.isAdmin); // false\n\n// 现在我们创建一个新用户 userB\nlet userB = {};\n// userB 会继承 userA 的 isAdmin 属性\nconsole.log(userB.isAdmin); // true\n```\n\n在 CTF 中，往往都是去找一些能够控制对象键名的操作，比如`merge`、`clone`等，这其中`merge`又是最常见的可操纵键名操作。最普通的`merge`函数如下：\n\n```JavaScript\nfunction merge(target, source) {\n  for (let key in source) {\n      if (key in source && key in target) {\n          merge(target[key], source[key])\n      } else {\n          target[key] = source[key]\n      }\n  }\n}\n```\n\n此时，我们运行以下代码，以 JSON 格式创建`o2`，在与`o1`合并的过程中，经过赋值操作`target[key] = source[key]`，实现了一个基本的原型链污染，被污染的对象是`Object.prototype`：\n\n```JavaScript\nlet o1 = {};\nlet o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}');\n\nmerge(o1, o2); // 1 2\nconsole.log(o1.a, o1.b);\n\no3 = {};\nconsole.log(o3.b); // 2\nconsole.log(Object.prototype); // [Object: null prototype] { b: 2 }\n```\n\n还有一个值得思考的问题，如果我们创建`o2`使用的语句是：`let o2 = {a: 1, \"__proto__\": {b: 2}}`，则不会实现原型链污染，可以思考一下原因。\n\n## 后话\n\n读到这里，应该就能大致理解什么是 JS 原型链了，也对开发和安全中的 JS 原型链有了一个基本的认识。\n\n但还有一个疑问没有解决：JS 原型链的本质是什么，它是一种机制，还是一种数据结构？\n\n原型链（Prototype Chain）从本质上来讲是一种机制，而不是某种特殊的数据结构。只是从习惯上来讲，我们会把从实例对象到 Object 这中间的 `__proto__` 调用称为“原型链”，上面说过的`dog.__proto__.__proto__.__proto__`就是例子——因为这确实很形象。\n\n## 参阅文章\n\n- [Javascript继承机制的设计思想](https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)，by 阮一峰的网络日志\n- [該來理解 JavaScript 的原型鍊了](https://blog.huli.tw/2017/08/27/the-javascripts-prototype-chain/)，by Huli's Blog\n- [继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)，by MDN Web Docs\n- [深入理解 JavaScript Prototype 污染攻击](https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03)，by phithon","source":"_posts/js-prototype-chain.md","raw":"---\ntitle: JavaScript 原型链详解\ndate: 2024/2/14\nauthor: ma5hr00m\ncategories:\n- JavaScript\n---\n\n继续补档，发现这块内容其实蛮多的。后面估计还会有两篇（怎么还有两篇啊喂！），分别是 [JavaScript执行原理·补](#) 和 [JavaScript部分特性](#)，这周不知道能不能搞定。\n\n先看 JS 原型链吧。\n\n## JS 继承机制设计\n\n1994年，网景公司（Netscape）发布了 Navigator v0.9，轰动一时。但当时的网页不具备交互功能，数据的交互全部依赖服务器端，这浪费了时间与服务器资源。\n\n网景公司需要一种网页脚本语言实现用户与浏览器的互动，工程师 [Brendan Eich](https://brendaneich.com/) 负责该语言的开发。他认为这种语言不必复杂，只需进行一些简单操作即可，比如填写表单。\n\n可能是受当时面向对象编程（object-oriented programming）的影响，Brendan  设计的 JS 里面所有的数据类型都是对象（object）。他需要为 JS 设计一种机制把这些对象连接起来，即“继承”机制。\n\n> 继承允许子类继承父类的属性和方法，并且可以在子类中添加新的属性和方法，实现代码的重用和扩展性。\n\n出于设计的初衷，即“开发一种简单的网页脚本语言”，Brendan 没有选择给 JS 引入类（class）的概念，而是创造了基于原型链的继承机制。\n\n在 Java 等面向对象的语言中，一般是通过调用 class 的构造函数（construct）创建实例，如：\n\n```Java\nclass Dog {\n    public String name;\n    \n    public Dog(String name) {\n        this.name = name;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Dog dog = new Dog(\"Rover\");\n        System.out.println(dog.name); // Rover\n    }\n}\n```\n\nBrendam 为 JS 做了简化设计，直接对构造函数使用`new`创建实例：\n\n```JavaScript\nfunction Dog(name) {\n    this.name = name;\n}\n\nvar dog = new Dog(\"Rover\");\nconsole.log(dog.name) // Rover\n```\n\n这种设计避免了在 JS 中引入 class，但这引出一个问题：JS 的实例该如何共享属性和方法？基于构造函数创建的实例都是独立的副本。\n\n先看看 Java 是如何基于 class 实现属性和方法共享的：\n\n```Java\nclass Animal {\n    public void eat() {\n        System.out.println(\"Animal is eating\");\n    }\n}\n\nclass Dog extends Animal {\n    public void bark() {\n        System.out.println(\"Dog is barking\");\n    }\n}\n\nclass Cat extends Animal {\n    public void meow() {\n        System.out.println(\"Cat is meowing\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Dog myDog = new Dog();\n        Cat myCat = new Cat();\n        \n        myDog.eat(); // Animal is eating\n        myDog.bark(); // Dog is barking\n        myCat.eat(); // Animal is eating\n        myCat.meow(); // Cat is meowing\n    }\n}\n```\n\n在这个例子中，`Dog`和`Cat`子类继承了`Animal`父类的`eat()`方法，并分别添加了`bark()`和`meow()`方法，这种基于类实现的继承很顺畅也便于理解。\n\nJS 中没有 class，但这种需求切实存在。Brendan 通过为构造函数添加`prototype`属性解决这个问题。\n\n```JavaScript\nfunction Dog(name) {\n  this.name = name;\n}\n\nDog.prototype.bark = function() {\n    console.log(this.name)\n}\n\nvar dogA = new Dog(\"Rover\");\nvar dogB = new Dog(\"Fido\");\ndogA.bark(); // Rover\ndogB.bark(); // Fido\n```\n\n我们给构造函数`Dog`的`prototype`添加了`bark()`方法，这样做的话，基于`Dog`创建的实例都可以使用`bark()`方法，数据共享同理。\n\n那这是如何实现的呢，或者说，`prototype`是什么，为什么可以在多个实例之间共享属性及方法？这就是我们接下来要说的内容。\n\n在这里先丢一张图，接下来的内容可以搭配这张图一起看，相信这会对初学者理解 JS 原型链很有帮助：\n\n![img](https://wiki.wgpsec.org/images/js-prototype-chain-pollution/3.png)\n\n## prototype 原型\n\n在 JS 中，每个函数都有一个`prototype`属性，每个对象都有一个`__proto__`属性。\n\n函数的`prototype` 属性本质上是一个对象，它包含了通过这个函数作为构造函数（即使用 `new` 关键字）创建的所有实例所共享的属性和方法。\n\n而`__proto__`是所有对象都有的一个属性，它指向了创建这个对象的构造函数的`prototype`。也就是说，如果我们有`var dog = new Dog()`，那么`dog.__proto__`就是`Dog.prototype`。\n\n> “引用”是指一个变量或者对象指向内存中的一个位置，这个位置存储了某个值。这里也可以说`dog.__proto__`是`Dog.prototype`的一个引用。\n\n那么 JS 是如何通过`prototype`实现继承的呢？\n\n当我们试图访问一个对象的属性时，如果该对象本身没有这个属性，JS 就会去它的`__proto__`（也就是它的构造函数的`prototype`）中寻找。因为`prototype`本身也是一个对象，如果 JS 在`prototype`中也没有找到被访问的属性，那么它就会去`prototype`的`__proto__`中寻找，以此类推，直到找到这个属性或者到达原型链的末端`null`。\n\n通过这种方式，JS 就实现了它所需要的继承机制。这种通过对象的`__proto__`属性逐步向上查询的机制，就是我们所说的 JS 原型链。\n\n再拿这个例子做一次讲解：\n\n```JavaScript\nfunction Dog(name) {\n  this.name = name;\n}\n\nDog.prototype = {\n  \"species\": \"dog\",\n} \n  \nvar dog = new Dog('Rover');\n\nconsole.log(dog.name); // Rover\nconsole.log(dog.species); // dog\nconsole.log(dog.age); // undefined\nconsole.log(dog.__proto__.__proto__.__proto__); // null\n\nconsole.log(dog.__proto__ === Dog.prototype) // true\nconsole.log(Dog.prototype.__proto__ === Object.prototype) // true\nconsole.log(Object.prototype.__proto__) // null\n```\n\n调用`dog.name`时，JS 查找到`dog`实例有`name`属性，就返回`Rover`；\n\n调用`dog.species`时，JS 发现当前实例中没有该属性，就去`dog.__proto__`中查询，找到`species`属性并返回`dog`；\n\n调用`dog.age`时，JS 发现当前实例和当前实例的`__proto__`属性中都没有该属性，就再向上去寻找，也就到`Dog.prototype.__proto__`（即`Object.prototype`）中去寻找，已然没有找到，就继续向上找，但`Object.prototype.__proto__`是整条原型链的起点——`null`，JS 查找不到`age`属性，就会返回一个`undefined`；\n\n如果我们再向上查询一层，即尝试访问`dog.__proto__.__proto__.__proto__.__proto__`，会直接抛出报错，JS 定义`null`没有原型，yejiu1无法访问到它的`prototype`属性。\n\n## constructor 构造函数\n\n在 JS 中，每个函数对象还有一个特殊的属性叫做`constructor`。这个属性指向创建该对象的构造函数。当我们创建一个函数时，JS 会自动为该函数创建一个`prototype`对象，并且这个`prototype`对象包含一个指向该函数本身的`constructor`属性。\n\n当我们使用构造函数创建实例对象时，这些实例对象会继承构造函数的`prototype`对象，从而形成原型链。因此，通过`constructor`属性，实例对象就可以访问到创建它们的构造函数。\n\n直接把`constructor`当作反向`prototype`理解即可。以刚才的代码举例：\n\n```JavaScript\nconsole.log(Dog.prototype.constructor === Dog); // true\n```\n\n## 前端开发中的原型链\n\n### class 语法糖\n\n现在的 Web 前端开发中几乎不直接使用原型链了，JS 已经在 ES6（ECMAScript 2015）中引入了类（Class）的概念，因为这能使得面向对象编程更加直观。\n\n个人感觉这表示着 JS 与 Brendan Eich 当年所设想的“简单的客户端脚本语言”越走越偏了，但这也说明 JS 一直在蓬勃发展，活跃的社区生态让 JS 把它的触手伸向了互联网的角角落落，越来越多的开发者将 JS 变得愈来愈完善。\n\n但请注意，JS 的 class 在底层上仍然是基于原型链的，只是一种语法糖。\n\n```JavaScript\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(this.name + ' makes a noise.');\n  }\n}\n\nlet animal = new Animal('Simba');\nanimal.speak(); // Outputs: \"Simba makes a noise.\"\n```\n\n以上代码是一个使用了 class 的 JS 示范，其基于原型链的版本如下：\n\n```JavaScript\nfunction Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function() {\n  console.log(this.name + ' makes a noise.');\n}\n\nlet animal = new Animal('Simba');\nanimal.speak(); // Outputs: \"Simba makes a noise.\"\n```\n\n这两个例子在功能上是相同的，但是它们的写法有所不同。class 语法提供了一种更清晰的方式来创建对象和处理继承。在 class 语法中，你可以直接在类定义内部声明方法，而在原型链中，你需要在原型对象上添加方法。\n\n### 性能影响\n\n我们前面说过，JS 在原型链中查找当前对象不存在的属性时，需要一级级的向上查找。如果我们要查找的属性在较深层的对象中，就会拖慢我们程序的运行速度；如果目标属性不存在中，JS 就会遍历整个原型链，这无疑会对程序的性能造成负面影响。\n\n此外，在遍历对象的属性时，原型链中的每个可枚举属性都将被枚举。如果我们想要检查一个对象是否具有某个属性，并且这个属性是直接定义在该对象上的，而不是定义在它的原型链上的，那么我们需要使用`hasOwnProperty`方法或`Object.hasOwn`方法。\n\n`hasOwnProperty`可以用来检查一个对象是否具有特定的自身属性（也就是该属性不是从原型链上继承来的）。这个方法是定义在`Object.prototype`上的，所以除非一个对象的原型链被设置为`null`（或者在原型链深层被覆盖），否则所有的对象都会继承这个方法。\n\n该方法的使用方法如下：\n\n```JavaScript\nlet obj = {\n    prop: 'value'\n};\nconsole.log(obj.hasOwnProperty('prop')); // 输出：true\n\nlet objWithNoProto = Object.create(null);\nconsole.log(objWithNoProto.hasOwnProperty); // 输出：undefined\n```\n\n此外，除非是为了与新的 JS 特性兼容，否则永远不应扩展原生原型。如果要使用 JS 原型链操作，也要对用户的输入进行严格校验，因为 JS 原型链有着独特的安全问题。\n\n## JS 原型链污染\n\n> JS 原型链污染推荐 phithon 大佬的 [深入理解 JavaScript Prototype 污染攻击](https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03)，以下`merge`示范代码就来自这篇文章。\n\n出于设计上的因素，JS 原型链操作容易产生独特的安全问题——JS 原型链污染。\n\n原理很简单，就是 JS 基于原型链实现的继承机制。如果我们能控制某个对象的原型，那我们就可以控制所有基于该原型创建的对象。以下是一个简单的示范案例：\n\n```JavaScript\n// 创建一个空对象 userA\nlet userA = {};\n\n// 给 userA 添加一个属性 isAdmin\nuserA.isAdmin = false;\nconsole.log(userA.isAdmin); // false\n\n// 现在我们想让所有用户都有这个属性，我们可以使用原型\nuserA.__proto__.isAdmin = true;\nconsole.log(userA.isAdmin); // false\n\n// 现在我们创建一个新用户 userB\nlet userB = {};\n// userB 会继承 userA 的 isAdmin 属性\nconsole.log(userB.isAdmin); // true\n```\n\n在 CTF 中，往往都是去找一些能够控制对象键名的操作，比如`merge`、`clone`等，这其中`merge`又是最常见的可操纵键名操作。最普通的`merge`函数如下：\n\n```JavaScript\nfunction merge(target, source) {\n  for (let key in source) {\n      if (key in source && key in target) {\n          merge(target[key], source[key])\n      } else {\n          target[key] = source[key]\n      }\n  }\n}\n```\n\n此时，我们运行以下代码，以 JSON 格式创建`o2`，在与`o1`合并的过程中，经过赋值操作`target[key] = source[key]`，实现了一个基本的原型链污染，被污染的对象是`Object.prototype`：\n\n```JavaScript\nlet o1 = {};\nlet o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}');\n\nmerge(o1, o2); // 1 2\nconsole.log(o1.a, o1.b);\n\no3 = {};\nconsole.log(o3.b); // 2\nconsole.log(Object.prototype); // [Object: null prototype] { b: 2 }\n```\n\n还有一个值得思考的问题，如果我们创建`o2`使用的语句是：`let o2 = {a: 1, \"__proto__\": {b: 2}}`，则不会实现原型链污染，可以思考一下原因。\n\n## 后话\n\n读到这里，应该就能大致理解什么是 JS 原型链了，也对开发和安全中的 JS 原型链有了一个基本的认识。\n\n但还有一个疑问没有解决：JS 原型链的本质是什么，它是一种机制，还是一种数据结构？\n\n原型链（Prototype Chain）从本质上来讲是一种机制，而不是某种特殊的数据结构。只是从习惯上来讲，我们会把从实例对象到 Object 这中间的 `__proto__` 调用称为“原型链”，上面说过的`dog.__proto__.__proto__.__proto__`就是例子——因为这确实很形象。\n\n## 参阅文章\n\n- [Javascript继承机制的设计思想](https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)，by 阮一峰的网络日志\n- [該來理解 JavaScript 的原型鍊了](https://blog.huli.tw/2017/08/27/the-javascripts-prototype-chain/)，by Huli's Blog\n- [继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)，by MDN Web Docs\n- [深入理解 JavaScript Prototype 污染攻击](https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03)，by phithon","slug":"js-prototype-chain","published":1,"updated":"2024-06-09T12:55:18.848Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap7000sf4ly3kga2gj1","content":"<p>继续补档，发现这块内容其实蛮多的。后面估计还会有两篇（怎么还有两篇啊喂！），分别是 <a href=\"#\">JavaScript执行原理·补</a> 和 <a href=\"#\">JavaScript部分特性</a>，这周不知道能不能搞定。</p>\n<p>先看 JS 原型链吧。</p>\n<h2 id=\"JS-继承机制设计\"><a href=\"#JS-继承机制设计\" class=\"headerlink\" title=\"JS 继承机制设计\"></a>JS 继承机制设计</h2><p>1994年，网景公司（Netscape）发布了 Navigator v0.9，轰动一时。但当时的网页不具备交互功能，数据的交互全部依赖服务器端，这浪费了时间与服务器资源。</p>\n<p>网景公司需要一种网页脚本语言实现用户与浏览器的互动，工程师 <a href=\"https://brendaneich.com/\">Brendan Eich</a> 负责该语言的开发。他认为这种语言不必复杂，只需进行一些简单操作即可，比如填写表单。</p>\n<p>可能是受当时面向对象编程（object-oriented programming）的影响，Brendan  设计的 JS 里面所有的数据类型都是对象（object）。他需要为 JS 设计一种机制把这些对象连接起来，即“继承”机制。</p>\n<blockquote>\n<p>继承允许子类继承父类的属性和方法，并且可以在子类中添加新的属性和方法，实现代码的重用和扩展性。</p>\n</blockquote>\n<p>出于设计的初衷，即“开发一种简单的网页脚本语言”，Brendan 没有选择给 JS 引入类（class）的概念，而是创造了基于原型链的继承机制。</p>\n<p>在 Java 等面向对象的语言中，一般是通过调用 class 的构造函数（construct）创建实例，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Dog</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Dog</span> <span class=\"variable\">dog</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Rover&quot;</span>);</span><br><span class=\"line\">        System.out.println(dog.name); <span class=\"comment\">// Rover</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Brendam 为 JS 做了简化设计，直接对构造函数使用<code>new</code>创建实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Dog</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Rover&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">name</span>) <span class=\"comment\">// Rover</span></span><br></pre></td></tr></table></figure>\n\n<p>这种设计避免了在 JS 中引入 class，但这引出一个问题：JS 的实例该如何共享属性和方法？基于构造函数创建的实例都是独立的副本。</p>\n<p>先看看 Java 是如何基于 class 实现属性和方法共享的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Animal is eating&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bark</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Dog is barking&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">meow</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Cat is meowing&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Dog</span> <span class=\"variable\">myDog</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\">        <span class=\"type\">Cat</span> <span class=\"variable\">myCat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        myDog.eat(); <span class=\"comment\">// Animal is eating</span></span><br><span class=\"line\">        myDog.bark(); <span class=\"comment\">// Dog is barking</span></span><br><span class=\"line\">        myCat.eat(); <span class=\"comment\">// Animal is eating</span></span><br><span class=\"line\">        myCat.meow(); <span class=\"comment\">// Cat is meowing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>Dog</code>和<code>Cat</code>子类继承了<code>Animal</code>父类的<code>eat()</code>方法，并分别添加了<code>bark()</code>和<code>meow()</code>方法，这种基于类实现的继承很顺畅也便于理解。</p>\n<p>JS 中没有 class，但这种需求切实存在。Brendan 通过为构造函数添加<code>prototype</code>属性解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Dog</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">bark</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dogA = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Rover&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dogB = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Fido&quot;</span>);</span><br><span class=\"line\">dogA.<span class=\"title function_\">bark</span>(); <span class=\"comment\">// Rover</span></span><br><span class=\"line\">dogB.<span class=\"title function_\">bark</span>(); <span class=\"comment\">// Fido</span></span><br></pre></td></tr></table></figure>\n\n<p>我们给构造函数<code>Dog</code>的<code>prototype</code>添加了<code>bark()</code>方法，这样做的话，基于<code>Dog</code>创建的实例都可以使用<code>bark()</code>方法，数据共享同理。</p>\n<p>那这是如何实现的呢，或者说，<code>prototype</code>是什么，为什么可以在多个实例之间共享属性及方法？这就是我们接下来要说的内容。</p>\n<p>在这里先丢一张图，接下来的内容可以搭配这张图一起看，相信这会对初学者理解 JS 原型链很有帮助：</p>\n<p><img src=\"https://wiki.wgpsec.org/images/js-prototype-chain-pollution/3.png\" alt=\"img\"></p>\n<h2 id=\"prototype-原型\"><a href=\"#prototype-原型\" class=\"headerlink\" title=\"prototype 原型\"></a>prototype 原型</h2><p>在 JS 中，每个函数都有一个<code>prototype</code>属性，每个对象都有一个<code>__proto__</code>属性。</p>\n<p>函数的<code>prototype</code> 属性本质上是一个对象，它包含了通过这个函数作为构造函数（即使用 <code>new</code> 关键字）创建的所有实例所共享的属性和方法。</p>\n<p>而<code>__proto__</code>是所有对象都有的一个属性，它指向了创建这个对象的构造函数的<code>prototype</code>。也就是说，如果我们有<code>var dog = new Dog()</code>，那么<code>dog.__proto__</code>就是<code>Dog.prototype</code>。</p>\n<blockquote>\n<p>“引用”是指一个变量或者对象指向内存中的一个位置，这个位置存储了某个值。这里也可以说<code>dog.__proto__</code>是<code>Dog.prototype</code>的一个引用。</p>\n</blockquote>\n<p>那么 JS 是如何通过<code>prototype</code>实现继承的呢？</p>\n<p>当我们试图访问一个对象的属性时，如果该对象本身没有这个属性，JS 就会去它的<code>__proto__</code>（也就是它的构造函数的<code>prototype</code>）中寻找。因为<code>prototype</code>本身也是一个对象，如果 JS 在<code>prototype</code>中也没有找到被访问的属性，那么它就会去<code>prototype</code>的<code>__proto__</code>中寻找，以此类推，直到找到这个属性或者到达原型链的末端<code>null</code>。</p>\n<p>通过这种方式，JS 就实现了它所需要的继承机制。这种通过对象的<code>__proto__</code>属性逐步向上查询的机制，就是我们所说的 JS 原型链。</p>\n<p>再拿这个例子做一次讲解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Dog</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;species&quot;</span>: <span class=\"string\">&quot;dog&quot;</span>,</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&#x27;Rover&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">name</span>); <span class=\"comment\">// Rover</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">species</span>); <span class=\"comment\">// dog</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">age</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span>); <span class=\"comment\">// null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span>) <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>调用<code>dog.name</code>时，JS 查找到<code>dog</code>实例有<code>name</code>属性，就返回<code>Rover</code>；</p>\n<p>调用<code>dog.species</code>时，JS 发现当前实例中没有该属性，就去<code>dog.__proto__</code>中查询，找到<code>species</code>属性并返回<code>dog</code>；</p>\n<p>调用<code>dog.age</code>时，JS 发现当前实例和当前实例的<code>__proto__</code>属性中都没有该属性，就再向上去寻找，也就到<code>Dog.prototype.__proto__</code>（即<code>Object.prototype</code>）中去寻找，已然没有找到，就继续向上找，但<code>Object.prototype.__proto__</code>是整条原型链的起点——<code>null</code>，JS 查找不到<code>age</code>属性，就会返回一个<code>undefined</code>；</p>\n<p>如果我们再向上查询一层，即尝试访问<code>dog.__proto__.__proto__.__proto__.__proto__</code>，会直接抛出报错，JS 定义<code>null</code>没有原型，yejiu1无法访问到它的<code>prototype</code>属性。</p>\n<h2 id=\"constructor-构造函数\"><a href=\"#constructor-构造函数\" class=\"headerlink\" title=\"constructor 构造函数\"></a>constructor 构造函数</h2><p>在 JS 中，每个函数对象还有一个特殊的属性叫做<code>constructor</code>。这个属性指向创建该对象的构造函数。当我们创建一个函数时，JS 会自动为该函数创建一个<code>prototype</code>对象，并且这个<code>prototype</code>对象包含一个指向该函数本身的<code>constructor</code>属性。</p>\n<p>当我们使用构造函数创建实例对象时，这些实例对象会继承构造函数的<code>prototype</code>对象，从而形成原型链。因此，通过<code>constructor</code>属性，实例对象就可以访问到创建它们的构造函数。</p>\n<p>直接把<code>constructor</code>当作反向<code>prototype</code>理解即可。以刚才的代码举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Dog</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"前端开发中的原型链\"><a href=\"#前端开发中的原型链\" class=\"headerlink\" title=\"前端开发中的原型链\"></a>前端开发中的原型链</h2><h3 id=\"class-语法糖\"><a href=\"#class-语法糖\" class=\"headerlink\" title=\"class 语法糖\"></a>class 语法糖</h3><p>现在的 Web 前端开发中几乎不直接使用原型链了，JS 已经在 ES6（ECMAScript 2015）中引入了类（Class）的概念，因为这能使得面向对象编程更加直观。</p>\n<p>个人感觉这表示着 JS 与 Brendan Eich 当年所设想的“简单的客户端脚本语言”越走越偏了，但这也说明 JS 一直在蓬勃发展，活跃的社区生态让 JS 把它的触手伸向了互联网的角角落落，越来越多的开发者将 JS 变得愈来愈完善。</p>\n<p>但请注意，JS 的 class 在底层上仍然是基于原型链的，只是一种语法糖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">speak</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&#x27; makes a noise.&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">&#x27;Simba&#x27;</span>);</span><br><span class=\"line\">animal.<span class=\"title function_\">speak</span>(); <span class=\"comment\">// Outputs: &quot;Simba makes a noise.&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上代码是一个使用了 class 的 JS 示范，其基于原型链的版本如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Animal</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Animal</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">speak</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&#x27; makes a noise.&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">&#x27;Simba&#x27;</span>);</span><br><span class=\"line\">animal.<span class=\"title function_\">speak</span>(); <span class=\"comment\">// Outputs: &quot;Simba makes a noise.&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这两个例子在功能上是相同的，但是它们的写法有所不同。class 语法提供了一种更清晰的方式来创建对象和处理继承。在 class 语法中，你可以直接在类定义内部声明方法，而在原型链中，你需要在原型对象上添加方法。</p>\n<h3 id=\"性能影响\"><a href=\"#性能影响\" class=\"headerlink\" title=\"性能影响\"></a>性能影响</h3><p>我们前面说过，JS 在原型链中查找当前对象不存在的属性时，需要一级级的向上查找。如果我们要查找的属性在较深层的对象中，就会拖慢我们程序的运行速度；如果目标属性不存在中，JS 就会遍历整个原型链，这无疑会对程序的性能造成负面影响。</p>\n<p>此外，在遍历对象的属性时，原型链中的每个可枚举属性都将被枚举。如果我们想要检查一个对象是否具有某个属性，并且这个属性是直接定义在该对象上的，而不是定义在它的原型链上的，那么我们需要使用<code>hasOwnProperty</code>方法或<code>Object.hasOwn</code>方法。</p>\n<p><code>hasOwnProperty</code>可以用来检查一个对象是否具有特定的自身属性（也就是该属性不是从原型链上继承来的）。这个方法是定义在<code>Object.prototype</code>上的，所以除非一个对象的原型链被设置为<code>null</code>（或者在原型链深层被覆盖），否则所有的对象都会继承这个方法。</p>\n<p>该方法的使用方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">prop</span>: <span class=\"string\">&#x27;value&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;prop&#x27;</span>)); <span class=\"comment\">// 输出：true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> objWithNoProto = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(objWithNoProto.<span class=\"property\">hasOwnProperty</span>); <span class=\"comment\">// 输出：undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，除非是为了与新的 JS 特性兼容，否则永远不应扩展原生原型。如果要使用 JS 原型链操作，也要对用户的输入进行严格校验，因为 JS 原型链有着独特的安全问题。</p>\n<h2 id=\"JS-原型链污染\"><a href=\"#JS-原型链污染\" class=\"headerlink\" title=\"JS 原型链污染\"></a>JS 原型链污染</h2><blockquote>\n<p>JS 原型链污染推荐 phithon 大佬的 <a href=\"https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03\">深入理解 JavaScript Prototype 污染攻击</a>，以下<code>merge</code>示范代码就来自这篇文章。</p>\n</blockquote>\n<p>出于设计上的因素，JS 原型链操作容易产生独特的安全问题——JS 原型链污染。</p>\n<p>原理很简单，就是 JS 基于原型链实现的继承机制。如果我们能控制某个对象的原型，那我们就可以控制所有基于该原型创建的对象。以下是一个简单的示范案例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个空对象 userA</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给 userA 添加一个属性 isAdmin</span></span><br><span class=\"line\">userA.<span class=\"property\">isAdmin</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(userA.<span class=\"property\">isAdmin</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在我们想让所有用户都有这个属性，我们可以使用原型</span></span><br><span class=\"line\">userA.<span class=\"property\">__proto__</span>.<span class=\"property\">isAdmin</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(userA.<span class=\"property\">isAdmin</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在我们创建一个新用户 userB</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userB = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// userB 会继承 userA 的 isAdmin 属性</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(userB.<span class=\"property\">isAdmin</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>在 CTF 中，往往都是去找一些能够控制对象键名的操作，比如<code>merge</code>、<code>clone</code>等，这其中<code>merge</code>又是最常见的可操纵键名操作。最普通的<code>merge</code>函数如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">merge</span>(<span class=\"params\">target, source</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (key <span class=\"keyword\">in</span> source &amp;&amp; key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">merge</span>(target[key], source[key])</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          target[key] = source[key]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，我们运行以下代码，以 JSON 格式创建<code>o2</code>，在与<code>o1</code>合并的过程中，经过赋值操作<code>target[key] = source[key]</code>，实现了一个基本的原型链污染，被污染的对象是<code>Object.prototype</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> o2 = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(<span class=\"string\">&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">merge</span>(o1, o2); <span class=\"comment\">// 1 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o1.<span class=\"property\">a</span>, o1.<span class=\"property\">b</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">o3 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o3.<span class=\"property\">b</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// [Object: null prototype] &#123; b: 2 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>还有一个值得思考的问题，如果我们创建<code>o2</code>使用的语句是：<code>let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</code>，则不会实现原型链污染，可以思考一下原因。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>读到这里，应该就能大致理解什么是 JS 原型链了，也对开发和安全中的 JS 原型链有了一个基本的认识。</p>\n<p>但还有一个疑问没有解决：JS 原型链的本质是什么，它是一种机制，还是一种数据结构？</p>\n<p>原型链（Prototype Chain）从本质上来讲是一种机制，而不是某种特殊的数据结构。只是从习惯上来讲，我们会把从实例对象到 Object 这中间的 <code>__proto__</code> 调用称为“原型链”，上面说过的<code>dog.__proto__.__proto__.__proto__</code>就是例子——因为这确实很形象。</p>\n<h2 id=\"参阅文章\"><a href=\"#参阅文章\" class=\"headerlink\" title=\"参阅文章\"></a>参阅文章</h2><ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html\">Javascript继承机制的设计思想</a>，by 阮一峰的网络日志</li>\n<li><a href=\"https://blog.huli.tw/2017/08/27/the-javascripts-prototype-chain/\">該來理解 JavaScript 的原型鍊了</a>，by Huli’s Blog</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">继承与原型链</a>，by MDN Web Docs</li>\n<li><a href=\"https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03\">深入理解 JavaScript Prototype 污染攻击</a>，by phithon</li>\n</ul>\n","excerpt":"","more":"<p>继续补档，发现这块内容其实蛮多的。后面估计还会有两篇（怎么还有两篇啊喂！），分别是 <a href=\"#\">JavaScript执行原理·补</a> 和 <a href=\"#\">JavaScript部分特性</a>，这周不知道能不能搞定。</p>\n<p>先看 JS 原型链吧。</p>\n<h2 id=\"JS-继承机制设计\"><a href=\"#JS-继承机制设计\" class=\"headerlink\" title=\"JS 继承机制设计\"></a>JS 继承机制设计</h2><p>1994年，网景公司（Netscape）发布了 Navigator v0.9，轰动一时。但当时的网页不具备交互功能，数据的交互全部依赖服务器端，这浪费了时间与服务器资源。</p>\n<p>网景公司需要一种网页脚本语言实现用户与浏览器的互动，工程师 <a href=\"https://brendaneich.com/\">Brendan Eich</a> 负责该语言的开发。他认为这种语言不必复杂，只需进行一些简单操作即可，比如填写表单。</p>\n<p>可能是受当时面向对象编程（object-oriented programming）的影响，Brendan  设计的 JS 里面所有的数据类型都是对象（object）。他需要为 JS 设计一种机制把这些对象连接起来，即“继承”机制。</p>\n<blockquote>\n<p>继承允许子类继承父类的属性和方法，并且可以在子类中添加新的属性和方法，实现代码的重用和扩展性。</p>\n</blockquote>\n<p>出于设计的初衷，即“开发一种简单的网页脚本语言”，Brendan 没有选择给 JS 引入类（class）的概念，而是创造了基于原型链的继承机制。</p>\n<p>在 Java 等面向对象的语言中，一般是通过调用 class 的构造函数（construct）创建实例，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Dog</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Dog</span> <span class=\"variable\">dog</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Rover&quot;</span>);</span><br><span class=\"line\">        System.out.println(dog.name); <span class=\"comment\">// Rover</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Brendam 为 JS 做了简化设计，直接对构造函数使用<code>new</code>创建实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Dog</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Rover&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">name</span>) <span class=\"comment\">// Rover</span></span><br></pre></td></tr></table></figure>\n\n<p>这种设计避免了在 JS 中引入 class，但这引出一个问题：JS 的实例该如何共享属性和方法？基于构造函数创建的实例都是独立的副本。</p>\n<p>先看看 Java 是如何基于 class 实现属性和方法共享的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Animal is eating&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bark</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Dog is barking&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">meow</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Cat is meowing&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Dog</span> <span class=\"variable\">myDog</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>();</span><br><span class=\"line\">        <span class=\"type\">Cat</span> <span class=\"variable\">myCat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        myDog.eat(); <span class=\"comment\">// Animal is eating</span></span><br><span class=\"line\">        myDog.bark(); <span class=\"comment\">// Dog is barking</span></span><br><span class=\"line\">        myCat.eat(); <span class=\"comment\">// Animal is eating</span></span><br><span class=\"line\">        myCat.meow(); <span class=\"comment\">// Cat is meowing</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>Dog</code>和<code>Cat</code>子类继承了<code>Animal</code>父类的<code>eat()</code>方法，并分别添加了<code>bark()</code>和<code>meow()</code>方法，这种基于类实现的继承很顺畅也便于理解。</p>\n<p>JS 中没有 class，但这种需求切实存在。Brendan 通过为构造函数添加<code>prototype</code>属性解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Dog</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">bark</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dogA = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Rover&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dogB = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&quot;Fido&quot;</span>);</span><br><span class=\"line\">dogA.<span class=\"title function_\">bark</span>(); <span class=\"comment\">// Rover</span></span><br><span class=\"line\">dogB.<span class=\"title function_\">bark</span>(); <span class=\"comment\">// Fido</span></span><br></pre></td></tr></table></figure>\n\n<p>我们给构造函数<code>Dog</code>的<code>prototype</code>添加了<code>bark()</code>方法，这样做的话，基于<code>Dog</code>创建的实例都可以使用<code>bark()</code>方法，数据共享同理。</p>\n<p>那这是如何实现的呢，或者说，<code>prototype</code>是什么，为什么可以在多个实例之间共享属性及方法？这就是我们接下来要说的内容。</p>\n<p>在这里先丢一张图，接下来的内容可以搭配这张图一起看，相信这会对初学者理解 JS 原型链很有帮助：</p>\n<p><img src=\"https://wiki.wgpsec.org/images/js-prototype-chain-pollution/3.png\" alt=\"img\"></p>\n<h2 id=\"prototype-原型\"><a href=\"#prototype-原型\" class=\"headerlink\" title=\"prototype 原型\"></a>prototype 原型</h2><p>在 JS 中，每个函数都有一个<code>prototype</code>属性，每个对象都有一个<code>__proto__</code>属性。</p>\n<p>函数的<code>prototype</code> 属性本质上是一个对象，它包含了通过这个函数作为构造函数（即使用 <code>new</code> 关键字）创建的所有实例所共享的属性和方法。</p>\n<p>而<code>__proto__</code>是所有对象都有的一个属性，它指向了创建这个对象的构造函数的<code>prototype</code>。也就是说，如果我们有<code>var dog = new Dog()</code>，那么<code>dog.__proto__</code>就是<code>Dog.prototype</code>。</p>\n<blockquote>\n<p>“引用”是指一个变量或者对象指向内存中的一个位置，这个位置存储了某个值。这里也可以说<code>dog.__proto__</code>是<code>Dog.prototype</code>的一个引用。</p>\n</blockquote>\n<p>那么 JS 是如何通过<code>prototype</code>实现继承的呢？</p>\n<p>当我们试图访问一个对象的属性时，如果该对象本身没有这个属性，JS 就会去它的<code>__proto__</code>（也就是它的构造函数的<code>prototype</code>）中寻找。因为<code>prototype</code>本身也是一个对象，如果 JS 在<code>prototype</code>中也没有找到被访问的属性，那么它就会去<code>prototype</code>的<code>__proto__</code>中寻找，以此类推，直到找到这个属性或者到达原型链的末端<code>null</code>。</p>\n<p>通过这种方式，JS 就实现了它所需要的继承机制。这种通过对象的<code>__proto__</code>属性逐步向上查询的机制，就是我们所说的 JS 原型链。</p>\n<p>再拿这个例子做一次讲解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Dog</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;species&quot;</span>: <span class=\"string\">&quot;dog&quot;</span>,</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> <span class=\"title class_\">Dog</span>(<span class=\"string\">&#x27;Rover&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">name</span>); <span class=\"comment\">// Rover</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">species</span>); <span class=\"comment\">// dog</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">age</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span>.<span class=\"property\">__proto__</span>); <span class=\"comment\">// null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(dog.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__proto__</span>) <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>调用<code>dog.name</code>时，JS 查找到<code>dog</code>实例有<code>name</code>属性，就返回<code>Rover</code>；</p>\n<p>调用<code>dog.species</code>时，JS 发现当前实例中没有该属性，就去<code>dog.__proto__</code>中查询，找到<code>species</code>属性并返回<code>dog</code>；</p>\n<p>调用<code>dog.age</code>时，JS 发现当前实例和当前实例的<code>__proto__</code>属性中都没有该属性，就再向上去寻找，也就到<code>Dog.prototype.__proto__</code>（即<code>Object.prototype</code>）中去寻找，已然没有找到，就继续向上找，但<code>Object.prototype.__proto__</code>是整条原型链的起点——<code>null</code>，JS 查找不到<code>age</code>属性，就会返回一个<code>undefined</code>；</p>\n<p>如果我们再向上查询一层，即尝试访问<code>dog.__proto__.__proto__.__proto__.__proto__</code>，会直接抛出报错，JS 定义<code>null</code>没有原型，yejiu1无法访问到它的<code>prototype</code>属性。</p>\n<h2 id=\"constructor-构造函数\"><a href=\"#constructor-构造函数\" class=\"headerlink\" title=\"constructor 构造函数\"></a>constructor 构造函数</h2><p>在 JS 中，每个函数对象还有一个特殊的属性叫做<code>constructor</code>。这个属性指向创建该对象的构造函数。当我们创建一个函数时，JS 会自动为该函数创建一个<code>prototype</code>对象，并且这个<code>prototype</code>对象包含一个指向该函数本身的<code>constructor</code>属性。</p>\n<p>当我们使用构造函数创建实例对象时，这些实例对象会继承构造函数的<code>prototype</code>对象，从而形成原型链。因此，通过<code>constructor</code>属性，实例对象就可以访问到创建它们的构造函数。</p>\n<p>直接把<code>constructor</code>当作反向<code>prototype</code>理解即可。以刚才的代码举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Dog</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Dog</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"前端开发中的原型链\"><a href=\"#前端开发中的原型链\" class=\"headerlink\" title=\"前端开发中的原型链\"></a>前端开发中的原型链</h2><h3 id=\"class-语法糖\"><a href=\"#class-语法糖\" class=\"headerlink\" title=\"class 语法糖\"></a>class 语法糖</h3><p>现在的 Web 前端开发中几乎不直接使用原型链了，JS 已经在 ES6（ECMAScript 2015）中引入了类（Class）的概念，因为这能使得面向对象编程更加直观。</p>\n<p>个人感觉这表示着 JS 与 Brendan Eich 当年所设想的“简单的客户端脚本语言”越走越偏了，但这也说明 JS 一直在蓬勃发展，活跃的社区生态让 JS 把它的触手伸向了互联网的角角落落，越来越多的开发者将 JS 变得愈来愈完善。</p>\n<p>但请注意，JS 的 class 在底层上仍然是基于原型链的，只是一种语法糖。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">speak</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&#x27; makes a noise.&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">&#x27;Simba&#x27;</span>);</span><br><span class=\"line\">animal.<span class=\"title function_\">speak</span>(); <span class=\"comment\">// Outputs: &quot;Simba makes a noise.&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>以上代码是一个使用了 class 的 JS 示范，其基于原型链的版本如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Animal</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Animal</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">speak</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> + <span class=\"string\">&#x27; makes a noise.&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">&#x27;Simba&#x27;</span>);</span><br><span class=\"line\">animal.<span class=\"title function_\">speak</span>(); <span class=\"comment\">// Outputs: &quot;Simba makes a noise.&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这两个例子在功能上是相同的，但是它们的写法有所不同。class 语法提供了一种更清晰的方式来创建对象和处理继承。在 class 语法中，你可以直接在类定义内部声明方法，而在原型链中，你需要在原型对象上添加方法。</p>\n<h3 id=\"性能影响\"><a href=\"#性能影响\" class=\"headerlink\" title=\"性能影响\"></a>性能影响</h3><p>我们前面说过，JS 在原型链中查找当前对象不存在的属性时，需要一级级的向上查找。如果我们要查找的属性在较深层的对象中，就会拖慢我们程序的运行速度；如果目标属性不存在中，JS 就会遍历整个原型链，这无疑会对程序的性能造成负面影响。</p>\n<p>此外，在遍历对象的属性时，原型链中的每个可枚举属性都将被枚举。如果我们想要检查一个对象是否具有某个属性，并且这个属性是直接定义在该对象上的，而不是定义在它的原型链上的，那么我们需要使用<code>hasOwnProperty</code>方法或<code>Object.hasOwn</code>方法。</p>\n<p><code>hasOwnProperty</code>可以用来检查一个对象是否具有特定的自身属性（也就是该属性不是从原型链上继承来的）。这个方法是定义在<code>Object.prototype</code>上的，所以除非一个对象的原型链被设置为<code>null</code>（或者在原型链深层被覆盖），否则所有的对象都会继承这个方法。</p>\n<p>该方法的使用方法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"attr\">prop</span>: <span class=\"string\">&#x27;value&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;prop&#x27;</span>)); <span class=\"comment\">// 输出：true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> objWithNoProto = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(objWithNoProto.<span class=\"property\">hasOwnProperty</span>); <span class=\"comment\">// 输出：undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，除非是为了与新的 JS 特性兼容，否则永远不应扩展原生原型。如果要使用 JS 原型链操作，也要对用户的输入进行严格校验，因为 JS 原型链有着独特的安全问题。</p>\n<h2 id=\"JS-原型链污染\"><a href=\"#JS-原型链污染\" class=\"headerlink\" title=\"JS 原型链污染\"></a>JS 原型链污染</h2><blockquote>\n<p>JS 原型链污染推荐 phithon 大佬的 <a href=\"https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03\">深入理解 JavaScript Prototype 污染攻击</a>，以下<code>merge</code>示范代码就来自这篇文章。</p>\n</blockquote>\n<p>出于设计上的因素，JS 原型链操作容易产生独特的安全问题——JS 原型链污染。</p>\n<p>原理很简单，就是 JS 基于原型链实现的继承机制。如果我们能控制某个对象的原型，那我们就可以控制所有基于该原型创建的对象。以下是一个简单的示范案例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个空对象 userA</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给 userA 添加一个属性 isAdmin</span></span><br><span class=\"line\">userA.<span class=\"property\">isAdmin</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(userA.<span class=\"property\">isAdmin</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在我们想让所有用户都有这个属性，我们可以使用原型</span></span><br><span class=\"line\">userA.<span class=\"property\">__proto__</span>.<span class=\"property\">isAdmin</span> = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(userA.<span class=\"property\">isAdmin</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在我们创建一个新用户 userB</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> userB = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// userB 会继承 userA 的 isAdmin 属性</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(userB.<span class=\"property\">isAdmin</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>在 CTF 中，往往都是去找一些能够控制对象键名的操作，比如<code>merge</code>、<code>clone</code>等，这其中<code>merge</code>又是最常见的可操纵键名操作。最普通的<code>merge</code>函数如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">merge</span>(<span class=\"params\">target, source</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (key <span class=\"keyword\">in</span> source &amp;&amp; key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">          <span class=\"title function_\">merge</span>(target[key], source[key])</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          target[key] = source[key]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，我们运行以下代码，以 JSON 格式创建<code>o2</code>，在与<code>o1</code>合并的过程中，经过赋值操作<code>target[key] = source[key]</code>，实现了一个基本的原型链污染，被污染的对象是<code>Object.prototype</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> o2 = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(<span class=\"string\">&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">merge</span>(o1, o2); <span class=\"comment\">// 1 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o1.<span class=\"property\">a</span>, o1.<span class=\"property\">b</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">o3 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o3.<span class=\"property\">b</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// [Object: null prototype] &#123; b: 2 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>还有一个值得思考的问题，如果我们创建<code>o2</code>使用的语句是：<code>let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</code>，则不会实现原型链污染，可以思考一下原因。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>读到这里，应该就能大致理解什么是 JS 原型链了，也对开发和安全中的 JS 原型链有了一个基本的认识。</p>\n<p>但还有一个疑问没有解决：JS 原型链的本质是什么，它是一种机制，还是一种数据结构？</p>\n<p>原型链（Prototype Chain）从本质上来讲是一种机制，而不是某种特殊的数据结构。只是从习惯上来讲，我们会把从实例对象到 Object 这中间的 <code>__proto__</code> 调用称为“原型链”，上面说过的<code>dog.__proto__.__proto__.__proto__</code>就是例子——因为这确实很形象。</p>\n<h2 id=\"参阅文章\"><a href=\"#参阅文章\" class=\"headerlink\" title=\"参阅文章\"></a>参阅文章</h2><ul>\n<li><a href=\"https://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html\">Javascript继承机制的设计思想</a>，by 阮一峰的网络日志</li>\n<li><a href=\"https://blog.huli.tw/2017/08/27/the-javascripts-prototype-chain/\">該來理解 JavaScript 的原型鍊了</a>，by Huli’s Blog</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">继承与原型链</a>，by MDN Web Docs</li>\n<li><a href=\"https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x03\">深入理解 JavaScript Prototype 污染攻击</a>，by phithon</li>\n</ul>\n"},{"title":"JavaScript 作用域与提升","date":"2024-02-15T16:00:00.000Z","author":"ma5hr00m","_content":"\n补档，本来想把【闭包】也一并放在本文中，但发现会有些臃肿，于是本文就只写作用域与提升。\n\n本文编写的 JavaScript 代码示范均使用 node v18.19.1，遵循 ES6 标准。\n\n## Scope 作用域\n\n什么是作用域呢？我的理解是：“变量的作用域就是该变量可访问的范围，函数对象同理”，作用域的作用是避免不同层级中的变量发生冲突。\n\nJS 中主要分为两种作用域：全局作用域（global scope）和局部作用域（local scope）。\n\n在 JS 中，局部作用域类似于“私人房间”，其中的变量只能在特定的区域内访问。当我们在局部作用域中声明变量时，它只能在该代码块、函数或条件语句中访问。局部作用域中的变量会受到外部代码干扰，例如：\n\n```JavaScript\nfunction myFunction() {\n  var localVariable = \"我在局部作用域中\";\n  console.log(localVariable);\n}\n\nmyFunction();\nconsole.log(localVariable);\n```\n\n在这段代码中，`localVariable`在局部作用域中声明，这意味着它只能在`myFunction`代码块内访问，尝试在作用域之外使用该变量会抛出`ReferenceError: localVariable is not defined`的报错。\n\n而全局作用域中中声明的变量可以在代码的任何地方访问。它可以类比为一个“公共广场”，所有人都可以看到和访问其中的内容。在全局作用域中声明的变量通常是在任何函数或代码块之外定义的。例如：\n\n```JavaScript\nvar globalVariable = \"我在全局作用域中\";\n\nfunction myFunction() {\n  console.log(globalVariable);\n}\n\nmyFunction();\nconsole.log(globalVariable);\n```\n\n在这个例子中，`globalVariable`在全局作用域中声明，`myFunction`中也可以直接访问它。因为`myFunction`函数中并没有对`globalVariable`显示地做出声明，也没有把其当作一个参数，同时满足这两个条件，我们就可以把`globalVariable`叫做自由变量（free variable）。\n\n还是在这个例子中，`myFunction`中使用了`globalVariable`，但当前作用域中并没有声明该变量，此时它就会向上一级作用域（这里是全局作用域）寻找该变量，如果在上一级没有找到，就向再上一级寻找，直到找到所需变量，或者抛出`is not defined`报错。这种\n\n```\nxxx-scope -> ... -> global scope\n```\n\n的查询方式，会形成一条作用域链（scope chain）。\n\n> 和 prototype chain 有些相似之处～\n\n### Block Scope 块级作用域\n\nES6 之前，JS 中只有全局/局部作用域，这会导致一些潜在的问题，如循环变量泄露：\n\n```JavaScript\nfor (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i); // Outputs: 3, 3, 3\n  }, 100);\n}\n```\n\n在上面的代码中，使用`var`在`for`循环中声明的变量`i`被提升到函数作用域，其值在循环的所有迭代中共享。这经常导致意外行为，特别是在处理像`setTimeout`这样的异步操作时。这对开发者来说很不方便，也不利于编写完善的代码。\n\n为了解决此类问题，ES6 中新增了`let&const`关键字以及块级作用域（block scope）。\n\n有了新的语法之后，我们就可以对上面的例子做出改进：\n\n```JavaScript\nfor (let j = 0; j < 3; j++) {\n  setTimeout(function() {\n    console.log(j); // Outputs: 0, 1, 2\n  }, 100);\n}\n```\n\n我们使用`let`，变量`j`的作用域就被限制在`for`循环的块内，确保每次迭代都为`j`创建一个新的词法环境。这可以防止与变量提升和异步操作等问题。\n\n因此，在实际开发过程中，我们一般推荐只使用`let&const`，不使用`var`，这可以最大程度避免我们代码出现 bug。\n\n### Static/Lexical Scope 静态作用域\n\n运行以下代码，会得到什么结果呢？\n\n```JavaScript\nvar x = 'global';\nfunction foo() {\n    console.log(x);\n}\nfunction bar() {\n    var x = 'local';\n    foo();\n}\nbar();\n```\n\n答案是`global`，这倒不难理解，按照前面说的，`foo()`函数被调用，发现函数作用域中没有`x`变量，就沿着作用域链向上寻找，在全局作用域中找到后就输出`global`。但在有些语言中会得到不同的输出结果。\n\n以 Perl 语言为例，实现同样功能的代码，会得到不同的输出：\n\n> 你可以使用该 [站点](https://www.jyshare.com/compile/) 在线运行以上代码并观察输出结果。\n\n```Perl\nour $x = 'global';\nsub foo {\n    print \"$x\\n\";\n}\nsub bar {\n    local $x = 'local';\n    foo();\n}\nbar(); # output: local\n```\n\n原因是这两种语言对作用域的定义不同。从本质上来讲，作用域就是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称查找变量。\n\n常见作用域有静态作用域（static scope）和动态作用域（dynamic scope），前者在词法分析阶段就已经决定，后者则是在代码执行过程中进行动态的划分，比如函数的作用域是在函数被调用时才决定。\n\nJS 采用的是静态作用域规则，我们在编写代码就已经决定了其作用域层级。静态作用域也叫做词法作用域（Lexical Scope），这个名称更加直白。\n\n> 如果你对什么是“词法分析”抱有疑问，可以参考我之前的文章：[JavaScript 执行原理](https://ma5hr00m.top/archives/2024/02/how-js-run.html)。\n\n## Hoisting 提升\n\n讲完作用域，我们可以来说说提升（hoisting）了。\n\nhoisting 是指将变量、函数或类的声明移动到它们所在的作用域的顶部，这允许开发者在代码中使用变量或函数时无需关心它们的声明位置。这里“移动”并不准确，但暂且按照这样理解也无妨。\n\n这是一个最简单的例子，我们在声明`ping()`之前调用了它，但这不会导致报错：\n\n```JavaScript\nping();\nfunction ping() {\n    console.log('pong');\n}\n```\n\n不抛出报错的原因就是 JS 引擎在运行时将`ping()`的声明“移动”到了函数调用之前，也就是提升了这个函数声明。\n\n为什么需要 hoisting 呢？在 Twitter 某位用户的询问中，Brendan Eich 回答了这个问题：\n\n> Function declaration hoisting is for mutual recursion & generally to avoid painful bottom-up ML-like order.\n\n在我们编写 JS 时，有时会遇到需要编写两个函数相互调用的情况，如果没有提升，处理这种情况就会变得繁琐。Brendan 不希望在 JS 中看到类似 ML 的自下而上的编程顺序。\n\n### 提升规则\n\n> 如果你只想知道 Hoisting 规则，而对其原理不感兴趣，只需看完本小节。\n\n这是变量提升的简单演示，运行代码会输出`undefined`而非`ReferenceError: a is not defined`：\n\n```JavaScript\nconsole.log(a) // output: undefined\nvar a = 1;\n```\n\nJS 引擎会提升变量声明操作，而不会提升变量赋值操作。以上代码等效于：\n\n```JavaScript\nvar a;\nconsole.log(a) // output: undefined\na = 1;\n```\n\n再来看这段代码，运行代码输出`2`而非`1`：\n\n```JavaScript\nfunction test(v){\n    console.log(v);\n    var v = 1;\n}\ntest(2); // output: 2\n```\n\n函数作用域中的变量也会提升，但因为我们调用`test()`时传入了参数`v`，所以在函数内代码运行之前会有一个隐性的函数声明+赋值操作，`var v = 1;`的声明操作也会提升，但因为`v=2`的赋值操作更先执行，所以会输出`2`。以上代码等效于：\n\n```JavaScript\nfunction test(v){\n    var v;\n    var v;\n    v = 2;\n    console.log(v);\n    v = 1;\n}\ntest(2); // output: 2\n```\n\n最后来看这段代码，运行代码输出`[Function: a]`而非`undefined`：\n\n```JavaScript\nconsole.log(a); // output: [Function: a]\nvar a;\nfunction a(){};\n```\n\n调换2、3行的声明顺序会得到相同结果。道理很简单，函数声明提升优先级 > 变量声明提升，无需过多解释。\n\n对以上三个示例做总结，可以得到以下 JS 中关于提升的三条规则：\n\n- 变量、函数声明操作都会提升；\n- 赋值操作不提升；\n- 函数声明操作优先级 > 变量声明优先级。\n\n### Execution Context 执行上下文\n\n在介绍 hoisting 实现原理之前，有必要先了解 JS 的执行上下文。\n\nES6 的执行上下文是指运行 JS 代码时的代码环境和相关信息。执行上下文包括三个部分：\n\n- 词法环境（lexical environment）\n- 变量环境（variable environment）\n- this 绑定（this binding）\n\n词法环境是一个存储标识符（变量，函数，类等）和它们的值的结构。词法环境有两个组成部分：环境记录（environment record）和外部环境引用（outer environment reference）。环境记录是一个存储当前作用域内的标识符和它们的值的对象；外部环境引用则是一个指向包含作用域的词法环境的指针。\n\n变量环境是一个与词法环境类似的结构，但是它只存储`var`声明的变量。在 ES6 之前，变量环境和词法环境是相同的，但是在 ES6 中引入了`let&const`关键字，变量环境和词法环境也有可能不同。\n\n`this`绑定是一个确定当前执行上下文中的`this`值的过程。`this`值取决于函数的调用方式，例如普通函数调用，方法调用，构造函数调用，箭头函数调用等。\n\n> `this`比较麻烦，本文中不细说。\n\n词法环境和变量环境本质上都是一种词法作用域，都是用来存储和查找标识符（变量，函数等）的值的结构。它们的区别在于，词法环境可以随着代码的执行而改变，而变量环境则保持不变。\n\n![20240226195039](https://img.ma5hr00m.top/blog/20240226195039.png)\n\n我们可以把词法环境理解为一个栈，每当进入一个新的作用域，就会创建一个新的词法环境，并将其压入栈顶。这个新的词法环境包含了当前作用域内的标识符和它们的值，以及一个指向外部词法环境的引用。当退出当前作用域时，就会将栈顶的词法环境弹出，恢复到上一个词法环境。这样，词法环境就能实现词法作用域的规则，即内部作用域可以访问外部作用域的标识符，但反之不行。\n\n变量环境则是一个特殊的词法环境，它只包含了用`var`声明的变量和函数声明。变量环境在执行上下文创建时就确定了，不会随着代码的执行而改变。这意味着，用`var`声明的变量和函数声明会被提升到它们所在的执行上下文的顶部，而不受块级作用域的限制。这也是为什么在 ES6 之前，JS 只有函数作用域，而没有块级作用域的原因。\n\nES6 引入了`let`和`const`关键字，它们创建的标识符只存在于词法环境中，而不在变量环境中。这样，就可以实现块级作用域，以及暂时性死区（TDZ）的特性。\n\n下面是一个例子，说明了词法环境和变量环境的区别：\n\n```JavaScript\n// 全局代码\nvar a = 1; // 在全局执行上下文的变量环境和词法环境中\nlet b = 2; // 只在全局执行上下文的词法环境中\n\nfunction foo() {\n  // 进入foo函数的执行上下文\n  var c = 3; // 在foo函数的执行上下文的变量环境和词法环境中\n  let d = 4; // 只在foo函数的执行上下文的词法环境中\n  console.log(a, b, c, d); // 1, 2, 3, 4\n  if (true) {\n    // 进入块级作用域\n    var e = 5; // 在foo函数的执行上下文的变量环境和词法环境中\n    let f = 6; // 只在块级作用域的词法环境中\n    console.log(a, b, c, d, e, f); // 1, 2, 3, 4, 5, 6\n  }\n  // 退出块级作用域\n  console.log(a, b, c, d, e); // 1, 2, 3, 4, 5\n  console.log(f); // ReferenceError: f is not defined\n}\n\n// 退出foo函数的执行上下文\nfoo();\nconsole.log(a, b); // 1, 2\nconsole.log(c, d, e, f); // ReferenceError: c is not defined\n```\n\n到这里应该就能理解词法环境和变量环境是什么了，如果还是感觉疑惑，不清楚这俩环境到底是什么，可以看看 [Variable Environment vs lexical environment](https://stackoverflow.com/questions/23948198/variable-environment-vs-lexical-environment) 这篇问答，里面解释得更详细一些。\n\n### 工作原理\n\n经过前面这么多铺垫，我感觉 Hoisting 的实现原理已经比较明晰。其实解释执行上下文的时候就已经算是在解释 Hositing 工作原理了。\n\n我们可以把 JS 执行划分为以下几个步骤，但重点放在提升操作上：\n\n1. 创建全局执行上下文，并将其压入执行栈。\n2. 对全局代码进行扫描，将`var`声明的变量添加到全局执行上下文的变量环境中，并赋值为`undefined`。将函数声明添加到全局执行上下文的词法环境中，并赋值为函数对象。对于`let`和`const`声明的变量，不会被提升，而是在全局执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。这就是暂时性死区（TDZ）的概念，即在变量被赋值之前，不能被访问或使用。\n3. 开始执行全局代码，按照顺序逐行执行。如果遇到函数调用，就创建一个函数执行上下文，并将其压入执行栈。\n4. 对函数代码进行扫描，将`var`声明的变量添加到函数执行上下文的变量环境中，并赋值为`undefined`。将函数声明添加到函数执行上下文的词法环境中，并赋值为函数对象。对于`let`和`const`声明的变量，同样不会被提升，而是在函数执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。\n5. 开始执行函数代码，按照顺序逐行执行。如果遇到函数调用，就重复步骤3和4。如果遇到`return`语句，就返回函数的结果，并将函数执行上下文从执行栈中弹出。\n6. 当全局代码执行完毕，就将全局执行上下文从执行栈中弹出，程序结束。\n\n流程如此，具体到代码中，把自己想象成 JS 引擎，按照上面的执行流程分析即可。如果感兴趣，可以试着分析以下代码，对应的输出也已经给在每行代码后面了：\n\n```JavaScript\nconsole.log(a); // undefined\nconsole.log(b); // ReferenceError: Cannot access 'b' before initialization\nconsole.log(c()); // 3\nconsole.log(d()); // TypeError: d is not a function\nvar a = 1;\nlet b = 2;\nfunction c() {\n  return 3;\n}\nvar d = function() {\n  return 4;\n};\n```\n\n## 补充\n\n文中有些概念并不明晰，但直接解释又会影响连贯性，于是摘出来放在这里。\n\n### ML-like Order\n\nML 是一种通用的函数式编程语言，具有可扩展的类型系统。它支持多态类型推断，这几乎消除了指定变量类型的负担，并极大地促进了代码的重用。ML 虽然没有得到广泛的使用，但它对其他语言产生了很大的影响，比如 Haskell、Rust、Scala 等。\n\n下面是一个用 Standard ML 编写的阶乘函数的例子：\n\n```\nfun factorial n =\n    if n = 0 then 1 else n * factorial (n-1)\n```\n\n这个函数必须在调用它的地方之前定义，否则会报错。\n\nML-like Order 是指 ML 语言中的函数定义顺序，它是自下而上的，也就是说，一个函数必须在它被调用之前定义。这样的顺序有时会导致一些不便，比如前面讲到的函数相互递归的情景，ML 就需要使用特殊的 fun 和 and 关键字，这种函数则会被称为互递归函数。比如判断一个自然数是奇数还是偶数：\n\n```\nfun isOdd n = if n = 0 then false else isEven (n-1)\nand isEven n = if n = 0 then true else isOdd (n-1)\n```\n\n为了避免这种情况，一些其他的语言（比如 JS）采用了函数声明提升（FDs hoisting）的机制，允许在任何地方定义函数，而不用考虑顺序。\n\n## 参阅文章\n\n- [解读ECMAScript[1\\]——执行环境、作用域及闭包](https://www.cnblogs.com/leoo2sk/archive/2010/12/19/ecmascript-scope.html)，by Eric Zhang\n- [详解JavaScript作用域和作用域链](https://juejin.cn/post/7030765196574457892#heading-8)，by Rockky\n- [所有的函式都是閉包：談 JS 中的作用域與 Closure](https://blog.huli.tw/2018/12/08/javascript-closure/)，by Huli\n- [我知道你懂 hoisting，可是你了解到多深](https://blog.huli.tw/2018/11/10/javascript-hoisting-and-tdz/)，by Huli\n- [ECMAScript® 2015 Language Specification](https://262.ecma-international.org/6.0/)","source":"_posts/js-scope-and-hoisting.md","raw":"---\ntitle: JavaScript 作用域与提升\ndate: 2024/02/16\nauthor: ma5hr00m\ncategories:\n- JavaScript\n---\n\n补档，本来想把【闭包】也一并放在本文中，但发现会有些臃肿，于是本文就只写作用域与提升。\n\n本文编写的 JavaScript 代码示范均使用 node v18.19.1，遵循 ES6 标准。\n\n## Scope 作用域\n\n什么是作用域呢？我的理解是：“变量的作用域就是该变量可访问的范围，函数对象同理”，作用域的作用是避免不同层级中的变量发生冲突。\n\nJS 中主要分为两种作用域：全局作用域（global scope）和局部作用域（local scope）。\n\n在 JS 中，局部作用域类似于“私人房间”，其中的变量只能在特定的区域内访问。当我们在局部作用域中声明变量时，它只能在该代码块、函数或条件语句中访问。局部作用域中的变量会受到外部代码干扰，例如：\n\n```JavaScript\nfunction myFunction() {\n  var localVariable = \"我在局部作用域中\";\n  console.log(localVariable);\n}\n\nmyFunction();\nconsole.log(localVariable);\n```\n\n在这段代码中，`localVariable`在局部作用域中声明，这意味着它只能在`myFunction`代码块内访问，尝试在作用域之外使用该变量会抛出`ReferenceError: localVariable is not defined`的报错。\n\n而全局作用域中中声明的变量可以在代码的任何地方访问。它可以类比为一个“公共广场”，所有人都可以看到和访问其中的内容。在全局作用域中声明的变量通常是在任何函数或代码块之外定义的。例如：\n\n```JavaScript\nvar globalVariable = \"我在全局作用域中\";\n\nfunction myFunction() {\n  console.log(globalVariable);\n}\n\nmyFunction();\nconsole.log(globalVariable);\n```\n\n在这个例子中，`globalVariable`在全局作用域中声明，`myFunction`中也可以直接访问它。因为`myFunction`函数中并没有对`globalVariable`显示地做出声明，也没有把其当作一个参数，同时满足这两个条件，我们就可以把`globalVariable`叫做自由变量（free variable）。\n\n还是在这个例子中，`myFunction`中使用了`globalVariable`，但当前作用域中并没有声明该变量，此时它就会向上一级作用域（这里是全局作用域）寻找该变量，如果在上一级没有找到，就向再上一级寻找，直到找到所需变量，或者抛出`is not defined`报错。这种\n\n```\nxxx-scope -> ... -> global scope\n```\n\n的查询方式，会形成一条作用域链（scope chain）。\n\n> 和 prototype chain 有些相似之处～\n\n### Block Scope 块级作用域\n\nES6 之前，JS 中只有全局/局部作用域，这会导致一些潜在的问题，如循环变量泄露：\n\n```JavaScript\nfor (var i = 0; i < 3; i++) {\n  setTimeout(function() {\n    console.log(i); // Outputs: 3, 3, 3\n  }, 100);\n}\n```\n\n在上面的代码中，使用`var`在`for`循环中声明的变量`i`被提升到函数作用域，其值在循环的所有迭代中共享。这经常导致意外行为，特别是在处理像`setTimeout`这样的异步操作时。这对开发者来说很不方便，也不利于编写完善的代码。\n\n为了解决此类问题，ES6 中新增了`let&const`关键字以及块级作用域（block scope）。\n\n有了新的语法之后，我们就可以对上面的例子做出改进：\n\n```JavaScript\nfor (let j = 0; j < 3; j++) {\n  setTimeout(function() {\n    console.log(j); // Outputs: 0, 1, 2\n  }, 100);\n}\n```\n\n我们使用`let`，变量`j`的作用域就被限制在`for`循环的块内，确保每次迭代都为`j`创建一个新的词法环境。这可以防止与变量提升和异步操作等问题。\n\n因此，在实际开发过程中，我们一般推荐只使用`let&const`，不使用`var`，这可以最大程度避免我们代码出现 bug。\n\n### Static/Lexical Scope 静态作用域\n\n运行以下代码，会得到什么结果呢？\n\n```JavaScript\nvar x = 'global';\nfunction foo() {\n    console.log(x);\n}\nfunction bar() {\n    var x = 'local';\n    foo();\n}\nbar();\n```\n\n答案是`global`，这倒不难理解，按照前面说的，`foo()`函数被调用，发现函数作用域中没有`x`变量，就沿着作用域链向上寻找，在全局作用域中找到后就输出`global`。但在有些语言中会得到不同的输出结果。\n\n以 Perl 语言为例，实现同样功能的代码，会得到不同的输出：\n\n> 你可以使用该 [站点](https://www.jyshare.com/compile/) 在线运行以上代码并观察输出结果。\n\n```Perl\nour $x = 'global';\nsub foo {\n    print \"$x\\n\";\n}\nsub bar {\n    local $x = 'local';\n    foo();\n}\nbar(); # output: local\n```\n\n原因是这两种语言对作用域的定义不同。从本质上来讲，作用域就是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称查找变量。\n\n常见作用域有静态作用域（static scope）和动态作用域（dynamic scope），前者在词法分析阶段就已经决定，后者则是在代码执行过程中进行动态的划分，比如函数的作用域是在函数被调用时才决定。\n\nJS 采用的是静态作用域规则，我们在编写代码就已经决定了其作用域层级。静态作用域也叫做词法作用域（Lexical Scope），这个名称更加直白。\n\n> 如果你对什么是“词法分析”抱有疑问，可以参考我之前的文章：[JavaScript 执行原理](https://ma5hr00m.top/archives/2024/02/how-js-run.html)。\n\n## Hoisting 提升\n\n讲完作用域，我们可以来说说提升（hoisting）了。\n\nhoisting 是指将变量、函数或类的声明移动到它们所在的作用域的顶部，这允许开发者在代码中使用变量或函数时无需关心它们的声明位置。这里“移动”并不准确，但暂且按照这样理解也无妨。\n\n这是一个最简单的例子，我们在声明`ping()`之前调用了它，但这不会导致报错：\n\n```JavaScript\nping();\nfunction ping() {\n    console.log('pong');\n}\n```\n\n不抛出报错的原因就是 JS 引擎在运行时将`ping()`的声明“移动”到了函数调用之前，也就是提升了这个函数声明。\n\n为什么需要 hoisting 呢？在 Twitter 某位用户的询问中，Brendan Eich 回答了这个问题：\n\n> Function declaration hoisting is for mutual recursion & generally to avoid painful bottom-up ML-like order.\n\n在我们编写 JS 时，有时会遇到需要编写两个函数相互调用的情况，如果没有提升，处理这种情况就会变得繁琐。Brendan 不希望在 JS 中看到类似 ML 的自下而上的编程顺序。\n\n### 提升规则\n\n> 如果你只想知道 Hoisting 规则，而对其原理不感兴趣，只需看完本小节。\n\n这是变量提升的简单演示，运行代码会输出`undefined`而非`ReferenceError: a is not defined`：\n\n```JavaScript\nconsole.log(a) // output: undefined\nvar a = 1;\n```\n\nJS 引擎会提升变量声明操作，而不会提升变量赋值操作。以上代码等效于：\n\n```JavaScript\nvar a;\nconsole.log(a) // output: undefined\na = 1;\n```\n\n再来看这段代码，运行代码输出`2`而非`1`：\n\n```JavaScript\nfunction test(v){\n    console.log(v);\n    var v = 1;\n}\ntest(2); // output: 2\n```\n\n函数作用域中的变量也会提升，但因为我们调用`test()`时传入了参数`v`，所以在函数内代码运行之前会有一个隐性的函数声明+赋值操作，`var v = 1;`的声明操作也会提升，但因为`v=2`的赋值操作更先执行，所以会输出`2`。以上代码等效于：\n\n```JavaScript\nfunction test(v){\n    var v;\n    var v;\n    v = 2;\n    console.log(v);\n    v = 1;\n}\ntest(2); // output: 2\n```\n\n最后来看这段代码，运行代码输出`[Function: a]`而非`undefined`：\n\n```JavaScript\nconsole.log(a); // output: [Function: a]\nvar a;\nfunction a(){};\n```\n\n调换2、3行的声明顺序会得到相同结果。道理很简单，函数声明提升优先级 > 变量声明提升，无需过多解释。\n\n对以上三个示例做总结，可以得到以下 JS 中关于提升的三条规则：\n\n- 变量、函数声明操作都会提升；\n- 赋值操作不提升；\n- 函数声明操作优先级 > 变量声明优先级。\n\n### Execution Context 执行上下文\n\n在介绍 hoisting 实现原理之前，有必要先了解 JS 的执行上下文。\n\nES6 的执行上下文是指运行 JS 代码时的代码环境和相关信息。执行上下文包括三个部分：\n\n- 词法环境（lexical environment）\n- 变量环境（variable environment）\n- this 绑定（this binding）\n\n词法环境是一个存储标识符（变量，函数，类等）和它们的值的结构。词法环境有两个组成部分：环境记录（environment record）和外部环境引用（outer environment reference）。环境记录是一个存储当前作用域内的标识符和它们的值的对象；外部环境引用则是一个指向包含作用域的词法环境的指针。\n\n变量环境是一个与词法环境类似的结构，但是它只存储`var`声明的变量。在 ES6 之前，变量环境和词法环境是相同的，但是在 ES6 中引入了`let&const`关键字，变量环境和词法环境也有可能不同。\n\n`this`绑定是一个确定当前执行上下文中的`this`值的过程。`this`值取决于函数的调用方式，例如普通函数调用，方法调用，构造函数调用，箭头函数调用等。\n\n> `this`比较麻烦，本文中不细说。\n\n词法环境和变量环境本质上都是一种词法作用域，都是用来存储和查找标识符（变量，函数等）的值的结构。它们的区别在于，词法环境可以随着代码的执行而改变，而变量环境则保持不变。\n\n![20240226195039](https://img.ma5hr00m.top/blog/20240226195039.png)\n\n我们可以把词法环境理解为一个栈，每当进入一个新的作用域，就会创建一个新的词法环境，并将其压入栈顶。这个新的词法环境包含了当前作用域内的标识符和它们的值，以及一个指向外部词法环境的引用。当退出当前作用域时，就会将栈顶的词法环境弹出，恢复到上一个词法环境。这样，词法环境就能实现词法作用域的规则，即内部作用域可以访问外部作用域的标识符，但反之不行。\n\n变量环境则是一个特殊的词法环境，它只包含了用`var`声明的变量和函数声明。变量环境在执行上下文创建时就确定了，不会随着代码的执行而改变。这意味着，用`var`声明的变量和函数声明会被提升到它们所在的执行上下文的顶部，而不受块级作用域的限制。这也是为什么在 ES6 之前，JS 只有函数作用域，而没有块级作用域的原因。\n\nES6 引入了`let`和`const`关键字，它们创建的标识符只存在于词法环境中，而不在变量环境中。这样，就可以实现块级作用域，以及暂时性死区（TDZ）的特性。\n\n下面是一个例子，说明了词法环境和变量环境的区别：\n\n```JavaScript\n// 全局代码\nvar a = 1; // 在全局执行上下文的变量环境和词法环境中\nlet b = 2; // 只在全局执行上下文的词法环境中\n\nfunction foo() {\n  // 进入foo函数的执行上下文\n  var c = 3; // 在foo函数的执行上下文的变量环境和词法环境中\n  let d = 4; // 只在foo函数的执行上下文的词法环境中\n  console.log(a, b, c, d); // 1, 2, 3, 4\n  if (true) {\n    // 进入块级作用域\n    var e = 5; // 在foo函数的执行上下文的变量环境和词法环境中\n    let f = 6; // 只在块级作用域的词法环境中\n    console.log(a, b, c, d, e, f); // 1, 2, 3, 4, 5, 6\n  }\n  // 退出块级作用域\n  console.log(a, b, c, d, e); // 1, 2, 3, 4, 5\n  console.log(f); // ReferenceError: f is not defined\n}\n\n// 退出foo函数的执行上下文\nfoo();\nconsole.log(a, b); // 1, 2\nconsole.log(c, d, e, f); // ReferenceError: c is not defined\n```\n\n到这里应该就能理解词法环境和变量环境是什么了，如果还是感觉疑惑，不清楚这俩环境到底是什么，可以看看 [Variable Environment vs lexical environment](https://stackoverflow.com/questions/23948198/variable-environment-vs-lexical-environment) 这篇问答，里面解释得更详细一些。\n\n### 工作原理\n\n经过前面这么多铺垫，我感觉 Hoisting 的实现原理已经比较明晰。其实解释执行上下文的时候就已经算是在解释 Hositing 工作原理了。\n\n我们可以把 JS 执行划分为以下几个步骤，但重点放在提升操作上：\n\n1. 创建全局执行上下文，并将其压入执行栈。\n2. 对全局代码进行扫描，将`var`声明的变量添加到全局执行上下文的变量环境中，并赋值为`undefined`。将函数声明添加到全局执行上下文的词法环境中，并赋值为函数对象。对于`let`和`const`声明的变量，不会被提升，而是在全局执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。这就是暂时性死区（TDZ）的概念，即在变量被赋值之前，不能被访问或使用。\n3. 开始执行全局代码，按照顺序逐行执行。如果遇到函数调用，就创建一个函数执行上下文，并将其压入执行栈。\n4. 对函数代码进行扫描，将`var`声明的变量添加到函数执行上下文的变量环境中，并赋值为`undefined`。将函数声明添加到函数执行上下文的词法环境中，并赋值为函数对象。对于`let`和`const`声明的变量，同样不会被提升，而是在函数执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。\n5. 开始执行函数代码，按照顺序逐行执行。如果遇到函数调用，就重复步骤3和4。如果遇到`return`语句，就返回函数的结果，并将函数执行上下文从执行栈中弹出。\n6. 当全局代码执行完毕，就将全局执行上下文从执行栈中弹出，程序结束。\n\n流程如此，具体到代码中，把自己想象成 JS 引擎，按照上面的执行流程分析即可。如果感兴趣，可以试着分析以下代码，对应的输出也已经给在每行代码后面了：\n\n```JavaScript\nconsole.log(a); // undefined\nconsole.log(b); // ReferenceError: Cannot access 'b' before initialization\nconsole.log(c()); // 3\nconsole.log(d()); // TypeError: d is not a function\nvar a = 1;\nlet b = 2;\nfunction c() {\n  return 3;\n}\nvar d = function() {\n  return 4;\n};\n```\n\n## 补充\n\n文中有些概念并不明晰，但直接解释又会影响连贯性，于是摘出来放在这里。\n\n### ML-like Order\n\nML 是一种通用的函数式编程语言，具有可扩展的类型系统。它支持多态类型推断，这几乎消除了指定变量类型的负担，并极大地促进了代码的重用。ML 虽然没有得到广泛的使用，但它对其他语言产生了很大的影响，比如 Haskell、Rust、Scala 等。\n\n下面是一个用 Standard ML 编写的阶乘函数的例子：\n\n```\nfun factorial n =\n    if n = 0 then 1 else n * factorial (n-1)\n```\n\n这个函数必须在调用它的地方之前定义，否则会报错。\n\nML-like Order 是指 ML 语言中的函数定义顺序，它是自下而上的，也就是说，一个函数必须在它被调用之前定义。这样的顺序有时会导致一些不便，比如前面讲到的函数相互递归的情景，ML 就需要使用特殊的 fun 和 and 关键字，这种函数则会被称为互递归函数。比如判断一个自然数是奇数还是偶数：\n\n```\nfun isOdd n = if n = 0 then false else isEven (n-1)\nand isEven n = if n = 0 then true else isOdd (n-1)\n```\n\n为了避免这种情况，一些其他的语言（比如 JS）采用了函数声明提升（FDs hoisting）的机制，允许在任何地方定义函数，而不用考虑顺序。\n\n## 参阅文章\n\n- [解读ECMAScript[1\\]——执行环境、作用域及闭包](https://www.cnblogs.com/leoo2sk/archive/2010/12/19/ecmascript-scope.html)，by Eric Zhang\n- [详解JavaScript作用域和作用域链](https://juejin.cn/post/7030765196574457892#heading-8)，by Rockky\n- [所有的函式都是閉包：談 JS 中的作用域與 Closure](https://blog.huli.tw/2018/12/08/javascript-closure/)，by Huli\n- [我知道你懂 hoisting，可是你了解到多深](https://blog.huli.tw/2018/11/10/javascript-hoisting-and-tdz/)，by Huli\n- [ECMAScript® 2015 Language Specification](https://262.ecma-international.org/6.0/)","slug":"js-scope-and-hoisting","published":1,"updated":"2024-06-09T12:55:16.794Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap8000tf4lygcko4722","content":"<p>补档，本来想把【闭包】也一并放在本文中，但发现会有些臃肿，于是本文就只写作用域与提升。</p>\n<p>本文编写的 JavaScript 代码示范均使用 node v18.19.1，遵循 ES6 标准。</p>\n<h2 id=\"Scope-作用域\"><a href=\"#Scope-作用域\" class=\"headerlink\" title=\"Scope 作用域\"></a>Scope 作用域</h2><p>什么是作用域呢？我的理解是：“变量的作用域就是该变量可访问的范围，函数对象同理”，作用域的作用是避免不同层级中的变量发生冲突。</p>\n<p>JS 中主要分为两种作用域：全局作用域（global scope）和局部作用域（local scope）。</p>\n<p>在 JS 中，局部作用域类似于“私人房间”，其中的变量只能在特定的区域内访问。当我们在局部作用域中声明变量时，它只能在该代码块、函数或条件语句中访问。局部作用域中的变量会受到外部代码干扰，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> localVariable = <span class=\"string\">&quot;我在局部作用域中&quot;</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(localVariable);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">myFunction</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(localVariable);</span><br></pre></td></tr></table></figure>\n\n<p>在这段代码中，<code>localVariable</code>在局部作用域中声明，这意味着它只能在<code>myFunction</code>代码块内访问，尝试在作用域之外使用该变量会抛出<code>ReferenceError: localVariable is not defined</code>的报错。</p>\n<p>而全局作用域中中声明的变量可以在代码的任何地方访问。它可以类比为一个“公共广场”，所有人都可以看到和访问其中的内容。在全局作用域中声明的变量通常是在任何函数或代码块之外定义的。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globalVariable = <span class=\"string\">&quot;我在全局作用域中&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globalVariable);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">myFunction</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globalVariable);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>globalVariable</code>在全局作用域中声明，<code>myFunction</code>中也可以直接访问它。因为<code>myFunction</code>函数中并没有对<code>globalVariable</code>显示地做出声明，也没有把其当作一个参数，同时满足这两个条件，我们就可以把<code>globalVariable</code>叫做自由变量（free variable）。</p>\n<p>还是在这个例子中，<code>myFunction</code>中使用了<code>globalVariable</code>，但当前作用域中并没有声明该变量，此时它就会向上一级作用域（这里是全局作用域）寻找该变量，如果在上一级没有找到，就向再上一级寻找，直到找到所需变量，或者抛出<code>is not defined</code>报错。这种</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx-scope -&gt; ... -&gt; global scope</span><br></pre></td></tr></table></figure>\n\n<p>的查询方式，会形成一条作用域链（scope chain）。</p>\n<blockquote>\n<p>和 prototype chain 有些相似之处～</p>\n</blockquote>\n<h3 id=\"Block-Scope-块级作用域\"><a href=\"#Block-Scope-块级作用域\" class=\"headerlink\" title=\"Block Scope 块级作用域\"></a>Block Scope 块级作用域</h3><p>ES6 之前，JS 中只有全局&#x2F;局部作用域，这会导致一些潜在的问题，如循环变量泄露：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// Outputs: 3, 3, 3</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，使用<code>var</code>在<code>for</code>循环中声明的变量<code>i</code>被提升到函数作用域，其值在循环的所有迭代中共享。这经常导致意外行为，特别是在处理像<code>setTimeout</code>这样的异步操作时。这对开发者来说很不方便，也不利于编写完善的代码。</p>\n<p>为了解决此类问题，ES6 中新增了<code>let&amp;const</code>关键字以及块级作用域（block scope）。</p>\n<p>有了新的语法之后，我们就可以对上面的例子做出改进：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j); <span class=\"comment\">// Outputs: 0, 1, 2</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用<code>let</code>，变量<code>j</code>的作用域就被限制在<code>for</code>循环的块内，确保每次迭代都为<code>j</code>创建一个新的词法环境。这可以防止与变量提升和异步操作等问题。</p>\n<p>因此，在实际开发过程中，我们一般推荐只使用<code>let&amp;const</code>，不使用<code>var</code>，这可以最大程度避免我们代码出现 bug。</p>\n<h3 id=\"Static-Lexical-Scope-静态作用域\"><a href=\"#Static-Lexical-Scope-静态作用域\" class=\"headerlink\" title=\"Static&#x2F;Lexical Scope 静态作用域\"></a>Static&#x2F;Lexical Scope 静态作用域</h3><p>运行以下代码，会得到什么结果呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">&#x27;global&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"string\">&#x27;local&#x27;</span>;</span><br><span class=\"line\">    <span class=\"title function_\">foo</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">bar</span>();</span><br></pre></td></tr></table></figure>\n\n<p>答案是<code>global</code>，这倒不难理解，按照前面说的，<code>foo()</code>函数被调用，发现函数作用域中没有<code>x</code>变量，就沿着作用域链向上寻找，在全局作用域中找到后就输出<code>global</code>。但在有些语言中会得到不同的输出结果。</p>\n<p>以 Perl 语言为例，实现同样功能的代码，会得到不同的输出：</p>\n<blockquote>\n<p>你可以使用该 <a href=\"https://www.jyshare.com/compile/\">站点</a> 在线运行以上代码并观察输出结果。</p>\n</blockquote>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">our</span> $x = <span class=\"string\">&#x27;global&#x27;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">sub</span> <span class=\"title\">foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;$x\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">sub</span> <span class=\"title\">bar</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">local</span> $x = <span class=\"string\">&#x27;local&#x27;</span>;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(); <span class=\"comment\"># output: local</span></span><br></pre></td></tr></table></figure>\n\n<p>原因是这两种语言对作用域的定义不同。从本质上来讲，作用域就是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称查找变量。</p>\n<p>常见作用域有静态作用域（static scope）和动态作用域（dynamic scope），前者在词法分析阶段就已经决定，后者则是在代码执行过程中进行动态的划分，比如函数的作用域是在函数被调用时才决定。</p>\n<p>JS 采用的是静态作用域规则，我们在编写代码就已经决定了其作用域层级。静态作用域也叫做词法作用域（Lexical Scope），这个名称更加直白。</p>\n<blockquote>\n<p>如果你对什么是“词法分析”抱有疑问，可以参考我之前的文章：<a href=\"https://ma5hr00m.top/archives/2024/02/how-js-run.html\">JavaScript 执行原理</a>。</p>\n</blockquote>\n<h2 id=\"Hoisting-提升\"><a href=\"#Hoisting-提升\" class=\"headerlink\" title=\"Hoisting 提升\"></a>Hoisting 提升</h2><p>讲完作用域，我们可以来说说提升（hoisting）了。</p>\n<p>hoisting 是指将变量、函数或类的声明移动到它们所在的作用域的顶部，这允许开发者在代码中使用变量或函数时无需关心它们的声明位置。这里“移动”并不准确，但暂且按照这样理解也无妨。</p>\n<p>这是一个最简单的例子，我们在声明<code>ping()</code>之前调用了它，但这不会导致报错：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">ping</span>();</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ping</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;pong&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不抛出报错的原因就是 JS 引擎在运行时将<code>ping()</code>的声明“移动”到了函数调用之前，也就是提升了这个函数声明。</p>\n<p>为什么需要 hoisting 呢？在 Twitter 某位用户的询问中，Brendan Eich 回答了这个问题：</p>\n<blockquote>\n<p>Function declaration hoisting is for mutual recursion &amp; generally to avoid painful bottom-up ML-like order.</p>\n</blockquote>\n<p>在我们编写 JS 时，有时会遇到需要编写两个函数相互调用的情况，如果没有提升，处理这种情况就会变得繁琐。Brendan 不希望在 JS 中看到类似 ML 的自下而上的编程顺序。</p>\n<h3 id=\"提升规则\"><a href=\"#提升规则\" class=\"headerlink\" title=\"提升规则\"></a>提升规则</h3><blockquote>\n<p>如果你只想知道 Hoisting 规则，而对其原理不感兴趣，只需看完本小节。</p>\n</blockquote>\n<p>这是变量提升的简单演示，运行代码会输出<code>undefined</code>而非<code>ReferenceError: a is not defined</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// output: undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>JS 引擎会提升变量声明操作，而不会提升变量赋值操作。以上代码等效于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// output: undefined</span></span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>再来看这段代码，运行代码输出<code>2</code>而非<code>1</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"number\">2</span>); <span class=\"comment\">// output: 2</span></span><br></pre></td></tr></table></figure>\n\n<p>函数作用域中的变量也会提升，但因为我们调用<code>test()</code>时传入了参数<code>v</code>，所以在函数内代码运行之前会有一个隐性的函数声明+赋值操作，<code>var v = 1;</code>的声明操作也会提升，但因为<code>v=2</code>的赋值操作更先执行，所以会输出<code>2</code>。以上代码等效于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v;</span><br><span class=\"line\">    v = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v);</span><br><span class=\"line\">    v = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"number\">2</span>); <span class=\"comment\">// output: 2</span></span><br></pre></td></tr></table></figure>\n\n<p>最后来看这段代码，运行代码输出<code>[Function: a]</code>而非<code>undefined</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// output: [Function: a]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>调换2、3行的声明顺序会得到相同结果。道理很简单，函数声明提升优先级 &gt; 变量声明提升，无需过多解释。</p>\n<p>对以上三个示例做总结，可以得到以下 JS 中关于提升的三条规则：</p>\n<ul>\n<li>变量、函数声明操作都会提升；</li>\n<li>赋值操作不提升；</li>\n<li>函数声明操作优先级 &gt; 变量声明优先级。</li>\n</ul>\n<h3 id=\"Execution-Context-执行上下文\"><a href=\"#Execution-Context-执行上下文\" class=\"headerlink\" title=\"Execution Context 执行上下文\"></a>Execution Context 执行上下文</h3><p>在介绍 hoisting 实现原理之前，有必要先了解 JS 的执行上下文。</p>\n<p>ES6 的执行上下文是指运行 JS 代码时的代码环境和相关信息。执行上下文包括三个部分：</p>\n<ul>\n<li>词法环境（lexical environment）</li>\n<li>变量环境（variable environment）</li>\n<li>this 绑定（this binding）</li>\n</ul>\n<p>词法环境是一个存储标识符（变量，函数，类等）和它们的值的结构。词法环境有两个组成部分：环境记录（environment record）和外部环境引用（outer environment reference）。环境记录是一个存储当前作用域内的标识符和它们的值的对象；外部环境引用则是一个指向包含作用域的词法环境的指针。</p>\n<p>变量环境是一个与词法环境类似的结构，但是它只存储<code>var</code>声明的变量。在 ES6 之前，变量环境和词法环境是相同的，但是在 ES6 中引入了<code>let&amp;const</code>关键字，变量环境和词法环境也有可能不同。</p>\n<p><code>this</code>绑定是一个确定当前执行上下文中的<code>this</code>值的过程。<code>this</code>值取决于函数的调用方式，例如普通函数调用，方法调用，构造函数调用，箭头函数调用等。</p>\n<blockquote>\n<p><code>this</code>比较麻烦，本文中不细说。</p>\n</blockquote>\n<p>词法环境和变量环境本质上都是一种词法作用域，都是用来存储和查找标识符（变量，函数等）的值的结构。它们的区别在于，词法环境可以随着代码的执行而改变，而变量环境则保持不变。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240226195039.png\" alt=\"20240226195039\"></p>\n<p>我们可以把词法环境理解为一个栈，每当进入一个新的作用域，就会创建一个新的词法环境，并将其压入栈顶。这个新的词法环境包含了当前作用域内的标识符和它们的值，以及一个指向外部词法环境的引用。当退出当前作用域时，就会将栈顶的词法环境弹出，恢复到上一个词法环境。这样，词法环境就能实现词法作用域的规则，即内部作用域可以访问外部作用域的标识符，但反之不行。</p>\n<p>变量环境则是一个特殊的词法环境，它只包含了用<code>var</code>声明的变量和函数声明。变量环境在执行上下文创建时就确定了，不会随着代码的执行而改变。这意味着，用<code>var</code>声明的变量和函数声明会被提升到它们所在的执行上下文的顶部，而不受块级作用域的限制。这也是为什么在 ES6 之前，JS 只有函数作用域，而没有块级作用域的原因。</p>\n<p>ES6 引入了<code>let</code>和<code>const</code>关键字，它们创建的标识符只存在于词法环境中，而不在变量环境中。这样，就可以实现块级作用域，以及暂时性死区（TDZ）的特性。</p>\n<p>下面是一个例子，说明了词法环境和变量环境的区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>; <span class=\"comment\">// 在全局执行上下文的变量环境和词法环境中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>; <span class=\"comment\">// 只在全局执行上下文的词法环境中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 进入foo函数的执行上下文</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = <span class=\"number\">3</span>; <span class=\"comment\">// 在foo函数的执行上下文的变量环境和词法环境中</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> d = <span class=\"number\">4</span>; <span class=\"comment\">// 只在foo函数的执行上下文的词法环境中</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b, c, d); <span class=\"comment\">// 1, 2, 3, 4</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 进入块级作用域</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> e = <span class=\"number\">5</span>; <span class=\"comment\">// 在foo函数的执行上下文的变量环境和词法环境中</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> f = <span class=\"number\">6</span>; <span class=\"comment\">// 只在块级作用域的词法环境中</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b, c, d, e, f); <span class=\"comment\">// 1, 2, 3, 4, 5, 6</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 退出块级作用域</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b, c, d, e); <span class=\"comment\">// 1, 2, 3, 4, 5</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(f); <span class=\"comment\">// ReferenceError: f is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 退出foo函数的执行上下文</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b); <span class=\"comment\">// 1, 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c, d, e, f); <span class=\"comment\">// ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>到这里应该就能理解词法环境和变量环境是什么了，如果还是感觉疑惑，不清楚这俩环境到底是什么，可以看看 <a href=\"https://stackoverflow.com/questions/23948198/variable-environment-vs-lexical-environment\">Variable Environment vs lexical environment</a> 这篇问答，里面解释得更详细一些。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>经过前面这么多铺垫，我感觉 Hoisting 的实现原理已经比较明晰。其实解释执行上下文的时候就已经算是在解释 Hositing 工作原理了。</p>\n<p>我们可以把 JS 执行划分为以下几个步骤，但重点放在提升操作上：</p>\n<ol>\n<li>创建全局执行上下文，并将其压入执行栈。</li>\n<li>对全局代码进行扫描，将<code>var</code>声明的变量添加到全局执行上下文的变量环境中，并赋值为<code>undefined</code>。将函数声明添加到全局执行上下文的词法环境中，并赋值为函数对象。对于<code>let</code>和<code>const</code>声明的变量，不会被提升，而是在全局执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。这就是暂时性死区（TDZ）的概念，即在变量被赋值之前，不能被访问或使用。</li>\n<li>开始执行全局代码，按照顺序逐行执行。如果遇到函数调用，就创建一个函数执行上下文，并将其压入执行栈。</li>\n<li>对函数代码进行扫描，将<code>var</code>声明的变量添加到函数执行上下文的变量环境中，并赋值为<code>undefined</code>。将函数声明添加到函数执行上下文的词法环境中，并赋值为函数对象。对于<code>let</code>和<code>const</code>声明的变量，同样不会被提升，而是在函数执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。</li>\n<li>开始执行函数代码，按照顺序逐行执行。如果遇到函数调用，就重复步骤3和4。如果遇到<code>return</code>语句，就返回函数的结果，并将函数执行上下文从执行栈中弹出。</li>\n<li>当全局代码执行完毕，就将全局执行上下文从执行栈中弹出，程序结束。</li>\n</ol>\n<p>流程如此，具体到代码中，把自己想象成 JS 引擎，按照上面的执行流程分析即可。如果感兴趣，可以试着分析以下代码，对应的输出也已经给在每行代码后面了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// ReferenceError: Cannot access &#x27;b&#x27; before initialization</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">c</span>()); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">d</span>()); <span class=\"comment\">// TypeError: d is not a function</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">c</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>文中有些概念并不明晰，但直接解释又会影响连贯性，于是摘出来放在这里。</p>\n<h3 id=\"ML-like-Order\"><a href=\"#ML-like-Order\" class=\"headerlink\" title=\"ML-like Order\"></a>ML-like Order</h3><p>ML 是一种通用的函数式编程语言，具有可扩展的类型系统。它支持多态类型推断，这几乎消除了指定变量类型的负担，并极大地促进了代码的重用。ML 虽然没有得到广泛的使用，但它对其他语言产生了很大的影响，比如 Haskell、Rust、Scala 等。</p>\n<p>下面是一个用 Standard ML 编写的阶乘函数的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun factorial n =</span><br><span class=\"line\">    if n = 0 then 1 else n * factorial (n-1)</span><br></pre></td></tr></table></figure>\n\n<p>这个函数必须在调用它的地方之前定义，否则会报错。</p>\n<p>ML-like Order 是指 ML 语言中的函数定义顺序，它是自下而上的，也就是说，一个函数必须在它被调用之前定义。这样的顺序有时会导致一些不便，比如前面讲到的函数相互递归的情景，ML 就需要使用特殊的 fun 和 and 关键字，这种函数则会被称为互递归函数。比如判断一个自然数是奇数还是偶数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun isOdd n = if n = 0 then false else isEven (n-1)</span><br><span class=\"line\">and isEven n = if n = 0 then true else isOdd (n-1)</span><br></pre></td></tr></table></figure>\n\n<p>为了避免这种情况，一些其他的语言（比如 JS）采用了函数声明提升（FDs hoisting）的机制，允许在任何地方定义函数，而不用考虑顺序。</p>\n<h2 id=\"参阅文章\"><a href=\"#参阅文章\" class=\"headerlink\" title=\"参阅文章\"></a>参阅文章</h2><ul>\n<li>[解读ECMAScript<a href=\"https://www.cnblogs.com/leoo2sk/archive/2010/12/19/ecmascript-scope.html\">1]——执行环境、作用域及闭包</a>，by Eric Zhang</li>\n<li><a href=\"https://juejin.cn/post/7030765196574457892#heading-8\">详解JavaScript作用域和作用域链</a>，by Rockky</li>\n<li><a href=\"https://blog.huli.tw/2018/12/08/javascript-closure/\">所有的函式都是閉包：談 JS 中的作用域與 Closure</a>，by Huli</li>\n<li><a href=\"https://blog.huli.tw/2018/11/10/javascript-hoisting-and-tdz/\">我知道你懂 hoisting，可是你了解到多深</a>，by Huli</li>\n<li><a href=\"https://262.ecma-international.org/6.0/\">ECMAScript® 2015 Language Specification</a></li>\n</ul>\n","excerpt":"","more":"<p>补档，本来想把【闭包】也一并放在本文中，但发现会有些臃肿，于是本文就只写作用域与提升。</p>\n<p>本文编写的 JavaScript 代码示范均使用 node v18.19.1，遵循 ES6 标准。</p>\n<h2 id=\"Scope-作用域\"><a href=\"#Scope-作用域\" class=\"headerlink\" title=\"Scope 作用域\"></a>Scope 作用域</h2><p>什么是作用域呢？我的理解是：“变量的作用域就是该变量可访问的范围，函数对象同理”，作用域的作用是避免不同层级中的变量发生冲突。</p>\n<p>JS 中主要分为两种作用域：全局作用域（global scope）和局部作用域（local scope）。</p>\n<p>在 JS 中，局部作用域类似于“私人房间”，其中的变量只能在特定的区域内访问。当我们在局部作用域中声明变量时，它只能在该代码块、函数或条件语句中访问。局部作用域中的变量会受到外部代码干扰，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> localVariable = <span class=\"string\">&quot;我在局部作用域中&quot;</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(localVariable);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">myFunction</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(localVariable);</span><br></pre></td></tr></table></figure>\n\n<p>在这段代码中，<code>localVariable</code>在局部作用域中声明，这意味着它只能在<code>myFunction</code>代码块内访问，尝试在作用域之外使用该变量会抛出<code>ReferenceError: localVariable is not defined</code>的报错。</p>\n<p>而全局作用域中中声明的变量可以在代码的任何地方访问。它可以类比为一个“公共广场”，所有人都可以看到和访问其中的内容。在全局作用域中声明的变量通常是在任何函数或代码块之外定义的。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globalVariable = <span class=\"string\">&quot;我在全局作用域中&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globalVariable);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">myFunction</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globalVariable);</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>globalVariable</code>在全局作用域中声明，<code>myFunction</code>中也可以直接访问它。因为<code>myFunction</code>函数中并没有对<code>globalVariable</code>显示地做出声明，也没有把其当作一个参数，同时满足这两个条件，我们就可以把<code>globalVariable</code>叫做自由变量（free variable）。</p>\n<p>还是在这个例子中，<code>myFunction</code>中使用了<code>globalVariable</code>，但当前作用域中并没有声明该变量，此时它就会向上一级作用域（这里是全局作用域）寻找该变量，如果在上一级没有找到，就向再上一级寻找，直到找到所需变量，或者抛出<code>is not defined</code>报错。这种</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx-scope -&gt; ... -&gt; global scope</span><br></pre></td></tr></table></figure>\n\n<p>的查询方式，会形成一条作用域链（scope chain）。</p>\n<blockquote>\n<p>和 prototype chain 有些相似之处～</p>\n</blockquote>\n<h3 id=\"Block-Scope-块级作用域\"><a href=\"#Block-Scope-块级作用域\" class=\"headerlink\" title=\"Block Scope 块级作用域\"></a>Block Scope 块级作用域</h3><p>ES6 之前，JS 中只有全局&#x2F;局部作用域，这会导致一些潜在的问题，如循环变量泄露：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// Outputs: 3, 3, 3</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，使用<code>var</code>在<code>for</code>循环中声明的变量<code>i</code>被提升到函数作用域，其值在循环的所有迭代中共享。这经常导致意外行为，特别是在处理像<code>setTimeout</code>这样的异步操作时。这对开发者来说很不方便，也不利于编写完善的代码。</p>\n<p>为了解决此类问题，ES6 中新增了<code>let&amp;const</code>关键字以及块级作用域（block scope）。</p>\n<p>有了新的语法之后，我们就可以对上面的例子做出改进：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">3</span>; j++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(j); <span class=\"comment\">// Outputs: 0, 1, 2</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们使用<code>let</code>，变量<code>j</code>的作用域就被限制在<code>for</code>循环的块内，确保每次迭代都为<code>j</code>创建一个新的词法环境。这可以防止与变量提升和异步操作等问题。</p>\n<p>因此，在实际开发过程中，我们一般推荐只使用<code>let&amp;const</code>，不使用<code>var</code>，这可以最大程度避免我们代码出现 bug。</p>\n<h3 id=\"Static-Lexical-Scope-静态作用域\"><a href=\"#Static-Lexical-Scope-静态作用域\" class=\"headerlink\" title=\"Static&#x2F;Lexical Scope 静态作用域\"></a>Static&#x2F;Lexical Scope 静态作用域</h3><p>运行以下代码，会得到什么结果呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">&#x27;global&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">bar</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"string\">&#x27;local&#x27;</span>;</span><br><span class=\"line\">    <span class=\"title function_\">foo</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">bar</span>();</span><br></pre></td></tr></table></figure>\n\n<p>答案是<code>global</code>，这倒不难理解，按照前面说的，<code>foo()</code>函数被调用，发现函数作用域中没有<code>x</code>变量，就沿着作用域链向上寻找，在全局作用域中找到后就输出<code>global</code>。但在有些语言中会得到不同的输出结果。</p>\n<p>以 Perl 语言为例，实现同样功能的代码，会得到不同的输出：</p>\n<blockquote>\n<p>你可以使用该 <a href=\"https://www.jyshare.com/compile/\">站点</a> 在线运行以上代码并观察输出结果。</p>\n</blockquote>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">our</span> $x = <span class=\"string\">&#x27;global&#x27;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">sub</span> <span class=\"title\">foo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">&quot;$x\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">sub</span> <span class=\"title\">bar</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">local</span> $x = <span class=\"string\">&#x27;local&#x27;</span>;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(); <span class=\"comment\"># output: local</span></span><br></pre></td></tr></table></figure>\n\n<p>原因是这两种语言对作用域的定义不同。从本质上来讲，作用域就是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称查找变量。</p>\n<p>常见作用域有静态作用域（static scope）和动态作用域（dynamic scope），前者在词法分析阶段就已经决定，后者则是在代码执行过程中进行动态的划分，比如函数的作用域是在函数被调用时才决定。</p>\n<p>JS 采用的是静态作用域规则，我们在编写代码就已经决定了其作用域层级。静态作用域也叫做词法作用域（Lexical Scope），这个名称更加直白。</p>\n<blockquote>\n<p>如果你对什么是“词法分析”抱有疑问，可以参考我之前的文章：<a href=\"https://ma5hr00m.top/archives/2024/02/how-js-run.html\">JavaScript 执行原理</a>。</p>\n</blockquote>\n<h2 id=\"Hoisting-提升\"><a href=\"#Hoisting-提升\" class=\"headerlink\" title=\"Hoisting 提升\"></a>Hoisting 提升</h2><p>讲完作用域，我们可以来说说提升（hoisting）了。</p>\n<p>hoisting 是指将变量、函数或类的声明移动到它们所在的作用域的顶部，这允许开发者在代码中使用变量或函数时无需关心它们的声明位置。这里“移动”并不准确，但暂且按照这样理解也无妨。</p>\n<p>这是一个最简单的例子，我们在声明<code>ping()</code>之前调用了它，但这不会导致报错：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">ping</span>();</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ping</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;pong&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不抛出报错的原因就是 JS 引擎在运行时将<code>ping()</code>的声明“移动”到了函数调用之前，也就是提升了这个函数声明。</p>\n<p>为什么需要 hoisting 呢？在 Twitter 某位用户的询问中，Brendan Eich 回答了这个问题：</p>\n<blockquote>\n<p>Function declaration hoisting is for mutual recursion &amp; generally to avoid painful bottom-up ML-like order.</p>\n</blockquote>\n<p>在我们编写 JS 时，有时会遇到需要编写两个函数相互调用的情况，如果没有提升，处理这种情况就会变得繁琐。Brendan 不希望在 JS 中看到类似 ML 的自下而上的编程顺序。</p>\n<h3 id=\"提升规则\"><a href=\"#提升规则\" class=\"headerlink\" title=\"提升规则\"></a>提升规则</h3><blockquote>\n<p>如果你只想知道 Hoisting 规则，而对其原理不感兴趣，只需看完本小节。</p>\n</blockquote>\n<p>这是变量提升的简单演示，运行代码会输出<code>undefined</code>而非<code>ReferenceError: a is not defined</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// output: undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>JS 引擎会提升变量声明操作，而不会提升变量赋值操作。以上代码等效于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a) <span class=\"comment\">// output: undefined</span></span><br><span class=\"line\">a = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>再来看这段代码，运行代码输出<code>2</code>而非<code>1</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"number\">2</span>); <span class=\"comment\">// output: 2</span></span><br></pre></td></tr></table></figure>\n\n<p>函数作用域中的变量也会提升，但因为我们调用<code>test()</code>时传入了参数<code>v</code>，所以在函数内代码运行之前会有一个隐性的函数声明+赋值操作，<code>var v = 1;</code>的声明操作也会提升，但因为<code>v=2</code>的赋值操作更先执行，所以会输出<code>2</code>。以上代码等效于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> v;</span><br><span class=\"line\">    v = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v);</span><br><span class=\"line\">    v = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">test</span>(<span class=\"number\">2</span>); <span class=\"comment\">// output: 2</span></span><br></pre></td></tr></table></figure>\n\n<p>最后来看这段代码，运行代码输出<code>[Function: a]</code>而非<code>undefined</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// output: [Function: a]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>调换2、3行的声明顺序会得到相同结果。道理很简单，函数声明提升优先级 &gt; 变量声明提升，无需过多解释。</p>\n<p>对以上三个示例做总结，可以得到以下 JS 中关于提升的三条规则：</p>\n<ul>\n<li>变量、函数声明操作都会提升；</li>\n<li>赋值操作不提升；</li>\n<li>函数声明操作优先级 &gt; 变量声明优先级。</li>\n</ul>\n<h3 id=\"Execution-Context-执行上下文\"><a href=\"#Execution-Context-执行上下文\" class=\"headerlink\" title=\"Execution Context 执行上下文\"></a>Execution Context 执行上下文</h3><p>在介绍 hoisting 实现原理之前，有必要先了解 JS 的执行上下文。</p>\n<p>ES6 的执行上下文是指运行 JS 代码时的代码环境和相关信息。执行上下文包括三个部分：</p>\n<ul>\n<li>词法环境（lexical environment）</li>\n<li>变量环境（variable environment）</li>\n<li>this 绑定（this binding）</li>\n</ul>\n<p>词法环境是一个存储标识符（变量，函数，类等）和它们的值的结构。词法环境有两个组成部分：环境记录（environment record）和外部环境引用（outer environment reference）。环境记录是一个存储当前作用域内的标识符和它们的值的对象；外部环境引用则是一个指向包含作用域的词法环境的指针。</p>\n<p>变量环境是一个与词法环境类似的结构，但是它只存储<code>var</code>声明的变量。在 ES6 之前，变量环境和词法环境是相同的，但是在 ES6 中引入了<code>let&amp;const</code>关键字，变量环境和词法环境也有可能不同。</p>\n<p><code>this</code>绑定是一个确定当前执行上下文中的<code>this</code>值的过程。<code>this</code>值取决于函数的调用方式，例如普通函数调用，方法调用，构造函数调用，箭头函数调用等。</p>\n<blockquote>\n<p><code>this</code>比较麻烦，本文中不细说。</p>\n</blockquote>\n<p>词法环境和变量环境本质上都是一种词法作用域，都是用来存储和查找标识符（变量，函数等）的值的结构。它们的区别在于，词法环境可以随着代码的执行而改变，而变量环境则保持不变。</p>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240226195039.png\" alt=\"20240226195039\"></p>\n<p>我们可以把词法环境理解为一个栈，每当进入一个新的作用域，就会创建一个新的词法环境，并将其压入栈顶。这个新的词法环境包含了当前作用域内的标识符和它们的值，以及一个指向外部词法环境的引用。当退出当前作用域时，就会将栈顶的词法环境弹出，恢复到上一个词法环境。这样，词法环境就能实现词法作用域的规则，即内部作用域可以访问外部作用域的标识符，但反之不行。</p>\n<p>变量环境则是一个特殊的词法环境，它只包含了用<code>var</code>声明的变量和函数声明。变量环境在执行上下文创建时就确定了，不会随着代码的执行而改变。这意味着，用<code>var</code>声明的变量和函数声明会被提升到它们所在的执行上下文的顶部，而不受块级作用域的限制。这也是为什么在 ES6 之前，JS 只有函数作用域，而没有块级作用域的原因。</p>\n<p>ES6 引入了<code>let</code>和<code>const</code>关键字，它们创建的标识符只存在于词法环境中，而不在变量环境中。这样，就可以实现块级作用域，以及暂时性死区（TDZ）的特性。</p>\n<p>下面是一个例子，说明了词法环境和变量环境的区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全局代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>; <span class=\"comment\">// 在全局执行上下文的变量环境和词法环境中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>; <span class=\"comment\">// 只在全局执行上下文的词法环境中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 进入foo函数的执行上下文</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = <span class=\"number\">3</span>; <span class=\"comment\">// 在foo函数的执行上下文的变量环境和词法环境中</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> d = <span class=\"number\">4</span>; <span class=\"comment\">// 只在foo函数的执行上下文的词法环境中</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b, c, d); <span class=\"comment\">// 1, 2, 3, 4</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 进入块级作用域</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> e = <span class=\"number\">5</span>; <span class=\"comment\">// 在foo函数的执行上下文的变量环境和词法环境中</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> f = <span class=\"number\">6</span>; <span class=\"comment\">// 只在块级作用域的词法环境中</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b, c, d, e, f); <span class=\"comment\">// 1, 2, 3, 4, 5, 6</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 退出块级作用域</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b, c, d, e); <span class=\"comment\">// 1, 2, 3, 4, 5</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(f); <span class=\"comment\">// ReferenceError: f is not defined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 退出foo函数的执行上下文</span></span><br><span class=\"line\"><span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b); <span class=\"comment\">// 1, 2</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c, d, e, f); <span class=\"comment\">// ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>到这里应该就能理解词法环境和变量环境是什么了，如果还是感觉疑惑，不清楚这俩环境到底是什么，可以看看 <a href=\"https://stackoverflow.com/questions/23948198/variable-environment-vs-lexical-environment\">Variable Environment vs lexical environment</a> 这篇问答，里面解释得更详细一些。</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><p>经过前面这么多铺垫，我感觉 Hoisting 的实现原理已经比较明晰。其实解释执行上下文的时候就已经算是在解释 Hositing 工作原理了。</p>\n<p>我们可以把 JS 执行划分为以下几个步骤，但重点放在提升操作上：</p>\n<ol>\n<li>创建全局执行上下文，并将其压入执行栈。</li>\n<li>对全局代码进行扫描，将<code>var</code>声明的变量添加到全局执行上下文的变量环境中，并赋值为<code>undefined</code>。将函数声明添加到全局执行上下文的词法环境中，并赋值为函数对象。对于<code>let</code>和<code>const</code>声明的变量，不会被提升，而是在全局执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。这就是暂时性死区（TDZ）的概念，即在变量被赋值之前，不能被访问或使用。</li>\n<li>开始执行全局代码，按照顺序逐行执行。如果遇到函数调用，就创建一个函数执行上下文，并将其压入执行栈。</li>\n<li>对函数代码进行扫描，将<code>var</code>声明的变量添加到函数执行上下文的变量环境中，并赋值为<code>undefined</code>。将函数声明添加到函数执行上下文的词法环境中，并赋值为函数对象。对于<code>let</code>和<code>const</code>声明的变量，同样不会被提升，而是在函数执行上下文的词法环境中创建一个未初始化的绑定，直到它们被赋值为止。</li>\n<li>开始执行函数代码，按照顺序逐行执行。如果遇到函数调用，就重复步骤3和4。如果遇到<code>return</code>语句，就返回函数的结果，并将函数执行上下文从执行栈中弹出。</li>\n<li>当全局代码执行完毕，就将全局执行上下文从执行栈中弹出，程序结束。</li>\n</ol>\n<p>流程如此，具体到代码中，把自己想象成 JS 引擎，按照上面的执行流程分析即可。如果感兴趣，可以试着分析以下代码，对应的输出也已经给在每行代码后面了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// ReferenceError: Cannot access &#x27;b&#x27; before initialization</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">c</span>()); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">d</span>()); <span class=\"comment\">// TypeError: d is not a function</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">c</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><p>文中有些概念并不明晰，但直接解释又会影响连贯性，于是摘出来放在这里。</p>\n<h3 id=\"ML-like-Order\"><a href=\"#ML-like-Order\" class=\"headerlink\" title=\"ML-like Order\"></a>ML-like Order</h3><p>ML 是一种通用的函数式编程语言，具有可扩展的类型系统。它支持多态类型推断，这几乎消除了指定变量类型的负担，并极大地促进了代码的重用。ML 虽然没有得到广泛的使用，但它对其他语言产生了很大的影响，比如 Haskell、Rust、Scala 等。</p>\n<p>下面是一个用 Standard ML 编写的阶乘函数的例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun factorial n =</span><br><span class=\"line\">    if n = 0 then 1 else n * factorial (n-1)</span><br></pre></td></tr></table></figure>\n\n<p>这个函数必须在调用它的地方之前定义，否则会报错。</p>\n<p>ML-like Order 是指 ML 语言中的函数定义顺序，它是自下而上的，也就是说，一个函数必须在它被调用之前定义。这样的顺序有时会导致一些不便，比如前面讲到的函数相互递归的情景，ML 就需要使用特殊的 fun 和 and 关键字，这种函数则会被称为互递归函数。比如判断一个自然数是奇数还是偶数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun isOdd n = if n = 0 then false else isEven (n-1)</span><br><span class=\"line\">and isEven n = if n = 0 then true else isOdd (n-1)</span><br></pre></td></tr></table></figure>\n\n<p>为了避免这种情况，一些其他的语言（比如 JS）采用了函数声明提升（FDs hoisting）的机制，允许在任何地方定义函数，而不用考虑顺序。</p>\n<h2 id=\"参阅文章\"><a href=\"#参阅文章\" class=\"headerlink\" title=\"参阅文章\"></a>参阅文章</h2><ul>\n<li>[解读ECMAScript<a href=\"https://www.cnblogs.com/leoo2sk/archive/2010/12/19/ecmascript-scope.html\">1]——执行环境、作用域及闭包</a>，by Eric Zhang</li>\n<li><a href=\"https://juejin.cn/post/7030765196574457892#heading-8\">详解JavaScript作用域和作用域链</a>，by Rockky</li>\n<li><a href=\"https://blog.huli.tw/2018/12/08/javascript-closure/\">所有的函式都是閉包：談 JS 中的作用域與 Closure</a>，by Huli</li>\n<li><a href=\"https://blog.huli.tw/2018/11/10/javascript-hoisting-and-tdz/\">我知道你懂 hoisting，可是你了解到多深</a>，by Huli</li>\n<li><a href=\"https://262.ecma-international.org/6.0/\">ECMAScript® 2015 Language Specification</a></li>\n</ul>\n"},{"title":"面向新生的 Linux 教程","date":"2023-10-13T16:00:00.000Z","author":"ma5hr00m","_content":"\n2023 年 ***Vidar-Team*** 第四次新生培训 Linux 部分内容讲解。\n\n## 什么是操作系统\n### 概念\n大家都知道计算机硬件和软件。硬件就是我们计算机的物理组成部分，比如内存、硬盘、键盘，都是些电子元件；软件就是大家常用的浏览器、游戏这些。\n你单独使用硬件或软件都很难正常工作。想让计算机正常工作，就需要硬件和软件相互配合。而负责中间这个过程的，就是操作系统。\n\n操作系统（Operating System），也就是我们说的 OS，本质上就是一组相互关联的软件程序。\n操作系统是计算机最底层的软件，负责管理计算机的硬件和软件资源，控制着计算机的运行。\n\n我们平常使用的应用程序，包括 vscode、firefox 这样的软件应用，以及我们写的 C 语言程序、Python 脚本什么的，都需要以操作系统为基本支撑。没有操作系统，这些应用程序就都无法正常运行。\n\n### 组成\n如下图所示，操作系统可以简单划分为内核和系统调用两部分：\n\n![操作系统抽象划分](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231013143007.png)\n\n- 内核：内核是操作系统的核心，它负责管理计算机的硬件资源，如CPU、内存、磁盘、网络等。内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性和稳定性。内核运行在特权模式下，可以直接访问硬件设备和指令。\n- 系统调用：系统调用是用户进程进入内核的接口层，它是由内核函数实现的。通过系统调用，用户进程可以临时切换到内核模式，使用内核提供的服务和功能，如文件操作、进程管理、网络通信等。系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且编程效率大大提高。\n\n一些系统组件运行在应用程序层，比如我们经常使用的 shell、图形界面等，它们也是操作系统的一部分。\n\n\n## Linux\nLinux 是一个操作系统。它由 *Linus* 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。\n现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。\n\n![Linux Logo](https://pakhotin.org/wp-content/uploads/2023/07/53113-106400-Linux-xl.jpg)\n\n在座的大多数人都在使用 Windows 操作系统，Windwos 足够满足大家的日常学习生活，比如写代码、玩游戏、看视频。\n那我们今天为什么要来介绍 Linux 呢？\n\n原因很简单。如果你未来要踏足计算机领域，不管你是要学习计算机安全，还是要做些其他的什么方向，你都会有茫茫多的场景需要接触到 Linux，你没法避开它。\n不论你是否会把 Linux 当作主力操作系统，你都有必要学会使用它。\n\n## Linux 的优势\n现在来说说我们为什么要使用 Linux。\n\nLinux 自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。\n以前有很多设置你可能需要在 windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。\n\n此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。\n这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。\n\n同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。\n这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。\n\n现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。\n\n比如，你现在想要在 Windows 系统中配置一个基本的 Java 开发环境（[教程](https://www.runoob.com/java/java-environment-setup.html)），\n你需要先去 Java 官网下载 JDK，然后安装，接着配置 `JAVA_HOME` 等环境变量，这样才能开始写代码。一些没有经验的新生就会在这里消耗大量时间。\n而在 Linux 下你不需要这么麻烦，多数情况下，你只需要使用一行类似的命令就可以完成上述工作：\n```bash\nsudo apt install openjdk-17-jdk\n```\n\n当这句指令执行成功后，你就可以开始写代码了。非常轻松愉快，也节省了很多时间，让你专注于 Java 语言本身，而非繁琐的环境配置。\n\n## 发行版\nLinux 操作系统分为很多种，这些不同的 Linux 统称为 Linux 发行版（*Linux distribution*）。\n\n这些发行版都是基于 Linux 内核的，它们之间的差异主要体现在软件包管理工具、软件包源、软件包版本等方面，我们一会儿会做详细讲解。\n\n大家可以看这张图，这张图展示了一些常见的 Linux 发行版：\n\n![常见Linux发行版](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015001556.png)\n\n从这张图里，大家可以看到现在当下流行的一些发行版，比如 `Ubuntu`、`Fedora`、`ArchLinux`、`CentOS` 等等。\n这些发行版各有特点，有各自的适用场景，也都有着庞大的用户群体以及高度活跃的社区生态。\n\n实际上，现有的 Linux 发行版远不止图中展示的这些，现在光是被记录 Linux 版本列表中的就有超过 300 个。\n它们大多数都正处于活跃的开发中，由不同的公司、组织或其他群体进行维护，不断地被改进。\n\n接下来，我们会以 `Ubuntu22.04` 为例，来介绍 Linux 操作系统的一些常见概念以及基本使用方法。\n\n## 来，Ubuntu！\n### 安装\n在自己的计算机中安装一个 Ubuntu 系统有以下几种方式：\n1. 安装到VMware，Virtual Box等虚拟机软件里（推荐），这也是大多数初学者的选择。\n2. 安装到物理机上，单系统或双系统，但不推荐大家这样做。  \n   刚开始你直接单系统的话可能会出各种各样的问题，你可能会在一段时间内不断的搞坏自己的系统，然后重装，然后再搞坏，然后再重装，但这个折腾的过程中你也能学到很多东西，看你愿不愿意花这个时间。  \n   双系统的话，确实兼具了使用 Windows 的方便和体验 Linux 物理机的优势，但你有可能会遇到一些奇奇怪怪的问题，而这些问题你去网上有时候很难搜到解决方案，会耗费你很多时间。\n3. WSL（*Windows Subsystem for Linux*）也是一种可选方案，这是微软为 Windows 提供的一个 Linux 子系统。\n   但 WSL 相比虚拟机或者物理机来说都会有一些限制，比如你无法使用图形界面，无法使用一些特殊的硬件设备等等。\n\n关于如何在自己的计算机中安装一个 Ubuntu 系统，今天不会讲解具体步骤，这次分享会之前我们已经在群里发过了详细的教程，大家可以从群文件中找到那份文件，自行查阅。\n网上也有详细的教程，大家也都可以搜到。\n\n### 换源 & 包管理\n当你在安装好 Ubuntu 虚拟机后，你可以看到这样的桌面：\n\n![Ubuntu默认桌面](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015005727.png)\n\n乍一看还是和 `windows` 区别蛮大的。\n\n为了方便的安装各种软件，我们需要先了解一下软件源和包管理工具。\n\n软件源（*software source*）是指存放软件包的服务器，它们通常由软件开发商或者 Linux 发行版的维护者维护。\n\n包管理工具（*package manager*）是指用于安装、更新、卸载软件包的工具，它们可以从软件源中下载软件包，然后安装到系统中。\n`Ubuntu` 自带的包管理工具是 `apt`，它的软件源默认是国外的。\n\n出于一些众所周知的原因，国内用户访问国外链接会比较慢，有时候还会请求超时。\n不管不问的话用起来会很不爽。\n为了解决问题，我们需要对我们的软件源进行更换，一般是将其更换为国内源，比如清华镜像源。\n\n我们可以使用指令来完成换源的操作，具体指令可以看看群里的文档，这里就不再赘述了。\n\n在换源之后，我们需要执行命令更新软件包列表 `sudo apt update`。\n成功执行后，我们就可以使用 `apt` 来方便地管理软件了。\n\n常用的 `apt` 指令有图片中这些，不需要刻意去记，你自己用几次就熟悉了。\n\n![常用apt指令](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015010916.png)\n\n除了 apt，其他 Linux 发行版也都有各自的包管理工具，比如 CentOS 的 `yum`、Fedora 的 `dnf`、Arch 的 `pacman` 等等。\n他们的使用方法都差不多，也都是用来管理软件包的。\n根据自己用的发行版来就好了。\n\n![根据包管理器划分Linux发行版](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231014223037.png)\n\n上面这张图是根据包管理工具的不同对当前常见的 Linux 发行版做的一个分类。\n\n## 文件系统\n现在来说说目录结构，这也是 Windows 和 Linux 之间的一个重要区别。\n\nWindows 的目录结构是以物理存储介质为主，通过分区来实现文件目录的管理，每个分区被视为一个独立的盘符，如 C 盘、D 盘等等。\n不同分区之间相互独立，联系并不紧密。\n\n而在 Linux 中，所有分区都被挂载到根目录下，所有的文件和目录都被组织成以一个跟节点开始的树形结构。\n这个树形结构就是 Linux 的文件系统。\n\n打开 Linux 的终端，输入 `ls /`，你就可以看到根目录下的所有文件和目录。\n\n![ls / 执行结果](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015105831.png)\n\nLinux 的根目录是 `/`，它是整个文件系统的起点，在根目录之下的既可以是其他目录，也可以是文件。\n而每一个目录中又可以包含其他目录和文件，如此反复就构成了一个庞大的文件系统。\n\n![Linux文件系统](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015113020.png)\n\n根目录下的每个目录都有各自作用。\n\n比如这里的 `/home` 目录，就是用户的主目录。在 Linux 中，每个用户都有自己的主目录，用来存放用户的个人文件。\n用户主目录一般是以用户的帐号命名的，比如上图中的 alice、bob、eve。\n\n再比如这里的 `/lib` 目录，这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。\n几乎所有的应用程序都需要用到这些共享库。\n\n<!-- 介绍各个目录的作用 -->\n\n这张图中的箭头是在表示某些目录之间的关系。\n\n先来看根目录下的 `/bin`，bin 是 `binary` 的缩写，这个目录下存放着一些最基本的命令，比如 `ls`、`cp`、`mv`、`rm` 等等。这些命令在系统启动时就会用到，可以被当前系统下所有用户使用。\n与 bin 相连的箭头指向了 `/usr/bin`，这个目录下存放着一些用户级的命令，比如 `vim`、`gcc` 等，这些命令只能被当前用户使用。\n\n类似的还有 `/sbin` 和 `/usr/sbin`。\n\n## 常用命令\n讲完前面这些，我们就可以来说说 Linux 常用的一些指令了。\n\n`ls`用来列出目录下的所有文件和目录。\n```\nls\nls -a\nls -l\nls <path>\n```\n\n`cd`用于切换目录。\n```\ncd ~ \ncd ..\ncd -\ncd <path>\n```\n\n`mkdir` 用于创建目录。\n```\nmkdir <name>\nmkdir –p <name>\n```\n\n`cp` 用于复制文件或目录到指定位置。\n```\ncp <src> <dst>\ncp –r <src> <dst>\n```\n\n`mv` 用于移动文件或目录到指定位置，这个指令也可以用来给某个文件或目录重命名。\n```\nmv <src> <dst>\n```\n\n`rm` 用于删除文件或目录。\n```\nrm <target>\nrm –r <target>\nrm –f <target>\n```\n\n## 权限管理\n在多用户计算机系统的管理中，权限是指某个特定用户具有特定的系统资源使用权利。\n\n个人主机大家一般不会管这么多，通常都是直接使用管理员身份登陆了，因为个人计算机的使用者一般都是大家可以信任的人。\n而在服务器上就不是这种情况。服务器上的用户可能彼此之间并不熟悉，而服务器中又往往存储着各种各样的资源，有些资源你不希望别的用户看到。\n服务器中的数据越重要，价值越高，往往服务器中对权限的设定就要越详细，用户的分级也要越明确。\n\n与 windows 不同，Linux 为每个文件都设置了很多属性，最大的作用就是维护数据安全。\n举个简单的例子，在你的 Linux 系统中，和系统服务相关的文件通常只有 root 用户才能读或写。\n就拿 `/etc/shadow` 这个文件来说，此文件记录了系统中所有用户的密码数据，非常重要，因此绝不能让任何人读取（否则密码数据会被窃取），只有 root 才可以有读取权限。\n\n再比如说，本来 root 用户才能做的开关机、新增或删除用户等命令，一旦允许任何人拥有这些权限，系统就可能会经常莫名其妙的挂掉。\n而且，万一 root 用户的密码被其他人获取，他们就可以登录你的系统，从事一些只有 root 用户才能执行的操作，这是绝对不允许发生的。\n\n因此，在服务器上，绝对不是所有的用户都使用 root 身份登录，而要根据不同的工作需要和职位需要，合理分配用户等级和权限等级。\n\n### 查看权限\n\nLinux 系统中，我们可以使用上文提到过的 `ls -al` 查看当前目录下所有文件的权限属性。\n\n![ls -al 指令](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015122718.png)\n\n在这些信息中，最左侧这一列就是文件的权限属性，它由 10 个字符组成。\n\n左侧 10 个字符，分为四部分，第一个字符表示文件类型，后面每部分 3 个字符，分别代表了所有者权限、所有者所在组权限、其他用户权限。\n\n文件类型共有以下可能的值：\n\n| `d` | `-` | `l` | `b` | `c` | `s` | `p` |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 目录 | 普通文件 | 链接文件 | 块设备 | 字符设备 | 套接字 | 管道 |\n\n文件权限共有以下可能的值，所有者、所有组、其他用户权限都一样：\n\n| `r` | `w` | `x` | `-` |\n| :---: | :---: | :---: | :---: |\n| 读权限，用数字4表示 | 写权限，用数字2表示 | 执行权限，用数字1表示 | 无权限，用数字0表示 |\n\n了解这些属性值之后，我们举个例子来讲解一下。\n```bash\ndrwxr-xr-x   3 root root       4096  9月 11 22:23 home\n```\n\n比如我们的 `/home` 目录，它的权限属性是 `drwxr-xr-x`，表示这是一个目录文件，这个目录可以被所有者读取、写入和执行，而属于同一组的用户和其他用户只能读取和执行它。\n\n### 修改权限\n我们可以使用 `chmod` 指令来修改文件的权限属性。一般有两种方式，一种是符号模式，一种是绝对模式。\n\n#### 符号模式\n我们可以使用以下格式的指令去修改文件的权限属性：\n```bash\nchmod [ugoa][+-=][rwx] filename\n```\n\n第一个参数是权限修改的范围，第二个参数是权限的操作，第三个参数是权限的类型。\n\n这里的第一个参数可以是以下四个字母中的任意一个：\n- `u` 表示文件的所有者\n- `g` 表示文件的所属组\n- `o` 表示其他用户\n- `a` 表示所有用户，相当于 `ugo` 的合集\n\n第二个符号参数可以是以下三个符号中的任意一个：\n- `+` 添加权限\n- `-` 删除权限\n- `=` 设置权限\n\n第三个符号参数就是我们前面说过的 `rwx`，分别表示读、写、执行权限。\n\n直接看使用案例可能更直观一些：\n```bash\nchmod u+x filename\nchmod g-w filename\nchmod o=rw- filename\n```\n\n#### 绝对模式\n由于权限中 rwx，其中一种权限只有存在和不存在两种状态，每种权限可以用一个 bit 来表示，`0` 表示无权限，`1` 表示有权限，rwx 只要三个 bit 表示。\n三个 bit 表示的一个二进制数即可表示rwx的情况。\n\n![权限原理](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015141918.png)\n\n求和之后，我们可以得到一个三位的八进制数，这个数就是我们要设置的权限。\n\n因此，我们可以使用一个三位的八进制数来表示权限，比如 `777`，这个数的二进制表示为 `111 111 111`，表示所有者、所属组和其他用户都有读、写、执行权限。\n```bash\nchmod 777 filename\n```\n\n### 其他相关指令\n除了 `chmod` 之外，还有一些指令用于 Linux 系统的权限管理，比如 `chown`、`chgrp` 等等。\n```bash\nchown user2 filename\nchgrp group2 filename\n```\n\n这两个指令分别用于修改文件的所有者和所属组，使用的频率比较低，用起来也比较简单，大家知道就好。\n\n## 更多的知识\nLinux 操作系统先讲这么多，更多的知识就留给大家自己去探索了。\n\n大家如果想看一些 Linux 教程书籍的话，推荐《鸟哥的 Linux 私房菜》，这本书是 Linux 界的经典书籍，内容详实，适合初学者阅读。\n学校图书馆和协会里也都有，欢迎大家来协会线下借阅。\n\n![鸟哥的Linux私房菜](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015143017.png)\n\n这些知识光听没什么用，大家还是要自己动手去实践，自己安装一个 Linux，多玩一玩，基本就能掌握个七七八八了。","source":"_posts/linux_for_freshman.md","raw":"---\ntitle: 面向新生的 Linux 教程\ndate: 2023/10/14\nauthor: ma5hr00m\ncategories:\n- Linux\n---\n\n2023 年 ***Vidar-Team*** 第四次新生培训 Linux 部分内容讲解。\n\n## 什么是操作系统\n### 概念\n大家都知道计算机硬件和软件。硬件就是我们计算机的物理组成部分，比如内存、硬盘、键盘，都是些电子元件；软件就是大家常用的浏览器、游戏这些。\n你单独使用硬件或软件都很难正常工作。想让计算机正常工作，就需要硬件和软件相互配合。而负责中间这个过程的，就是操作系统。\n\n操作系统（Operating System），也就是我们说的 OS，本质上就是一组相互关联的软件程序。\n操作系统是计算机最底层的软件，负责管理计算机的硬件和软件资源，控制着计算机的运行。\n\n我们平常使用的应用程序，包括 vscode、firefox 这样的软件应用，以及我们写的 C 语言程序、Python 脚本什么的，都需要以操作系统为基本支撑。没有操作系统，这些应用程序就都无法正常运行。\n\n### 组成\n如下图所示，操作系统可以简单划分为内核和系统调用两部分：\n\n![操作系统抽象划分](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231013143007.png)\n\n- 内核：内核是操作系统的核心，它负责管理计算机的硬件资源，如CPU、内存、磁盘、网络等。内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性和稳定性。内核运行在特权模式下，可以直接访问硬件设备和指令。\n- 系统调用：系统调用是用户进程进入内核的接口层，它是由内核函数实现的。通过系统调用，用户进程可以临时切换到内核模式，使用内核提供的服务和功能，如文件操作、进程管理、网络通信等。系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且编程效率大大提高。\n\n一些系统组件运行在应用程序层，比如我们经常使用的 shell、图形界面等，它们也是操作系统的一部分。\n\n\n## Linux\nLinux 是一个操作系统。它由 *Linus* 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。\n现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。\n\n![Linux Logo](https://pakhotin.org/wp-content/uploads/2023/07/53113-106400-Linux-xl.jpg)\n\n在座的大多数人都在使用 Windows 操作系统，Windwos 足够满足大家的日常学习生活，比如写代码、玩游戏、看视频。\n那我们今天为什么要来介绍 Linux 呢？\n\n原因很简单。如果你未来要踏足计算机领域，不管你是要学习计算机安全，还是要做些其他的什么方向，你都会有茫茫多的场景需要接触到 Linux，你没法避开它。\n不论你是否会把 Linux 当作主力操作系统，你都有必要学会使用它。\n\n## Linux 的优势\n现在来说说我们为什么要使用 Linux。\n\nLinux 自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。\n以前有很多设置你可能需要在 windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。\n\n此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。\n这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。\n\n同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。\n这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。\n\n现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。\n\n比如，你现在想要在 Windows 系统中配置一个基本的 Java 开发环境（[教程](https://www.runoob.com/java/java-environment-setup.html)），\n你需要先去 Java 官网下载 JDK，然后安装，接着配置 `JAVA_HOME` 等环境变量，这样才能开始写代码。一些没有经验的新生就会在这里消耗大量时间。\n而在 Linux 下你不需要这么麻烦，多数情况下，你只需要使用一行类似的命令就可以完成上述工作：\n```bash\nsudo apt install openjdk-17-jdk\n```\n\n当这句指令执行成功后，你就可以开始写代码了。非常轻松愉快，也节省了很多时间，让你专注于 Java 语言本身，而非繁琐的环境配置。\n\n## 发行版\nLinux 操作系统分为很多种，这些不同的 Linux 统称为 Linux 发行版（*Linux distribution*）。\n\n这些发行版都是基于 Linux 内核的，它们之间的差异主要体现在软件包管理工具、软件包源、软件包版本等方面，我们一会儿会做详细讲解。\n\n大家可以看这张图，这张图展示了一些常见的 Linux 发行版：\n\n![常见Linux发行版](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015001556.png)\n\n从这张图里，大家可以看到现在当下流行的一些发行版，比如 `Ubuntu`、`Fedora`、`ArchLinux`、`CentOS` 等等。\n这些发行版各有特点，有各自的适用场景，也都有着庞大的用户群体以及高度活跃的社区生态。\n\n实际上，现有的 Linux 发行版远不止图中展示的这些，现在光是被记录 Linux 版本列表中的就有超过 300 个。\n它们大多数都正处于活跃的开发中，由不同的公司、组织或其他群体进行维护，不断地被改进。\n\n接下来，我们会以 `Ubuntu22.04` 为例，来介绍 Linux 操作系统的一些常见概念以及基本使用方法。\n\n## 来，Ubuntu！\n### 安装\n在自己的计算机中安装一个 Ubuntu 系统有以下几种方式：\n1. 安装到VMware，Virtual Box等虚拟机软件里（推荐），这也是大多数初学者的选择。\n2. 安装到物理机上，单系统或双系统，但不推荐大家这样做。  \n   刚开始你直接单系统的话可能会出各种各样的问题，你可能会在一段时间内不断的搞坏自己的系统，然后重装，然后再搞坏，然后再重装，但这个折腾的过程中你也能学到很多东西，看你愿不愿意花这个时间。  \n   双系统的话，确实兼具了使用 Windows 的方便和体验 Linux 物理机的优势，但你有可能会遇到一些奇奇怪怪的问题，而这些问题你去网上有时候很难搜到解决方案，会耗费你很多时间。\n3. WSL（*Windows Subsystem for Linux*）也是一种可选方案，这是微软为 Windows 提供的一个 Linux 子系统。\n   但 WSL 相比虚拟机或者物理机来说都会有一些限制，比如你无法使用图形界面，无法使用一些特殊的硬件设备等等。\n\n关于如何在自己的计算机中安装一个 Ubuntu 系统，今天不会讲解具体步骤，这次分享会之前我们已经在群里发过了详细的教程，大家可以从群文件中找到那份文件，自行查阅。\n网上也有详细的教程，大家也都可以搜到。\n\n### 换源 & 包管理\n当你在安装好 Ubuntu 虚拟机后，你可以看到这样的桌面：\n\n![Ubuntu默认桌面](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015005727.png)\n\n乍一看还是和 `windows` 区别蛮大的。\n\n为了方便的安装各种软件，我们需要先了解一下软件源和包管理工具。\n\n软件源（*software source*）是指存放软件包的服务器，它们通常由软件开发商或者 Linux 发行版的维护者维护。\n\n包管理工具（*package manager*）是指用于安装、更新、卸载软件包的工具，它们可以从软件源中下载软件包，然后安装到系统中。\n`Ubuntu` 自带的包管理工具是 `apt`，它的软件源默认是国外的。\n\n出于一些众所周知的原因，国内用户访问国外链接会比较慢，有时候还会请求超时。\n不管不问的话用起来会很不爽。\n为了解决问题，我们需要对我们的软件源进行更换，一般是将其更换为国内源，比如清华镜像源。\n\n我们可以使用指令来完成换源的操作，具体指令可以看看群里的文档，这里就不再赘述了。\n\n在换源之后，我们需要执行命令更新软件包列表 `sudo apt update`。\n成功执行后，我们就可以使用 `apt` 来方便地管理软件了。\n\n常用的 `apt` 指令有图片中这些，不需要刻意去记，你自己用几次就熟悉了。\n\n![常用apt指令](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015010916.png)\n\n除了 apt，其他 Linux 发行版也都有各自的包管理工具，比如 CentOS 的 `yum`、Fedora 的 `dnf`、Arch 的 `pacman` 等等。\n他们的使用方法都差不多，也都是用来管理软件包的。\n根据自己用的发行版来就好了。\n\n![根据包管理器划分Linux发行版](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231014223037.png)\n\n上面这张图是根据包管理工具的不同对当前常见的 Linux 发行版做的一个分类。\n\n## 文件系统\n现在来说说目录结构，这也是 Windows 和 Linux 之间的一个重要区别。\n\nWindows 的目录结构是以物理存储介质为主，通过分区来实现文件目录的管理，每个分区被视为一个独立的盘符，如 C 盘、D 盘等等。\n不同分区之间相互独立，联系并不紧密。\n\n而在 Linux 中，所有分区都被挂载到根目录下，所有的文件和目录都被组织成以一个跟节点开始的树形结构。\n这个树形结构就是 Linux 的文件系统。\n\n打开 Linux 的终端，输入 `ls /`，你就可以看到根目录下的所有文件和目录。\n\n![ls / 执行结果](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015105831.png)\n\nLinux 的根目录是 `/`，它是整个文件系统的起点，在根目录之下的既可以是其他目录，也可以是文件。\n而每一个目录中又可以包含其他目录和文件，如此反复就构成了一个庞大的文件系统。\n\n![Linux文件系统](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015113020.png)\n\n根目录下的每个目录都有各自作用。\n\n比如这里的 `/home` 目录，就是用户的主目录。在 Linux 中，每个用户都有自己的主目录，用来存放用户的个人文件。\n用户主目录一般是以用户的帐号命名的，比如上图中的 alice、bob、eve。\n\n再比如这里的 `/lib` 目录，这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。\n几乎所有的应用程序都需要用到这些共享库。\n\n<!-- 介绍各个目录的作用 -->\n\n这张图中的箭头是在表示某些目录之间的关系。\n\n先来看根目录下的 `/bin`，bin 是 `binary` 的缩写，这个目录下存放着一些最基本的命令，比如 `ls`、`cp`、`mv`、`rm` 等等。这些命令在系统启动时就会用到，可以被当前系统下所有用户使用。\n与 bin 相连的箭头指向了 `/usr/bin`，这个目录下存放着一些用户级的命令，比如 `vim`、`gcc` 等，这些命令只能被当前用户使用。\n\n类似的还有 `/sbin` 和 `/usr/sbin`。\n\n## 常用命令\n讲完前面这些，我们就可以来说说 Linux 常用的一些指令了。\n\n`ls`用来列出目录下的所有文件和目录。\n```\nls\nls -a\nls -l\nls <path>\n```\n\n`cd`用于切换目录。\n```\ncd ~ \ncd ..\ncd -\ncd <path>\n```\n\n`mkdir` 用于创建目录。\n```\nmkdir <name>\nmkdir –p <name>\n```\n\n`cp` 用于复制文件或目录到指定位置。\n```\ncp <src> <dst>\ncp –r <src> <dst>\n```\n\n`mv` 用于移动文件或目录到指定位置，这个指令也可以用来给某个文件或目录重命名。\n```\nmv <src> <dst>\n```\n\n`rm` 用于删除文件或目录。\n```\nrm <target>\nrm –r <target>\nrm –f <target>\n```\n\n## 权限管理\n在多用户计算机系统的管理中，权限是指某个特定用户具有特定的系统资源使用权利。\n\n个人主机大家一般不会管这么多，通常都是直接使用管理员身份登陆了，因为个人计算机的使用者一般都是大家可以信任的人。\n而在服务器上就不是这种情况。服务器上的用户可能彼此之间并不熟悉，而服务器中又往往存储着各种各样的资源，有些资源你不希望别的用户看到。\n服务器中的数据越重要，价值越高，往往服务器中对权限的设定就要越详细，用户的分级也要越明确。\n\n与 windows 不同，Linux 为每个文件都设置了很多属性，最大的作用就是维护数据安全。\n举个简单的例子，在你的 Linux 系统中，和系统服务相关的文件通常只有 root 用户才能读或写。\n就拿 `/etc/shadow` 这个文件来说，此文件记录了系统中所有用户的密码数据，非常重要，因此绝不能让任何人读取（否则密码数据会被窃取），只有 root 才可以有读取权限。\n\n再比如说，本来 root 用户才能做的开关机、新增或删除用户等命令，一旦允许任何人拥有这些权限，系统就可能会经常莫名其妙的挂掉。\n而且，万一 root 用户的密码被其他人获取，他们就可以登录你的系统，从事一些只有 root 用户才能执行的操作，这是绝对不允许发生的。\n\n因此，在服务器上，绝对不是所有的用户都使用 root 身份登录，而要根据不同的工作需要和职位需要，合理分配用户等级和权限等级。\n\n### 查看权限\n\nLinux 系统中，我们可以使用上文提到过的 `ls -al` 查看当前目录下所有文件的权限属性。\n\n![ls -al 指令](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015122718.png)\n\n在这些信息中，最左侧这一列就是文件的权限属性，它由 10 个字符组成。\n\n左侧 10 个字符，分为四部分，第一个字符表示文件类型，后面每部分 3 个字符，分别代表了所有者权限、所有者所在组权限、其他用户权限。\n\n文件类型共有以下可能的值：\n\n| `d` | `-` | `l` | `b` | `c` | `s` | `p` |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 目录 | 普通文件 | 链接文件 | 块设备 | 字符设备 | 套接字 | 管道 |\n\n文件权限共有以下可能的值，所有者、所有组、其他用户权限都一样：\n\n| `r` | `w` | `x` | `-` |\n| :---: | :---: | :---: | :---: |\n| 读权限，用数字4表示 | 写权限，用数字2表示 | 执行权限，用数字1表示 | 无权限，用数字0表示 |\n\n了解这些属性值之后，我们举个例子来讲解一下。\n```bash\ndrwxr-xr-x   3 root root       4096  9月 11 22:23 home\n```\n\n比如我们的 `/home` 目录，它的权限属性是 `drwxr-xr-x`，表示这是一个目录文件，这个目录可以被所有者读取、写入和执行，而属于同一组的用户和其他用户只能读取和执行它。\n\n### 修改权限\n我们可以使用 `chmod` 指令来修改文件的权限属性。一般有两种方式，一种是符号模式，一种是绝对模式。\n\n#### 符号模式\n我们可以使用以下格式的指令去修改文件的权限属性：\n```bash\nchmod [ugoa][+-=][rwx] filename\n```\n\n第一个参数是权限修改的范围，第二个参数是权限的操作，第三个参数是权限的类型。\n\n这里的第一个参数可以是以下四个字母中的任意一个：\n- `u` 表示文件的所有者\n- `g` 表示文件的所属组\n- `o` 表示其他用户\n- `a` 表示所有用户，相当于 `ugo` 的合集\n\n第二个符号参数可以是以下三个符号中的任意一个：\n- `+` 添加权限\n- `-` 删除权限\n- `=` 设置权限\n\n第三个符号参数就是我们前面说过的 `rwx`，分别表示读、写、执行权限。\n\n直接看使用案例可能更直观一些：\n```bash\nchmod u+x filename\nchmod g-w filename\nchmod o=rw- filename\n```\n\n#### 绝对模式\n由于权限中 rwx，其中一种权限只有存在和不存在两种状态，每种权限可以用一个 bit 来表示，`0` 表示无权限，`1` 表示有权限，rwx 只要三个 bit 表示。\n三个 bit 表示的一个二进制数即可表示rwx的情况。\n\n![权限原理](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015141918.png)\n\n求和之后，我们可以得到一个三位的八进制数，这个数就是我们要设置的权限。\n\n因此，我们可以使用一个三位的八进制数来表示权限，比如 `777`，这个数的二进制表示为 `111 111 111`，表示所有者、所属组和其他用户都有读、写、执行权限。\n```bash\nchmod 777 filename\n```\n\n### 其他相关指令\n除了 `chmod` 之外，还有一些指令用于 Linux 系统的权限管理，比如 `chown`、`chgrp` 等等。\n```bash\nchown user2 filename\nchgrp group2 filename\n```\n\n这两个指令分别用于修改文件的所有者和所属组，使用的频率比较低，用起来也比较简单，大家知道就好。\n\n## 更多的知识\nLinux 操作系统先讲这么多，更多的知识就留给大家自己去探索了。\n\n大家如果想看一些 Linux 教程书籍的话，推荐《鸟哥的 Linux 私房菜》，这本书是 Linux 界的经典书籍，内容详实，适合初学者阅读。\n学校图书馆和协会里也都有，欢迎大家来协会线下借阅。\n\n![鸟哥的Linux私房菜](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015143017.png)\n\n这些知识光听没什么用，大家还是要自己动手去实践，自己安装一个 Linux，多玩一玩，基本就能掌握个七七八八了。","slug":"linux_for_freshman","published":1,"updated":"2024-06-09T12:55:42.717Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap8000wf4lycx870b8u","content":"<p>2023 年 <em><strong>Vidar-Team</strong></em> 第四次新生培训 Linux 部分内容讲解。</p>\n<h2 id=\"什么是操作系统\"><a href=\"#什么是操作系统\" class=\"headerlink\" title=\"什么是操作系统\"></a>什么是操作系统</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>大家都知道计算机硬件和软件。硬件就是我们计算机的物理组成部分，比如内存、硬盘、键盘，都是些电子元件；软件就是大家常用的浏览器、游戏这些。<br>你单独使用硬件或软件都很难正常工作。想让计算机正常工作，就需要硬件和软件相互配合。而负责中间这个过程的，就是操作系统。</p>\n<p>操作系统（Operating System），也就是我们说的 OS，本质上就是一组相互关联的软件程序。<br>操作系统是计算机最底层的软件，负责管理计算机的硬件和软件资源，控制着计算机的运行。</p>\n<p>我们平常使用的应用程序，包括 vscode、firefox 这样的软件应用，以及我们写的 C 语言程序、Python 脚本什么的，都需要以操作系统为基本支撑。没有操作系统，这些应用程序就都无法正常运行。</p>\n<h3 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h3><p>如下图所示，操作系统可以简单划分为内核和系统调用两部分：</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231013143007.png\" alt=\"操作系统抽象划分\"></p>\n<ul>\n<li>内核：内核是操作系统的核心，它负责管理计算机的硬件资源，如CPU、内存、磁盘、网络等。内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性和稳定性。内核运行在特权模式下，可以直接访问硬件设备和指令。</li>\n<li>系统调用：系统调用是用户进程进入内核的接口层，它是由内核函数实现的。通过系统调用，用户进程可以临时切换到内核模式，使用内核提供的服务和功能，如文件操作、进程管理、网络通信等。系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且编程效率大大提高。</li>\n</ul>\n<p>一些系统组件运行在应用程序层，比如我们经常使用的 shell、图形界面等，它们也是操作系统的一部分。</p>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><p>Linux 是一个操作系统。它由 <em>Linus</em> 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。<br>现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。</p>\n<p><img src=\"https://pakhotin.org/wp-content/uploads/2023/07/53113-106400-Linux-xl.jpg\" alt=\"Linux Logo\"></p>\n<p>在座的大多数人都在使用 Windows 操作系统，Windwos 足够满足大家的日常学习生活，比如写代码、玩游戏、看视频。<br>那我们今天为什么要来介绍 Linux 呢？</p>\n<p>原因很简单。如果你未来要踏足计算机领域，不管你是要学习计算机安全，还是要做些其他的什么方向，你都会有茫茫多的场景需要接触到 Linux，你没法避开它。<br>不论你是否会把 Linux 当作主力操作系统，你都有必要学会使用它。</p>\n<h2 id=\"Linux-的优势\"><a href=\"#Linux-的优势\" class=\"headerlink\" title=\"Linux 的优势\"></a>Linux 的优势</h2><p>现在来说说我们为什么要使用 Linux。</p>\n<p>Linux 自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。<br>以前有很多设置你可能需要在 windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。</p>\n<p>此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。<br>这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。</p>\n<p>同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。<br>这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。</p>\n<p>现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。</p>\n<p>比如，你现在想要在 Windows 系统中配置一个基本的 Java 开发环境（<a href=\"https://www.runoob.com/java/java-environment-setup.html\">教程</a>），<br>你需要先去 Java 官网下载 JDK，然后安装，接着配置 <code>JAVA_HOME</code> 等环境变量，这样才能开始写代码。一些没有经验的新生就会在这里消耗大量时间。<br>而在 Linux 下你不需要这么麻烦，多数情况下，你只需要使用一行类似的命令就可以完成上述工作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install openjdk-17-jdk</span><br></pre></td></tr></table></figure>\n\n<p>当这句指令执行成功后，你就可以开始写代码了。非常轻松愉快，也节省了很多时间，让你专注于 Java 语言本身，而非繁琐的环境配置。</p>\n<h2 id=\"发行版\"><a href=\"#发行版\" class=\"headerlink\" title=\"发行版\"></a>发行版</h2><p>Linux 操作系统分为很多种，这些不同的 Linux 统称为 Linux 发行版（<em>Linux distribution</em>）。</p>\n<p>这些发行版都是基于 Linux 内核的，它们之间的差异主要体现在软件包管理工具、软件包源、软件包版本等方面，我们一会儿会做详细讲解。</p>\n<p>大家可以看这张图，这张图展示了一些常见的 Linux 发行版：</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015001556.png\" alt=\"常见Linux发行版\"></p>\n<p>从这张图里，大家可以看到现在当下流行的一些发行版，比如 <code>Ubuntu</code>、<code>Fedora</code>、<code>ArchLinux</code>、<code>CentOS</code> 等等。<br>这些发行版各有特点，有各自的适用场景，也都有着庞大的用户群体以及高度活跃的社区生态。</p>\n<p>实际上，现有的 Linux 发行版远不止图中展示的这些，现在光是被记录 Linux 版本列表中的就有超过 300 个。<br>它们大多数都正处于活跃的开发中，由不同的公司、组织或其他群体进行维护，不断地被改进。</p>\n<p>接下来，我们会以 <code>Ubuntu22.04</code> 为例，来介绍 Linux 操作系统的一些常见概念以及基本使用方法。</p>\n<h2 id=\"来，Ubuntu！\"><a href=\"#来，Ubuntu！\" class=\"headerlink\" title=\"来，Ubuntu！\"></a>来，Ubuntu！</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在自己的计算机中安装一个 Ubuntu 系统有以下几种方式：</p>\n<ol>\n<li>安装到VMware，Virtual Box等虚拟机软件里（推荐），这也是大多数初学者的选择。</li>\n<li>安装到物理机上，单系统或双系统，但不推荐大家这样做。<br>刚开始你直接单系统的话可能会出各种各样的问题，你可能会在一段时间内不断的搞坏自己的系统，然后重装，然后再搞坏，然后再重装，但这个折腾的过程中你也能学到很多东西，看你愿不愿意花这个时间。<br>双系统的话，确实兼具了使用 Windows 的方便和体验 Linux 物理机的优势，但你有可能会遇到一些奇奇怪怪的问题，而这些问题你去网上有时候很难搜到解决方案，会耗费你很多时间。</li>\n<li>WSL（<em>Windows Subsystem for Linux</em>）也是一种可选方案，这是微软为 Windows 提供的一个 Linux 子系统。<br>但 WSL 相比虚拟机或者物理机来说都会有一些限制，比如你无法使用图形界面，无法使用一些特殊的硬件设备等等。</li>\n</ol>\n<p>关于如何在自己的计算机中安装一个 Ubuntu 系统，今天不会讲解具体步骤，这次分享会之前我们已经在群里发过了详细的教程，大家可以从群文件中找到那份文件，自行查阅。<br>网上也有详细的教程，大家也都可以搜到。</p>\n<h3 id=\"换源-包管理\"><a href=\"#换源-包管理\" class=\"headerlink\" title=\"换源 &amp; 包管理\"></a>换源 &amp; 包管理</h3><p>当你在安装好 Ubuntu 虚拟机后，你可以看到这样的桌面：</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015005727.png\" alt=\"Ubuntu默认桌面\"></p>\n<p>乍一看还是和 <code>windows</code> 区别蛮大的。</p>\n<p>为了方便的安装各种软件，我们需要先了解一下软件源和包管理工具。</p>\n<p>软件源（<em>software source</em>）是指存放软件包的服务器，它们通常由软件开发商或者 Linux 发行版的维护者维护。</p>\n<p>包管理工具（<em>package manager</em>）是指用于安装、更新、卸载软件包的工具，它们可以从软件源中下载软件包，然后安装到系统中。<br><code>Ubuntu</code> 自带的包管理工具是 <code>apt</code>，它的软件源默认是国外的。</p>\n<p>出于一些众所周知的原因，国内用户访问国外链接会比较慢，有时候还会请求超时。<br>不管不问的话用起来会很不爽。<br>为了解决问题，我们需要对我们的软件源进行更换，一般是将其更换为国内源，比如清华镜像源。</p>\n<p>我们可以使用指令来完成换源的操作，具体指令可以看看群里的文档，这里就不再赘述了。</p>\n<p>在换源之后，我们需要执行命令更新软件包列表 <code>sudo apt update</code>。<br>成功执行后，我们就可以使用 <code>apt</code> 来方便地管理软件了。</p>\n<p>常用的 <code>apt</code> 指令有图片中这些，不需要刻意去记，你自己用几次就熟悉了。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015010916.png\" alt=\"常用apt指令\"></p>\n<p>除了 apt，其他 Linux 发行版也都有各自的包管理工具，比如 CentOS 的 <code>yum</code>、Fedora 的 <code>dnf</code>、Arch 的 <code>pacman</code> 等等。<br>他们的使用方法都差不多，也都是用来管理软件包的。<br>根据自己用的发行版来就好了。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231014223037.png\" alt=\"根据包管理器划分Linux发行版\"></p>\n<p>上面这张图是根据包管理工具的不同对当前常见的 Linux 发行版做的一个分类。</p>\n<h2 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h2><p>现在来说说目录结构，这也是 Windows 和 Linux 之间的一个重要区别。</p>\n<p>Windows 的目录结构是以物理存储介质为主，通过分区来实现文件目录的管理，每个分区被视为一个独立的盘符，如 C 盘、D 盘等等。<br>不同分区之间相互独立，联系并不紧密。</p>\n<p>而在 Linux 中，所有分区都被挂载到根目录下，所有的文件和目录都被组织成以一个跟节点开始的树形结构。<br>这个树形结构就是 Linux 的文件系统。</p>\n<p>打开 Linux 的终端，输入 <code>ls /</code>，你就可以看到根目录下的所有文件和目录。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015105831.png\" alt=\"ls / 执行结果\"></p>\n<p>Linux 的根目录是 <code>/</code>，它是整个文件系统的起点，在根目录之下的既可以是其他目录，也可以是文件。<br>而每一个目录中又可以包含其他目录和文件，如此反复就构成了一个庞大的文件系统。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015113020.png\" alt=\"Linux文件系统\"></p>\n<p>根目录下的每个目录都有各自作用。</p>\n<p>比如这里的 <code>/home</code> 目录，就是用户的主目录。在 Linux 中，每个用户都有自己的主目录，用来存放用户的个人文件。<br>用户主目录一般是以用户的帐号命名的，比如上图中的 alice、bob、eve。</p>\n<p>再比如这里的 <code>/lib</code> 目录，这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。<br>几乎所有的应用程序都需要用到这些共享库。</p>\n<!-- 介绍各个目录的作用 -->\n\n<p>这张图中的箭头是在表示某些目录之间的关系。</p>\n<p>先来看根目录下的 <code>/bin</code>，bin 是 <code>binary</code> 的缩写，这个目录下存放着一些最基本的命令，比如 <code>ls</code>、<code>cp</code>、<code>mv</code>、<code>rm</code> 等等。这些命令在系统启动时就会用到，可以被当前系统下所有用户使用。<br>与 bin 相连的箭头指向了 <code>/usr/bin</code>，这个目录下存放着一些用户级的命令，比如 <code>vim</code>、<code>gcc</code> 等，这些命令只能被当前用户使用。</p>\n<p>类似的还有 <code>/sbin</code> 和 <code>/usr/sbin</code>。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>讲完前面这些，我们就可以来说说 Linux 常用的一些指令了。</p>\n<p><code>ls</code>用来列出目录下的所有文件和目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">ls -a</span><br><span class=\"line\">ls -l</span><br><span class=\"line\">ls &lt;path&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>cd</code>用于切换目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~ </span><br><span class=\"line\">cd ..</span><br><span class=\"line\">cd -</span><br><span class=\"line\">cd &lt;path&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>mkdir</code> 用于创建目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir &lt;name&gt;</span><br><span class=\"line\">mkdir –p &lt;name&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>cp</code> 用于复制文件或目录到指定位置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp &lt;src&gt; &lt;dst&gt;</span><br><span class=\"line\">cp –r &lt;src&gt; &lt;dst&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>mv</code> 用于移动文件或目录到指定位置，这个指令也可以用来给某个文件或目录重命名。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv &lt;src&gt; &lt;dst&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>rm</code> 用于删除文件或目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm &lt;target&gt;</span><br><span class=\"line\">rm –r &lt;target&gt;</span><br><span class=\"line\">rm –f &lt;target&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h2><p>在多用户计算机系统的管理中，权限是指某个特定用户具有特定的系统资源使用权利。</p>\n<p>个人主机大家一般不会管这么多，通常都是直接使用管理员身份登陆了，因为个人计算机的使用者一般都是大家可以信任的人。<br>而在服务器上就不是这种情况。服务器上的用户可能彼此之间并不熟悉，而服务器中又往往存储着各种各样的资源，有些资源你不希望别的用户看到。<br>服务器中的数据越重要，价值越高，往往服务器中对权限的设定就要越详细，用户的分级也要越明确。</p>\n<p>与 windows 不同，Linux 为每个文件都设置了很多属性，最大的作用就是维护数据安全。<br>举个简单的例子，在你的 Linux 系统中，和系统服务相关的文件通常只有 root 用户才能读或写。<br>就拿 <code>/etc/shadow</code> 这个文件来说，此文件记录了系统中所有用户的密码数据，非常重要，因此绝不能让任何人读取（否则密码数据会被窃取），只有 root 才可以有读取权限。</p>\n<p>再比如说，本来 root 用户才能做的开关机、新增或删除用户等命令，一旦允许任何人拥有这些权限，系统就可能会经常莫名其妙的挂掉。<br>而且，万一 root 用户的密码被其他人获取，他们就可以登录你的系统，从事一些只有 root 用户才能执行的操作，这是绝对不允许发生的。</p>\n<p>因此，在服务器上，绝对不是所有的用户都使用 root 身份登录，而要根据不同的工作需要和职位需要，合理分配用户等级和权限等级。</p>\n<h3 id=\"查看权限\"><a href=\"#查看权限\" class=\"headerlink\" title=\"查看权限\"></a>查看权限</h3><p>Linux 系统中，我们可以使用上文提到过的 <code>ls -al</code> 查看当前目录下所有文件的权限属性。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015122718.png\" alt=\"ls -al 指令\"></p>\n<p>在这些信息中，最左侧这一列就是文件的权限属性，它由 10 个字符组成。</p>\n<p>左侧 10 个字符，分为四部分，第一个字符表示文件类型，后面每部分 3 个字符，分别代表了所有者权限、所有者所在组权限、其他用户权限。</p>\n<p>文件类型共有以下可能的值：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code>d</code></th>\n<th align=\"center\"><code>-</code></th>\n<th align=\"center\"><code>l</code></th>\n<th align=\"center\"><code>b</code></th>\n<th align=\"center\"><code>c</code></th>\n<th align=\"center\"><code>s</code></th>\n<th align=\"center\"><code>p</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">目录</td>\n<td align=\"center\">普通文件</td>\n<td align=\"center\">链接文件</td>\n<td align=\"center\">块设备</td>\n<td align=\"center\">字符设备</td>\n<td align=\"center\">套接字</td>\n<td align=\"center\">管道</td>\n</tr>\n</tbody></table>\n<p>文件权限共有以下可能的值，所有者、所有组、其他用户权限都一样：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code>r</code></th>\n<th align=\"center\"><code>w</code></th>\n<th align=\"center\"><code>x</code></th>\n<th align=\"center\"><code>-</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">读权限，用数字4表示</td>\n<td align=\"center\">写权限，用数字2表示</td>\n<td align=\"center\">执行权限，用数字1表示</td>\n<td align=\"center\">无权限，用数字0表示</td>\n</tr>\n</tbody></table>\n<p>了解这些属性值之后，我们举个例子来讲解一下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drwxr-xr-x   3 root root       4096  9月 11 22:23 home</span><br></pre></td></tr></table></figure>\n\n<p>比如我们的 <code>/home</code> 目录，它的权限属性是 <code>drwxr-xr-x</code>，表示这是一个目录文件，这个目录可以被所有者读取、写入和执行，而属于同一组的用户和其他用户只能读取和执行它。</p>\n<h3 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h3><p>我们可以使用 <code>chmod</code> 指令来修改文件的权限属性。一般有两种方式，一种是符号模式，一种是绝对模式。</p>\n<h4 id=\"符号模式\"><a href=\"#符号模式\" class=\"headerlink\" title=\"符号模式\"></a>符号模式</h4><p>我们可以使用以下格式的指令去修改文件的权限属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> [ugoa][+-=][rwx] filename</span><br></pre></td></tr></table></figure>\n\n<p>第一个参数是权限修改的范围，第二个参数是权限的操作，第三个参数是权限的类型。</p>\n<p>这里的第一个参数可以是以下四个字母中的任意一个：</p>\n<ul>\n<li><code>u</code> 表示文件的所有者</li>\n<li><code>g</code> 表示文件的所属组</li>\n<li><code>o</code> 表示其他用户</li>\n<li><code>a</code> 表示所有用户，相当于 <code>ugo</code> 的合集</li>\n</ul>\n<p>第二个符号参数可以是以下三个符号中的任意一个：</p>\n<ul>\n<li><code>+</code> 添加权限</li>\n<li><code>-</code> 删除权限</li>\n<li><code>=</code> 设置权限</li>\n</ul>\n<p>第三个符号参数就是我们前面说过的 <code>rwx</code>，分别表示读、写、执行权限。</p>\n<p>直接看使用案例可能更直观一些：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> u+x filename</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> g-w filename</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> o=rw- filename</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"绝对模式\"><a href=\"#绝对模式\" class=\"headerlink\" title=\"绝对模式\"></a>绝对模式</h4><p>由于权限中 rwx，其中一种权限只有存在和不存在两种状态，每种权限可以用一个 bit 来表示，<code>0</code> 表示无权限，<code>1</code> 表示有权限，rwx 只要三个 bit 表示。<br>三个 bit 表示的一个二进制数即可表示rwx的情况。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015141918.png\" alt=\"权限原理\"></p>\n<p>求和之后，我们可以得到一个三位的八进制数，这个数就是我们要设置的权限。</p>\n<p>因此，我们可以使用一个三位的八进制数来表示权限，比如 <code>777</code>，这个数的二进制表示为 <code>111 111 111</code>，表示所有者、所属组和其他用户都有读、写、执行权限。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 777 filename</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他相关指令\"><a href=\"#其他相关指令\" class=\"headerlink\" title=\"其他相关指令\"></a>其他相关指令</h3><p>除了 <code>chmod</code> 之外，还有一些指令用于 Linux 系统的权限管理，比如 <code>chown</code>、<code>chgrp</code> 等等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chown</span> user2 filename</span><br><span class=\"line\"><span class=\"built_in\">chgrp</span> group2 filename</span><br></pre></td></tr></table></figure>\n\n<p>这两个指令分别用于修改文件的所有者和所属组，使用的频率比较低，用起来也比较简单，大家知道就好。</p>\n<h2 id=\"更多的知识\"><a href=\"#更多的知识\" class=\"headerlink\" title=\"更多的知识\"></a>更多的知识</h2><p>Linux 操作系统先讲这么多，更多的知识就留给大家自己去探索了。</p>\n<p>大家如果想看一些 Linux 教程书籍的话，推荐《鸟哥的 Linux 私房菜》，这本书是 Linux 界的经典书籍，内容详实，适合初学者阅读。<br>学校图书馆和协会里也都有，欢迎大家来协会线下借阅。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015143017.png\" alt=\"鸟哥的Linux私房菜\"></p>\n<p>这些知识光听没什么用，大家还是要自己动手去实践，自己安装一个 Linux，多玩一玩，基本就能掌握个七七八八了。</p>\n","excerpt":"","more":"<p>2023 年 <em><strong>Vidar-Team</strong></em> 第四次新生培训 Linux 部分内容讲解。</p>\n<h2 id=\"什么是操作系统\"><a href=\"#什么是操作系统\" class=\"headerlink\" title=\"什么是操作系统\"></a>什么是操作系统</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>大家都知道计算机硬件和软件。硬件就是我们计算机的物理组成部分，比如内存、硬盘、键盘，都是些电子元件；软件就是大家常用的浏览器、游戏这些。<br>你单独使用硬件或软件都很难正常工作。想让计算机正常工作，就需要硬件和软件相互配合。而负责中间这个过程的，就是操作系统。</p>\n<p>操作系统（Operating System），也就是我们说的 OS，本质上就是一组相互关联的软件程序。<br>操作系统是计算机最底层的软件，负责管理计算机的硬件和软件资源，控制着计算机的运行。</p>\n<p>我们平常使用的应用程序，包括 vscode、firefox 这样的软件应用，以及我们写的 C 语言程序、Python 脚本什么的，都需要以操作系统为基本支撑。没有操作系统，这些应用程序就都无法正常运行。</p>\n<h3 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h3><p>如下图所示，操作系统可以简单划分为内核和系统调用两部分：</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231013143007.png\" alt=\"操作系统抽象划分\"></p>\n<ul>\n<li>内核：内核是操作系统的核心，它负责管理计算机的硬件资源，如CPU、内存、磁盘、网络等。内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性和稳定性。内核运行在特权模式下，可以直接访问硬件设备和指令。</li>\n<li>系统调用：系统调用是用户进程进入内核的接口层，它是由内核函数实现的。通过系统调用，用户进程可以临时切换到内核模式，使用内核提供的服务和功能，如文件操作、进程管理、网络通信等。系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且编程效率大大提高。</li>\n</ul>\n<p>一些系统组件运行在应用程序层，比如我们经常使用的 shell、图形界面等，它们也是操作系统的一部分。</p>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><p>Linux 是一个操作系统。它由 <em>Linus</em> 于 1991 年构思设计而成。最初这只是他的一项兴趣爱好。<br>现如今，经过多年的发展，这项兴趣爱好已经成为了拥有最大用户群的操作系统。</p>\n<p><img src=\"https://pakhotin.org/wp-content/uploads/2023/07/53113-106400-Linux-xl.jpg\" alt=\"Linux Logo\"></p>\n<p>在座的大多数人都在使用 Windows 操作系统，Windwos 足够满足大家的日常学习生活，比如写代码、玩游戏、看视频。<br>那我们今天为什么要来介绍 Linux 呢？</p>\n<p>原因很简单。如果你未来要踏足计算机领域，不管你是要学习计算机安全，还是要做些其他的什么方向，你都会有茫茫多的场景需要接触到 Linux，你没法避开它。<br>不论你是否会把 Linux 当作主力操作系统，你都有必要学会使用它。</p>\n<h2 id=\"Linux-的优势\"><a href=\"#Linux-的优势\" class=\"headerlink\" title=\"Linux 的优势\"></a>Linux 的优势</h2><p>现在来说说我们为什么要使用 Linux。</p>\n<p>Linux 自带强大的命令行工具，可以完成各种工作，比如文件操作、网络通信、进程管理等，而不需要使用图形化界面。<br>以前有很多设置你可能需要在 windows 的系统设置里面翻来翻去，而在 Linux 下，你只需要打开命令行，敲一些指令就行。</p>\n<p>此外，相比 Windows 系统，Linux 可以做到更加高效，更加安全，更加稳定，以及更小的损耗。<br>这些优势使得 Linux 在服务器领域占据了大量份额，对运维来说，熟练使用 Linux 是必备技能。</p>\n<p>同时，Linux 还是一款开源的操作系统，每个人都可以下载其源代码进行定制。<br>这使得 Linux 有着强大的生命力，可以适应各种场景的需求，也促生了 Linux 活跃的社区生态。</p>\n<p>现阶段，对大家来说，使用 Linux 最大的好处就是可以快速地搭建各种环境。</p>\n<p>比如，你现在想要在 Windows 系统中配置一个基本的 Java 开发环境（<a href=\"https://www.runoob.com/java/java-environment-setup.html\">教程</a>），<br>你需要先去 Java 官网下载 JDK，然后安装，接着配置 <code>JAVA_HOME</code> 等环境变量，这样才能开始写代码。一些没有经验的新生就会在这里消耗大量时间。<br>而在 Linux 下你不需要这么麻烦，多数情况下，你只需要使用一行类似的命令就可以完成上述工作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install openjdk-17-jdk</span><br></pre></td></tr></table></figure>\n\n<p>当这句指令执行成功后，你就可以开始写代码了。非常轻松愉快，也节省了很多时间，让你专注于 Java 语言本身，而非繁琐的环境配置。</p>\n<h2 id=\"发行版\"><a href=\"#发行版\" class=\"headerlink\" title=\"发行版\"></a>发行版</h2><p>Linux 操作系统分为很多种，这些不同的 Linux 统称为 Linux 发行版（<em>Linux distribution</em>）。</p>\n<p>这些发行版都是基于 Linux 内核的，它们之间的差异主要体现在软件包管理工具、软件包源、软件包版本等方面，我们一会儿会做详细讲解。</p>\n<p>大家可以看这张图，这张图展示了一些常见的 Linux 发行版：</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015001556.png\" alt=\"常见Linux发行版\"></p>\n<p>从这张图里，大家可以看到现在当下流行的一些发行版，比如 <code>Ubuntu</code>、<code>Fedora</code>、<code>ArchLinux</code>、<code>CentOS</code> 等等。<br>这些发行版各有特点，有各自的适用场景，也都有着庞大的用户群体以及高度活跃的社区生态。</p>\n<p>实际上，现有的 Linux 发行版远不止图中展示的这些，现在光是被记录 Linux 版本列表中的就有超过 300 个。<br>它们大多数都正处于活跃的开发中，由不同的公司、组织或其他群体进行维护，不断地被改进。</p>\n<p>接下来，我们会以 <code>Ubuntu22.04</code> 为例，来介绍 Linux 操作系统的一些常见概念以及基本使用方法。</p>\n<h2 id=\"来，Ubuntu！\"><a href=\"#来，Ubuntu！\" class=\"headerlink\" title=\"来，Ubuntu！\"></a>来，Ubuntu！</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>在自己的计算机中安装一个 Ubuntu 系统有以下几种方式：</p>\n<ol>\n<li>安装到VMware，Virtual Box等虚拟机软件里（推荐），这也是大多数初学者的选择。</li>\n<li>安装到物理机上，单系统或双系统，但不推荐大家这样做。<br>刚开始你直接单系统的话可能会出各种各样的问题，你可能会在一段时间内不断的搞坏自己的系统，然后重装，然后再搞坏，然后再重装，但这个折腾的过程中你也能学到很多东西，看你愿不愿意花这个时间。<br>双系统的话，确实兼具了使用 Windows 的方便和体验 Linux 物理机的优势，但你有可能会遇到一些奇奇怪怪的问题，而这些问题你去网上有时候很难搜到解决方案，会耗费你很多时间。</li>\n<li>WSL（<em>Windows Subsystem for Linux</em>）也是一种可选方案，这是微软为 Windows 提供的一个 Linux 子系统。<br>但 WSL 相比虚拟机或者物理机来说都会有一些限制，比如你无法使用图形界面，无法使用一些特殊的硬件设备等等。</li>\n</ol>\n<p>关于如何在自己的计算机中安装一个 Ubuntu 系统，今天不会讲解具体步骤，这次分享会之前我们已经在群里发过了详细的教程，大家可以从群文件中找到那份文件，自行查阅。<br>网上也有详细的教程，大家也都可以搜到。</p>\n<h3 id=\"换源-包管理\"><a href=\"#换源-包管理\" class=\"headerlink\" title=\"换源 &amp; 包管理\"></a>换源 &amp; 包管理</h3><p>当你在安装好 Ubuntu 虚拟机后，你可以看到这样的桌面：</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015005727.png\" alt=\"Ubuntu默认桌面\"></p>\n<p>乍一看还是和 <code>windows</code> 区别蛮大的。</p>\n<p>为了方便的安装各种软件，我们需要先了解一下软件源和包管理工具。</p>\n<p>软件源（<em>software source</em>）是指存放软件包的服务器，它们通常由软件开发商或者 Linux 发行版的维护者维护。</p>\n<p>包管理工具（<em>package manager</em>）是指用于安装、更新、卸载软件包的工具，它们可以从软件源中下载软件包，然后安装到系统中。<br><code>Ubuntu</code> 自带的包管理工具是 <code>apt</code>，它的软件源默认是国外的。</p>\n<p>出于一些众所周知的原因，国内用户访问国外链接会比较慢，有时候还会请求超时。<br>不管不问的话用起来会很不爽。<br>为了解决问题，我们需要对我们的软件源进行更换，一般是将其更换为国内源，比如清华镜像源。</p>\n<p>我们可以使用指令来完成换源的操作，具体指令可以看看群里的文档，这里就不再赘述了。</p>\n<p>在换源之后，我们需要执行命令更新软件包列表 <code>sudo apt update</code>。<br>成功执行后，我们就可以使用 <code>apt</code> 来方便地管理软件了。</p>\n<p>常用的 <code>apt</code> 指令有图片中这些，不需要刻意去记，你自己用几次就熟悉了。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015010916.png\" alt=\"常用apt指令\"></p>\n<p>除了 apt，其他 Linux 发行版也都有各自的包管理工具，比如 CentOS 的 <code>yum</code>、Fedora 的 <code>dnf</code>、Arch 的 <code>pacman</code> 等等。<br>他们的使用方法都差不多，也都是用来管理软件包的。<br>根据自己用的发行版来就好了。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231014223037.png\" alt=\"根据包管理器划分Linux发行版\"></p>\n<p>上面这张图是根据包管理工具的不同对当前常见的 Linux 发行版做的一个分类。</p>\n<h2 id=\"文件系统\"><a href=\"#文件系统\" class=\"headerlink\" title=\"文件系统\"></a>文件系统</h2><p>现在来说说目录结构，这也是 Windows 和 Linux 之间的一个重要区别。</p>\n<p>Windows 的目录结构是以物理存储介质为主，通过分区来实现文件目录的管理，每个分区被视为一个独立的盘符，如 C 盘、D 盘等等。<br>不同分区之间相互独立，联系并不紧密。</p>\n<p>而在 Linux 中，所有分区都被挂载到根目录下，所有的文件和目录都被组织成以一个跟节点开始的树形结构。<br>这个树形结构就是 Linux 的文件系统。</p>\n<p>打开 Linux 的终端，输入 <code>ls /</code>，你就可以看到根目录下的所有文件和目录。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015105831.png\" alt=\"ls / 执行结果\"></p>\n<p>Linux 的根目录是 <code>/</code>，它是整个文件系统的起点，在根目录之下的既可以是其他目录，也可以是文件。<br>而每一个目录中又可以包含其他目录和文件，如此反复就构成了一个庞大的文件系统。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015113020.png\" alt=\"Linux文件系统\"></p>\n<p>根目录下的每个目录都有各自作用。</p>\n<p>比如这里的 <code>/home</code> 目录，就是用户的主目录。在 Linux 中，每个用户都有自己的主目录，用来存放用户的个人文件。<br>用户主目录一般是以用户的帐号命名的，比如上图中的 alice、bob、eve。</p>\n<p>再比如这里的 <code>/lib</code> 目录，这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。<br>几乎所有的应用程序都需要用到这些共享库。</p>\n<!-- 介绍各个目录的作用 -->\n\n<p>这张图中的箭头是在表示某些目录之间的关系。</p>\n<p>先来看根目录下的 <code>/bin</code>，bin 是 <code>binary</code> 的缩写，这个目录下存放着一些最基本的命令，比如 <code>ls</code>、<code>cp</code>、<code>mv</code>、<code>rm</code> 等等。这些命令在系统启动时就会用到，可以被当前系统下所有用户使用。<br>与 bin 相连的箭头指向了 <code>/usr/bin</code>，这个目录下存放着一些用户级的命令，比如 <code>vim</code>、<code>gcc</code> 等，这些命令只能被当前用户使用。</p>\n<p>类似的还有 <code>/sbin</code> 和 <code>/usr/sbin</code>。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>讲完前面这些，我们就可以来说说 Linux 常用的一些指令了。</p>\n<p><code>ls</code>用来列出目录下的所有文件和目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">ls -a</span><br><span class=\"line\">ls -l</span><br><span class=\"line\">ls &lt;path&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>cd</code>用于切换目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~ </span><br><span class=\"line\">cd ..</span><br><span class=\"line\">cd -</span><br><span class=\"line\">cd &lt;path&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>mkdir</code> 用于创建目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir &lt;name&gt;</span><br><span class=\"line\">mkdir –p &lt;name&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>cp</code> 用于复制文件或目录到指定位置。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp &lt;src&gt; &lt;dst&gt;</span><br><span class=\"line\">cp –r &lt;src&gt; &lt;dst&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>mv</code> 用于移动文件或目录到指定位置，这个指令也可以用来给某个文件或目录重命名。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv &lt;src&gt; &lt;dst&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>rm</code> 用于删除文件或目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm &lt;target&gt;</span><br><span class=\"line\">rm –r &lt;target&gt;</span><br><span class=\"line\">rm –f &lt;target&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h2><p>在多用户计算机系统的管理中，权限是指某个特定用户具有特定的系统资源使用权利。</p>\n<p>个人主机大家一般不会管这么多，通常都是直接使用管理员身份登陆了，因为个人计算机的使用者一般都是大家可以信任的人。<br>而在服务器上就不是这种情况。服务器上的用户可能彼此之间并不熟悉，而服务器中又往往存储着各种各样的资源，有些资源你不希望别的用户看到。<br>服务器中的数据越重要，价值越高，往往服务器中对权限的设定就要越详细，用户的分级也要越明确。</p>\n<p>与 windows 不同，Linux 为每个文件都设置了很多属性，最大的作用就是维护数据安全。<br>举个简单的例子，在你的 Linux 系统中，和系统服务相关的文件通常只有 root 用户才能读或写。<br>就拿 <code>/etc/shadow</code> 这个文件来说，此文件记录了系统中所有用户的密码数据，非常重要，因此绝不能让任何人读取（否则密码数据会被窃取），只有 root 才可以有读取权限。</p>\n<p>再比如说，本来 root 用户才能做的开关机、新增或删除用户等命令，一旦允许任何人拥有这些权限，系统就可能会经常莫名其妙的挂掉。<br>而且，万一 root 用户的密码被其他人获取，他们就可以登录你的系统，从事一些只有 root 用户才能执行的操作，这是绝对不允许发生的。</p>\n<p>因此，在服务器上，绝对不是所有的用户都使用 root 身份登录，而要根据不同的工作需要和职位需要，合理分配用户等级和权限等级。</p>\n<h3 id=\"查看权限\"><a href=\"#查看权限\" class=\"headerlink\" title=\"查看权限\"></a>查看权限</h3><p>Linux 系统中，我们可以使用上文提到过的 <code>ls -al</code> 查看当前目录下所有文件的权限属性。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015122718.png\" alt=\"ls -al 指令\"></p>\n<p>在这些信息中，最左侧这一列就是文件的权限属性，它由 10 个字符组成。</p>\n<p>左侧 10 个字符，分为四部分，第一个字符表示文件类型，后面每部分 3 个字符，分别代表了所有者权限、所有者所在组权限、其他用户权限。</p>\n<p>文件类型共有以下可能的值：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code>d</code></th>\n<th align=\"center\"><code>-</code></th>\n<th align=\"center\"><code>l</code></th>\n<th align=\"center\"><code>b</code></th>\n<th align=\"center\"><code>c</code></th>\n<th align=\"center\"><code>s</code></th>\n<th align=\"center\"><code>p</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">目录</td>\n<td align=\"center\">普通文件</td>\n<td align=\"center\">链接文件</td>\n<td align=\"center\">块设备</td>\n<td align=\"center\">字符设备</td>\n<td align=\"center\">套接字</td>\n<td align=\"center\">管道</td>\n</tr>\n</tbody></table>\n<p>文件权限共有以下可能的值，所有者、所有组、其他用户权限都一样：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code>r</code></th>\n<th align=\"center\"><code>w</code></th>\n<th align=\"center\"><code>x</code></th>\n<th align=\"center\"><code>-</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">读权限，用数字4表示</td>\n<td align=\"center\">写权限，用数字2表示</td>\n<td align=\"center\">执行权限，用数字1表示</td>\n<td align=\"center\">无权限，用数字0表示</td>\n</tr>\n</tbody></table>\n<p>了解这些属性值之后，我们举个例子来讲解一下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drwxr-xr-x   3 root root       4096  9月 11 22:23 home</span><br></pre></td></tr></table></figure>\n\n<p>比如我们的 <code>/home</code> 目录，它的权限属性是 <code>drwxr-xr-x</code>，表示这是一个目录文件，这个目录可以被所有者读取、写入和执行，而属于同一组的用户和其他用户只能读取和执行它。</p>\n<h3 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h3><p>我们可以使用 <code>chmod</code> 指令来修改文件的权限属性。一般有两种方式，一种是符号模式，一种是绝对模式。</p>\n<h4 id=\"符号模式\"><a href=\"#符号模式\" class=\"headerlink\" title=\"符号模式\"></a>符号模式</h4><p>我们可以使用以下格式的指令去修改文件的权限属性：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> [ugoa][+-=][rwx] filename</span><br></pre></td></tr></table></figure>\n\n<p>第一个参数是权限修改的范围，第二个参数是权限的操作，第三个参数是权限的类型。</p>\n<p>这里的第一个参数可以是以下四个字母中的任意一个：</p>\n<ul>\n<li><code>u</code> 表示文件的所有者</li>\n<li><code>g</code> 表示文件的所属组</li>\n<li><code>o</code> 表示其他用户</li>\n<li><code>a</code> 表示所有用户，相当于 <code>ugo</code> 的合集</li>\n</ul>\n<p>第二个符号参数可以是以下三个符号中的任意一个：</p>\n<ul>\n<li><code>+</code> 添加权限</li>\n<li><code>-</code> 删除权限</li>\n<li><code>=</code> 设置权限</li>\n</ul>\n<p>第三个符号参数就是我们前面说过的 <code>rwx</code>，分别表示读、写、执行权限。</p>\n<p>直接看使用案例可能更直观一些：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> u+x filename</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> g-w filename</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> o=rw- filename</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"绝对模式\"><a href=\"#绝对模式\" class=\"headerlink\" title=\"绝对模式\"></a>绝对模式</h4><p>由于权限中 rwx，其中一种权限只有存在和不存在两种状态，每种权限可以用一个 bit 来表示，<code>0</code> 表示无权限，<code>1</code> 表示有权限，rwx 只要三个 bit 表示。<br>三个 bit 表示的一个二进制数即可表示rwx的情况。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015141918.png\" alt=\"权限原理\"></p>\n<p>求和之后，我们可以得到一个三位的八进制数，这个数就是我们要设置的权限。</p>\n<p>因此，我们可以使用一个三位的八进制数来表示权限，比如 <code>777</code>，这个数的二进制表示为 <code>111 111 111</code>，表示所有者、所属组和其他用户都有读、写、执行权限。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chmod</span> 777 filename</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他相关指令\"><a href=\"#其他相关指令\" class=\"headerlink\" title=\"其他相关指令\"></a>其他相关指令</h3><p>除了 <code>chmod</code> 之外，还有一些指令用于 Linux 系统的权限管理，比如 <code>chown</code>、<code>chgrp</code> 等等。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">chown</span> user2 filename</span><br><span class=\"line\"><span class=\"built_in\">chgrp</span> group2 filename</span><br></pre></td></tr></table></figure>\n\n<p>这两个指令分别用于修改文件的所有者和所属组，使用的频率比较低，用起来也比较简单，大家知道就好。</p>\n<h2 id=\"更多的知识\"><a href=\"#更多的知识\" class=\"headerlink\" title=\"更多的知识\"></a>更多的知识</h2><p>Linux 操作系统先讲这么多，更多的知识就留给大家自己去探索了。</p>\n<p>大家如果想看一些 Linux 教程书籍的话，推荐《鸟哥的 Linux 私房菜》，这本书是 Linux 界的经典书籍，内容详实，适合初学者阅读。<br>学校图书馆和协会里也都有，欢迎大家来协会线下借阅。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20231015143017.png\" alt=\"鸟哥的Linux私房菜\"></p>\n<p>这些知识光听没什么用，大家还是要自己动手去实践，自己安装一个 Linux，多玩一玩，基本就能掌握个七七八八了。</p>\n"},{"title":"通过 nvm 配置 Node.js 开发环境","date":"2023-06-11T16:00:00.000Z","author":"ma5hr00m","_content":"\n阿菇之前遇到过这个问题，顺利地解决了。这里补一篇博客，说说具体的操作步骤。本教程的测试环境为 `Ubuntu22.04`，理论上适用于大多数 Linux 系统（在正确安装相关工具的前提下）。\n\n## 引入\n关于 Node.js，我觉得它官网的描述就是最准确的：\n\n> Node.js® is an open-source, cross-platform JavaScript runtime environment.\n\n在我们使用 Node.js 开发 Web 应用或者搭建靶场的时候，会有指定的版本要求，这需要我们能够迅速准确的切换我们当前的 Node.js 版本。`nvm` 就是一个优秀的 node.js 版本管理工具，允许我们在同一台机器上方便地安装切换各版本的 Node.js🥰。\n\n## 安装nvm\n执行以下操作之前，如果你已经通过其他渠道下载了 Node.js，请将其卸载，否则会出现冲突问题。本篇文章不会介绍如何解决冲突造成的问题。\n\n这里只介绍一种最通用的办法——使用 `curl` 拉取官方安装包📦并执行。\n\n首先在你的系统安装 curl，这是一个常用的命令行工具，用于发出网络请求然后获取数据。执行以下命令安装 nvm：\n```bash\nsudo curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | sh\n```\n\n稍等片刻，当你看到以下提示时，证明你已经成功安装了 nvm。之后按照提示重启终端或者使用指令更新环境变量即可：\n```bash\n# bash\n=> nvm is already installed in /root/.nvm, trying to update the script\n=> nvm source string already in /root/.profile\n=> bash_completion source string already in /root/.profile\n=> Close and reopen your terminal to start using nvm or run the following to use it now:\nexport NVM_DIR=\"$HOME/.nvm\"\n```\n\n重启终端或执行对应指令后，我们使用 `nvm -v` 检验是否成功更新环境变量，如果看到控制台中输出了版本信息，则表示环境变量更新成功，也表明你的 nvm 能够正常使用啦！\n```bash\nnvm --version\n# 0.35.3\n```\n\n### 可能遇到的问题\n当你使用 curl 拉取 nvm 安装时，可能会遇到以下报错信息：\n```bash\ncurl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused\n```\n\n如果遇到了，请在 `/etc/hosts` 文件的末尾中添加下面的 dns 解析：\n```\n199.232.68.133 raw.githubusercontent.com\n199.232.68.133 user-images.githubusercontent.com\n199.232.68.133 avatars2.githubusercontent.com\n199.232.68.133 avatars1.githubusercontent.com\n```\n\n然后重新执行上面的指令，拉取安装包并进行安装。\n\n## 安装Node.js\n使用 nvm 安装对应版本的 Node.js 很方便。首先，使用以下指令查看可用的 node 版本：\n```bash\nnvm ls-remote\n```\n\n你可以从输出中看到从 `v0.1.14` 到 `v20,5.1` 之间几乎所有的版本。找到你需要的版本，通过以下指令进行安装，这里拿 `v20.0.0` 做示范，安装其他版本的 node 同理：\n```bash\nnvm install v20.0.0\n```\n\n稍等片刻后，看到 `Checksums matched!` 即代表已经安装成功。这时一般会将你目前的 node 版本自动切换为刚下载的版本。\n\n你可以使用以下指令查看当前使用 node 版本：\n```bash\nnode -v \n# v20.0.0\n```\n\n到这里就已经基本结束啦🥰！下面会再给出一些常用的 nvm 指令，基本能满足日常学习所需：\n```bash\n# 安装指定版本的 node\nnvm install <version>\n\n# 使用指定版本的 node\nnvm use <version>\n\n# 列出已安装的所有版本的 node\nnvm ls\n\n# 列出所有可用（可安装）的 node\nnvm ls-remote\n\n# 列出当前使用的 node 版本\nnvm current\n```\n\n## 测试\n以下步骤适用于在本地搭建 Node,js 开发环境的初学者，如果你是在云服务器或者 docker 容器中安装的 nvm，我相信你没有必要看这部分内容😋\n\n编写一个原生的 Node.js web 应用做测试。\n\n先使用 vim 在当前目录创建一个 `app.js`，然后将以下内容复制粘贴进去，保存退出：\n```javascript\nconst http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 3000;\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('hello, Node.js!');\n});\n\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n```\n\n使用以下指令运行上面这个 web 应用，然后在浏览器中访问 [http://127.0.0.1:3000](http://127.0.0.1:3000) 即可看到页面中的 `hello, Node.js!` 字符串。\n\n然后，开始你的 Node.js 学习之旅吧！\n\n## 后记\n想再说说 DNS 污染。\n\n简单地说，DNS 污染就是域名服务器返回了错误的 IP 地址，导致无法请求到目标资源。导致 DNS 污染的操作有很多，可能是服务器本身的缺陷、开发者的错误设置，也有可能是他人造成的恶意攻击，不晓得本篇中 [nvm 安装程序](https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh) 的 DNS 污染是出于什么原因。","source":"_posts/nvm-node.md","raw":"---\ntitle: 通过 nvm 配置 Node.js 开发环境\ndate: 2023/6/12\nauthor: ma5hr00m\ncategories:\n- Node.js\n---\n\n阿菇之前遇到过这个问题，顺利地解决了。这里补一篇博客，说说具体的操作步骤。本教程的测试环境为 `Ubuntu22.04`，理论上适用于大多数 Linux 系统（在正确安装相关工具的前提下）。\n\n## 引入\n关于 Node.js，我觉得它官网的描述就是最准确的：\n\n> Node.js® is an open-source, cross-platform JavaScript runtime environment.\n\n在我们使用 Node.js 开发 Web 应用或者搭建靶场的时候，会有指定的版本要求，这需要我们能够迅速准确的切换我们当前的 Node.js 版本。`nvm` 就是一个优秀的 node.js 版本管理工具，允许我们在同一台机器上方便地安装切换各版本的 Node.js🥰。\n\n## 安装nvm\n执行以下操作之前，如果你已经通过其他渠道下载了 Node.js，请将其卸载，否则会出现冲突问题。本篇文章不会介绍如何解决冲突造成的问题。\n\n这里只介绍一种最通用的办法——使用 `curl` 拉取官方安装包📦并执行。\n\n首先在你的系统安装 curl，这是一个常用的命令行工具，用于发出网络请求然后获取数据。执行以下命令安装 nvm：\n```bash\nsudo curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | sh\n```\n\n稍等片刻，当你看到以下提示时，证明你已经成功安装了 nvm。之后按照提示重启终端或者使用指令更新环境变量即可：\n```bash\n# bash\n=> nvm is already installed in /root/.nvm, trying to update the script\n=> nvm source string already in /root/.profile\n=> bash_completion source string already in /root/.profile\n=> Close and reopen your terminal to start using nvm or run the following to use it now:\nexport NVM_DIR=\"$HOME/.nvm\"\n```\n\n重启终端或执行对应指令后，我们使用 `nvm -v` 检验是否成功更新环境变量，如果看到控制台中输出了版本信息，则表示环境变量更新成功，也表明你的 nvm 能够正常使用啦！\n```bash\nnvm --version\n# 0.35.3\n```\n\n### 可能遇到的问题\n当你使用 curl 拉取 nvm 安装时，可能会遇到以下报错信息：\n```bash\ncurl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused\n```\n\n如果遇到了，请在 `/etc/hosts` 文件的末尾中添加下面的 dns 解析：\n```\n199.232.68.133 raw.githubusercontent.com\n199.232.68.133 user-images.githubusercontent.com\n199.232.68.133 avatars2.githubusercontent.com\n199.232.68.133 avatars1.githubusercontent.com\n```\n\n然后重新执行上面的指令，拉取安装包并进行安装。\n\n## 安装Node.js\n使用 nvm 安装对应版本的 Node.js 很方便。首先，使用以下指令查看可用的 node 版本：\n```bash\nnvm ls-remote\n```\n\n你可以从输出中看到从 `v0.1.14` 到 `v20,5.1` 之间几乎所有的版本。找到你需要的版本，通过以下指令进行安装，这里拿 `v20.0.0` 做示范，安装其他版本的 node 同理：\n```bash\nnvm install v20.0.0\n```\n\n稍等片刻后，看到 `Checksums matched!` 即代表已经安装成功。这时一般会将你目前的 node 版本自动切换为刚下载的版本。\n\n你可以使用以下指令查看当前使用 node 版本：\n```bash\nnode -v \n# v20.0.0\n```\n\n到这里就已经基本结束啦🥰！下面会再给出一些常用的 nvm 指令，基本能满足日常学习所需：\n```bash\n# 安装指定版本的 node\nnvm install <version>\n\n# 使用指定版本的 node\nnvm use <version>\n\n# 列出已安装的所有版本的 node\nnvm ls\n\n# 列出所有可用（可安装）的 node\nnvm ls-remote\n\n# 列出当前使用的 node 版本\nnvm current\n```\n\n## 测试\n以下步骤适用于在本地搭建 Node,js 开发环境的初学者，如果你是在云服务器或者 docker 容器中安装的 nvm，我相信你没有必要看这部分内容😋\n\n编写一个原生的 Node.js web 应用做测试。\n\n先使用 vim 在当前目录创建一个 `app.js`，然后将以下内容复制粘贴进去，保存退出：\n```javascript\nconst http = require('http');\n\nconst hostname = '127.0.0.1';\nconst port = 3000;\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('hello, Node.js!');\n});\n\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);\n});\n```\n\n使用以下指令运行上面这个 web 应用，然后在浏览器中访问 [http://127.0.0.1:3000](http://127.0.0.1:3000) 即可看到页面中的 `hello, Node.js!` 字符串。\n\n然后，开始你的 Node.js 学习之旅吧！\n\n## 后记\n想再说说 DNS 污染。\n\n简单地说，DNS 污染就是域名服务器返回了错误的 IP 地址，导致无法请求到目标资源。导致 DNS 污染的操作有很多，可能是服务器本身的缺陷、开发者的错误设置，也有可能是他人造成的恶意攻击，不晓得本篇中 [nvm 安装程序](https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh) 的 DNS 污染是出于什么原因。","slug":"nvm-node","published":1,"updated":"2024-06-09T12:56:11.441Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap9000yf4ly6y2z6e7s","content":"<p>阿菇之前遇到过这个问题，顺利地解决了。这里补一篇博客，说说具体的操作步骤。本教程的测试环境为 <code>Ubuntu22.04</code>，理论上适用于大多数 Linux 系统（在正确安装相关工具的前提下）。</p>\n<h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>关于 Node.js，我觉得它官网的描述就是最准确的：</p>\n<blockquote>\n<p>Node.js® is an open-source, cross-platform JavaScript runtime environment.</p>\n</blockquote>\n<p>在我们使用 Node.js 开发 Web 应用或者搭建靶场的时候，会有指定的版本要求，这需要我们能够迅速准确的切换我们当前的 Node.js 版本。<code>nvm</code> 就是一个优秀的 node.js 版本管理工具，允许我们在同一台机器上方便地安装切换各版本的 Node.js🥰。</p>\n<h2 id=\"安装nvm\"><a href=\"#安装nvm\" class=\"headerlink\" title=\"安装nvm\"></a>安装nvm</h2><p>执行以下操作之前，如果你已经通过其他渠道下载了 Node.js，请将其卸载，否则会出现冲突问题。本篇文章不会介绍如何解决冲突造成的问题。</p>\n<p>这里只介绍一种最通用的办法——使用 <code>curl</code> 拉取官方安装包📦并执行。</p>\n<p>首先在你的系统安装 curl，这是一个常用的命令行工具，用于发出网络请求然后获取数据。执行以下命令安装 nvm：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>稍等片刻，当你看到以下提示时，证明你已经成功安装了 nvm。之后按照提示重启终端或者使用指令更新环境变量即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># bash</span></span><br><span class=\"line\">=&gt; nvm is already installed <span class=\"keyword\">in</span> /root/.nvm, trying to update the script</span><br><span class=\"line\">=&gt; nvm <span class=\"built_in\">source</span> string already <span class=\"keyword\">in</span> /root/.profile</span><br><span class=\"line\">=&gt; bash_completion <span class=\"built_in\">source</span> string already <span class=\"keyword\">in</span> /root/.profile</span><br><span class=\"line\">=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:</span><br><span class=\"line\"><span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">&quot;<span class=\"variable\">$HOME</span>/.nvm&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>重启终端或执行对应指令后，我们使用 <code>nvm -v</code> 检验是否成功更新环境变量，如果看到控制台中输出了版本信息，则表示环境变量更新成功，也表明你的 nvm 能够正常使用啦！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm --version</span><br><span class=\"line\"><span class=\"comment\"># 0.35.3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可能遇到的问题\"><a href=\"#可能遇到的问题\" class=\"headerlink\" title=\"可能遇到的问题\"></a>可能遇到的问题</h3><p>当你使用 curl 拉取 nvm 安装时，可能会遇到以下报错信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure>\n\n<p>如果遇到了，请在 <code>/etc/hosts</code> 文件的末尾中添加下面的 dns 解析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">199.232.68.133 raw.githubusercontent.com</span><br><span class=\"line\">199.232.68.133 user-images.githubusercontent.com</span><br><span class=\"line\">199.232.68.133 avatars2.githubusercontent.com</span><br><span class=\"line\">199.232.68.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure>\n\n<p>然后重新执行上面的指令，拉取安装包并进行安装。</p>\n<h2 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h2><p>使用 nvm 安装对应版本的 Node.js 很方便。首先，使用以下指令查看可用的 node 版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm ls-remote</span><br></pre></td></tr></table></figure>\n\n<p>你可以从输出中看到从 <code>v0.1.14</code> 到 <code>v20,5.1</code> 之间几乎所有的版本。找到你需要的版本，通过以下指令进行安装，这里拿 <code>v20.0.0</code> 做示范，安装其他版本的 node 同理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install v20.0.0</span><br></pre></td></tr></table></figure>\n\n<p>稍等片刻后，看到 <code>Checksums matched!</code> 即代表已经安装成功。这时一般会将你目前的 node 版本自动切换为刚下载的版本。</p>\n<p>你可以使用以下指令查看当前使用 node 版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v </span><br><span class=\"line\"><span class=\"comment\"># v20.0.0</span></span><br></pre></td></tr></table></figure>\n\n<p>到这里就已经基本结束啦🥰！下面会再给出一些常用的 nvm 指令，基本能满足日常学习所需：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装指定版本的 node</span></span><br><span class=\"line\">nvm install &lt;version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用指定版本的 node</span></span><br><span class=\"line\">nvm use &lt;version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出已安装的所有版本的 node</span></span><br><span class=\"line\">nvm <span class=\"built_in\">ls</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有可用（可安装）的 node</span></span><br><span class=\"line\">nvm ls-remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出当前使用的 node 版本</span></span><br><span class=\"line\">nvm current</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>以下步骤适用于在本地搭建 Node,js 开发环境的初学者，如果你是在云服务器或者 docker 容器中安装的 nvm，我相信你没有必要看这部分内容😋</p>\n<p>编写一个原生的 Node.js web 应用做测试。</p>\n<p>先使用 vim 在当前目录创建一个 <code>app.js</code>，然后将以下内容复制粘贴进去，保存退出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hostname = <span class=\"string\">&#x27;127.0.0.1&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> port = <span class=\"number\">3000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  res.<span class=\"property\">statusCode</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">  res.<span class=\"title function_\">setHeader</span>(<span class=\"string\">&#x27;Content-Type&#x27;</span>, <span class=\"string\">&#x27;text/plain&#x27;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">end</span>(<span class=\"string\">&#x27;hello, Node.js!&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.<span class=\"title function_\">listen</span>(port, hostname, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Server running at http://<span class=\"subst\">$&#123;hostname&#125;</span>:<span class=\"subst\">$&#123;port&#125;</span>/`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用以下指令运行上面这个 web 应用，然后在浏览器中访问 <a href=\"http://127.0.0.1:3000/\">http://127.0.0.1:3000</a> 即可看到页面中的 <code>hello, Node.js!</code> 字符串。</p>\n<p>然后，开始你的 Node.js 学习之旅吧！</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>想再说说 DNS 污染。</p>\n<p>简单地说，DNS 污染就是域名服务器返回了错误的 IP 地址，导致无法请求到目标资源。导致 DNS 污染的操作有很多，可能是服务器本身的缺陷、开发者的错误设置，也有可能是他人造成的恶意攻击，不晓得本篇中 <a href=\"https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh\">nvm 安装程序</a> 的 DNS 污染是出于什么原因。</p>\n","excerpt":"","more":"<p>阿菇之前遇到过这个问题，顺利地解决了。这里补一篇博客，说说具体的操作步骤。本教程的测试环境为 <code>Ubuntu22.04</code>，理论上适用于大多数 Linux 系统（在正确安装相关工具的前提下）。</p>\n<h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>关于 Node.js，我觉得它官网的描述就是最准确的：</p>\n<blockquote>\n<p>Node.js® is an open-source, cross-platform JavaScript runtime environment.</p>\n</blockquote>\n<p>在我们使用 Node.js 开发 Web 应用或者搭建靶场的时候，会有指定的版本要求，这需要我们能够迅速准确的切换我们当前的 Node.js 版本。<code>nvm</code> 就是一个优秀的 node.js 版本管理工具，允许我们在同一台机器上方便地安装切换各版本的 Node.js🥰。</p>\n<h2 id=\"安装nvm\"><a href=\"#安装nvm\" class=\"headerlink\" title=\"安装nvm\"></a>安装nvm</h2><p>执行以下操作之前，如果你已经通过其他渠道下载了 Node.js，请将其卸载，否则会出现冲突问题。本篇文章不会介绍如何解决冲突造成的问题。</p>\n<p>这里只介绍一种最通用的办法——使用 <code>curl</code> 拉取官方安装包📦并执行。</p>\n<p>首先在你的系统安装 curl，这是一个常用的命令行工具，用于发出网络请求然后获取数据。执行以下命令安装 nvm：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>稍等片刻，当你看到以下提示时，证明你已经成功安装了 nvm。之后按照提示重启终端或者使用指令更新环境变量即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># bash</span></span><br><span class=\"line\">=&gt; nvm is already installed <span class=\"keyword\">in</span> /root/.nvm, trying to update the script</span><br><span class=\"line\">=&gt; nvm <span class=\"built_in\">source</span> string already <span class=\"keyword\">in</span> /root/.profile</span><br><span class=\"line\">=&gt; bash_completion <span class=\"built_in\">source</span> string already <span class=\"keyword\">in</span> /root/.profile</span><br><span class=\"line\">=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:</span><br><span class=\"line\"><span class=\"built_in\">export</span> NVM_DIR=<span class=\"string\">&quot;<span class=\"variable\">$HOME</span>/.nvm&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>重启终端或执行对应指令后，我们使用 <code>nvm -v</code> 检验是否成功更新环境变量，如果看到控制台中输出了版本信息，则表示环境变量更新成功，也表明你的 nvm 能够正常使用啦！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm --version</span><br><span class=\"line\"><span class=\"comment\"># 0.35.3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可能遇到的问题\"><a href=\"#可能遇到的问题\" class=\"headerlink\" title=\"可能遇到的问题\"></a>可能遇到的问题</h3><p>当你使用 curl 拉取 nvm 安装时，可能会遇到以下报错信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure>\n\n<p>如果遇到了，请在 <code>/etc/hosts</code> 文件的末尾中添加下面的 dns 解析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">199.232.68.133 raw.githubusercontent.com</span><br><span class=\"line\">199.232.68.133 user-images.githubusercontent.com</span><br><span class=\"line\">199.232.68.133 avatars2.githubusercontent.com</span><br><span class=\"line\">199.232.68.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure>\n\n<p>然后重新执行上面的指令，拉取安装包并进行安装。</p>\n<h2 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h2><p>使用 nvm 安装对应版本的 Node.js 很方便。首先，使用以下指令查看可用的 node 版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm ls-remote</span><br></pre></td></tr></table></figure>\n\n<p>你可以从输出中看到从 <code>v0.1.14</code> 到 <code>v20,5.1</code> 之间几乎所有的版本。找到你需要的版本，通过以下指令进行安装，这里拿 <code>v20.0.0</code> 做示范，安装其他版本的 node 同理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install v20.0.0</span><br></pre></td></tr></table></figure>\n\n<p>稍等片刻后，看到 <code>Checksums matched!</code> 即代表已经安装成功。这时一般会将你目前的 node 版本自动切换为刚下载的版本。</p>\n<p>你可以使用以下指令查看当前使用 node 版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v </span><br><span class=\"line\"><span class=\"comment\"># v20.0.0</span></span><br></pre></td></tr></table></figure>\n\n<p>到这里就已经基本结束啦🥰！下面会再给出一些常用的 nvm 指令，基本能满足日常学习所需：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装指定版本的 node</span></span><br><span class=\"line\">nvm install &lt;version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用指定版本的 node</span></span><br><span class=\"line\">nvm use &lt;version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出已安装的所有版本的 node</span></span><br><span class=\"line\">nvm <span class=\"built_in\">ls</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出所有可用（可安装）的 node</span></span><br><span class=\"line\">nvm ls-remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 列出当前使用的 node 版本</span></span><br><span class=\"line\">nvm current</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>以下步骤适用于在本地搭建 Node,js 开发环境的初学者，如果你是在云服务器或者 docker 容器中安装的 nvm，我相信你没有必要看这部分内容😋</p>\n<p>编写一个原生的 Node.js web 应用做测试。</p>\n<p>先使用 vim 在当前目录创建一个 <code>app.js</code>，然后将以下内容复制粘贴进去，保存退出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hostname = <span class=\"string\">&#x27;127.0.0.1&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> port = <span class=\"number\">3000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  res.<span class=\"property\">statusCode</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">  res.<span class=\"title function_\">setHeader</span>(<span class=\"string\">&#x27;Content-Type&#x27;</span>, <span class=\"string\">&#x27;text/plain&#x27;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">end</span>(<span class=\"string\">&#x27;hello, Node.js!&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.<span class=\"title function_\">listen</span>(port, hostname, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Server running at http://<span class=\"subst\">$&#123;hostname&#125;</span>:<span class=\"subst\">$&#123;port&#125;</span>/`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用以下指令运行上面这个 web 应用，然后在浏览器中访问 <a href=\"http://127.0.0.1:3000/\">http://127.0.0.1:3000</a> 即可看到页面中的 <code>hello, Node.js!</code> 字符串。</p>\n<p>然后，开始你的 Node.js 学习之旅吧！</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>想再说说 DNS 污染。</p>\n<p>简单地说，DNS 污染就是域名服务器返回了错误的 IP 地址，导致无法请求到目标资源。导致 DNS 污染的操作有很多，可能是服务器本身的缺陷、开发者的错误设置，也有可能是他人造成的恶意攻击，不晓得本篇中 <a href=\"https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh\">nvm 安装程序</a> 的 DNS 污染是出于什么原因。</p>\n"},{"title":"基于 Koa2+SQLite 构建 CRUD API","date":"2023-04-27T16:00:00.000Z","author":"ma5hr00m","_content":"\n暑期的尾声渐近，创新实践课的老师突然要验收暑期学习成果，愚蠢的阿菇对此事完全没有印象……毫无准备的他决定临时搓个小东西出来。前端肯定是要用 React 来做，后端嘛……思来想去，准备学习 koa 现学现卖一下。之前没用 node.js 写过后端，想尝试尝试新东西，单纯为了补作业而写东西感觉不值……\n\n## 准备\n先了解一些基本概念。\n\n### koa\n`koa` 是一个基于 Node.js 的 Web 开发框架，提供了一种**简洁优雅**的方式来处理 HTTP 请求和响应。我个人觉得 koa 就是精简版的 Express，删减了路由、视图渲染等多种功能，同时在中间件以及异步处理等方面进行了一些优化。\n\n可以去 [👋koa 官网](https://www.koajs.com.cn/) 进一步了解。但官网阅读起来比较难受，目录不是很好，但一手文档的参考简直自然是没得说。\n\n如果只想要快速上手 koa 开发，阿菇更推荐下面这个教程：\n\n[《Koa3 进阶学习笔记》](https://chenshenhai.github.io/koa2-note/)\n\n### sqlite\n`sqlite` 是一个嵌入式 SQL 数据库引擎，它提供了一种简单、轻量级且独立的方法来存储和管理数据。它不需要单独的服务器进程，可以直接在应用程序中使用。它不像 MySQL 那么笨重，轻便到你只需要在你的项目中留有一个 sqlite.db 即可，对初学者来说省去了很多配置环境的麻烦（阿菇首次接触到的数据库就是 sqlite）。\n\n## 模式\n`MVC` 是一个最基本的核心架构知识，以后会经常用到。你是离不开它的🤗。\n\n![MVC架构图](https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828212321994.png)\n\nMVC 模式，全称为 Model-View-Controller（模型-视图-控制器）模式，它是一种软件架构模式，其目标是将软件的用户界面（即前台页面）和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。\n\n具体到代码层面，MVC 将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）。Model 负责数据的存储和处理，Controller 负责业务逻辑的处理和协调，View 负责数据的可视化呈现给用户。\n\nMVC 模式的优势在于分离关注点、提高代码的可重用性和可维护性。通过将应用程序分成模型、视图和控制器，实现更好地组织代码、降低模块之间的耦合度，并提供了良好的扩展性和可测试性。\n\n除了 MVC，还有其他一些常见的架构模式，这里不做展开介绍😜，感兴趣的请自行前往以下链接了解：\n- [MVP模式（Model-View-Presenter）](https://zh.wikipedia.org/wiki/Model-view-presenter)\n- [MVVM模式（Model-View-ViewModel）](https://en.wikipedia.org/wiki/Model–view–viewmodel)\n\n## 实战场景概括\n在接下来的实战中，我们会实现一个 `users` 表，包括 id、username 和 password 三个列，并基于这个表使用 koa 以及相关库实现 crud api 接口，并在完成后使用 `postman` 工具进行测试。\n\n不想听我啰嗦的可以直接去看 GitHub 项目地址：\n\n[koa2-crud-example](https://github.com/ma5hr00m/koa2-crud-example)\n\n## 初始化项目\n常用的 koa 语法前往官网自行了解 👉[Koa 中文网](https://www.koajs.com.cn/#application)\n```bash\n# 初始化 node.js 项目\nmkdir example\ncd example\nyarn init\n\n# 安装 koa\nyarn add -D koa\n```\n\n## init & ping\n该部分参考：[处理 URL - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960)。这个文章会告诉你如何搭建一个基础的 koa 服务，并编写一个 `/ping` api 进行示范。\n\n你需要先安装一些依赖库：\n```bash\nyarn add -D koa-router require-directory\n```\n\n`koa-router` 是一个用于 koa 框架的路由中间件，它提供了类似于 Express 的路由功能（例如 app.get、app.put、app.post 等）。它支持命名 URL 参数、命名路由与 URL 生成、匹配特定主机的路由、响应带有允许方法的 OPTIONS 请求、支持 405 方法不允许和 501 未实现等特性。\n\n`require-directory` 可以递归地遍历指定目录，使用 `require()` 加载每个文件，并返回包含这些模块的嵌套哈希结构。它可以用来自动加载目录中的所有模块，而不需要手动一个一个地加载（似乎只适配 Common JS）。\n\n完成以下代码，你能实现一个最基本的 koa 后端服务，当你访问 http://localhost:3000/ping 时能得到一个 `pong!` 响应。\n\n先来看看目录结构：\n\n<div align='center'>\n    <img style='height:200px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828220513695.png' />\n</div>\n\n`/core/init.js` 文件用于初始化 /api/ 目录下所有 api 接口文件：\n\n```js\nconst requireDirectory = require('require-directory');\nconst Router = require('koa-router');\n\nclass InitManager {\n    static initCore(app) {\n        InitManager.app = app;\n        InitManager.initLoadRouters();\n    }\n\n    static initLoadRouters() {\n        function whenLoadModule(obj) {\n            if (obj instanceof Router) {\n                InitManager.app.use(obj.routes())\n            }\n        }\n\n        const apiDirectory = `${process.cwd()}/api`\n        \n        requireDirectory(module, apiDirectory, {\n            visit: whenLoadModule\n        });\n    }\n}\n\nmodule.exports = InitManager;\n```\n\n`/api/ping.js` 实现了一个简单的后端 api 接口，当用户访问 /ping 路由时，后端服务会返回给用户一个 `pong!` 文本响应：\n\n```js\nconst Router = require('koa-router');\n\nconst router = new Router();\n\nrouter.get('/ping',async ctx => {\n    ctx.body = 'pong!';\n} );\n\nmodule.exports = router;\n```\n\n`/app.js` 是入口文件，初始化一个 Koa 对象，调用 `init.js` 启用所有 api 接口，然后监听本地 3000 端口：\n\n```js\nconst Koa = require('koa');\nconst InitManager = require('./core/init');\n\nconst app = new Koa();\n\nInitManager.initCore(app);\n\napp.listen(3000);\nconsole.log(`🎁 Listening on localhost:3000 ...`);\n```\n\n完成以上代码后，在项目根目录执行以下指令启动服务：\n\n```bash\nnode app.js\n```\n\n## database\n先安装一些依赖库：\n```bash\nyarn add -D sqlite3 sequelize\n```\n\n`sequelize` 是一个基于 promise 的 Node.js ORM（对象关系映射），可用于 PostgresSQL、MySQL、MariaDB、SQLite 和 Microsoft SQL Server 数据库。它提供了一种简单、灵活且强大的方法来定义模型和关系，并支持事务、迁移和复杂查询等高级功能。\n\n简单的说，就是大家都不想写 Raw SQL，觉得麻烦且存在安全问题，就封装了一套接口用来实现常用的 SQL 语句。\n\n我们在项目根目录下创建一个 `/database/db.js`，写入以下内容：\n\n```js\n// 你不需要手动创建 database.db，若代码检测到对应数据库不存在则会自动创建\nconst { Sequelize } = require('sequelize');\n\nconst sequelize = new Sequelize({\n    dialect: 'sqlite',\n    storage: './sqlite.db'\n});\n\ntry {\n    sequelize.authenticate();\n    console.log(`Connect to database successfully`);\n} catch (err) {\n    console.log(`Connection failed: ${err}`);\n}\n\nmodule.exports = { sequelize };\n```\n\n## schema\n我们在项目根目录下创建一个 `/schema/user.js`，该文件的作用是定义了数据库模型，方便我们在其他文件使用。写入以下内容：\n```js\nconst { DataTypes } = require('sequelize');\n\nmodule.exports = function(sequelize) {\n    return sequelize.define('user', {\n        id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true,\n            allowNull: false,\n            field: 'id',\n        },\n        username: {\n            type: DataTypes.TEXT,\n            allowNull: false,\n            field: 'username',\n        },\n        password: {\n            type: DataTypes.TEXT,\n            allowNull: false,\n            field: 'password',\n        },\n    });\n}\n```\n\n## modules\n这段代码定义了一个名为 `userModel` 的类，它包含了一些静态方法，用于对数据库中的 `users` 表进行操作。\n```js\nconst db = require('../database/db');\n\nconst sequelize = db.sequelize;\n\nconst user = require('../schema/user')(sequelize);\nuser.sync({force: false});\n\nclass userModel {\n    static async showAllUsers() {\n        const users = await user.findAll();\n        return users;\n    }\n\n    static async createUser(username, password) {\n        const newUser = await user.create({\n            username,\n            password\n        });\n        return newUser;\n    }\n\n    static async deleteUser(username) {\n        const result = await user.destroy({\n            where: {\n                username\n            }\n        });\n        return result;\n    }\n\n    static async searchUser(username) {\n        const result = await user.findOne({\n            where: {\n                username\n            }\n        });\n        return result;\n    }\n\n    static async updateUser(userId, username, password) {\n        const result = await user.update({\n            username,\n            password,\n        }, {\n            where: {\n                id: userId\n            }\n        });\n        return result;\n    }\n}\n\nmodule.exports = userModel;\n```\n\n## controllers\n这段代码定义了一个名为 `userController` 的类，它包含了一些静态方法，用于处理与用户相关的 HTTP 请求。\n\ncontrollers 中的静态方法与上文提到的 modules 中的静态方法一一对应。\n```javascript\nconst userModel = require('../modules/user');\n\nclass userController {\n    static async show(ctx) {\n        const users = await userModel.showAllUsers();\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: users\n        };\n    }\n\n    static async create(ctx) {\n        const data = ctx.request.body;\n        const username = data.username;\n        const password = data.password;\n        console.log(username + ' ' + password);\n\n        const newUser = await userModel.createUser(username, password);\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: newUser\n        };\n    }\n\n    static async delete(ctx) {\n        const data = ctx.request.body;\n        const username = data.username;\n        const result = await userModel.deleteUser(username);\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: result\n        };\n    }\n\n    static async search(ctx) {\n        const data = ctx.request.body;\n        const username = data.username;\n        const result = await userModel.searchUser(username);\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: result\n        };\n    }\n\n    static async update(ctx) {\n        const data = ctx.request.body;\n        const userId = data.userId;\n        const username = data.username;\n        const password = data.password;\n        const result = await userModel.updateUser(userId, username, password);\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: result\n        };\n    }\n}\n\nmodule.exports = userController;\n```\n\n## router/api\n我们为每个接口单独创建一个文件，便于后期维护。每个接口也是对应到 `userControllers` 类中的静态方法。\n\n`/api/show` 接口，用于展示当前数据库所有内容：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.get('/api/show', userController.show);\n\nmodule.exports = router;\n```\n\n`/api/create` 接口，用于创建一个新的用户：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.post('/api/create', userController.create);\n\nmodule.exports = router;\n```\n\n`/api/delete` 接口，用于删除一个用户：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.post('/api/delete', userController.delete);\n\nmodule.exports = router;\n```\n\n`/api/search` 接口，用于查找一个用户：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.post('/api/search', userController.search);\n\nmodule.exports = router;\n```\n\n`/api/update` 接口，用于更新一个用户的信息：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.post('/api/update', userController.update);\n\nmodule.exports = router;\n```\n\n## bodyparser & cors\n### 参数解析\n原生 kao 不支持解析 POST 请求正文数据，也就是说，此时你编写的 body 参数解析代码并不生效！\n\n就像我们编写的 controllers 部分代码需要解析 POST 请求主体并获取参数，此时并不会生效。比如：\n```javascript\n// /controllers/user.js\nclass userController {\n \t... ...\n    \n    static async create(ctx) {\n        // 解析 POST 请求主体中的 username & password 参数\n        const data = ctx.request.body;\n        const username = data.username;\n        const password = data.password;\n        ...\n    }\n\n    ... ...\n}\n```\n\n为了解决这个问题，我们需要安装以下依赖库：\n```bash\nyarn add -D koa-bodyparser\n```\n\n`koa-bodyparser` 是一个 koa 框架的中间件，它可以解析 HTTP 请求的正文（body）数据，并将解析后的数据存储在 `ctx.request.body` 中。它支持解析 JSON、表单和文本类型的正文数据，但不支持解析多部分格式（multipart）数据。也就是说，如果想要实现文件上传，我们还会需要其他的库。\n\n安装成功后，我们将以下代码添加到 app.js 中，之后我们用于解析 body 的代码就能够正常工作了。\n\n```javascript\nconst bodyParser = require('koa-bodyparser');\n\napp.use(bodyParser());\n```\n\n### 跨域\n假设你的 koa 后端运行在 [http://localhost:3000](http://localhost:3000)，而你的 react 前端运行在 [http://localhost:5173](http://localhost:5173)。如果此时你的前端服务向后端 api 发送请求，会遭到拒绝，提示存在跨域问题：\n\n<div align='center'>\n    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829135418397.png' />\n</div>\n\n最简单的解决方法就是在我们的 app.js 中添加一个用于处理跨域资源共享（CORS）的中间件，你可以通过以下指令安装这个库：\n```bash\nyarn add -D koa-cors\n```\n\n安装成功后，将以下代码添加到 app.js 中：\n```javascript\nconst cors = require('koa-cors');\n...\napp.use(cors());\n```\n\n## app\n在解决前面的工作之后，我们开始编写入口文件 app.js：\n\n```JavaScript\nconst Koa = require('koa');\nconst bodyParser = require('koa-bodyparser');\nconst cors = require('koa-cors');\nconst InitManager = require('./core/init');\n\nconst app = new Koa();\n\napp.use(cors());\napp.use(bodyParser());\nInitManager.initCore(app);\n\napp.listen(3000);\nconsole.log(`🎁 Listening on localhost:3000 ...`);\n```\n\n完成之后，我们只需要在项目根目录下运行 `node app.js` 指令，即可启动我们的 koa 后端服务！\n\n## 测试工具\n我们按照以上步骤实现了一套 koa-crud，还需要对其功能进行测试🤧。\n\n当然，你可以通过访问网页完成对 api 的测试，但这种方法局限性太大，不够灵活且很不方便。好在，现在有很多成熟的🔨工具供我们使用。\n\n我个人推荐 `postman`。\n\npostman 是一款用于测试和开发 API 的合作平台和工具。它提供了一个用户友好的界面，让开发人员能够轻松地发送 HTTP 请求、测试响应并与 API 进行交互\n\n使用 postman，你可以创建各种类型的 HTTP 请求（例如 GET、POST 和 PUT），设置请求参数（如头部、身体、查询参数等），发送请求，并查看服务器返回的响应。它还提供了断言（assertions）功能，用于验证API的响应是否符合预期。\n\n<div align='center'>\n    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829141158347.png' />\n</div>\n\n下载使用都很简单，这里不做介绍，请自行前往 💥[postman 官网](https://www.postman.com/) 了解。\n\n## 优化\n以上代码就是 `kao+sqlite` 实现 CRUD 的简单实战，整套代码还有很多可以✨优化的地方。\n\n比如，调用这个 koa 服务中的 api 都需要使用 POST 请求，不符合目前流行的 `RESTful` 设计风格，后续可以进行调整（但 POST 一把嗦确实无脑易用🤣）。\n\n在 controllers 中，我也没有进行适当的错误处理，不方便 DEBUG，也是可以优化的点。\n\n对传入参数的处理也没有做，我不晓得 koa-bodyparser 有没有进行处理，也可能会存在安全问题。\n\n> 问题多多❤～摩多摩多❤～\n\n不过呢，这是阿菇第一次用 koa 写后端服务（其实后端都没怎么写过🥲），至少能跑起来了！后续会继续优化这个服务，并更新在 GitHub 仓库中，以上实现的 api 会被规范化为 `/api/v1/*`，之后优化过的版本会注册为 `/api/v2/`，这样做可能较符合实际生产环境的写法……\n\n## 参考\n- [Koa 中文网](https://www.koajs.com.cn/#)\n- [Koa2 进阶学习笔记](https://chenshenhai.github.io/koa2-note/)\n- [koa - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960)\n- [Koa 框架教程 - 阮一峰的网络日志](https://ruanyifeng.com/blog/2017/08/koa.html)\n- [koa 连接sqlite3 项目目录结构 - 稀土掘金](https://juejin.cn/post/7066568536944017438#heading-8)\n\n## 后话\n每次写CRUD，都会觉得后端这套东西的逻辑性比前端要强😇，写的时候行云流水。\n\n`koa` 给我的开发初体验不错，主打一个轻便简洁，仅存储少量数据时配合 `sqlite` 更是方便。","source":"_posts/koa2-crud-example.md","raw":"---\ntitle: 基于 Koa2+SQLite 构建 CRUD API\ndate: 2023/04/28\nauthor: ma5hr00m\ncategories:\n- Node.js\n---\n\n暑期的尾声渐近，创新实践课的老师突然要验收暑期学习成果，愚蠢的阿菇对此事完全没有印象……毫无准备的他决定临时搓个小东西出来。前端肯定是要用 React 来做，后端嘛……思来想去，准备学习 koa 现学现卖一下。之前没用 node.js 写过后端，想尝试尝试新东西，单纯为了补作业而写东西感觉不值……\n\n## 准备\n先了解一些基本概念。\n\n### koa\n`koa` 是一个基于 Node.js 的 Web 开发框架，提供了一种**简洁优雅**的方式来处理 HTTP 请求和响应。我个人觉得 koa 就是精简版的 Express，删减了路由、视图渲染等多种功能，同时在中间件以及异步处理等方面进行了一些优化。\n\n可以去 [👋koa 官网](https://www.koajs.com.cn/) 进一步了解。但官网阅读起来比较难受，目录不是很好，但一手文档的参考简直自然是没得说。\n\n如果只想要快速上手 koa 开发，阿菇更推荐下面这个教程：\n\n[《Koa3 进阶学习笔记》](https://chenshenhai.github.io/koa2-note/)\n\n### sqlite\n`sqlite` 是一个嵌入式 SQL 数据库引擎，它提供了一种简单、轻量级且独立的方法来存储和管理数据。它不需要单独的服务器进程，可以直接在应用程序中使用。它不像 MySQL 那么笨重，轻便到你只需要在你的项目中留有一个 sqlite.db 即可，对初学者来说省去了很多配置环境的麻烦（阿菇首次接触到的数据库就是 sqlite）。\n\n## 模式\n`MVC` 是一个最基本的核心架构知识，以后会经常用到。你是离不开它的🤗。\n\n![MVC架构图](https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828212321994.png)\n\nMVC 模式，全称为 Model-View-Controller（模型-视图-控制器）模式，它是一种软件架构模式，其目标是将软件的用户界面（即前台页面）和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。\n\n具体到代码层面，MVC 将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）。Model 负责数据的存储和处理，Controller 负责业务逻辑的处理和协调，View 负责数据的可视化呈现给用户。\n\nMVC 模式的优势在于分离关注点、提高代码的可重用性和可维护性。通过将应用程序分成模型、视图和控制器，实现更好地组织代码、降低模块之间的耦合度，并提供了良好的扩展性和可测试性。\n\n除了 MVC，还有其他一些常见的架构模式，这里不做展开介绍😜，感兴趣的请自行前往以下链接了解：\n- [MVP模式（Model-View-Presenter）](https://zh.wikipedia.org/wiki/Model-view-presenter)\n- [MVVM模式（Model-View-ViewModel）](https://en.wikipedia.org/wiki/Model–view–viewmodel)\n\n## 实战场景概括\n在接下来的实战中，我们会实现一个 `users` 表，包括 id、username 和 password 三个列，并基于这个表使用 koa 以及相关库实现 crud api 接口，并在完成后使用 `postman` 工具进行测试。\n\n不想听我啰嗦的可以直接去看 GitHub 项目地址：\n\n[koa2-crud-example](https://github.com/ma5hr00m/koa2-crud-example)\n\n## 初始化项目\n常用的 koa 语法前往官网自行了解 👉[Koa 中文网](https://www.koajs.com.cn/#application)\n```bash\n# 初始化 node.js 项目\nmkdir example\ncd example\nyarn init\n\n# 安装 koa\nyarn add -D koa\n```\n\n## init & ping\n该部分参考：[处理 URL - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960)。这个文章会告诉你如何搭建一个基础的 koa 服务，并编写一个 `/ping` api 进行示范。\n\n你需要先安装一些依赖库：\n```bash\nyarn add -D koa-router require-directory\n```\n\n`koa-router` 是一个用于 koa 框架的路由中间件，它提供了类似于 Express 的路由功能（例如 app.get、app.put、app.post 等）。它支持命名 URL 参数、命名路由与 URL 生成、匹配特定主机的路由、响应带有允许方法的 OPTIONS 请求、支持 405 方法不允许和 501 未实现等特性。\n\n`require-directory` 可以递归地遍历指定目录，使用 `require()` 加载每个文件，并返回包含这些模块的嵌套哈希结构。它可以用来自动加载目录中的所有模块，而不需要手动一个一个地加载（似乎只适配 Common JS）。\n\n完成以下代码，你能实现一个最基本的 koa 后端服务，当你访问 http://localhost:3000/ping 时能得到一个 `pong!` 响应。\n\n先来看看目录结构：\n\n<div align='center'>\n    <img style='height:200px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828220513695.png' />\n</div>\n\n`/core/init.js` 文件用于初始化 /api/ 目录下所有 api 接口文件：\n\n```js\nconst requireDirectory = require('require-directory');\nconst Router = require('koa-router');\n\nclass InitManager {\n    static initCore(app) {\n        InitManager.app = app;\n        InitManager.initLoadRouters();\n    }\n\n    static initLoadRouters() {\n        function whenLoadModule(obj) {\n            if (obj instanceof Router) {\n                InitManager.app.use(obj.routes())\n            }\n        }\n\n        const apiDirectory = `${process.cwd()}/api`\n        \n        requireDirectory(module, apiDirectory, {\n            visit: whenLoadModule\n        });\n    }\n}\n\nmodule.exports = InitManager;\n```\n\n`/api/ping.js` 实现了一个简单的后端 api 接口，当用户访问 /ping 路由时，后端服务会返回给用户一个 `pong!` 文本响应：\n\n```js\nconst Router = require('koa-router');\n\nconst router = new Router();\n\nrouter.get('/ping',async ctx => {\n    ctx.body = 'pong!';\n} );\n\nmodule.exports = router;\n```\n\n`/app.js` 是入口文件，初始化一个 Koa 对象，调用 `init.js` 启用所有 api 接口，然后监听本地 3000 端口：\n\n```js\nconst Koa = require('koa');\nconst InitManager = require('./core/init');\n\nconst app = new Koa();\n\nInitManager.initCore(app);\n\napp.listen(3000);\nconsole.log(`🎁 Listening on localhost:3000 ...`);\n```\n\n完成以上代码后，在项目根目录执行以下指令启动服务：\n\n```bash\nnode app.js\n```\n\n## database\n先安装一些依赖库：\n```bash\nyarn add -D sqlite3 sequelize\n```\n\n`sequelize` 是一个基于 promise 的 Node.js ORM（对象关系映射），可用于 PostgresSQL、MySQL、MariaDB、SQLite 和 Microsoft SQL Server 数据库。它提供了一种简单、灵活且强大的方法来定义模型和关系，并支持事务、迁移和复杂查询等高级功能。\n\n简单的说，就是大家都不想写 Raw SQL，觉得麻烦且存在安全问题，就封装了一套接口用来实现常用的 SQL 语句。\n\n我们在项目根目录下创建一个 `/database/db.js`，写入以下内容：\n\n```js\n// 你不需要手动创建 database.db，若代码检测到对应数据库不存在则会自动创建\nconst { Sequelize } = require('sequelize');\n\nconst sequelize = new Sequelize({\n    dialect: 'sqlite',\n    storage: './sqlite.db'\n});\n\ntry {\n    sequelize.authenticate();\n    console.log(`Connect to database successfully`);\n} catch (err) {\n    console.log(`Connection failed: ${err}`);\n}\n\nmodule.exports = { sequelize };\n```\n\n## schema\n我们在项目根目录下创建一个 `/schema/user.js`，该文件的作用是定义了数据库模型，方便我们在其他文件使用。写入以下内容：\n```js\nconst { DataTypes } = require('sequelize');\n\nmodule.exports = function(sequelize) {\n    return sequelize.define('user', {\n        id: {\n            type: DataTypes.INTEGER,\n            primaryKey: true,\n            autoIncrement: true,\n            allowNull: false,\n            field: 'id',\n        },\n        username: {\n            type: DataTypes.TEXT,\n            allowNull: false,\n            field: 'username',\n        },\n        password: {\n            type: DataTypes.TEXT,\n            allowNull: false,\n            field: 'password',\n        },\n    });\n}\n```\n\n## modules\n这段代码定义了一个名为 `userModel` 的类，它包含了一些静态方法，用于对数据库中的 `users` 表进行操作。\n```js\nconst db = require('../database/db');\n\nconst sequelize = db.sequelize;\n\nconst user = require('../schema/user')(sequelize);\nuser.sync({force: false});\n\nclass userModel {\n    static async showAllUsers() {\n        const users = await user.findAll();\n        return users;\n    }\n\n    static async createUser(username, password) {\n        const newUser = await user.create({\n            username,\n            password\n        });\n        return newUser;\n    }\n\n    static async deleteUser(username) {\n        const result = await user.destroy({\n            where: {\n                username\n            }\n        });\n        return result;\n    }\n\n    static async searchUser(username) {\n        const result = await user.findOne({\n            where: {\n                username\n            }\n        });\n        return result;\n    }\n\n    static async updateUser(userId, username, password) {\n        const result = await user.update({\n            username,\n            password,\n        }, {\n            where: {\n                id: userId\n            }\n        });\n        return result;\n    }\n}\n\nmodule.exports = userModel;\n```\n\n## controllers\n这段代码定义了一个名为 `userController` 的类，它包含了一些静态方法，用于处理与用户相关的 HTTP 请求。\n\ncontrollers 中的静态方法与上文提到的 modules 中的静态方法一一对应。\n```javascript\nconst userModel = require('../modules/user');\n\nclass userController {\n    static async show(ctx) {\n        const users = await userModel.showAllUsers();\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: users\n        };\n    }\n\n    static async create(ctx) {\n        const data = ctx.request.body;\n        const username = data.username;\n        const password = data.password;\n        console.log(username + ' ' + password);\n\n        const newUser = await userModel.createUser(username, password);\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: newUser\n        };\n    }\n\n    static async delete(ctx) {\n        const data = ctx.request.body;\n        const username = data.username;\n        const result = await userModel.deleteUser(username);\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: result\n        };\n    }\n\n    static async search(ctx) {\n        const data = ctx.request.body;\n        const username = data.username;\n        const result = await userModel.searchUser(username);\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: result\n        };\n    }\n\n    static async update(ctx) {\n        const data = ctx.request.body;\n        const userId = data.userId;\n        const username = data.username;\n        const password = data.password;\n        const result = await userModel.updateUser(userId, username, password);\n        ctx.response.status = 200;\n        ctx.body = {\n            status: 200,\n            message: 'success',\n            data: result\n        };\n    }\n}\n\nmodule.exports = userController;\n```\n\n## router/api\n我们为每个接口单独创建一个文件，便于后期维护。每个接口也是对应到 `userControllers` 类中的静态方法。\n\n`/api/show` 接口，用于展示当前数据库所有内容：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.get('/api/show', userController.show);\n\nmodule.exports = router;\n```\n\n`/api/create` 接口，用于创建一个新的用户：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.post('/api/create', userController.create);\n\nmodule.exports = router;\n```\n\n`/api/delete` 接口，用于删除一个用户：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.post('/api/delete', userController.delete);\n\nmodule.exports = router;\n```\n\n`/api/search` 接口，用于查找一个用户：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.post('/api/search', userController.search);\n\nmodule.exports = router;\n```\n\n`/api/update` 接口，用于更新一个用户的信息：\n```javascript\nconst Router = require('koa-router');\nconst userController = require('../controllers/user');\n\nconst router = new Router();\n\nrouter.post('/api/update', userController.update);\n\nmodule.exports = router;\n```\n\n## bodyparser & cors\n### 参数解析\n原生 kao 不支持解析 POST 请求正文数据，也就是说，此时你编写的 body 参数解析代码并不生效！\n\n就像我们编写的 controllers 部分代码需要解析 POST 请求主体并获取参数，此时并不会生效。比如：\n```javascript\n// /controllers/user.js\nclass userController {\n \t... ...\n    \n    static async create(ctx) {\n        // 解析 POST 请求主体中的 username & password 参数\n        const data = ctx.request.body;\n        const username = data.username;\n        const password = data.password;\n        ...\n    }\n\n    ... ...\n}\n```\n\n为了解决这个问题，我们需要安装以下依赖库：\n```bash\nyarn add -D koa-bodyparser\n```\n\n`koa-bodyparser` 是一个 koa 框架的中间件，它可以解析 HTTP 请求的正文（body）数据，并将解析后的数据存储在 `ctx.request.body` 中。它支持解析 JSON、表单和文本类型的正文数据，但不支持解析多部分格式（multipart）数据。也就是说，如果想要实现文件上传，我们还会需要其他的库。\n\n安装成功后，我们将以下代码添加到 app.js 中，之后我们用于解析 body 的代码就能够正常工作了。\n\n```javascript\nconst bodyParser = require('koa-bodyparser');\n\napp.use(bodyParser());\n```\n\n### 跨域\n假设你的 koa 后端运行在 [http://localhost:3000](http://localhost:3000)，而你的 react 前端运行在 [http://localhost:5173](http://localhost:5173)。如果此时你的前端服务向后端 api 发送请求，会遭到拒绝，提示存在跨域问题：\n\n<div align='center'>\n    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829135418397.png' />\n</div>\n\n最简单的解决方法就是在我们的 app.js 中添加一个用于处理跨域资源共享（CORS）的中间件，你可以通过以下指令安装这个库：\n```bash\nyarn add -D koa-cors\n```\n\n安装成功后，将以下代码添加到 app.js 中：\n```javascript\nconst cors = require('koa-cors');\n...\napp.use(cors());\n```\n\n## app\n在解决前面的工作之后，我们开始编写入口文件 app.js：\n\n```JavaScript\nconst Koa = require('koa');\nconst bodyParser = require('koa-bodyparser');\nconst cors = require('koa-cors');\nconst InitManager = require('./core/init');\n\nconst app = new Koa();\n\napp.use(cors());\napp.use(bodyParser());\nInitManager.initCore(app);\n\napp.listen(3000);\nconsole.log(`🎁 Listening on localhost:3000 ...`);\n```\n\n完成之后，我们只需要在项目根目录下运行 `node app.js` 指令，即可启动我们的 koa 后端服务！\n\n## 测试工具\n我们按照以上步骤实现了一套 koa-crud，还需要对其功能进行测试🤧。\n\n当然，你可以通过访问网页完成对 api 的测试，但这种方法局限性太大，不够灵活且很不方便。好在，现在有很多成熟的🔨工具供我们使用。\n\n我个人推荐 `postman`。\n\npostman 是一款用于测试和开发 API 的合作平台和工具。它提供了一个用户友好的界面，让开发人员能够轻松地发送 HTTP 请求、测试响应并与 API 进行交互\n\n使用 postman，你可以创建各种类型的 HTTP 请求（例如 GET、POST 和 PUT），设置请求参数（如头部、身体、查询参数等），发送请求，并查看服务器返回的响应。它还提供了断言（assertions）功能，用于验证API的响应是否符合预期。\n\n<div align='center'>\n    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829141158347.png' />\n</div>\n\n下载使用都很简单，这里不做介绍，请自行前往 💥[postman 官网](https://www.postman.com/) 了解。\n\n## 优化\n以上代码就是 `kao+sqlite` 实现 CRUD 的简单实战，整套代码还有很多可以✨优化的地方。\n\n比如，调用这个 koa 服务中的 api 都需要使用 POST 请求，不符合目前流行的 `RESTful` 设计风格，后续可以进行调整（但 POST 一把嗦确实无脑易用🤣）。\n\n在 controllers 中，我也没有进行适当的错误处理，不方便 DEBUG，也是可以优化的点。\n\n对传入参数的处理也没有做，我不晓得 koa-bodyparser 有没有进行处理，也可能会存在安全问题。\n\n> 问题多多❤～摩多摩多❤～\n\n不过呢，这是阿菇第一次用 koa 写后端服务（其实后端都没怎么写过🥲），至少能跑起来了！后续会继续优化这个服务，并更新在 GitHub 仓库中，以上实现的 api 会被规范化为 `/api/v1/*`，之后优化过的版本会注册为 `/api/v2/`，这样做可能较符合实际生产环境的写法……\n\n## 参考\n- [Koa 中文网](https://www.koajs.com.cn/#)\n- [Koa2 进阶学习笔记](https://chenshenhai.github.io/koa2-note/)\n- [koa - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960)\n- [Koa 框架教程 - 阮一峰的网络日志](https://ruanyifeng.com/blog/2017/08/koa.html)\n- [koa 连接sqlite3 项目目录结构 - 稀土掘金](https://juejin.cn/post/7066568536944017438#heading-8)\n\n## 后话\n每次写CRUD，都会觉得后端这套东西的逻辑性比前端要强😇，写的时候行云流水。\n\n`koa` 给我的开发初体验不错，主打一个轻便简洁，仅存储少量数据时配合 `sqlite` 更是方便。","slug":"koa2-crud-example","published":1,"updated":"2024-06-09T12:56:25.626Z","comments":1,"layout":"post","photos":[],"_id":"clxhruap90010f4lydrji24xy","content":"<p>暑期的尾声渐近，创新实践课的老师突然要验收暑期学习成果，愚蠢的阿菇对此事完全没有印象……毫无准备的他决定临时搓个小东西出来。前端肯定是要用 React 来做，后端嘛……思来想去，准备学习 koa 现学现卖一下。之前没用 node.js 写过后端，想尝试尝试新东西，单纯为了补作业而写东西感觉不值……</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>先了解一些基本概念。</p>\n<h3 id=\"koa\"><a href=\"#koa\" class=\"headerlink\" title=\"koa\"></a>koa</h3><p><code>koa</code> 是一个基于 Node.js 的 Web 开发框架，提供了一种<strong>简洁优雅</strong>的方式来处理 HTTP 请求和响应。我个人觉得 koa 就是精简版的 Express，删减了路由、视图渲染等多种功能，同时在中间件以及异步处理等方面进行了一些优化。</p>\n<p>可以去 <a href=\"https://www.koajs.com.cn/\">👋koa 官网</a> 进一步了解。但官网阅读起来比较难受，目录不是很好，但一手文档的参考简直自然是没得说。</p>\n<p>如果只想要快速上手 koa 开发，阿菇更推荐下面这个教程：</p>\n<p><a href=\"https://chenshenhai.github.io/koa2-note/\">《Koa3 进阶学习笔记》</a></p>\n<h3 id=\"sqlite\"><a href=\"#sqlite\" class=\"headerlink\" title=\"sqlite\"></a>sqlite</h3><p><code>sqlite</code> 是一个嵌入式 SQL 数据库引擎，它提供了一种简单、轻量级且独立的方法来存储和管理数据。它不需要单独的服务器进程，可以直接在应用程序中使用。它不像 MySQL 那么笨重，轻便到你只需要在你的项目中留有一个 sqlite.db 即可，对初学者来说省去了很多配置环境的麻烦（阿菇首次接触到的数据库就是 sqlite）。</p>\n<h2 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h2><p><code>MVC</code> 是一个最基本的核心架构知识，以后会经常用到。你是离不开它的🤗。</p>\n<p><img src=\"https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828212321994.png\" alt=\"MVC架构图\"></p>\n<p>MVC 模式，全称为 Model-View-Controller（模型-视图-控制器）模式，它是一种软件架构模式，其目标是将软件的用户界面（即前台页面）和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。</p>\n<p>具体到代码层面，MVC 将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）。Model 负责数据的存储和处理，Controller 负责业务逻辑的处理和协调，View 负责数据的可视化呈现给用户。</p>\n<p>MVC 模式的优势在于分离关注点、提高代码的可重用性和可维护性。通过将应用程序分成模型、视图和控制器，实现更好地组织代码、降低模块之间的耦合度，并提供了良好的扩展性和可测试性。</p>\n<p>除了 MVC，还有其他一些常见的架构模式，这里不做展开介绍😜，感兴趣的请自行前往以下链接了解：</p>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/Model-view-presenter\">MVP模式（Model-View-Presenter）</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\">MVVM模式（Model-View-ViewModel）</a></li>\n</ul>\n<h2 id=\"实战场景概括\"><a href=\"#实战场景概括\" class=\"headerlink\" title=\"实战场景概括\"></a>实战场景概括</h2><p>在接下来的实战中，我们会实现一个 <code>users</code> 表，包括 id、username 和 password 三个列，并基于这个表使用 koa 以及相关库实现 crud api 接口，并在完成后使用 <code>postman</code> 工具进行测试。</p>\n<p>不想听我啰嗦的可以直接去看 GitHub 项目地址：</p>\n<p><a href=\"https://github.com/ma5hr00m/koa2-crud-example\">koa2-crud-example</a></p>\n<h2 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h2><p>常用的 koa 语法前往官网自行了解 👉<a href=\"https://www.koajs.com.cn/#application\">Koa 中文网</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化 node.js 项目</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> example</span><br><span class=\"line\"><span class=\"built_in\">cd</span> example</span><br><span class=\"line\">yarn init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 koa</span></span><br><span class=\"line\">yarn add -D koa</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"init-ping\"><a href=\"#init-ping\" class=\"headerlink\" title=\"init &amp; ping\"></a>init &amp; ping</h2><p>该部分参考：<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960\">处理 URL - 廖雪峰的官方网站</a>。这个文章会告诉你如何搭建一个基础的 koa 服务，并编写一个 <code>/ping</code> api 进行示范。</p>\n<p>你需要先安装一些依赖库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D koa-router require-directory</span><br></pre></td></tr></table></figure>\n\n<p><code>koa-router</code> 是一个用于 koa 框架的路由中间件，它提供了类似于 Express 的路由功能（例如 app.get、app.put、app.post 等）。它支持命名 URL 参数、命名路由与 URL 生成、匹配特定主机的路由、响应带有允许方法的 OPTIONS 请求、支持 405 方法不允许和 501 未实现等特性。</p>\n<p><code>require-directory</code> 可以递归地遍历指定目录，使用 <code>require()</code> 加载每个文件，并返回包含这些模块的嵌套哈希结构。它可以用来自动加载目录中的所有模块，而不需要手动一个一个地加载（似乎只适配 Common JS）。</p>\n<p>完成以下代码，你能实现一个最基本的 koa 后端服务，当你访问 <a href=\"http://localhost:3000/ping\">http://localhost:3000/ping</a> 时能得到一个 <code>pong!</code> 响应。</p>\n<p>先来看看目录结构：</p>\n<div align='center'>\n    <img style='height:200px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828220513695.png' />\n</div>\n\n<p><code>/core/init.js</code> 文件用于初始化 &#x2F;api&#x2F; 目录下所有 api 接口文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> requireDirectory = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;require-directory&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InitManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">initCore</span>(<span class=\"params\">app</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">InitManager</span>.<span class=\"property\">app</span> = app;</span><br><span class=\"line\">        <span class=\"title class_\">InitManager</span>.<span class=\"title function_\">initLoadRouters</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">initLoadRouters</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">function</span> <span class=\"title function_\">whenLoadModule</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Router</span>) &#123;</span><br><span class=\"line\">                <span class=\"title class_\">InitManager</span>.<span class=\"property\">app</span>.<span class=\"title function_\">use</span>(obj.<span class=\"title function_\">routes</span>())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> apiDirectory = <span class=\"string\">`<span class=\"subst\">$&#123;process.cwd()&#125;</span>/api`</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        requireDirectory(<span class=\"variable language_\">module</span>, apiDirectory, &#123;</span><br><span class=\"line\">            <span class=\"attr\">visit</span>: whenLoadModule</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title class_\">InitManager</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/ping.js</code> 实现了一个简单的后端 api 接口，当用户访问 &#x2F;ping 路由时，后端服务会返回给用户一个 <code>pong!</code> 文本响应：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/ping&#x27;</span>,<span class=\"keyword\">async</span> ctx =&gt; &#123;</span><br><span class=\"line\">    ctx.<span class=\"property\">body</span> = <span class=\"string\">&#x27;pong!&#x27;</span>;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/app.js</code> 是入口文件，初始化一个 Koa 对象，调用 <code>init.js</code> 启用所有 api 接口，然后监听本地 3000 端口：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Koa</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">InitManager</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./core/init&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Koa</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">InitManager</span>.<span class=\"title function_\">initCore</span>(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`🎁 Listening on localhost:3000 ...`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>完成以上代码后，在项目根目录执行以下指令启动服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node app.js</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"database\"><a href=\"#database\" class=\"headerlink\" title=\"database\"></a>database</h2><p>先安装一些依赖库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D sqlite3 sequelize</span><br></pre></td></tr></table></figure>\n\n<p><code>sequelize</code> 是一个基于 promise 的 Node.js ORM（对象关系映射），可用于 PostgresSQL、MySQL、MariaDB、SQLite 和 Microsoft SQL Server 数据库。它提供了一种简单、灵活且强大的方法来定义模型和关系，并支持事务、迁移和复杂查询等高级功能。</p>\n<p>简单的说，就是大家都不想写 Raw SQL，觉得麻烦且存在安全问题，就封装了一套接口用来实现常用的 SQL 语句。</p>\n<p>我们在项目根目录下创建一个 <code>/database/db.js</code>，写入以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你不需要手动创建 database.db，若代码检测到对应数据库不存在则会自动创建</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">Sequelize</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;sequelize&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sequelize = <span class=\"keyword\">new</span> <span class=\"title class_\">Sequelize</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">dialect</span>: <span class=\"string\">&#x27;sqlite&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">storage</span>: <span class=\"string\">&#x27;./sqlite.db&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    sequelize.<span class=\"title function_\">authenticate</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Connect to database successfully`</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Connection failed: <span class=\"subst\">$&#123;err&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123; sequelize &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"schema\"><a href=\"#schema\" class=\"headerlink\" title=\"schema\"></a>schema</h2><p>我们在项目根目录下创建一个 <code>/schema/user.js</code>，该文件的作用是定义了数据库模型，方便我们在其他文件使用。写入以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">DataTypes</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;sequelize&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span>(<span class=\"params\">sequelize</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sequelize.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;user&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">id</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"title class_\">DataTypes</span>.<span class=\"property\">INTEGER</span>,</span><br><span class=\"line\">            <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">autoIncrement</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">allowNull</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">field</span>: <span class=\"string\">&#x27;id&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">username</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"title class_\">DataTypes</span>.<span class=\"property\">TEXT</span>,</span><br><span class=\"line\">            <span class=\"attr\">allowNull</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">field</span>: <span class=\"string\">&#x27;username&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">password</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"title class_\">DataTypes</span>.<span class=\"property\">TEXT</span>,</span><br><span class=\"line\">            <span class=\"attr\">allowNull</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">field</span>: <span class=\"string\">&#x27;password&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"modules\"><a href=\"#modules\" class=\"headerlink\" title=\"modules\"></a>modules</h2><p>这段代码定义了一个名为 <code>userModel</code> 的类，它包含了一些静态方法，用于对数据库中的 <code>users</code> 表进行操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../database/db&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sequelize = db.<span class=\"property\">sequelize</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../schema/user&#x27;</span>)(sequelize);</span><br><span class=\"line\">user.<span class=\"title function_\">sync</span>(&#123;<span class=\"attr\">force</span>: <span class=\"literal\">false</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">userModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">showAllUsers</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> user.<span class=\"title function_\">findAll</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> users;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">createUser</span>(<span class=\"params\">username, password</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newUser = <span class=\"keyword\">await</span> user.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">            username,</span><br><span class=\"line\">            password</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newUser;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">deleteUser</span>(<span class=\"params\">username</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> user.<span class=\"title function_\">destroy</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">                username</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">searchUser</span>(<span class=\"params\">username</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> user.<span class=\"title function_\">findOne</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">                username</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">updateUser</span>(<span class=\"params\">userId, username, password</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> user.<span class=\"title function_\">update</span>(&#123;</span><br><span class=\"line\">            username,</span><br><span class=\"line\">            password,</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">id</span>: userId</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = userModel;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"controllers\"><a href=\"#controllers\" class=\"headerlink\" title=\"controllers\"></a>controllers</h2><p>这段代码定义了一个名为 <code>userController</code> 的类，它包含了一些静态方法，用于处理与用户相关的 HTTP 请求。</p>\n<p>controllers 中的静态方法与上文提到的 modules 中的静态方法一一对应。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../modules/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">userController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">show</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">showAllUsers</span>();</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: users</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">create</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> password = data.<span class=\"property\">password</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(username + <span class=\"string\">&#x27; &#x27;</span> + password);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> newUser = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">createUser</span>(username, password);</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: newUser</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">delete</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">deleteUser</span>(username);</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: result</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">search</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">searchUser</span>(username);</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: result</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">update</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> userId = data.<span class=\"property\">userId</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> password = data.<span class=\"property\">password</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">updateUser</span>(userId, username, password);</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: result</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = userController;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"router-api\"><a href=\"#router-api\" class=\"headerlink\" title=\"router&#x2F;api\"></a>router&#x2F;api</h2><p>我们为每个接口单独创建一个文件，便于后期维护。每个接口也是对应到 <code>userControllers</code> 类中的静态方法。</p>\n<p><code>/api/show</code> 接口，用于展示当前数据库所有内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/api/show&#x27;</span>, userController.<span class=\"property\">show</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/create</code> 接口，用于创建一个新的用户：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/api/create&#x27;</span>, userController.<span class=\"property\">create</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/delete</code> 接口，用于删除一个用户：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/api/delete&#x27;</span>, userController.<span class=\"property\">delete</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/search</code> 接口，用于查找一个用户：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/api/search&#x27;</span>, userController.<span class=\"property\">search</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/update</code> 接口，用于更新一个用户的信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/api/update&#x27;</span>, userController.<span class=\"property\">update</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bodyparser-cors\"><a href=\"#bodyparser-cors\" class=\"headerlink\" title=\"bodyparser &amp; cors\"></a>bodyparser &amp; cors</h2><h3 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h3><p>原生 kao 不支持解析 POST 请求正文数据，也就是说，此时你编写的 body 参数解析代码并不生效！</p>\n<p>就像我们编写的 controllers 部分代码需要解析 POST 请求主体并获取参数，此时并不会生效。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /controllers/user.js</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">userController</span> &#123;</span><br><span class=\"line\"> \t... ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">create</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解析 POST 请求主体中的 username &amp; password 参数</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> password = data.<span class=\"property\">password</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了解决这个问题，我们需要安装以下依赖库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D koa-bodyparser</span><br></pre></td></tr></table></figure>\n\n<p><code>koa-bodyparser</code> 是一个 koa 框架的中间件，它可以解析 HTTP 请求的正文（body）数据，并将解析后的数据存储在 <code>ctx.request.body</code> 中。它支持解析 JSON、表单和文本类型的正文数据，但不支持解析多部分格式（multipart）数据。也就是说，如果想要实现文件上传，我们还会需要其他的库。</p>\n<p>安装成功后，我们将以下代码添加到 app.js 中，之后我们用于解析 body 的代码就能够正常工作了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"title function_\">bodyParser</span>());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><p>假设你的 koa 后端运行在 <a href=\"http://localhost:3000/\">http://localhost:3000</a>，而你的 react 前端运行在 <a href=\"http://localhost:5173/\">http://localhost:5173</a>。如果此时你的前端服务向后端 api 发送请求，会遭到拒绝，提示存在跨域问题：</p>\n<div align='center'>\n    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829135418397.png' />\n</div>\n\n<p>最简单的解决方法就是在我们的 app.js 中添加一个用于处理跨域资源共享（CORS）的中间件，你可以通过以下指令安装这个库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D koa-cors</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后，将以下代码添加到 app.js 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cors = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-cors&#x27;</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"title function_\">cors</span>());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h2><p>在解决前面的工作之后，我们开始编写入口文件 app.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Koa</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cors = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-cors&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">InitManager</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./core/init&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Koa</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"title function_\">cors</span>());</span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"title function_\">bodyParser</span>());</span><br><span class=\"line\"><span class=\"title class_\">InitManager</span>.<span class=\"title function_\">initCore</span>(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`🎁 Listening on localhost:3000 ...`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>完成之后，我们只需要在项目根目录下运行 <code>node app.js</code> 指令，即可启动我们的 koa 后端服务！</p>\n<h2 id=\"测试工具\"><a href=\"#测试工具\" class=\"headerlink\" title=\"测试工具\"></a>测试工具</h2><p>我们按照以上步骤实现了一套 koa-crud，还需要对其功能进行测试🤧。</p>\n<p>当然，你可以通过访问网页完成对 api 的测试，但这种方法局限性太大，不够灵活且很不方便。好在，现在有很多成熟的🔨工具供我们使用。</p>\n<p>我个人推荐 <code>postman</code>。</p>\n<p>postman 是一款用于测试和开发 API 的合作平台和工具。它提供了一个用户友好的界面，让开发人员能够轻松地发送 HTTP 请求、测试响应并与 API 进行交互</p>\n<p>使用 postman，你可以创建各种类型的 HTTP 请求（例如 GET、POST 和 PUT），设置请求参数（如头部、身体、查询参数等），发送请求，并查看服务器返回的响应。它还提供了断言（assertions）功能，用于验证API的响应是否符合预期。</p>\n<div align='center'>\n    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829141158347.png' />\n</div>\n\n<p>下载使用都很简单，这里不做介绍，请自行前往 💥<a href=\"https://www.postman.com/\">postman 官网</a> 了解。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>以上代码就是 <code>kao+sqlite</code> 实现 CRUD 的简单实战，整套代码还有很多可以✨优化的地方。</p>\n<p>比如，调用这个 koa 服务中的 api 都需要使用 POST 请求，不符合目前流行的 <code>RESTful</code> 设计风格，后续可以进行调整（但 POST 一把嗦确实无脑易用🤣）。</p>\n<p>在 controllers 中，我也没有进行适当的错误处理，不方便 DEBUG，也是可以优化的点。</p>\n<p>对传入参数的处理也没有做，我不晓得 koa-bodyparser 有没有进行处理，也可能会存在安全问题。</p>\n<blockquote>\n<p>问题多多❤～摩多摩多❤～</p>\n</blockquote>\n<p>不过呢，这是阿菇第一次用 koa 写后端服务（其实后端都没怎么写过🥲），至少能跑起来了！后续会继续优化这个服务，并更新在 GitHub 仓库中，以上实现的 api 会被规范化为 <code>/api/v1/*</code>，之后优化过的版本会注册为 <code>/api/v2/</code>，这样做可能较符合实际生产环境的写法……</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.koajs.com.cn/#\">Koa 中文网</a></li>\n<li><a href=\"https://chenshenhai.github.io/koa2-note/\">Koa2 进阶学习笔记</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960\">koa - 廖雪峰的官方网站</a></li>\n<li><a href=\"https://ruanyifeng.com/blog/2017/08/koa.html\">Koa 框架教程 - 阮一峰的网络日志</a></li>\n<li><a href=\"https://juejin.cn/post/7066568536944017438#heading-8\">koa 连接sqlite3 项目目录结构 - 稀土掘金</a></li>\n</ul>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>每次写CRUD，都会觉得后端这套东西的逻辑性比前端要强😇，写的时候行云流水。</p>\n<p><code>koa</code> 给我的开发初体验不错，主打一个轻便简洁，仅存储少量数据时配合 <code>sqlite</code> 更是方便。</p>\n","excerpt":"","more":"<p>暑期的尾声渐近，创新实践课的老师突然要验收暑期学习成果，愚蠢的阿菇对此事完全没有印象……毫无准备的他决定临时搓个小东西出来。前端肯定是要用 React 来做，后端嘛……思来想去，准备学习 koa 现学现卖一下。之前没用 node.js 写过后端，想尝试尝试新东西，单纯为了补作业而写东西感觉不值……</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>先了解一些基本概念。</p>\n<h3 id=\"koa\"><a href=\"#koa\" class=\"headerlink\" title=\"koa\"></a>koa</h3><p><code>koa</code> 是一个基于 Node.js 的 Web 开发框架，提供了一种<strong>简洁优雅</strong>的方式来处理 HTTP 请求和响应。我个人觉得 koa 就是精简版的 Express，删减了路由、视图渲染等多种功能，同时在中间件以及异步处理等方面进行了一些优化。</p>\n<p>可以去 <a href=\"https://www.koajs.com.cn/\">👋koa 官网</a> 进一步了解。但官网阅读起来比较难受，目录不是很好，但一手文档的参考简直自然是没得说。</p>\n<p>如果只想要快速上手 koa 开发，阿菇更推荐下面这个教程：</p>\n<p><a href=\"https://chenshenhai.github.io/koa2-note/\">《Koa3 进阶学习笔记》</a></p>\n<h3 id=\"sqlite\"><a href=\"#sqlite\" class=\"headerlink\" title=\"sqlite\"></a>sqlite</h3><p><code>sqlite</code> 是一个嵌入式 SQL 数据库引擎，它提供了一种简单、轻量级且独立的方法来存储和管理数据。它不需要单独的服务器进程，可以直接在应用程序中使用。它不像 MySQL 那么笨重，轻便到你只需要在你的项目中留有一个 sqlite.db 即可，对初学者来说省去了很多配置环境的麻烦（阿菇首次接触到的数据库就是 sqlite）。</p>\n<h2 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h2><p><code>MVC</code> 是一个最基本的核心架构知识，以后会经常用到。你是离不开它的🤗。</p>\n<p><img src=\"https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828212321994.png\" alt=\"MVC架构图\"></p>\n<p>MVC 模式，全称为 Model-View-Controller（模型-视图-控制器）模式，它是一种软件架构模式，其目标是将软件的用户界面（即前台页面）和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。</p>\n<p>具体到代码层面，MVC 将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）。Model 负责数据的存储和处理，Controller 负责业务逻辑的处理和协调，View 负责数据的可视化呈现给用户。</p>\n<p>MVC 模式的优势在于分离关注点、提高代码的可重用性和可维护性。通过将应用程序分成模型、视图和控制器，实现更好地组织代码、降低模块之间的耦合度，并提供了良好的扩展性和可测试性。</p>\n<p>除了 MVC，还有其他一些常见的架构模式，这里不做展开介绍😜，感兴趣的请自行前往以下链接了解：</p>\n<ul>\n<li><a href=\"https://zh.wikipedia.org/wiki/Model-view-presenter\">MVP模式（Model-View-Presenter）</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel\">MVVM模式（Model-View-ViewModel）</a></li>\n</ul>\n<h2 id=\"实战场景概括\"><a href=\"#实战场景概括\" class=\"headerlink\" title=\"实战场景概括\"></a>实战场景概括</h2><p>在接下来的实战中，我们会实现一个 <code>users</code> 表，包括 id、username 和 password 三个列，并基于这个表使用 koa 以及相关库实现 crud api 接口，并在完成后使用 <code>postman</code> 工具进行测试。</p>\n<p>不想听我啰嗦的可以直接去看 GitHub 项目地址：</p>\n<p><a href=\"https://github.com/ma5hr00m/koa2-crud-example\">koa2-crud-example</a></p>\n<h2 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h2><p>常用的 koa 语法前往官网自行了解 👉<a href=\"https://www.koajs.com.cn/#application\">Koa 中文网</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 初始化 node.js 项目</span></span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> example</span><br><span class=\"line\"><span class=\"built_in\">cd</span> example</span><br><span class=\"line\">yarn init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 koa</span></span><br><span class=\"line\">yarn add -D koa</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"init-ping\"><a href=\"#init-ping\" class=\"headerlink\" title=\"init &amp; ping\"></a>init &amp; ping</h2><p>该部分参考：<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960\">处理 URL - 廖雪峰的官方网站</a>。这个文章会告诉你如何搭建一个基础的 koa 服务，并编写一个 <code>/ping</code> api 进行示范。</p>\n<p>你需要先安装一些依赖库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D koa-router require-directory</span><br></pre></td></tr></table></figure>\n\n<p><code>koa-router</code> 是一个用于 koa 框架的路由中间件，它提供了类似于 Express 的路由功能（例如 app.get、app.put、app.post 等）。它支持命名 URL 参数、命名路由与 URL 生成、匹配特定主机的路由、响应带有允许方法的 OPTIONS 请求、支持 405 方法不允许和 501 未实现等特性。</p>\n<p><code>require-directory</code> 可以递归地遍历指定目录，使用 <code>require()</code> 加载每个文件，并返回包含这些模块的嵌套哈希结构。它可以用来自动加载目录中的所有模块，而不需要手动一个一个地加载（似乎只适配 Common JS）。</p>\n<p>完成以下代码，你能实现一个最基本的 koa 后端服务，当你访问 <a href=\"http://localhost:3000/ping\">http://localhost:3000/ping</a> 时能得到一个 <code>pong!</code> 响应。</p>\n<p>先来看看目录结构：</p>\n<div align='center'>\n    <img style='height:200px' src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230828220513695.png' />\n</div>\n\n<p><code>/core/init.js</code> 文件用于初始化 &#x2F;api&#x2F; 目录下所有 api 接口文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> requireDirectory = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;require-directory&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InitManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">initCore</span>(<span class=\"params\">app</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">InitManager</span>.<span class=\"property\">app</span> = app;</span><br><span class=\"line\">        <span class=\"title class_\">InitManager</span>.<span class=\"title function_\">initLoadRouters</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">initLoadRouters</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">function</span> <span class=\"title function_\">whenLoadModule</span>(<span class=\"params\">obj</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Router</span>) &#123;</span><br><span class=\"line\">                <span class=\"title class_\">InitManager</span>.<span class=\"property\">app</span>.<span class=\"title function_\">use</span>(obj.<span class=\"title function_\">routes</span>())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> apiDirectory = <span class=\"string\">`<span class=\"subst\">$&#123;process.cwd()&#125;</span>/api`</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        requireDirectory(<span class=\"variable language_\">module</span>, apiDirectory, &#123;</span><br><span class=\"line\">            <span class=\"attr\">visit</span>: whenLoadModule</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title class_\">InitManager</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/ping.js</code> 实现了一个简单的后端 api 接口，当用户访问 &#x2F;ping 路由时，后端服务会返回给用户一个 <code>pong!</code> 文本响应：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/ping&#x27;</span>,<span class=\"keyword\">async</span> ctx =&gt; &#123;</span><br><span class=\"line\">    ctx.<span class=\"property\">body</span> = <span class=\"string\">&#x27;pong!&#x27;</span>;</span><br><span class=\"line\">&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/app.js</code> 是入口文件，初始化一个 Koa 对象，调用 <code>init.js</code> 启用所有 api 接口，然后监听本地 3000 端口：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Koa</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">InitManager</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./core/init&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Koa</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">InitManager</span>.<span class=\"title function_\">initCore</span>(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`🎁 Listening on localhost:3000 ...`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>完成以上代码后，在项目根目录执行以下指令启动服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node app.js</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"database\"><a href=\"#database\" class=\"headerlink\" title=\"database\"></a>database</h2><p>先安装一些依赖库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D sqlite3 sequelize</span><br></pre></td></tr></table></figure>\n\n<p><code>sequelize</code> 是一个基于 promise 的 Node.js ORM（对象关系映射），可用于 PostgresSQL、MySQL、MariaDB、SQLite 和 Microsoft SQL Server 数据库。它提供了一种简单、灵活且强大的方法来定义模型和关系，并支持事务、迁移和复杂查询等高级功能。</p>\n<p>简单的说，就是大家都不想写 Raw SQL，觉得麻烦且存在安全问题，就封装了一套接口用来实现常用的 SQL 语句。</p>\n<p>我们在项目根目录下创建一个 <code>/database/db.js</code>，写入以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 你不需要手动创建 database.db，若代码检测到对应数据库不存在则会自动创建</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">Sequelize</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;sequelize&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sequelize = <span class=\"keyword\">new</span> <span class=\"title class_\">Sequelize</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">dialect</span>: <span class=\"string\">&#x27;sqlite&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">storage</span>: <span class=\"string\">&#x27;./sqlite.db&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    sequelize.<span class=\"title function_\">authenticate</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Connect to database successfully`</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Connection failed: <span class=\"subst\">$&#123;err&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123; sequelize &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"schema\"><a href=\"#schema\" class=\"headerlink\" title=\"schema\"></a>schema</h2><p>我们在项目根目录下创建一个 <code>/schema/user.js</code>，该文件的作用是定义了数据库模型，方便我们在其他文件使用。写入以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"title class_\">DataTypes</span> &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;sequelize&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span>(<span class=\"params\">sequelize</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sequelize.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;user&#x27;</span>, &#123;</span><br><span class=\"line\">        <span class=\"attr\">id</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"title class_\">DataTypes</span>.<span class=\"property\">INTEGER</span>,</span><br><span class=\"line\">            <span class=\"attr\">primaryKey</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">autoIncrement</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">allowNull</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">field</span>: <span class=\"string\">&#x27;id&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">username</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"title class_\">DataTypes</span>.<span class=\"property\">TEXT</span>,</span><br><span class=\"line\">            <span class=\"attr\">allowNull</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">field</span>: <span class=\"string\">&#x27;username&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">password</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">type</span>: <span class=\"title class_\">DataTypes</span>.<span class=\"property\">TEXT</span>,</span><br><span class=\"line\">            <span class=\"attr\">allowNull</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            <span class=\"attr\">field</span>: <span class=\"string\">&#x27;password&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"modules\"><a href=\"#modules\" class=\"headerlink\" title=\"modules\"></a>modules</h2><p>这段代码定义了一个名为 <code>userModel</code> 的类，它包含了一些静态方法，用于对数据库中的 <code>users</code> 表进行操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> db = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../database/db&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> sequelize = db.<span class=\"property\">sequelize</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../schema/user&#x27;</span>)(sequelize);</span><br><span class=\"line\">user.<span class=\"title function_\">sync</span>(&#123;<span class=\"attr\">force</span>: <span class=\"literal\">false</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">userModel</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">showAllUsers</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> user.<span class=\"title function_\">findAll</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> users;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">createUser</span>(<span class=\"params\">username, password</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> newUser = <span class=\"keyword\">await</span> user.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">            username,</span><br><span class=\"line\">            password</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newUser;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">deleteUser</span>(<span class=\"params\">username</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> user.<span class=\"title function_\">destroy</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">                username</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">searchUser</span>(<span class=\"params\">username</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> user.<span class=\"title function_\">findOne</span>(&#123;</span><br><span class=\"line\">            <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">                username</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">updateUser</span>(<span class=\"params\">userId, username, password</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> user.<span class=\"title function_\">update</span>(&#123;</span><br><span class=\"line\">            username,</span><br><span class=\"line\">            password,</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">                <span class=\"attr\">id</span>: userId</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = userModel;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"controllers\"><a href=\"#controllers\" class=\"headerlink\" title=\"controllers\"></a>controllers</h2><p>这段代码定义了一个名为 <code>userController</code> 的类，它包含了一些静态方法，用于处理与用户相关的 HTTP 请求。</p>\n<p>controllers 中的静态方法与上文提到的 modules 中的静态方法一一对应。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../modules/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">userController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">show</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">showAllUsers</span>();</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: users</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">create</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> password = data.<span class=\"property\">password</span>;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(username + <span class=\"string\">&#x27; &#x27;</span> + password);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> newUser = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">createUser</span>(username, password);</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: newUser</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">delete</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">deleteUser</span>(username);</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: result</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">search</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">searchUser</span>(username);</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: result</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">update</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> userId = data.<span class=\"property\">userId</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> password = data.<span class=\"property\">password</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> userModel.<span class=\"title function_\">updateUser</span>(userId, username, password);</span><br><span class=\"line\">        ctx.<span class=\"property\">response</span>.<span class=\"property\">status</span> = <span class=\"number\">200</span>;</span><br><span class=\"line\">        ctx.<span class=\"property\">body</span> = &#123;</span><br><span class=\"line\">            <span class=\"attr\">status</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">            <span class=\"attr\">message</span>: <span class=\"string\">&#x27;success&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">data</span>: result</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = userController;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"router-api\"><a href=\"#router-api\" class=\"headerlink\" title=\"router&#x2F;api\"></a>router&#x2F;api</h2><p>我们为每个接口单独创建一个文件，便于后期维护。每个接口也是对应到 <code>userControllers</code> 类中的静态方法。</p>\n<p><code>/api/show</code> 接口，用于展示当前数据库所有内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/api/show&#x27;</span>, userController.<span class=\"property\">show</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/create</code> 接口，用于创建一个新的用户：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/api/create&#x27;</span>, userController.<span class=\"property\">create</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/delete</code> 接口，用于删除一个用户：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/api/delete&#x27;</span>, userController.<span class=\"property\">delete</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/search</code> 接口，用于查找一个用户：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/api/search&#x27;</span>, userController.<span class=\"property\">search</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<p><code>/api/update</code> 接口，用于更新一个用户的信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Router</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> userController = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../controllers/user&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> <span class=\"title class_\">Router</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">router.<span class=\"title function_\">post</span>(<span class=\"string\">&#x27;/api/update&#x27;</span>, userController.<span class=\"property\">update</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = router;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bodyparser-cors\"><a href=\"#bodyparser-cors\" class=\"headerlink\" title=\"bodyparser &amp; cors\"></a>bodyparser &amp; cors</h2><h3 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h3><p>原生 kao 不支持解析 POST 请求正文数据，也就是说，此时你编写的 body 参数解析代码并不生效！</p>\n<p>就像我们编写的 controllers 部分代码需要解析 POST 请求主体并获取参数，此时并不会生效。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /controllers/user.js</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">userController</span> &#123;</span><br><span class=\"line\"> \t... ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">async</span> <span class=\"title function_\">create</span>(<span class=\"params\">ctx</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解析 POST 请求主体中的 username &amp; password 参数</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = ctx.<span class=\"property\">request</span>.<span class=\"property\">body</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> username = data.<span class=\"property\">username</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> password = data.<span class=\"property\">password</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了解决这个问题，我们需要安装以下依赖库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D koa-bodyparser</span><br></pre></td></tr></table></figure>\n\n<p><code>koa-bodyparser</code> 是一个 koa 框架的中间件，它可以解析 HTTP 请求的正文（body）数据，并将解析后的数据存储在 <code>ctx.request.body</code> 中。它支持解析 JSON、表单和文本类型的正文数据，但不支持解析多部分格式（multipart）数据。也就是说，如果想要实现文件上传，我们还会需要其他的库。</p>\n<p>安装成功后，我们将以下代码添加到 app.js 中，之后我们用于解析 body 的代码就能够正常工作了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"title function_\">bodyParser</span>());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><p>假设你的 koa 后端运行在 <a href=\"http://localhost:3000/\">http://localhost:3000</a>，而你的 react 前端运行在 <a href=\"http://localhost:5173/\">http://localhost:5173</a>。如果此时你的前端服务向后端 api 发送请求，会遭到拒绝，提示存在跨域问题：</p>\n<div align='center'>\n    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829135418397.png' />\n</div>\n\n<p>最简单的解决方法就是在我们的 app.js 中添加一个用于处理跨域资源共享（CORS）的中间件，你可以通过以下指令安装这个库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add -D koa-cors</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后，将以下代码添加到 app.js 中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cors = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-cors&#x27;</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"title function_\">cors</span>());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"app\"><a href=\"#app\" class=\"headerlink\" title=\"app\"></a>app</h2><p>在解决前面的工作之后，我们开始编写入口文件 app.js：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">Koa</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> cors = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-cors&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">InitManager</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./core/init&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> <span class=\"title class_\">Koa</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"title function_\">cors</span>());</span><br><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"title function_\">bodyParser</span>());</span><br><span class=\"line\"><span class=\"title class_\">InitManager</span>.<span class=\"title function_\">initCore</span>(app);</span><br><span class=\"line\"></span><br><span class=\"line\">app.<span class=\"title function_\">listen</span>(<span class=\"number\">3000</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`🎁 Listening on localhost:3000 ...`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>完成之后，我们只需要在项目根目录下运行 <code>node app.js</code> 指令，即可启动我们的 koa 后端服务！</p>\n<h2 id=\"测试工具\"><a href=\"#测试工具\" class=\"headerlink\" title=\"测试工具\"></a>测试工具</h2><p>我们按照以上步骤实现了一套 koa-crud，还需要对其功能进行测试🤧。</p>\n<p>当然，你可以通过访问网页完成对 api 的测试，但这种方法局限性太大，不够灵活且很不方便。好在，现在有很多成熟的🔨工具供我们使用。</p>\n<p>我个人推荐 <code>postman</code>。</p>\n<p>postman 是一款用于测试和开发 API 的合作平台和工具。它提供了一个用户友好的界面，让开发人员能够轻松地发送 HTTP 请求、测试响应并与 API 进行交互</p>\n<p>使用 postman，你可以创建各种类型的 HTTP 请求（例如 GET、POST 和 PUT），设置请求参数（如头部、身体、查询参数等），发送请求，并查看服务器返回的响应。它还提供了断言（assertions）功能，用于验证API的响应是否符合预期。</p>\n<div align='center'>\n    <img src='https://agu-images.oss-cn-hangzhou.aliyuncs.com/test/image-20230829141158347.png' />\n</div>\n\n<p>下载使用都很简单，这里不做介绍，请自行前往 💥<a href=\"https://www.postman.com/\">postman 官网</a> 了解。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>以上代码就是 <code>kao+sqlite</code> 实现 CRUD 的简单实战，整套代码还有很多可以✨优化的地方。</p>\n<p>比如，调用这个 koa 服务中的 api 都需要使用 POST 请求，不符合目前流行的 <code>RESTful</code> 设计风格，后续可以进行调整（但 POST 一把嗦确实无脑易用🤣）。</p>\n<p>在 controllers 中，我也没有进行适当的错误处理，不方便 DEBUG，也是可以优化的点。</p>\n<p>对传入参数的处理也没有做，我不晓得 koa-bodyparser 有没有进行处理，也可能会存在安全问题。</p>\n<blockquote>\n<p>问题多多❤～摩多摩多❤～</p>\n</blockquote>\n<p>不过呢，这是阿菇第一次用 koa 写后端服务（其实后端都没怎么写过🥲），至少能跑起来了！后续会继续优化这个服务，并更新在 GitHub 仓库中，以上实现的 api 会被规范化为 <code>/api/v1/*</code>，之后优化过的版本会注册为 <code>/api/v2/</code>，这样做可能较符合实际生产环境的写法……</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.koajs.com.cn/#\">Koa 中文网</a></li>\n<li><a href=\"https://chenshenhai.github.io/koa2-note/\">Koa2 进阶学习笔记</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960\">koa - 廖雪峰的官方网站</a></li>\n<li><a href=\"https://ruanyifeng.com/blog/2017/08/koa.html\">Koa 框架教程 - 阮一峰的网络日志</a></li>\n<li><a href=\"https://juejin.cn/post/7066568536944017438#heading-8\">koa 连接sqlite3 项目目录结构 - 稀土掘金</a></li>\n</ul>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>每次写CRUD，都会觉得后端这套东西的逻辑性比前端要强😇，写的时候行云流水。</p>\n<p><code>koa</code> 给我的开发初体验不错，主打一个轻便简洁，仅存储少量数据时配合 <code>sqlite</code> 更是方便。</p>\n"},{"title":"Nginx 进程模型概述","date":"2024-02-19T16:00:00.000Z","author":"ma5hr00m","_content":"\nNginx 平时一直有在用，但说实话，对其工作原理一直没有深入了解。那不如从现在开始了解，之后会慢慢更。先说说进程模型。\n\n## 发展\n\nNginx 的开发始于 2002 年，由 Igor Sysoev 发起，最初是为了解决 C10K 问题，即如何让一个服务器同时处理超过一万个客户端连接。\n\n第一个公开版本发布于 2004 年 10 月。自此，Nginx 此开始了它的快速发展。Nginx 目前是世界上使用最多的 Web 服务器之一，根据 Netcraft 的统计，截至 2024 年 2 月，Nginx 占据了全球 Web 服务器市场的 32.8% 的份额，仅次于 Apache。\n\n## 安装与管理\n\n主流 Linux 发行版的包管理工具都支持下载 nginx，这里以 Manjaro 为例：\n\n```Bash\nsudo pacman -S nginx\n```\n\nNginx 可通过`-s`参数响应一些自带的信号，比如：\n\n- `stop`：立即关闭\n- `quit`：正常关闭\n- `reload`：重新加载配置文件\n- `reopen`：重新打开日志文件\n\n例如，当我们在`etc/nginx/conf.d`中修改配置文件添加 Web 服务时，改动内容并不会直接生效，需要我们重启 nginx 服务或者使用`-s reload`指令传递重新加载配置文件的信号。\n\n此外，我们可以通过`systemctl`等指令管理本地的 Nginx 服务，比如最常见的检查 Nginx 状态的指令：\n\n```Bash\nsystemctl status nginx\n```\n\n## Nginx配置文件结构\n\n在正式介绍之前，我想要先从 nginx 配置文件入手，这可能会更加便于理解，毕竟配置文件是我们接触 nginx 最直接的地方。\n\nLinux 下 nginx 配置文件的默认位置是在`/etc/nginx/nginx.conf`，这里先举一个简单的例子：\n\n```Nginx\n# 全局块\nuser  nobody; # 指定运行nginx服务的用户和用户组\nworker_processes  1; # 指定工作线程数\nerror_log  logs/error.log; # 指定错误日志的路径和级别\npid        logs/nginx.pid; # 指定pid文件的路径\n\n# events块\nevents {\n    worker_connections  1024; # 指定每个工作进程可以同时开启的最大连接数\n}\n\n# http块\nhttp {\n    # http全局块\n    include       mime.types; # 引入MIME-Type定义文件\n    default_type  application/octet-stream; # 设置默认的MIME-Type\n    sendfile        on; # 开启sendfile传输文件的优化\n    keepalive_timeout  65; # 设置连接超时时间\n\n    # server块\n    server {\n        # server全局块\n        listen       8000; # 监听8000端口\n        server_name  localhost; # 设置虚拟主机的名称\n\n        # location块\n        location / {\n            root   html; # 设置根目录的路径\n            index  index.html index.htm; # 设置默认的首页文件\n        }\n\n        # location块\n        location /images {\n            root   /data; # 设置图片资源的路径\n            autoindex on; # 开启目录浏览功能\n        }\n\n        # location块\n        location ~ \\.php$ {\n            root           html; # 设置PHP文件的路径\n            fastcgi_pass   127.0.0.1:9000; # 设置PHP-FPM的地址和端口\n            fastcgi_index  index.php; # 设置默认的PHP文件\n            fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name; # 设置PHP脚本的完整路径\n            include        fastcgi_params; # 引入fastcgi的配置文件\n        }\n    }\n}\n```\n\n- 全局块：从开始到`events`块之间的部分，主要设置一些影响 nginx 服务器整体运行的配置指令，例如`user`，`worker_processes`，`error_log`，`pid`等。\n- `events`块：涉及的指令主要影响 nginx 服务器与用户的网络连接，例如`worker_connections`，`accept_mutex`，`multi_accept`，`use`等。\n- `http`块：包含`http`全局块和多个`server`块，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个块中。`http`全局块是不包含在`server`块中的部分，主要设置一些影响`http`协议的配置指令，例如`include`，`default_type`等。`server`块是虚拟主机的配置，每个`server`块可以包含`server`全局块和多个`location`块。`server`全局块是不包含在`location`块中的部分，主要设置一些影响虚拟主机的配置指令，例如`listen`，`server_name`等。`location`块是 URL 匹配的配置，每个`location`块可以包含一些针对特定请求的处理规则，例如`root`，`index`，`proxy_pass`等。\n\n从方便理解的角度，每个`server`块就对应一个应用，而`location`可以理解为应用对应的路由。一般情况下，我们想要在自己的服务器中新增某个 Web 应用配置，就在`http`块中添加`server`块即可。\n\n你可以尝试在 nginx 默认端口为 80 的`server`块中添加下面这个`location`块：\n\n```Nginx\nlocation / {\n    default_type text/plain\n    return 200 \"pong\"\n}\n```\n\n退出保存，使用`nginx -s reload`重新加载配置文件，使用`curl`或在浏览器中请求`http://ocalhost/ping`，即可得到返回的`pong`响应数据。\n\n```Bash\ncurl http://localhost/ping # pong\n```\n\n## 工作模式概述\n\n在正式开始 Nginx 进程模型的介绍之前，还需要了解下 nginx 的基本工作模式是怎样的。\n\nNginx 服务启动后，会创建一个 master 主进程，该主进程在进行一部分初始化工作后，会产生一个或多个工作进程 worker；收到来自客户端的请求后，nginx 可能涉及与后端服务器的通信，它可以将收到的 http 请求代理转发到目标服务器，由专门的后端服务器处理数据。\n\n同时，为了提高对请求的响应效率，降低服务器受到的网络压力，nginx 采用了缓存机制，将历史应答数据缓存到本地，保障了客户端对缓存文件的快速访问。\n\n## 进程模型\n\nNginx 采用了 master-worker 进程模型。相比于 apache 采用的传统多进模型，nginx 的进程模型有一些显著的优势：\n\n- Master-worker 异步非阻塞的特点允许 nginx 在高并发下保持低资源低消耗高性能，同时也提高了服务的稳定性，单个 workder 进程出现异常不影响其他 worker 和 master 的运行；\n- 实现了热部署，即在不重启 nginx 服务的前提下重新加载配置文件；\n- ……\n\n![20240229225629](https://img.ma5hr00m.top/blog/20240229225629.png)\n\n### master 进程\n\nmaster 模块负责接收外部信号，在根据信号的不同管理 worker 模块以实现对应的功能。master 模块本身不会处理网络请求，它只是作为一个调度者，作为用户与 worker 之间的桥梁而存在。\n\n在 nginx 服务初始化时，master 会读取并解析配置文件，出现错误就报告并推出。我们可以使用`-t`参数主动检查配置文件是否存在错误，以确保不会重启 nginx 失败：\n\n```Bash\nsudo nginx -t\n```\n\n在运行过程中，master 进程也会监控 worker 进程运行状态、如果 worker 模块出现异常，master 就会`fork()`一个新的 worker 进程，保证整个 nginx 服务正常运行。\n\n那现在，我们会想知道 master 进程具体是如何管理 worker 进程的呢 🤔️\n\n### master 管理 worker\n\nmaster 进程通过信号量机制（Semaphore Mechanism）和定时器机制（Timer Mechanism）来监控并管理 worker 进程。\n\n信号量机制（semaphore mechanism）是一种用于实现进程间同步和互斥的方法，它使用一个整数变量来表示系统中某种资源的数量或状态，进程可以通过原子操作（atomic operation）来增加或减少信号量的值，从而实现对资源的请求和释放。\n\nnginx 的 master 模块和 worker 模块之间通过信号（signal）来实现同步和通信，信号是一种用于进程间交互的软件中断，它可以用来传递一些简单的信息或命令。nginx 使用了一些预定义的信号，比如`SIGCHLD`、`SIGALRM`、`SIGTERM`、`SIGQUIT`、`SIGHUP`、`SIGUSR1`等，每个信号都有特定的含义和作用。\n\n- 当 worker 模块退出或者崩溃时，它会向 master 模块发送`SIGCHLD`信号，通知 master 模块有子进程已经终止。master 模块在收到`SIGCHLD`信号后，会调用`waitpid()`函数来回收子进程的资源，并检查子进程的退出码，如果是非正常退出，就会重新`fork()`一个新的 worker 模块，保证服务的可用性。\n- 当 master 模块需要重启或者升级时，它会向 worker 模块发送`SIGTERM`或者`SIGQUIT`信号，要求 worker 模块正常关闭或者立即终止。worker 模块在收到这些信号后，会停止接受新的请求，并处理完已经接受的请求，然后退出。master 模块在收到所有 worker 模块的`SIGCHLD`信号后，会重新加载配置文件，并启动新的 worker 模块。\n- 当 master 模块需要重新加载配置文件或者重新打开日志文件时，它会向 worker 模块发送`SIGHUP`或者`SIGUSR1`信号，要求 worker 模块重新读取配置文件或者重新打开日志文件。worker 模块在收到这些信号后，会先关闭旧的配置文件或者日志文件，然后打开新的配置文件或者日志文件，并继续处理请求。\n\n而定时器机制（timer mechanism）是一种用于实现进程间通信和调度的方法，它使用一个计数器来表示系统中某种事件的发生时间或间隔，进程可以通过设置或取消定时器来触发或取消某种动作，从而实现对事件的响应和控制。\n\nnginx 则使用了`SIGALRM`信号来实现定时器的功能。\n\n- 当 master 模块启动时，它会设置一个定时器，每隔一定的时间（默认是 5 秒），就会向 worker 模块发送 `SIGALRM`信号，要求 worker 模块向 master 模块报告自己的状态，比如是否存活、是否忙碌、是否有异常等。master 模块在收到 worker 模块的回应后，会更新 worker 模块的状态，并根据 worker 模块的状态来调整定时器的间隔，如果 worker 模块频繁退出或者出错，就会缩短定时器的间隔，反之则会延长定时器的间隔。\n- 当 master 模块收到`SIGALRM`信号时，它会检查 worker 模块是否存活，如果发现有 worker 模块已经死亡，就会重新`fork()`一个新的 worker 模块，保证服务的可用性。master 模块还会检查 worker 模块是否忙碌，如果发现有 worker 模块长时间没有处理请求，就会认为 worker 模块已经卡死，然后向 worker 模块发送`SIGKILL`信号，强制终止 worker 模块，并重新`fork()`一个新的 worker 模块，保证服务的可用性。\n\n### worker 进程 \n\nworker 接受 master 的调度，负责处理客户端的连接和请求。客户端的请求完全由 worker 处理，而且请求与 worker 是一一对应的关系。同时，worker 进程之间都是平等关系。\n\n这句话可以引出来一个问题：worker 之间是平等的关系，每条请求只由单个 worker处理，但接收请求时会存在多个 worker，那 master 是怎么决定让哪个 worker 去处理当前请求的呢？\n\n### worker 工作流程\n\n在开始之前，有必要先介绍 nginx 的 accepy_mutex 机制，该机制有效的避免了惊群效应（thundering herd problem）和锁队列（lock convoy）问题，而这些问题会导致 nginx 的性能下降和资源浪费。\n\naccept_mutex 是一个互斥锁（mutex），它可以保证在同一时刻，只有一个 worker 可以接受新连接，其他 worker 则会等待或者处理已有的连接。\n\naccept_mutex 机制的开启和关闭可以通过配置文件中的`accept_mutex`指令来控制，它的默认值是`off`。同时，还会有一个`accept_mutex_delay`时间参数，它指定了在另一个 worker 正在接受新连接的情况下，worker 尝试重新开始接受新连接的最长时间，它的默认值是`500ms`。这个参数可以避免工作进程频繁地抢夺 accept_mutex，从而减少系统开销。\n\n好，到这里就差不多。现在介绍 worker 工作流程。\n\n在 nginx 服务器启动时，会先创建一个 master 进程，master 会先建立好需要`listen`的 socket（listenfd）之后，再根据配置文件中`worker_process`指令创建指定数量的 worker 进程，用于处理请求。然后，master 会创建 accept_mutex，并把它传递给 worker。\n\n每个 worker 都会初始化事件模块（event module）和连接模块（connection module），事件模块负责监听和处理事件，连接模块负责管理连接。worker 会根据配置文件中的`use`指令，选择最合适的事件通知机制,再根据配置文件中的`worker_connections`指令，创建一个连接池（connection pool），并分配一定数量的连接（connection）给事件模块，每个连接都有一个读事件（read event）和一个写事件（write event）。\n\n当有新连接到来时，事件模块会通知 worker，然后所有 worker 会来抢唯一的 accept_mutex，抢到 mutex 的 worker 进程就会注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当 worker 接受完新连接后，它会释放 accept_mutex，并处理新连接的请求。\n\n那没抢到 mutex 的 worker 会做什么呢？它们会等待`accept_mutex_delay`的时间，如果在这段时间内没有其他 worker 获得 mutex，它们就会再次尝试获取 mutex，并重复上述过程；如果在这段时间内有其他 worker 获得 mutex，那么等待的 worker 就会放弃，转而继续处理已有的连接或者进入休眠状态。\n\n抢到 mutex 的 worker 会进入事件循环（event loop），不断地检查事件队列中是否有就绪的事件，如果有，就调用相应的事件处理函数。对于读事件，事件处理函数会读取客户端发送的数据，并根据数据的类型，调用相应的模块来处理请求，例如，如果是 HTTP 请求，就调用 HTTP 模块（HTTP module）；如果是邮件请求，就调用邮件模块（mail module）……对于写事件，事件处理函数会发送数据给客户端，并根据数据的状态，决定是否关闭连接或者继续处理请求。\n\n处理完一个连接或者请求时，worker 会把连接放回连接池中，等待下一次使用，或者释放连接，以便其他工作进程使用。\n\n## 补充\n\n### Netcraft\n\nNetcraft 是一家英国的网络安全公司，成立于 1995 年。该公司主要提供互联网基础架构，网络安全，以及网站评测等服务。 其中，Netcraft 的网站评测功能可以帮助用户评估网站的安全性，包括网站托管地址，服务器软件，以及脚本语言等信息。\n\nNetcraft 每月都会对全球的网站进行抽样调查，收集网站的响应头、域名、IP 地址、证书等数据，然后根据这些数据分析出网站使用的服务器软件，操作系统，网络服务商等信息。\n\nNetcraft 的调查报告已经成为人们了解全球网站数量以及各种服务器市场份额等情况的主要依据。访问 [Netcraft](https://www.netcraft.com/) 的官网就可以查看最新的调查结果，或者使用它的搜索功能，查询任意网站的相关信息。\n\n### 异步非阻塞\n\n前文中有提到 master-worker 是一种异步非阻塞的进程模型。我认为可以在这里做一个更详细的描述，就是该进程模型为什么是“异步非阻塞”的：\n\n- **异步**：在 nginx 的 master-worker 模式中，master 进程负责管理 worker 进程，而 worker 进程则处理实际的客户端请求。这种架构下，master 进程和 worker 进程之间采用异步通信方式，master 进程不会阻塞在等待 worker 进程的响应上，从而提高了整体的并发处理能力；\n- **非阻塞**：nginx 中的 worker 进程使用非阻塞 I/O 操作来处理客户端请求。这意味着当一个请求需要进行 I/O 操作时（比如读取文件或从网络接收数据），worker 进程不会一直等待数据准备就绪，而是会继续处理其他请求。一旦数据准备就绪，worker 进程会立即处理它，而不会阻塞在这个操作上；\n- **事件驱动**：nginx 使用事件驱动的方式来处理 I/O 操作。它利用操作系统提供的事件通知机制（如 epoll 或 kqueue）来实现非阻塞 I/O。当一个事件发生时（比如一个连接建立或数据可读），nginx 将相应的事件添加到事件队列中，并通过事件驱动的方式处理这些事件，而不是通过阻塞式的等待。\n\nnginx 的 master-worker 模式通过异步、非阻塞和事件驱动的设计，实现了高性能和高并发处理能力。这种模式使得 nginx 能够高效地处理大量并发请求，而不会因为阻塞在 I/O 操作上而导致性能下降。而 apache 传统的多进程模型（Prefork）无法实现异步非阻塞，所以会把这点作为 nginx 相比 apache 的一个优势。\n\n## 后话\n\n只是一个概述，很多内容等着补充 😪️\n\n## 参考文档\n\n- [Nginx 中文文档](https://docshome.gitbook.io/nginx-docs/)\n- [Nginx 完全手册](https://www.freecodecamp.org/chinese/news/the-nginx-handbook/)，by freeCodeCamp\n- [Nginx 工作模式和进程模型](https://learnku.com/articles/38414)，by 已下线\n","source":"_posts/overview-of-nginx-process-model.md","raw":"---\ntitle: Nginx 进程模型概述\ndate: 2024/2/20\nauthor: ma5hr00m\ncategories:\n- Nginx\n---\n\nNginx 平时一直有在用，但说实话，对其工作原理一直没有深入了解。那不如从现在开始了解，之后会慢慢更。先说说进程模型。\n\n## 发展\n\nNginx 的开发始于 2002 年，由 Igor Sysoev 发起，最初是为了解决 C10K 问题，即如何让一个服务器同时处理超过一万个客户端连接。\n\n第一个公开版本发布于 2004 年 10 月。自此，Nginx 此开始了它的快速发展。Nginx 目前是世界上使用最多的 Web 服务器之一，根据 Netcraft 的统计，截至 2024 年 2 月，Nginx 占据了全球 Web 服务器市场的 32.8% 的份额，仅次于 Apache。\n\n## 安装与管理\n\n主流 Linux 发行版的包管理工具都支持下载 nginx，这里以 Manjaro 为例：\n\n```Bash\nsudo pacman -S nginx\n```\n\nNginx 可通过`-s`参数响应一些自带的信号，比如：\n\n- `stop`：立即关闭\n- `quit`：正常关闭\n- `reload`：重新加载配置文件\n- `reopen`：重新打开日志文件\n\n例如，当我们在`etc/nginx/conf.d`中修改配置文件添加 Web 服务时，改动内容并不会直接生效，需要我们重启 nginx 服务或者使用`-s reload`指令传递重新加载配置文件的信号。\n\n此外，我们可以通过`systemctl`等指令管理本地的 Nginx 服务，比如最常见的检查 Nginx 状态的指令：\n\n```Bash\nsystemctl status nginx\n```\n\n## Nginx配置文件结构\n\n在正式介绍之前，我想要先从 nginx 配置文件入手，这可能会更加便于理解，毕竟配置文件是我们接触 nginx 最直接的地方。\n\nLinux 下 nginx 配置文件的默认位置是在`/etc/nginx/nginx.conf`，这里先举一个简单的例子：\n\n```Nginx\n# 全局块\nuser  nobody; # 指定运行nginx服务的用户和用户组\nworker_processes  1; # 指定工作线程数\nerror_log  logs/error.log; # 指定错误日志的路径和级别\npid        logs/nginx.pid; # 指定pid文件的路径\n\n# events块\nevents {\n    worker_connections  1024; # 指定每个工作进程可以同时开启的最大连接数\n}\n\n# http块\nhttp {\n    # http全局块\n    include       mime.types; # 引入MIME-Type定义文件\n    default_type  application/octet-stream; # 设置默认的MIME-Type\n    sendfile        on; # 开启sendfile传输文件的优化\n    keepalive_timeout  65; # 设置连接超时时间\n\n    # server块\n    server {\n        # server全局块\n        listen       8000; # 监听8000端口\n        server_name  localhost; # 设置虚拟主机的名称\n\n        # location块\n        location / {\n            root   html; # 设置根目录的路径\n            index  index.html index.htm; # 设置默认的首页文件\n        }\n\n        # location块\n        location /images {\n            root   /data; # 设置图片资源的路径\n            autoindex on; # 开启目录浏览功能\n        }\n\n        # location块\n        location ~ \\.php$ {\n            root           html; # 设置PHP文件的路径\n            fastcgi_pass   127.0.0.1:9000; # 设置PHP-FPM的地址和端口\n            fastcgi_index  index.php; # 设置默认的PHP文件\n            fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name; # 设置PHP脚本的完整路径\n            include        fastcgi_params; # 引入fastcgi的配置文件\n        }\n    }\n}\n```\n\n- 全局块：从开始到`events`块之间的部分，主要设置一些影响 nginx 服务器整体运行的配置指令，例如`user`，`worker_processes`，`error_log`，`pid`等。\n- `events`块：涉及的指令主要影响 nginx 服务器与用户的网络连接，例如`worker_connections`，`accept_mutex`，`multi_accept`，`use`等。\n- `http`块：包含`http`全局块和多个`server`块，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个块中。`http`全局块是不包含在`server`块中的部分，主要设置一些影响`http`协议的配置指令，例如`include`，`default_type`等。`server`块是虚拟主机的配置，每个`server`块可以包含`server`全局块和多个`location`块。`server`全局块是不包含在`location`块中的部分，主要设置一些影响虚拟主机的配置指令，例如`listen`，`server_name`等。`location`块是 URL 匹配的配置，每个`location`块可以包含一些针对特定请求的处理规则，例如`root`，`index`，`proxy_pass`等。\n\n从方便理解的角度，每个`server`块就对应一个应用，而`location`可以理解为应用对应的路由。一般情况下，我们想要在自己的服务器中新增某个 Web 应用配置，就在`http`块中添加`server`块即可。\n\n你可以尝试在 nginx 默认端口为 80 的`server`块中添加下面这个`location`块：\n\n```Nginx\nlocation / {\n    default_type text/plain\n    return 200 \"pong\"\n}\n```\n\n退出保存，使用`nginx -s reload`重新加载配置文件，使用`curl`或在浏览器中请求`http://ocalhost/ping`，即可得到返回的`pong`响应数据。\n\n```Bash\ncurl http://localhost/ping # pong\n```\n\n## 工作模式概述\n\n在正式开始 Nginx 进程模型的介绍之前，还需要了解下 nginx 的基本工作模式是怎样的。\n\nNginx 服务启动后，会创建一个 master 主进程，该主进程在进行一部分初始化工作后，会产生一个或多个工作进程 worker；收到来自客户端的请求后，nginx 可能涉及与后端服务器的通信，它可以将收到的 http 请求代理转发到目标服务器，由专门的后端服务器处理数据。\n\n同时，为了提高对请求的响应效率，降低服务器受到的网络压力，nginx 采用了缓存机制，将历史应答数据缓存到本地，保障了客户端对缓存文件的快速访问。\n\n## 进程模型\n\nNginx 采用了 master-worker 进程模型。相比于 apache 采用的传统多进模型，nginx 的进程模型有一些显著的优势：\n\n- Master-worker 异步非阻塞的特点允许 nginx 在高并发下保持低资源低消耗高性能，同时也提高了服务的稳定性，单个 workder 进程出现异常不影响其他 worker 和 master 的运行；\n- 实现了热部署，即在不重启 nginx 服务的前提下重新加载配置文件；\n- ……\n\n![20240229225629](https://img.ma5hr00m.top/blog/20240229225629.png)\n\n### master 进程\n\nmaster 模块负责接收外部信号，在根据信号的不同管理 worker 模块以实现对应的功能。master 模块本身不会处理网络请求，它只是作为一个调度者，作为用户与 worker 之间的桥梁而存在。\n\n在 nginx 服务初始化时，master 会读取并解析配置文件，出现错误就报告并推出。我们可以使用`-t`参数主动检查配置文件是否存在错误，以确保不会重启 nginx 失败：\n\n```Bash\nsudo nginx -t\n```\n\n在运行过程中，master 进程也会监控 worker 进程运行状态、如果 worker 模块出现异常，master 就会`fork()`一个新的 worker 进程，保证整个 nginx 服务正常运行。\n\n那现在，我们会想知道 master 进程具体是如何管理 worker 进程的呢 🤔️\n\n### master 管理 worker\n\nmaster 进程通过信号量机制（Semaphore Mechanism）和定时器机制（Timer Mechanism）来监控并管理 worker 进程。\n\n信号量机制（semaphore mechanism）是一种用于实现进程间同步和互斥的方法，它使用一个整数变量来表示系统中某种资源的数量或状态，进程可以通过原子操作（atomic operation）来增加或减少信号量的值，从而实现对资源的请求和释放。\n\nnginx 的 master 模块和 worker 模块之间通过信号（signal）来实现同步和通信，信号是一种用于进程间交互的软件中断，它可以用来传递一些简单的信息或命令。nginx 使用了一些预定义的信号，比如`SIGCHLD`、`SIGALRM`、`SIGTERM`、`SIGQUIT`、`SIGHUP`、`SIGUSR1`等，每个信号都有特定的含义和作用。\n\n- 当 worker 模块退出或者崩溃时，它会向 master 模块发送`SIGCHLD`信号，通知 master 模块有子进程已经终止。master 模块在收到`SIGCHLD`信号后，会调用`waitpid()`函数来回收子进程的资源，并检查子进程的退出码，如果是非正常退出，就会重新`fork()`一个新的 worker 模块，保证服务的可用性。\n- 当 master 模块需要重启或者升级时，它会向 worker 模块发送`SIGTERM`或者`SIGQUIT`信号，要求 worker 模块正常关闭或者立即终止。worker 模块在收到这些信号后，会停止接受新的请求，并处理完已经接受的请求，然后退出。master 模块在收到所有 worker 模块的`SIGCHLD`信号后，会重新加载配置文件，并启动新的 worker 模块。\n- 当 master 模块需要重新加载配置文件或者重新打开日志文件时，它会向 worker 模块发送`SIGHUP`或者`SIGUSR1`信号，要求 worker 模块重新读取配置文件或者重新打开日志文件。worker 模块在收到这些信号后，会先关闭旧的配置文件或者日志文件，然后打开新的配置文件或者日志文件，并继续处理请求。\n\n而定时器机制（timer mechanism）是一种用于实现进程间通信和调度的方法，它使用一个计数器来表示系统中某种事件的发生时间或间隔，进程可以通过设置或取消定时器来触发或取消某种动作，从而实现对事件的响应和控制。\n\nnginx 则使用了`SIGALRM`信号来实现定时器的功能。\n\n- 当 master 模块启动时，它会设置一个定时器，每隔一定的时间（默认是 5 秒），就会向 worker 模块发送 `SIGALRM`信号，要求 worker 模块向 master 模块报告自己的状态，比如是否存活、是否忙碌、是否有异常等。master 模块在收到 worker 模块的回应后，会更新 worker 模块的状态，并根据 worker 模块的状态来调整定时器的间隔，如果 worker 模块频繁退出或者出错，就会缩短定时器的间隔，反之则会延长定时器的间隔。\n- 当 master 模块收到`SIGALRM`信号时，它会检查 worker 模块是否存活，如果发现有 worker 模块已经死亡，就会重新`fork()`一个新的 worker 模块，保证服务的可用性。master 模块还会检查 worker 模块是否忙碌，如果发现有 worker 模块长时间没有处理请求，就会认为 worker 模块已经卡死，然后向 worker 模块发送`SIGKILL`信号，强制终止 worker 模块，并重新`fork()`一个新的 worker 模块，保证服务的可用性。\n\n### worker 进程 \n\nworker 接受 master 的调度，负责处理客户端的连接和请求。客户端的请求完全由 worker 处理，而且请求与 worker 是一一对应的关系。同时，worker 进程之间都是平等关系。\n\n这句话可以引出来一个问题：worker 之间是平等的关系，每条请求只由单个 worker处理，但接收请求时会存在多个 worker，那 master 是怎么决定让哪个 worker 去处理当前请求的呢？\n\n### worker 工作流程\n\n在开始之前，有必要先介绍 nginx 的 accepy_mutex 机制，该机制有效的避免了惊群效应（thundering herd problem）和锁队列（lock convoy）问题，而这些问题会导致 nginx 的性能下降和资源浪费。\n\naccept_mutex 是一个互斥锁（mutex），它可以保证在同一时刻，只有一个 worker 可以接受新连接，其他 worker 则会等待或者处理已有的连接。\n\naccept_mutex 机制的开启和关闭可以通过配置文件中的`accept_mutex`指令来控制，它的默认值是`off`。同时，还会有一个`accept_mutex_delay`时间参数，它指定了在另一个 worker 正在接受新连接的情况下，worker 尝试重新开始接受新连接的最长时间，它的默认值是`500ms`。这个参数可以避免工作进程频繁地抢夺 accept_mutex，从而减少系统开销。\n\n好，到这里就差不多。现在介绍 worker 工作流程。\n\n在 nginx 服务器启动时，会先创建一个 master 进程，master 会先建立好需要`listen`的 socket（listenfd）之后，再根据配置文件中`worker_process`指令创建指定数量的 worker 进程，用于处理请求。然后，master 会创建 accept_mutex，并把它传递给 worker。\n\n每个 worker 都会初始化事件模块（event module）和连接模块（connection module），事件模块负责监听和处理事件，连接模块负责管理连接。worker 会根据配置文件中的`use`指令，选择最合适的事件通知机制,再根据配置文件中的`worker_connections`指令，创建一个连接池（connection pool），并分配一定数量的连接（connection）给事件模块，每个连接都有一个读事件（read event）和一个写事件（write event）。\n\n当有新连接到来时，事件模块会通知 worker，然后所有 worker 会来抢唯一的 accept_mutex，抢到 mutex 的 worker 进程就会注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当 worker 接受完新连接后，它会释放 accept_mutex，并处理新连接的请求。\n\n那没抢到 mutex 的 worker 会做什么呢？它们会等待`accept_mutex_delay`的时间，如果在这段时间内没有其他 worker 获得 mutex，它们就会再次尝试获取 mutex，并重复上述过程；如果在这段时间内有其他 worker 获得 mutex，那么等待的 worker 就会放弃，转而继续处理已有的连接或者进入休眠状态。\n\n抢到 mutex 的 worker 会进入事件循环（event loop），不断地检查事件队列中是否有就绪的事件，如果有，就调用相应的事件处理函数。对于读事件，事件处理函数会读取客户端发送的数据，并根据数据的类型，调用相应的模块来处理请求，例如，如果是 HTTP 请求，就调用 HTTP 模块（HTTP module）；如果是邮件请求，就调用邮件模块（mail module）……对于写事件，事件处理函数会发送数据给客户端，并根据数据的状态，决定是否关闭连接或者继续处理请求。\n\n处理完一个连接或者请求时，worker 会把连接放回连接池中，等待下一次使用，或者释放连接，以便其他工作进程使用。\n\n## 补充\n\n### Netcraft\n\nNetcraft 是一家英国的网络安全公司，成立于 1995 年。该公司主要提供互联网基础架构，网络安全，以及网站评测等服务。 其中，Netcraft 的网站评测功能可以帮助用户评估网站的安全性，包括网站托管地址，服务器软件，以及脚本语言等信息。\n\nNetcraft 每月都会对全球的网站进行抽样调查，收集网站的响应头、域名、IP 地址、证书等数据，然后根据这些数据分析出网站使用的服务器软件，操作系统，网络服务商等信息。\n\nNetcraft 的调查报告已经成为人们了解全球网站数量以及各种服务器市场份额等情况的主要依据。访问 [Netcraft](https://www.netcraft.com/) 的官网就可以查看最新的调查结果，或者使用它的搜索功能，查询任意网站的相关信息。\n\n### 异步非阻塞\n\n前文中有提到 master-worker 是一种异步非阻塞的进程模型。我认为可以在这里做一个更详细的描述，就是该进程模型为什么是“异步非阻塞”的：\n\n- **异步**：在 nginx 的 master-worker 模式中，master 进程负责管理 worker 进程，而 worker 进程则处理实际的客户端请求。这种架构下，master 进程和 worker 进程之间采用异步通信方式，master 进程不会阻塞在等待 worker 进程的响应上，从而提高了整体的并发处理能力；\n- **非阻塞**：nginx 中的 worker 进程使用非阻塞 I/O 操作来处理客户端请求。这意味着当一个请求需要进行 I/O 操作时（比如读取文件或从网络接收数据），worker 进程不会一直等待数据准备就绪，而是会继续处理其他请求。一旦数据准备就绪，worker 进程会立即处理它，而不会阻塞在这个操作上；\n- **事件驱动**：nginx 使用事件驱动的方式来处理 I/O 操作。它利用操作系统提供的事件通知机制（如 epoll 或 kqueue）来实现非阻塞 I/O。当一个事件发生时（比如一个连接建立或数据可读），nginx 将相应的事件添加到事件队列中，并通过事件驱动的方式处理这些事件，而不是通过阻塞式的等待。\n\nnginx 的 master-worker 模式通过异步、非阻塞和事件驱动的设计，实现了高性能和高并发处理能力。这种模式使得 nginx 能够高效地处理大量并发请求，而不会因为阻塞在 I/O 操作上而导致性能下降。而 apache 传统的多进程模型（Prefork）无法实现异步非阻塞，所以会把这点作为 nginx 相比 apache 的一个优势。\n\n## 后话\n\n只是一个概述，很多内容等着补充 😪️\n\n## 参考文档\n\n- [Nginx 中文文档](https://docshome.gitbook.io/nginx-docs/)\n- [Nginx 完全手册](https://www.freecodecamp.org/chinese/news/the-nginx-handbook/)，by freeCodeCamp\n- [Nginx 工作模式和进程模型](https://learnku.com/articles/38414)，by 已下线\n","slug":"overview-of-nginx-process-model","published":1,"updated":"2024-06-09T12:55:13.557Z","comments":1,"layout":"post","photos":[],"_id":"clxhruapa0013f4ly8kec40m6","content":"<p>Nginx 平时一直有在用，但说实话，对其工作原理一直没有深入了解。那不如从现在开始了解，之后会慢慢更。先说说进程模型。</p>\n<h2 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h2><p>Nginx 的开发始于 2002 年，由 Igor Sysoev 发起，最初是为了解决 C10K 问题，即如何让一个服务器同时处理超过一万个客户端连接。</p>\n<p>第一个公开版本发布于 2004 年 10 月。自此，Nginx 此开始了它的快速发展。Nginx 目前是世界上使用最多的 Web 服务器之一，根据 Netcraft 的统计，截至 2024 年 2 月，Nginx 占据了全球 Web 服务器市场的 32.8% 的份额，仅次于 Apache。</p>\n<h2 id=\"安装与管理\"><a href=\"#安装与管理\" class=\"headerlink\" title=\"安装与管理\"></a>安装与管理</h2><p>主流 Linux 发行版的包管理工具都支持下载 nginx，这里以 Manjaro 为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S nginx</span><br></pre></td></tr></table></figure>\n\n<p>Nginx 可通过<code>-s</code>参数响应一些自带的信号，比如：</p>\n<ul>\n<li><code>stop</code>：立即关闭</li>\n<li><code>quit</code>：正常关闭</li>\n<li><code>reload</code>：重新加载配置文件</li>\n<li><code>reopen</code>：重新打开日志文件</li>\n</ul>\n<p>例如，当我们在<code>etc/nginx/conf.d</code>中修改配置文件添加 Web 服务时，改动内容并不会直接生效，需要我们重启 nginx 服务或者使用<code>-s reload</code>指令传递重新加载配置文件的信号。</p>\n<p>此外，我们可以通过<code>systemctl</code>等指令管理本地的 Nginx 服务，比如最常见的检查 Nginx 状态的指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status nginx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx配置文件结构\"><a href=\"#Nginx配置文件结构\" class=\"headerlink\" title=\"Nginx配置文件结构\"></a>Nginx配置文件结构</h2><p>在正式介绍之前，我想要先从 nginx 配置文件入手，这可能会更加便于理解，毕竟配置文件是我们接触 nginx 最直接的地方。</p>\n<p>Linux 下 nginx 配置文件的默认位置是在<code>/etc/nginx/nginx.conf</code>，这里先举一个简单的例子：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局块</span></span><br><span class=\"line\"><span class=\"attribute\">user</span>  nobody; <span class=\"comment\"># 指定运行nginx服务的用户和用户组</span></span><br><span class=\"line\"><span class=\"attribute\">worker_processes</span>  <span class=\"number\">1</span>; <span class=\"comment\"># 指定工作线程数</span></span><br><span class=\"line\"><span class=\"attribute\">error_log</span>  logs/<span class=\"literal\">error</span>.log; <span class=\"comment\"># 指定错误日志的路径和级别</span></span><br><span class=\"line\"><span class=\"attribute\">pid</span>        logs/nginx.pid; <span class=\"comment\"># 指定pid文件的路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># events块</span></span><br><span class=\"line\"><span class=\"section\">events</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">worker_connections</span>  <span class=\"number\">1024</span>; <span class=\"comment\"># 指定每个工作进程可以同时开启的最大连接数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># http块</span></span><br><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\"># http全局块</span></span><br><span class=\"line\">    <span class=\"attribute\">include</span>       mime.types; <span class=\"comment\"># 引入MIME-Type定义文件</span></span><br><span class=\"line\">    <span class=\"attribute\">default_type</span>  application/octet-stream; <span class=\"comment\"># 设置默认的MIME-Type</span></span><br><span class=\"line\">    <span class=\"attribute\">sendfile</span>        <span class=\"literal\">on</span>; <span class=\"comment\"># 开启sendfile传输文件的优化</span></span><br><span class=\"line\">    <span class=\"attribute\">keepalive_timeout</span>  <span class=\"number\">65</span>; <span class=\"comment\"># 设置连接超时时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># server块</span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\"># server全局块</span></span><br><span class=\"line\">        <span class=\"attribute\">listen</span>       <span class=\"number\">8000</span>; <span class=\"comment\"># 监听8000端口</span></span><br><span class=\"line\">        <span class=\"attribute\">server_name</span>  localhost; <span class=\"comment\"># 设置虚拟主机的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># location块</span></span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>   html; <span class=\"comment\"># 设置根目录的路径</span></span><br><span class=\"line\">            <span class=\"attribute\">index</span>  index.html index.htm; <span class=\"comment\"># 设置默认的首页文件</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># location块</span></span><br><span class=\"line\">        <span class=\"section\">location</span> /images &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>   /data; <span class=\"comment\"># 设置图片资源的路径</span></span><br><span class=\"line\">            <span class=\"attribute\">autoindex</span> <span class=\"literal\">on</span>; <span class=\"comment\"># 开启目录浏览功能</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># location块</span></span><br><span class=\"line\">        <span class=\"section\">location</span> <span class=\"regexp\">~ \\.php$</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>           html; <span class=\"comment\"># 设置PHP文件的路径</span></span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_pass</span>   <span class=\"number\">127.0.0.1:9000</span>; <span class=\"comment\"># 设置PHP-FPM的地址和端口</span></span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_index</span>  index.php; <span class=\"comment\"># 设置默认的PHP文件</span></span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_param</span>  SCRIPT_FILENAME  /scripts<span class=\"variable\">$fastcgi_script_name</span>; <span class=\"comment\"># 设置PHP脚本的完整路径</span></span><br><span class=\"line\">            <span class=\"attribute\">include</span>        fastcgi_params; <span class=\"comment\"># 引入fastcgi的配置文件</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局块：从开始到<code>events</code>块之间的部分，主要设置一些影响 nginx 服务器整体运行的配置指令，例如<code>user</code>，<code>worker_processes</code>，<code>error_log</code>，<code>pid</code>等。</li>\n<li><code>events</code>块：涉及的指令主要影响 nginx 服务器与用户的网络连接，例如<code>worker_connections</code>，<code>accept_mutex</code>，<code>multi_accept</code>，<code>use</code>等。</li>\n<li><code>http</code>块：包含<code>http</code>全局块和多个<code>server</code>块，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个块中。<code>http</code>全局块是不包含在<code>server</code>块中的部分，主要设置一些影响<code>http</code>协议的配置指令，例如<code>include</code>，<code>default_type</code>等。<code>server</code>块是虚拟主机的配置，每个<code>server</code>块可以包含<code>server</code>全局块和多个<code>location</code>块。<code>server</code>全局块是不包含在<code>location</code>块中的部分，主要设置一些影响虚拟主机的配置指令，例如<code>listen</code>，<code>server_name</code>等。<code>location</code>块是 URL 匹配的配置，每个<code>location</code>块可以包含一些针对特定请求的处理规则，例如<code>root</code>，<code>index</code>，<code>proxy_pass</code>等。</li>\n</ul>\n<p>从方便理解的角度，每个<code>server</code>块就对应一个应用，而<code>location</code>可以理解为应用对应的路由。一般情况下，我们想要在自己的服务器中新增某个 Web 应用配置，就在<code>http</code>块中添加<code>server</code>块即可。</p>\n<p>你可以尝试在 nginx 默认端口为 80 的<code>server</code>块中添加下面这个<code>location</code>块：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">default_type</span> text/plain</span><br><span class=\"line\">    return <span class=\"number\">200</span> <span class=\"string\">&quot;pong&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>退出保存，使用<code>nginx -s reload</code>重新加载配置文件，使用<code>curl</code>或在浏览器中请求<code>http://ocalhost/ping</code>，即可得到返回的<code>pong</code>响应数据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost/ping <span class=\"comment\"># pong</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工作模式概述\"><a href=\"#工作模式概述\" class=\"headerlink\" title=\"工作模式概述\"></a>工作模式概述</h2><p>在正式开始 Nginx 进程模型的介绍之前，还需要了解下 nginx 的基本工作模式是怎样的。</p>\n<p>Nginx 服务启动后，会创建一个 master 主进程，该主进程在进行一部分初始化工作后，会产生一个或多个工作进程 worker；收到来自客户端的请求后，nginx 可能涉及与后端服务器的通信，它可以将收到的 http 请求代理转发到目标服务器，由专门的后端服务器处理数据。</p>\n<p>同时，为了提高对请求的响应效率，降低服务器受到的网络压力，nginx 采用了缓存机制，将历史应答数据缓存到本地，保障了客户端对缓存文件的快速访问。</p>\n<h2 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h2><p>Nginx 采用了 master-worker 进程模型。相比于 apache 采用的传统多进模型，nginx 的进程模型有一些显著的优势：</p>\n<ul>\n<li>Master-worker 异步非阻塞的特点允许 nginx 在高并发下保持低资源低消耗高性能，同时也提高了服务的稳定性，单个 workder 进程出现异常不影响其他 worker 和 master 的运行；</li>\n<li>实现了热部署，即在不重启 nginx 服务的前提下重新加载配置文件；</li>\n<li>……</li>\n</ul>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240229225629.png\" alt=\"20240229225629\"></p>\n<h3 id=\"master-进程\"><a href=\"#master-进程\" class=\"headerlink\" title=\"master 进程\"></a>master 进程</h3><p>master 模块负责接收外部信号，在根据信号的不同管理 worker 模块以实现对应的功能。master 模块本身不会处理网络请求，它只是作为一个调度者，作为用户与 worker 之间的桥梁而存在。</p>\n<p>在 nginx 服务初始化时，master 会读取并解析配置文件，出现错误就报告并推出。我们可以使用<code>-t</code>参数主动检查配置文件是否存在错误，以确保不会重启 nginx 失败：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -t</span><br></pre></td></tr></table></figure>\n\n<p>在运行过程中，master 进程也会监控 worker 进程运行状态、如果 worker 模块出现异常，master 就会<code>fork()</code>一个新的 worker 进程，保证整个 nginx 服务正常运行。</p>\n<p>那现在，我们会想知道 master 进程具体是如何管理 worker 进程的呢 🤔️</p>\n<h3 id=\"master-管理-worker\"><a href=\"#master-管理-worker\" class=\"headerlink\" title=\"master 管理 worker\"></a>master 管理 worker</h3><p>master 进程通过信号量机制（Semaphore Mechanism）和定时器机制（Timer Mechanism）来监控并管理 worker 进程。</p>\n<p>信号量机制（semaphore mechanism）是一种用于实现进程间同步和互斥的方法，它使用一个整数变量来表示系统中某种资源的数量或状态，进程可以通过原子操作（atomic operation）来增加或减少信号量的值，从而实现对资源的请求和释放。</p>\n<p>nginx 的 master 模块和 worker 模块之间通过信号（signal）来实现同步和通信，信号是一种用于进程间交互的软件中断，它可以用来传递一些简单的信息或命令。nginx 使用了一些预定义的信号，比如<code>SIGCHLD</code>、<code>SIGALRM</code>、<code>SIGTERM</code>、<code>SIGQUIT</code>、<code>SIGHUP</code>、<code>SIGUSR1</code>等，每个信号都有特定的含义和作用。</p>\n<ul>\n<li>当 worker 模块退出或者崩溃时，它会向 master 模块发送<code>SIGCHLD</code>信号，通知 master 模块有子进程已经终止。master 模块在收到<code>SIGCHLD</code>信号后，会调用<code>waitpid()</code>函数来回收子进程的资源，并检查子进程的退出码，如果是非正常退出，就会重新<code>fork()</code>一个新的 worker 模块，保证服务的可用性。</li>\n<li>当 master 模块需要重启或者升级时，它会向 worker 模块发送<code>SIGTERM</code>或者<code>SIGQUIT</code>信号，要求 worker 模块正常关闭或者立即终止。worker 模块在收到这些信号后，会停止接受新的请求，并处理完已经接受的请求，然后退出。master 模块在收到所有 worker 模块的<code>SIGCHLD</code>信号后，会重新加载配置文件，并启动新的 worker 模块。</li>\n<li>当 master 模块需要重新加载配置文件或者重新打开日志文件时，它会向 worker 模块发送<code>SIGHUP</code>或者<code>SIGUSR1</code>信号，要求 worker 模块重新读取配置文件或者重新打开日志文件。worker 模块在收到这些信号后，会先关闭旧的配置文件或者日志文件，然后打开新的配置文件或者日志文件，并继续处理请求。</li>\n</ul>\n<p>而定时器机制（timer mechanism）是一种用于实现进程间通信和调度的方法，它使用一个计数器来表示系统中某种事件的发生时间或间隔，进程可以通过设置或取消定时器来触发或取消某种动作，从而实现对事件的响应和控制。</p>\n<p>nginx 则使用了<code>SIGALRM</code>信号来实现定时器的功能。</p>\n<ul>\n<li>当 master 模块启动时，它会设置一个定时器，每隔一定的时间（默认是 5 秒），就会向 worker 模块发送 <code>SIGALRM</code>信号，要求 worker 模块向 master 模块报告自己的状态，比如是否存活、是否忙碌、是否有异常等。master 模块在收到 worker 模块的回应后，会更新 worker 模块的状态，并根据 worker 模块的状态来调整定时器的间隔，如果 worker 模块频繁退出或者出错，就会缩短定时器的间隔，反之则会延长定时器的间隔。</li>\n<li>当 master 模块收到<code>SIGALRM</code>信号时，它会检查 worker 模块是否存活，如果发现有 worker 模块已经死亡，就会重新<code>fork()</code>一个新的 worker 模块，保证服务的可用性。master 模块还会检查 worker 模块是否忙碌，如果发现有 worker 模块长时间没有处理请求，就会认为 worker 模块已经卡死，然后向 worker 模块发送<code>SIGKILL</code>信号，强制终止 worker 模块，并重新<code>fork()</code>一个新的 worker 模块，保证服务的可用性。</li>\n</ul>\n<h3 id=\"worker-进程\"><a href=\"#worker-进程\" class=\"headerlink\" title=\"worker 进程\"></a>worker 进程</h3><p>worker 接受 master 的调度，负责处理客户端的连接和请求。客户端的请求完全由 worker 处理，而且请求与 worker 是一一对应的关系。同时，worker 进程之间都是平等关系。</p>\n<p>这句话可以引出来一个问题：worker 之间是平等的关系，每条请求只由单个 worker处理，但接收请求时会存在多个 worker，那 master 是怎么决定让哪个 worker 去处理当前请求的呢？</p>\n<h3 id=\"worker-工作流程\"><a href=\"#worker-工作流程\" class=\"headerlink\" title=\"worker 工作流程\"></a>worker 工作流程</h3><p>在开始之前，有必要先介绍 nginx 的 accepy_mutex 机制，该机制有效的避免了惊群效应（thundering herd problem）和锁队列（lock convoy）问题，而这些问题会导致 nginx 的性能下降和资源浪费。</p>\n<p>accept_mutex 是一个互斥锁（mutex），它可以保证在同一时刻，只有一个 worker 可以接受新连接，其他 worker 则会等待或者处理已有的连接。</p>\n<p>accept_mutex 机制的开启和关闭可以通过配置文件中的<code>accept_mutex</code>指令来控制，它的默认值是<code>off</code>。同时，还会有一个<code>accept_mutex_delay</code>时间参数，它指定了在另一个 worker 正在接受新连接的情况下，worker 尝试重新开始接受新连接的最长时间，它的默认值是<code>500ms</code>。这个参数可以避免工作进程频繁地抢夺 accept_mutex，从而减少系统开销。</p>\n<p>好，到这里就差不多。现在介绍 worker 工作流程。</p>\n<p>在 nginx 服务器启动时，会先创建一个 master 进程，master 会先建立好需要<code>listen</code>的 socket（listenfd）之后，再根据配置文件中<code>worker_process</code>指令创建指定数量的 worker 进程，用于处理请求。然后，master 会创建 accept_mutex，并把它传递给 worker。</p>\n<p>每个 worker 都会初始化事件模块（event module）和连接模块（connection module），事件模块负责监听和处理事件，连接模块负责管理连接。worker 会根据配置文件中的<code>use</code>指令，选择最合适的事件通知机制,再根据配置文件中的<code>worker_connections</code>指令，创建一个连接池（connection pool），并分配一定数量的连接（connection）给事件模块，每个连接都有一个读事件（read event）和一个写事件（write event）。</p>\n<p>当有新连接到来时，事件模块会通知 worker，然后所有 worker 会来抢唯一的 accept_mutex，抢到 mutex 的 worker 进程就会注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当 worker 接受完新连接后，它会释放 accept_mutex，并处理新连接的请求。</p>\n<p>那没抢到 mutex 的 worker 会做什么呢？它们会等待<code>accept_mutex_delay</code>的时间，如果在这段时间内没有其他 worker 获得 mutex，它们就会再次尝试获取 mutex，并重复上述过程；如果在这段时间内有其他 worker 获得 mutex，那么等待的 worker 就会放弃，转而继续处理已有的连接或者进入休眠状态。</p>\n<p>抢到 mutex 的 worker 会进入事件循环（event loop），不断地检查事件队列中是否有就绪的事件，如果有，就调用相应的事件处理函数。对于读事件，事件处理函数会读取客户端发送的数据，并根据数据的类型，调用相应的模块来处理请求，例如，如果是 HTTP 请求，就调用 HTTP 模块（HTTP module）；如果是邮件请求，就调用邮件模块（mail module）……对于写事件，事件处理函数会发送数据给客户端，并根据数据的状态，决定是否关闭连接或者继续处理请求。</p>\n<p>处理完一个连接或者请求时，worker 会把连接放回连接池中，等待下一次使用，或者释放连接，以便其他工作进程使用。</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"Netcraft\"><a href=\"#Netcraft\" class=\"headerlink\" title=\"Netcraft\"></a>Netcraft</h3><p>Netcraft 是一家英国的网络安全公司，成立于 1995 年。该公司主要提供互联网基础架构，网络安全，以及网站评测等服务。 其中，Netcraft 的网站评测功能可以帮助用户评估网站的安全性，包括网站托管地址，服务器软件，以及脚本语言等信息。</p>\n<p>Netcraft 每月都会对全球的网站进行抽样调查，收集网站的响应头、域名、IP 地址、证书等数据，然后根据这些数据分析出网站使用的服务器软件，操作系统，网络服务商等信息。</p>\n<p>Netcraft 的调查报告已经成为人们了解全球网站数量以及各种服务器市场份额等情况的主要依据。访问 <a href=\"https://www.netcraft.com/\">Netcraft</a> 的官网就可以查看最新的调查结果，或者使用它的搜索功能，查询任意网站的相关信息。</p>\n<h3 id=\"异步非阻塞\"><a href=\"#异步非阻塞\" class=\"headerlink\" title=\"异步非阻塞\"></a>异步非阻塞</h3><p>前文中有提到 master-worker 是一种异步非阻塞的进程模型。我认为可以在这里做一个更详细的描述，就是该进程模型为什么是“异步非阻塞”的：</p>\n<ul>\n<li><strong>异步</strong>：在 nginx 的 master-worker 模式中，master 进程负责管理 worker 进程，而 worker 进程则处理实际的客户端请求。这种架构下，master 进程和 worker 进程之间采用异步通信方式，master 进程不会阻塞在等待 worker 进程的响应上，从而提高了整体的并发处理能力；</li>\n<li><strong>非阻塞</strong>：nginx 中的 worker 进程使用非阻塞 I&#x2F;O 操作来处理客户端请求。这意味着当一个请求需要进行 I&#x2F;O 操作时（比如读取文件或从网络接收数据），worker 进程不会一直等待数据准备就绪，而是会继续处理其他请求。一旦数据准备就绪，worker 进程会立即处理它，而不会阻塞在这个操作上；</li>\n<li><strong>事件驱动</strong>：nginx 使用事件驱动的方式来处理 I&#x2F;O 操作。它利用操作系统提供的事件通知机制（如 epoll 或 kqueue）来实现非阻塞 I&#x2F;O。当一个事件发生时（比如一个连接建立或数据可读），nginx 将相应的事件添加到事件队列中，并通过事件驱动的方式处理这些事件，而不是通过阻塞式的等待。</li>\n</ul>\n<p>nginx 的 master-worker 模式通过异步、非阻塞和事件驱动的设计，实现了高性能和高并发处理能力。这种模式使得 nginx 能够高效地处理大量并发请求，而不会因为阻塞在 I&#x2F;O 操作上而导致性能下降。而 apache 传统的多进程模型（Prefork）无法实现异步非阻塞，所以会把这点作为 nginx 相比 apache 的一个优势。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>只是一个概述，很多内容等着补充 😪️</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://docshome.gitbook.io/nginx-docs/\">Nginx 中文文档</a></li>\n<li><a href=\"https://www.freecodecamp.org/chinese/news/the-nginx-handbook/\">Nginx 完全手册</a>，by freeCodeCamp</li>\n<li><a href=\"https://learnku.com/articles/38414\">Nginx 工作模式和进程模型</a>，by 已下线</li>\n</ul>\n","excerpt":"","more":"<p>Nginx 平时一直有在用，但说实话，对其工作原理一直没有深入了解。那不如从现在开始了解，之后会慢慢更。先说说进程模型。</p>\n<h2 id=\"发展\"><a href=\"#发展\" class=\"headerlink\" title=\"发展\"></a>发展</h2><p>Nginx 的开发始于 2002 年，由 Igor Sysoev 发起，最初是为了解决 C10K 问题，即如何让一个服务器同时处理超过一万个客户端连接。</p>\n<p>第一个公开版本发布于 2004 年 10 月。自此，Nginx 此开始了它的快速发展。Nginx 目前是世界上使用最多的 Web 服务器之一，根据 Netcraft 的统计，截至 2024 年 2 月，Nginx 占据了全球 Web 服务器市场的 32.8% 的份额，仅次于 Apache。</p>\n<h2 id=\"安装与管理\"><a href=\"#安装与管理\" class=\"headerlink\" title=\"安装与管理\"></a>安装与管理</h2><p>主流 Linux 发行版的包管理工具都支持下载 nginx，这里以 Manjaro 为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo pacman -S nginx</span><br></pre></td></tr></table></figure>\n\n<p>Nginx 可通过<code>-s</code>参数响应一些自带的信号，比如：</p>\n<ul>\n<li><code>stop</code>：立即关闭</li>\n<li><code>quit</code>：正常关闭</li>\n<li><code>reload</code>：重新加载配置文件</li>\n<li><code>reopen</code>：重新打开日志文件</li>\n</ul>\n<p>例如，当我们在<code>etc/nginx/conf.d</code>中修改配置文件添加 Web 服务时，改动内容并不会直接生效，需要我们重启 nginx 服务或者使用<code>-s reload</code>指令传递重新加载配置文件的信号。</p>\n<p>此外，我们可以通过<code>systemctl</code>等指令管理本地的 Nginx 服务，比如最常见的检查 Nginx 状态的指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status nginx</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx配置文件结构\"><a href=\"#Nginx配置文件结构\" class=\"headerlink\" title=\"Nginx配置文件结构\"></a>Nginx配置文件结构</h2><p>在正式介绍之前，我想要先从 nginx 配置文件入手，这可能会更加便于理解，毕竟配置文件是我们接触 nginx 最直接的地方。</p>\n<p>Linux 下 nginx 配置文件的默认位置是在<code>/etc/nginx/nginx.conf</code>，这里先举一个简单的例子：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局块</span></span><br><span class=\"line\"><span class=\"attribute\">user</span>  nobody; <span class=\"comment\"># 指定运行nginx服务的用户和用户组</span></span><br><span class=\"line\"><span class=\"attribute\">worker_processes</span>  <span class=\"number\">1</span>; <span class=\"comment\"># 指定工作线程数</span></span><br><span class=\"line\"><span class=\"attribute\">error_log</span>  logs/<span class=\"literal\">error</span>.log; <span class=\"comment\"># 指定错误日志的路径和级别</span></span><br><span class=\"line\"><span class=\"attribute\">pid</span>        logs/nginx.pid; <span class=\"comment\"># 指定pid文件的路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># events块</span></span><br><span class=\"line\"><span class=\"section\">events</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">worker_connections</span>  <span class=\"number\">1024</span>; <span class=\"comment\"># 指定每个工作进程可以同时开启的最大连接数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># http块</span></span><br><span class=\"line\"><span class=\"section\">http</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\"># http全局块</span></span><br><span class=\"line\">    <span class=\"attribute\">include</span>       mime.types; <span class=\"comment\"># 引入MIME-Type定义文件</span></span><br><span class=\"line\">    <span class=\"attribute\">default_type</span>  application/octet-stream; <span class=\"comment\"># 设置默认的MIME-Type</span></span><br><span class=\"line\">    <span class=\"attribute\">sendfile</span>        <span class=\"literal\">on</span>; <span class=\"comment\"># 开启sendfile传输文件的优化</span></span><br><span class=\"line\">    <span class=\"attribute\">keepalive_timeout</span>  <span class=\"number\">65</span>; <span class=\"comment\"># 设置连接超时时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># server块</span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\"># server全局块</span></span><br><span class=\"line\">        <span class=\"attribute\">listen</span>       <span class=\"number\">8000</span>; <span class=\"comment\"># 监听8000端口</span></span><br><span class=\"line\">        <span class=\"attribute\">server_name</span>  localhost; <span class=\"comment\"># 设置虚拟主机的名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># location块</span></span><br><span class=\"line\">        <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>   html; <span class=\"comment\"># 设置根目录的路径</span></span><br><span class=\"line\">            <span class=\"attribute\">index</span>  index.html index.htm; <span class=\"comment\"># 设置默认的首页文件</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># location块</span></span><br><span class=\"line\">        <span class=\"section\">location</span> /images &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>   /data; <span class=\"comment\"># 设置图片资源的路径</span></span><br><span class=\"line\">            <span class=\"attribute\">autoindex</span> <span class=\"literal\">on</span>; <span class=\"comment\"># 开启目录浏览功能</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># location块</span></span><br><span class=\"line\">        <span class=\"section\">location</span> <span class=\"regexp\">~ \\.php$</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">root</span>           html; <span class=\"comment\"># 设置PHP文件的路径</span></span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_pass</span>   <span class=\"number\">127.0.0.1:9000</span>; <span class=\"comment\"># 设置PHP-FPM的地址和端口</span></span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_index</span>  index.php; <span class=\"comment\"># 设置默认的PHP文件</span></span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_param</span>  SCRIPT_FILENAME  /scripts<span class=\"variable\">$fastcgi_script_name</span>; <span class=\"comment\"># 设置PHP脚本的完整路径</span></span><br><span class=\"line\">            <span class=\"attribute\">include</span>        fastcgi_params; <span class=\"comment\"># 引入fastcgi的配置文件</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局块：从开始到<code>events</code>块之间的部分，主要设置一些影响 nginx 服务器整体运行的配置指令，例如<code>user</code>，<code>worker_processes</code>，<code>error_log</code>，<code>pid</code>等。</li>\n<li><code>events</code>块：涉及的指令主要影响 nginx 服务器与用户的网络连接，例如<code>worker_connections</code>，<code>accept_mutex</code>，<code>multi_accept</code>，<code>use</code>等。</li>\n<li><code>http</code>块：包含<code>http</code>全局块和多个<code>server</code>块，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个块中。<code>http</code>全局块是不包含在<code>server</code>块中的部分，主要设置一些影响<code>http</code>协议的配置指令，例如<code>include</code>，<code>default_type</code>等。<code>server</code>块是虚拟主机的配置，每个<code>server</code>块可以包含<code>server</code>全局块和多个<code>location</code>块。<code>server</code>全局块是不包含在<code>location</code>块中的部分，主要设置一些影响虚拟主机的配置指令，例如<code>listen</code>，<code>server_name</code>等。<code>location</code>块是 URL 匹配的配置，每个<code>location</code>块可以包含一些针对特定请求的处理规则，例如<code>root</code>，<code>index</code>，<code>proxy_pass</code>等。</li>\n</ul>\n<p>从方便理解的角度，每个<code>server</code>块就对应一个应用，而<code>location</code>可以理解为应用对应的路由。一般情况下，我们想要在自己的服务器中新增某个 Web 应用配置，就在<code>http</code>块中添加<code>server</code>块即可。</p>\n<p>你可以尝试在 nginx 默认端口为 80 的<code>server</code>块中添加下面这个<code>location</code>块：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">default_type</span> text/plain</span><br><span class=\"line\">    return <span class=\"number\">200</span> <span class=\"string\">&quot;pong&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>退出保存，使用<code>nginx -s reload</code>重新加载配置文件，使用<code>curl</code>或在浏览器中请求<code>http://ocalhost/ping</code>，即可得到返回的<code>pong</code>响应数据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://localhost/ping <span class=\"comment\"># pong</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工作模式概述\"><a href=\"#工作模式概述\" class=\"headerlink\" title=\"工作模式概述\"></a>工作模式概述</h2><p>在正式开始 Nginx 进程模型的介绍之前，还需要了解下 nginx 的基本工作模式是怎样的。</p>\n<p>Nginx 服务启动后，会创建一个 master 主进程，该主进程在进行一部分初始化工作后，会产生一个或多个工作进程 worker；收到来自客户端的请求后，nginx 可能涉及与后端服务器的通信，它可以将收到的 http 请求代理转发到目标服务器，由专门的后端服务器处理数据。</p>\n<p>同时，为了提高对请求的响应效率，降低服务器受到的网络压力，nginx 采用了缓存机制，将历史应答数据缓存到本地，保障了客户端对缓存文件的快速访问。</p>\n<h2 id=\"进程模型\"><a href=\"#进程模型\" class=\"headerlink\" title=\"进程模型\"></a>进程模型</h2><p>Nginx 采用了 master-worker 进程模型。相比于 apache 采用的传统多进模型，nginx 的进程模型有一些显著的优势：</p>\n<ul>\n<li>Master-worker 异步非阻塞的特点允许 nginx 在高并发下保持低资源低消耗高性能，同时也提高了服务的稳定性，单个 workder 进程出现异常不影响其他 worker 和 master 的运行；</li>\n<li>实现了热部署，即在不重启 nginx 服务的前提下重新加载配置文件；</li>\n<li>……</li>\n</ul>\n<p><img src=\"https://img.ma5hr00m.top/blog/20240229225629.png\" alt=\"20240229225629\"></p>\n<h3 id=\"master-进程\"><a href=\"#master-进程\" class=\"headerlink\" title=\"master 进程\"></a>master 进程</h3><p>master 模块负责接收外部信号，在根据信号的不同管理 worker 模块以实现对应的功能。master 模块本身不会处理网络请求，它只是作为一个调度者，作为用户与 worker 之间的桥梁而存在。</p>\n<p>在 nginx 服务初始化时，master 会读取并解析配置文件，出现错误就报告并推出。我们可以使用<code>-t</code>参数主动检查配置文件是否存在错误，以确保不会重启 nginx 失败：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nginx -t</span><br></pre></td></tr></table></figure>\n\n<p>在运行过程中，master 进程也会监控 worker 进程运行状态、如果 worker 模块出现异常，master 就会<code>fork()</code>一个新的 worker 进程，保证整个 nginx 服务正常运行。</p>\n<p>那现在，我们会想知道 master 进程具体是如何管理 worker 进程的呢 🤔️</p>\n<h3 id=\"master-管理-worker\"><a href=\"#master-管理-worker\" class=\"headerlink\" title=\"master 管理 worker\"></a>master 管理 worker</h3><p>master 进程通过信号量机制（Semaphore Mechanism）和定时器机制（Timer Mechanism）来监控并管理 worker 进程。</p>\n<p>信号量机制（semaphore mechanism）是一种用于实现进程间同步和互斥的方法，它使用一个整数变量来表示系统中某种资源的数量或状态，进程可以通过原子操作（atomic operation）来增加或减少信号量的值，从而实现对资源的请求和释放。</p>\n<p>nginx 的 master 模块和 worker 模块之间通过信号（signal）来实现同步和通信，信号是一种用于进程间交互的软件中断，它可以用来传递一些简单的信息或命令。nginx 使用了一些预定义的信号，比如<code>SIGCHLD</code>、<code>SIGALRM</code>、<code>SIGTERM</code>、<code>SIGQUIT</code>、<code>SIGHUP</code>、<code>SIGUSR1</code>等，每个信号都有特定的含义和作用。</p>\n<ul>\n<li>当 worker 模块退出或者崩溃时，它会向 master 模块发送<code>SIGCHLD</code>信号，通知 master 模块有子进程已经终止。master 模块在收到<code>SIGCHLD</code>信号后，会调用<code>waitpid()</code>函数来回收子进程的资源，并检查子进程的退出码，如果是非正常退出，就会重新<code>fork()</code>一个新的 worker 模块，保证服务的可用性。</li>\n<li>当 master 模块需要重启或者升级时，它会向 worker 模块发送<code>SIGTERM</code>或者<code>SIGQUIT</code>信号，要求 worker 模块正常关闭或者立即终止。worker 模块在收到这些信号后，会停止接受新的请求，并处理完已经接受的请求，然后退出。master 模块在收到所有 worker 模块的<code>SIGCHLD</code>信号后，会重新加载配置文件，并启动新的 worker 模块。</li>\n<li>当 master 模块需要重新加载配置文件或者重新打开日志文件时，它会向 worker 模块发送<code>SIGHUP</code>或者<code>SIGUSR1</code>信号，要求 worker 模块重新读取配置文件或者重新打开日志文件。worker 模块在收到这些信号后，会先关闭旧的配置文件或者日志文件，然后打开新的配置文件或者日志文件，并继续处理请求。</li>\n</ul>\n<p>而定时器机制（timer mechanism）是一种用于实现进程间通信和调度的方法，它使用一个计数器来表示系统中某种事件的发生时间或间隔，进程可以通过设置或取消定时器来触发或取消某种动作，从而实现对事件的响应和控制。</p>\n<p>nginx 则使用了<code>SIGALRM</code>信号来实现定时器的功能。</p>\n<ul>\n<li>当 master 模块启动时，它会设置一个定时器，每隔一定的时间（默认是 5 秒），就会向 worker 模块发送 <code>SIGALRM</code>信号，要求 worker 模块向 master 模块报告自己的状态，比如是否存活、是否忙碌、是否有异常等。master 模块在收到 worker 模块的回应后，会更新 worker 模块的状态，并根据 worker 模块的状态来调整定时器的间隔，如果 worker 模块频繁退出或者出错，就会缩短定时器的间隔，反之则会延长定时器的间隔。</li>\n<li>当 master 模块收到<code>SIGALRM</code>信号时，它会检查 worker 模块是否存活，如果发现有 worker 模块已经死亡，就会重新<code>fork()</code>一个新的 worker 模块，保证服务的可用性。master 模块还会检查 worker 模块是否忙碌，如果发现有 worker 模块长时间没有处理请求，就会认为 worker 模块已经卡死，然后向 worker 模块发送<code>SIGKILL</code>信号，强制终止 worker 模块，并重新<code>fork()</code>一个新的 worker 模块，保证服务的可用性。</li>\n</ul>\n<h3 id=\"worker-进程\"><a href=\"#worker-进程\" class=\"headerlink\" title=\"worker 进程\"></a>worker 进程</h3><p>worker 接受 master 的调度，负责处理客户端的连接和请求。客户端的请求完全由 worker 处理，而且请求与 worker 是一一对应的关系。同时，worker 进程之间都是平等关系。</p>\n<p>这句话可以引出来一个问题：worker 之间是平等的关系，每条请求只由单个 worker处理，但接收请求时会存在多个 worker，那 master 是怎么决定让哪个 worker 去处理当前请求的呢？</p>\n<h3 id=\"worker-工作流程\"><a href=\"#worker-工作流程\" class=\"headerlink\" title=\"worker 工作流程\"></a>worker 工作流程</h3><p>在开始之前，有必要先介绍 nginx 的 accepy_mutex 机制，该机制有效的避免了惊群效应（thundering herd problem）和锁队列（lock convoy）问题，而这些问题会导致 nginx 的性能下降和资源浪费。</p>\n<p>accept_mutex 是一个互斥锁（mutex），它可以保证在同一时刻，只有一个 worker 可以接受新连接，其他 worker 则会等待或者处理已有的连接。</p>\n<p>accept_mutex 机制的开启和关闭可以通过配置文件中的<code>accept_mutex</code>指令来控制，它的默认值是<code>off</code>。同时，还会有一个<code>accept_mutex_delay</code>时间参数，它指定了在另一个 worker 正在接受新连接的情况下，worker 尝试重新开始接受新连接的最长时间，它的默认值是<code>500ms</code>。这个参数可以避免工作进程频繁地抢夺 accept_mutex，从而减少系统开销。</p>\n<p>好，到这里就差不多。现在介绍 worker 工作流程。</p>\n<p>在 nginx 服务器启动时，会先创建一个 master 进程，master 会先建立好需要<code>listen</code>的 socket（listenfd）之后，再根据配置文件中<code>worker_process</code>指令创建指定数量的 worker 进程，用于处理请求。然后，master 会创建 accept_mutex，并把它传递给 worker。</p>\n<p>每个 worker 都会初始化事件模块（event module）和连接模块（connection module），事件模块负责监听和处理事件，连接模块负责管理连接。worker 会根据配置文件中的<code>use</code>指令，选择最合适的事件通知机制,再根据配置文件中的<code>worker_connections</code>指令，创建一个连接池（connection pool），并分配一定数量的连接（connection）给事件模块，每个连接都有一个读事件（read event）和一个写事件（write event）。</p>\n<p>当有新连接到来时，事件模块会通知 worker，然后所有 worker 会来抢唯一的 accept_mutex，抢到 mutex 的 worker 进程就会注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当 worker 接受完新连接后，它会释放 accept_mutex，并处理新连接的请求。</p>\n<p>那没抢到 mutex 的 worker 会做什么呢？它们会等待<code>accept_mutex_delay</code>的时间，如果在这段时间内没有其他 worker 获得 mutex，它们就会再次尝试获取 mutex，并重复上述过程；如果在这段时间内有其他 worker 获得 mutex，那么等待的 worker 就会放弃，转而继续处理已有的连接或者进入休眠状态。</p>\n<p>抢到 mutex 的 worker 会进入事件循环（event loop），不断地检查事件队列中是否有就绪的事件，如果有，就调用相应的事件处理函数。对于读事件，事件处理函数会读取客户端发送的数据，并根据数据的类型，调用相应的模块来处理请求，例如，如果是 HTTP 请求，就调用 HTTP 模块（HTTP module）；如果是邮件请求，就调用邮件模块（mail module）……对于写事件，事件处理函数会发送数据给客户端，并根据数据的状态，决定是否关闭连接或者继续处理请求。</p>\n<p>处理完一个连接或者请求时，worker 会把连接放回连接池中，等待下一次使用，或者释放连接，以便其他工作进程使用。</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"Netcraft\"><a href=\"#Netcraft\" class=\"headerlink\" title=\"Netcraft\"></a>Netcraft</h3><p>Netcraft 是一家英国的网络安全公司，成立于 1995 年。该公司主要提供互联网基础架构，网络安全，以及网站评测等服务。 其中，Netcraft 的网站评测功能可以帮助用户评估网站的安全性，包括网站托管地址，服务器软件，以及脚本语言等信息。</p>\n<p>Netcraft 每月都会对全球的网站进行抽样调查，收集网站的响应头、域名、IP 地址、证书等数据，然后根据这些数据分析出网站使用的服务器软件，操作系统，网络服务商等信息。</p>\n<p>Netcraft 的调查报告已经成为人们了解全球网站数量以及各种服务器市场份额等情况的主要依据。访问 <a href=\"https://www.netcraft.com/\">Netcraft</a> 的官网就可以查看最新的调查结果，或者使用它的搜索功能，查询任意网站的相关信息。</p>\n<h3 id=\"异步非阻塞\"><a href=\"#异步非阻塞\" class=\"headerlink\" title=\"异步非阻塞\"></a>异步非阻塞</h3><p>前文中有提到 master-worker 是一种异步非阻塞的进程模型。我认为可以在这里做一个更详细的描述，就是该进程模型为什么是“异步非阻塞”的：</p>\n<ul>\n<li><strong>异步</strong>：在 nginx 的 master-worker 模式中，master 进程负责管理 worker 进程，而 worker 进程则处理实际的客户端请求。这种架构下，master 进程和 worker 进程之间采用异步通信方式，master 进程不会阻塞在等待 worker 进程的响应上，从而提高了整体的并发处理能力；</li>\n<li><strong>非阻塞</strong>：nginx 中的 worker 进程使用非阻塞 I&#x2F;O 操作来处理客户端请求。这意味着当一个请求需要进行 I&#x2F;O 操作时（比如读取文件或从网络接收数据），worker 进程不会一直等待数据准备就绪，而是会继续处理其他请求。一旦数据准备就绪，worker 进程会立即处理它，而不会阻塞在这个操作上；</li>\n<li><strong>事件驱动</strong>：nginx 使用事件驱动的方式来处理 I&#x2F;O 操作。它利用操作系统提供的事件通知机制（如 epoll 或 kqueue）来实现非阻塞 I&#x2F;O。当一个事件发生时（比如一个连接建立或数据可读），nginx 将相应的事件添加到事件队列中，并通过事件驱动的方式处理这些事件，而不是通过阻塞式的等待。</li>\n</ul>\n<p>nginx 的 master-worker 模式通过异步、非阻塞和事件驱动的设计，实现了高性能和高并发处理能力。这种模式使得 nginx 能够高效地处理大量并发请求，而不会因为阻塞在 I&#x2F;O 操作上而导致性能下降。而 apache 传统的多进程模型（Prefork）无法实现异步非阻塞，所以会把这点作为 nginx 相比 apache 的一个优势。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>只是一个概述，很多内容等着补充 😪️</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ul>\n<li><a href=\"https://docshome.gitbook.io/nginx-docs/\">Nginx 中文文档</a></li>\n<li><a href=\"https://www.freecodecamp.org/chinese/news/the-nginx-handbook/\">Nginx 完全手册</a>，by freeCodeCamp</li>\n<li><a href=\"https://learnku.com/articles/38414\">Nginx 工作模式和进程模型</a>，by 已下线</li>\n</ul>\n"},{"title":"基于 UnoCSS 实现响应式设计&颜色主题","date":"2023-01-25T16:00:00.000Z","author":"ma5hr00m","_content":"\nUnoCSS 是一个 🔥火热的原子级 CSS 引擎。具体介绍不多说，本篇文章主题是实践，概念性的知识请去其官方网站了解：[UnoCSS 中文文档](https://alfred-skyblue.github.io/unocss-docs-cn/)。\n\n此外，本篇文章撸出来的小页面在线展示链接如下，对最终效果感兴趣的话可以看看：[Online Demo](http://example.ma5hr00m.top/)。\n\n## 准备\n使用 React&UnoCSS 的组合。先撸个简单的 Demo 页面，用于展示本篇的主题：\n​\n![Demo页面](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926170511.png)\n\n实际上就是一个简单的信息卡片，卡片底部是一个用于切换颜色主题的复选框。\n\n## 响应式设计\n### 历史\n在 Web 发展的洪荒年代，大家搭建的网页多是使用固定布局，如果用户使用的屏幕尺寸与设计者考虑的屏幕尺寸不同，就会出现多余的滚动条或者多余的页面空白，严重降低了用户体验😵‍💫。\n\n如果你想感受一下早期的 Web 前端页面，可以看看这个[👉历史悠久的网站](https://nic.eu.org/)，并尝试分别使用不同设备访问它（或者使用 DevTools 自带的工具）。\n\n> 这个网站本身也比较有趣，以后我可能会讲讲它。\n\n随着科技的发展，人们使用的屏幕尺寸越来越多，逐渐出现了响应式网页设计的概念（*responsive web design，RWD*）。*RWD* 是一种让网页能够根据不同的设备和屏幕尺寸自动适应的设计方法。它可以让网页在手机、电脑等设不同备上保持良好的布局。你现在能看到的大多数网站都使用了响应式设计，最常见的就是顶部导航栏的标签：\n\n> 在此页面打开 Devtools，改变页面尺寸，看看会发生什么！\n​\n### 相关概念\n在正式开始之前，有一些常见概念需要你了解🧐：\n- *视口 viewport*  \n  视口是浏览器窗口中显示网页内容的区域。不同的设备有不同的视口大小，你可以使用meta标签来设置视口的宽度和缩放比例。\n- *媒体查询 media query*  \n  媒体查询是一种CSS技术，可以让你根据不同的媒体类型和特征（如屏幕宽度、高度、分辨率等）来应用不同的样式规则。\n- *流式布局 fluid layout*    \n  流式布局是一种使用百分比或相对单位（如em、rem、vw、vh等）来定义网页元素宽度和高度的布局方法。它可以让网页元素随着视口大小的变化而自动调整。\n- *断点 breakpoint*  \n  断点是指在不同的视口大小下，网页布局发生变化的临界点。你可以使用媒体查询来定义不同的断点，并在每个断点下应用不同的样式规则。\n- *弹性盒子 flexbox*  \n  弹性盒子是一种CSS布局模块，可以让你轻松地对齐和分配网页元素。它可以让你在水平或垂直方向上创建弹性的网格系统，并根据视口大小自动调整元素的大小和顺序。\n- *网格 grid*  \n  网格是另一种CSS布局模块，可以让你创建复杂的二维网格系统，并在每个网格单元中放置网页元素。它可以让你定义不同的行和列，并根据视口大小自动调整它们的大小和位置。\n\n## 颜色主题\n这个无需多言，很多网站都已经配置了亮色主题和暗色主题，用户可以自行选择。\n\n## 实战\n### 响应式设计\n`UnoCSS` 基本兼容了 `Tailwind CSS` 的语法，我们可以使用类似的方法使用断点，编写在不同尺寸下的组件样式。\n\n首先，我们可以在配置文件中手动设置不同层级的断点。当然，你也可以使用默认值，我这里稍微做了些修改，添加了 `xxs`、`xxl` 断点：\n```javascript\n// uno.config.js\nexport default defineConfig({\n    ... ...\n    theme: {\n        breakpoints: {\n            xxs: '0px',\n            xs: '320px',\n            sm: '480px',\n            md: '768px',\n            lg: '1024px',\n            xl: '1280px',\n            xxl: '1600px',\n        },\n    },\n    ... ...\n})\n```\n\n按照如上代码进行配置后，我们可以在 React 的 `.jsx` 文件中通过 `md:` 语法设置不同断点下的样式：\n```jsx\n<div className={`shadow card-base text-base flex flex-col p-10 md:w-fit md:h-fit xxs:box-border xxs:items-center xxs:justify-center xxs:w-full xxs:h-full`}>\n    <h2 className=\"text-lg font-bold m-0\">\n        Responsive Design & Theme\n    </h2>\n    <p className=\"mb-4 text-center\">\n        Change window size or click the following button.\n    </p>\n    <div className='h-30px w-full flex items-center justify-center'>\n        <SwitchButton\n              height='50px'\n              width='60px'\n              layout='translate-x-[-50%]'\n              isChecked={isChecked}\n              SwitchFunction={handleSwitch}\n        />\n    </div>\n</div>\n```\n\n正如本篇文章开头展示的图片，这段代码实现了一个简单的信息卡片。当页面宽度不小于 `768px` 时，卡片为固定尺寸，可以显示背景背景；当页面宽度小于 `768px` 时，这个卡片会占满全屏，遮挡住页面背景。\n\n![对比展示](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171533.png)\n\n### 主题切换\n在展示页面中，我只做了亮暗色主题。\n\n如果你想要在 UnoCSS 中使用亮暗色主题，需要在配置文件中进行设置。我使用的方法参考了该框架作者 `Anthony Fu` 的一条推文。\n\n![展示](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171653.png)\n\n该条推文至今已有一年时间，或许已经出现了更加优秀的主题切换方案。\n​\n首先，我们需要在配置文件中进行配置，设置 `shortcuts` 并设置了亮暗色主题的不同颜色。\n```javascript\nexport default defineConfig({\n    ... ...\n    shortcuts:{\n        'switch-animation': 'transition duration-300',\n        'bg-base': 'bg-[#f0f0f0] dark:bg-[#20202a] switch-animation',\n        'card-base': 'bg-[#ffffff] dark:bg-[#10101a] switch-animation',\n        'text-base': 'text-[#20202a] dark:text-[#f0f0f0] switch-animation',\n        'switch-label-base': 'bg-gray-200 dark:bg-gray-800 switch-animation',\n        'switch-span-base': 'bg-white dark:bg-gray-300 switch-animation',\n    },\n    ... ...\n})\n```\n\n然后，我们编写一个 `SwitchButton.jsx` 组件，用于切换主题状态。为了使这个状态能够应用到主页面，我们将这个 `theme` 状态提升到其父组件中，并将其值绑定到相对底层的 div 元素中，以控制颜色主题。具体代码实现如下：\n```jsx\n// SwitchButton/index.jsx\nimport PropTypes from 'prop-types';\n​\nfunction SwitchButton({ height, width, layout, theme, SwitchFunction }) {\n    const handleSwitch = (event) => {\n        SwitchFunction(event.target.checked);\n    };\n​\n    return (\n        <div className={`relative h-[${height}] w-[${width}] flex items-center justify-center ${layout}`}>\n            <input\n                type=\"checkbox\"\n                id=\"dark-light\"\n                className=\"absolute z-1 w-12 h-5\"\n                onChange={handleSwitch}\n            />\n            <label \n                htmlFor=\"dark-light\"\n                className='absolute z-2 block w-11 h-6 switch-label-base rounded-full shadow-inner cursor-pointer switch-animation hover:cursor-pointer'\n            >\n                <span\n                    className={`absolute top-1 left-1.5 w-4 h-4 switch-span-base rounded-full shadow-md switch-animation ${theme=='dark' ? 'translate-x-[100%]' : ''}`}\n                >   \n                </span>\n            </label>\n        </div>\n    );\n}\n​\nSwitchButton.propTypes = {\n    height: PropTypes.string.isRequired,\n    width: PropTypes.string.isRequired,\n    layout: PropTypes.string.isRequired,\n    theme: PropTypes.string.isRequired,\n    SwitchFunction: PropTypes.func.isRequired,\n};\n​\nexport default SwitchButton;\n```\n\n<br/>\n\n```jsx\n// App.jsx\nimport { useState } from 'react';\nimport SwitchButton from './SwitchButton/index';\n​\nfunction App() {\n  const [theme, setTheme] = useState('dark');\n​\n  const handleSwitch = () => {\n    setTheme((prevChecked) => (prevChecked === 'dark' ? 'light' : 'dark'));\n  };\n​\n  return (\n    <div className={`w-100vw h-100vh flex flex-col ${theme}`}>\n      <main className=\"w-100vw flex-1 flex justify-center items-center bg-base\">\n        <div className={` shadow card-base text-base flex flex-col p-10  md:w-fit md:h-fit xxs:box-border xxs:items-center xxs:justify-center xxs:w-full xxs:h-full`}>\n          <h2 className=\"text-lg font-bold m-0\">\n            Responsive Design & Theme\n          </h2>\n          <p className=\"mb-4 text-center\">\n            Change window size or click the following button.\n          </p>\n          <div className='h-30px w-full flex items-center justify-center'>\n            <SwitchButton\n              height='50px'\n              width='60px'\n              layout='translate-x-[-50%]'\n              theme={theme}\n              SwitchFunction={handleSwitch}\n            />\n          </div>\n        </div>\n      </main>\n    </div>\n  );\n}\n​\nexport default App;\n```\n\n至此，我们的颜色主题切换效果也已经实现了，具体效果请移步 `demo` 网站查看：[demo](http://example.ma5hr00m.top/)\n\n## 后续\n写这个 demo 的时候其实还不会用状态管理库，所以选择了状态提升，现在看起来很捞。\n\n跨组件传参的话，建议直接使用状态管理库，比如 `jotai`.","source":"_posts/unocss-theme.md","raw":"---\ntitle: 基于 UnoCSS 实现响应式设计&颜色主题\ndate: 2023/01/26\nauthor: ma5hr00m\ncategories:\n- CSS\n---\n\nUnoCSS 是一个 🔥火热的原子级 CSS 引擎。具体介绍不多说，本篇文章主题是实践，概念性的知识请去其官方网站了解：[UnoCSS 中文文档](https://alfred-skyblue.github.io/unocss-docs-cn/)。\n\n此外，本篇文章撸出来的小页面在线展示链接如下，对最终效果感兴趣的话可以看看：[Online Demo](http://example.ma5hr00m.top/)。\n\n## 准备\n使用 React&UnoCSS 的组合。先撸个简单的 Demo 页面，用于展示本篇的主题：\n​\n![Demo页面](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926170511.png)\n\n实际上就是一个简单的信息卡片，卡片底部是一个用于切换颜色主题的复选框。\n\n## 响应式设计\n### 历史\n在 Web 发展的洪荒年代，大家搭建的网页多是使用固定布局，如果用户使用的屏幕尺寸与设计者考虑的屏幕尺寸不同，就会出现多余的滚动条或者多余的页面空白，严重降低了用户体验😵‍💫。\n\n如果你想感受一下早期的 Web 前端页面，可以看看这个[👉历史悠久的网站](https://nic.eu.org/)，并尝试分别使用不同设备访问它（或者使用 DevTools 自带的工具）。\n\n> 这个网站本身也比较有趣，以后我可能会讲讲它。\n\n随着科技的发展，人们使用的屏幕尺寸越来越多，逐渐出现了响应式网页设计的概念（*responsive web design，RWD*）。*RWD* 是一种让网页能够根据不同的设备和屏幕尺寸自动适应的设计方法。它可以让网页在手机、电脑等设不同备上保持良好的布局。你现在能看到的大多数网站都使用了响应式设计，最常见的就是顶部导航栏的标签：\n\n> 在此页面打开 Devtools，改变页面尺寸，看看会发生什么！\n​\n### 相关概念\n在正式开始之前，有一些常见概念需要你了解🧐：\n- *视口 viewport*  \n  视口是浏览器窗口中显示网页内容的区域。不同的设备有不同的视口大小，你可以使用meta标签来设置视口的宽度和缩放比例。\n- *媒体查询 media query*  \n  媒体查询是一种CSS技术，可以让你根据不同的媒体类型和特征（如屏幕宽度、高度、分辨率等）来应用不同的样式规则。\n- *流式布局 fluid layout*    \n  流式布局是一种使用百分比或相对单位（如em、rem、vw、vh等）来定义网页元素宽度和高度的布局方法。它可以让网页元素随着视口大小的变化而自动调整。\n- *断点 breakpoint*  \n  断点是指在不同的视口大小下，网页布局发生变化的临界点。你可以使用媒体查询来定义不同的断点，并在每个断点下应用不同的样式规则。\n- *弹性盒子 flexbox*  \n  弹性盒子是一种CSS布局模块，可以让你轻松地对齐和分配网页元素。它可以让你在水平或垂直方向上创建弹性的网格系统，并根据视口大小自动调整元素的大小和顺序。\n- *网格 grid*  \n  网格是另一种CSS布局模块，可以让你创建复杂的二维网格系统，并在每个网格单元中放置网页元素。它可以让你定义不同的行和列，并根据视口大小自动调整它们的大小和位置。\n\n## 颜色主题\n这个无需多言，很多网站都已经配置了亮色主题和暗色主题，用户可以自行选择。\n\n## 实战\n### 响应式设计\n`UnoCSS` 基本兼容了 `Tailwind CSS` 的语法，我们可以使用类似的方法使用断点，编写在不同尺寸下的组件样式。\n\n首先，我们可以在配置文件中手动设置不同层级的断点。当然，你也可以使用默认值，我这里稍微做了些修改，添加了 `xxs`、`xxl` 断点：\n```javascript\n// uno.config.js\nexport default defineConfig({\n    ... ...\n    theme: {\n        breakpoints: {\n            xxs: '0px',\n            xs: '320px',\n            sm: '480px',\n            md: '768px',\n            lg: '1024px',\n            xl: '1280px',\n            xxl: '1600px',\n        },\n    },\n    ... ...\n})\n```\n\n按照如上代码进行配置后，我们可以在 React 的 `.jsx` 文件中通过 `md:` 语法设置不同断点下的样式：\n```jsx\n<div className={`shadow card-base text-base flex flex-col p-10 md:w-fit md:h-fit xxs:box-border xxs:items-center xxs:justify-center xxs:w-full xxs:h-full`}>\n    <h2 className=\"text-lg font-bold m-0\">\n        Responsive Design & Theme\n    </h2>\n    <p className=\"mb-4 text-center\">\n        Change window size or click the following button.\n    </p>\n    <div className='h-30px w-full flex items-center justify-center'>\n        <SwitchButton\n              height='50px'\n              width='60px'\n              layout='translate-x-[-50%]'\n              isChecked={isChecked}\n              SwitchFunction={handleSwitch}\n        />\n    </div>\n</div>\n```\n\n正如本篇文章开头展示的图片，这段代码实现了一个简单的信息卡片。当页面宽度不小于 `768px` 时，卡片为固定尺寸，可以显示背景背景；当页面宽度小于 `768px` 时，这个卡片会占满全屏，遮挡住页面背景。\n\n![对比展示](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171533.png)\n\n### 主题切换\n在展示页面中，我只做了亮暗色主题。\n\n如果你想要在 UnoCSS 中使用亮暗色主题，需要在配置文件中进行设置。我使用的方法参考了该框架作者 `Anthony Fu` 的一条推文。\n\n![展示](https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171653.png)\n\n该条推文至今已有一年时间，或许已经出现了更加优秀的主题切换方案。\n​\n首先，我们需要在配置文件中进行配置，设置 `shortcuts` 并设置了亮暗色主题的不同颜色。\n```javascript\nexport default defineConfig({\n    ... ...\n    shortcuts:{\n        'switch-animation': 'transition duration-300',\n        'bg-base': 'bg-[#f0f0f0] dark:bg-[#20202a] switch-animation',\n        'card-base': 'bg-[#ffffff] dark:bg-[#10101a] switch-animation',\n        'text-base': 'text-[#20202a] dark:text-[#f0f0f0] switch-animation',\n        'switch-label-base': 'bg-gray-200 dark:bg-gray-800 switch-animation',\n        'switch-span-base': 'bg-white dark:bg-gray-300 switch-animation',\n    },\n    ... ...\n})\n```\n\n然后，我们编写一个 `SwitchButton.jsx` 组件，用于切换主题状态。为了使这个状态能够应用到主页面，我们将这个 `theme` 状态提升到其父组件中，并将其值绑定到相对底层的 div 元素中，以控制颜色主题。具体代码实现如下：\n```jsx\n// SwitchButton/index.jsx\nimport PropTypes from 'prop-types';\n​\nfunction SwitchButton({ height, width, layout, theme, SwitchFunction }) {\n    const handleSwitch = (event) => {\n        SwitchFunction(event.target.checked);\n    };\n​\n    return (\n        <div className={`relative h-[${height}] w-[${width}] flex items-center justify-center ${layout}`}>\n            <input\n                type=\"checkbox\"\n                id=\"dark-light\"\n                className=\"absolute z-1 w-12 h-5\"\n                onChange={handleSwitch}\n            />\n            <label \n                htmlFor=\"dark-light\"\n                className='absolute z-2 block w-11 h-6 switch-label-base rounded-full shadow-inner cursor-pointer switch-animation hover:cursor-pointer'\n            >\n                <span\n                    className={`absolute top-1 left-1.5 w-4 h-4 switch-span-base rounded-full shadow-md switch-animation ${theme=='dark' ? 'translate-x-[100%]' : ''}`}\n                >   \n                </span>\n            </label>\n        </div>\n    );\n}\n​\nSwitchButton.propTypes = {\n    height: PropTypes.string.isRequired,\n    width: PropTypes.string.isRequired,\n    layout: PropTypes.string.isRequired,\n    theme: PropTypes.string.isRequired,\n    SwitchFunction: PropTypes.func.isRequired,\n};\n​\nexport default SwitchButton;\n```\n\n<br/>\n\n```jsx\n// App.jsx\nimport { useState } from 'react';\nimport SwitchButton from './SwitchButton/index';\n​\nfunction App() {\n  const [theme, setTheme] = useState('dark');\n​\n  const handleSwitch = () => {\n    setTheme((prevChecked) => (prevChecked === 'dark' ? 'light' : 'dark'));\n  };\n​\n  return (\n    <div className={`w-100vw h-100vh flex flex-col ${theme}`}>\n      <main className=\"w-100vw flex-1 flex justify-center items-center bg-base\">\n        <div className={` shadow card-base text-base flex flex-col p-10  md:w-fit md:h-fit xxs:box-border xxs:items-center xxs:justify-center xxs:w-full xxs:h-full`}>\n          <h2 className=\"text-lg font-bold m-0\">\n            Responsive Design & Theme\n          </h2>\n          <p className=\"mb-4 text-center\">\n            Change window size or click the following button.\n          </p>\n          <div className='h-30px w-full flex items-center justify-center'>\n            <SwitchButton\n              height='50px'\n              width='60px'\n              layout='translate-x-[-50%]'\n              theme={theme}\n              SwitchFunction={handleSwitch}\n            />\n          </div>\n        </div>\n      </main>\n    </div>\n  );\n}\n​\nexport default App;\n```\n\n至此，我们的颜色主题切换效果也已经实现了，具体效果请移步 `demo` 网站查看：[demo](http://example.ma5hr00m.top/)\n\n## 后续\n写这个 demo 的时候其实还不会用状态管理库，所以选择了状态提升，现在看起来很捞。\n\n跨组件传参的话，建议直接使用状态管理库，比如 `jotai`.","slug":"unocss-theme","published":1,"updated":"2024-06-09T12:56:40.121Z","comments":1,"layout":"post","photos":[],"_id":"clxhruapa0015f4lycz8s6ow8","content":"<p>UnoCSS 是一个 🔥火热的原子级 CSS 引擎。具体介绍不多说，本篇文章主题是实践，概念性的知识请去其官方网站了解：<a href=\"https://alfred-skyblue.github.io/unocss-docs-cn/\">UnoCSS 中文文档</a>。</p>\n<p>此外，本篇文章撸出来的小页面在线展示链接如下，对最终效果感兴趣的话可以看看：<a href=\"http://example.ma5hr00m.top/\">Online Demo</a>。</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>使用 React&amp;UnoCSS 的组合。先撸个简单的 Demo 页面，用于展示本篇的主题：<br>​<br><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926170511.png\" alt=\"Demo页面\"></p>\n<p>实际上就是一个简单的信息卡片，卡片底部是一个用于切换颜色主题的复选框。</p>\n<h2 id=\"响应式设计\"><a href=\"#响应式设计\" class=\"headerlink\" title=\"响应式设计\"></a>响应式设计</h2><h3 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h3><p>在 Web 发展的洪荒年代，大家搭建的网页多是使用固定布局，如果用户使用的屏幕尺寸与设计者考虑的屏幕尺寸不同，就会出现多余的滚动条或者多余的页面空白，严重降低了用户体验😵‍💫。</p>\n<p>如果你想感受一下早期的 Web 前端页面，可以看看这个<a href=\"https://nic.eu.org/\">👉历史悠久的网站</a>，并尝试分别使用不同设备访问它（或者使用 DevTools 自带的工具）。</p>\n<blockquote>\n<p>这个网站本身也比较有趣，以后我可能会讲讲它。</p>\n</blockquote>\n<p>随着科技的发展，人们使用的屏幕尺寸越来越多，逐渐出现了响应式网页设计的概念（<em>responsive web design，RWD</em>）。<em>RWD</em> 是一种让网页能够根据不同的设备和屏幕尺寸自动适应的设计方法。它可以让网页在手机、电脑等设不同备上保持良好的布局。你现在能看到的大多数网站都使用了响应式设计，最常见的就是顶部导航栏的标签：</p>\n<blockquote>\n<p>在此页面打开 Devtools，改变页面尺寸，看看会发生什么！<br>​</p>\n</blockquote>\n<h3 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h3><p>在正式开始之前，有一些常见概念需要你了解🧐：</p>\n<ul>\n<li><em>视口 viewport</em><br>视口是浏览器窗口中显示网页内容的区域。不同的设备有不同的视口大小，你可以使用meta标签来设置视口的宽度和缩放比例。</li>\n<li><em>媒体查询 media query</em><br>媒体查询是一种CSS技术，可以让你根据不同的媒体类型和特征（如屏幕宽度、高度、分辨率等）来应用不同的样式规则。</li>\n<li><em>流式布局 fluid layout</em><br>流式布局是一种使用百分比或相对单位（如em、rem、vw、vh等）来定义网页元素宽度和高度的布局方法。它可以让网页元素随着视口大小的变化而自动调整。</li>\n<li><em>断点 breakpoint</em><br>断点是指在不同的视口大小下，网页布局发生变化的临界点。你可以使用媒体查询来定义不同的断点，并在每个断点下应用不同的样式规则。</li>\n<li><em>弹性盒子 flexbox</em><br>弹性盒子是一种CSS布局模块，可以让你轻松地对齐和分配网页元素。它可以让你在水平或垂直方向上创建弹性的网格系统，并根据视口大小自动调整元素的大小和顺序。</li>\n<li><em>网格 grid</em><br>网格是另一种CSS布局模块，可以让你创建复杂的二维网格系统，并在每个网格单元中放置网页元素。它可以让你定义不同的行和列，并根据视口大小自动调整它们的大小和位置。</li>\n</ul>\n<h2 id=\"颜色主题\"><a href=\"#颜色主题\" class=\"headerlink\" title=\"颜色主题\"></a>颜色主题</h2><p>这个无需多言，很多网站都已经配置了亮色主题和暗色主题，用户可以自行选择。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"响应式设计-1\"><a href=\"#响应式设计-1\" class=\"headerlink\" title=\"响应式设计\"></a>响应式设计</h3><p><code>UnoCSS</code> 基本兼容了 <code>Tailwind CSS</code> 的语法，我们可以使用类似的方法使用断点，编写在不同尺寸下的组件样式。</p>\n<p>首先，我们可以在配置文件中手动设置不同层级的断点。当然，你也可以使用默认值，我这里稍微做了些修改，添加了 <code>xxs</code>、<code>xxl</code> 断点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uno.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineConfig</span>(&#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">    <span class=\"attr\">theme</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">breakpoints</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">xxs</span>: <span class=\"string\">&#x27;0px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">xs</span>: <span class=\"string\">&#x27;320px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">sm</span>: <span class=\"string\">&#x27;480px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">md</span>: <span class=\"string\">&#x27;768px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">lg</span>: <span class=\"string\">&#x27;1024px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">xl</span>: <span class=\"string\">&#x27;1280px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">xxl</span>: <span class=\"string\">&#x27;1600px&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>按照如上代码进行配置后，我们可以在 React 的 <code>.jsx</code> 文件中通过 <code>md:</code> 语法设置不同断点下的样式：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div className=&#123;<span class=\"string\">`shadow card-base text-base flex flex-col p-10 md:w-fit md:h-fit xxs:box-border xxs:items-center xxs:justify-center xxs:w-full xxs:h-full`</span>&#125;&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;text-lg font-bold m-0&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        Responsive Design &amp; Theme</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;mb-4 text-center&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        Change window size or click the following button.</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#x27;h-30px w-full flex items-center justify-center&#x27;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">SwitchButton</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">height</span>=<span class=\"string\">&#x27;50px&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">width</span>=<span class=\"string\">&#x27;60px&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">layout</span>=<span class=\"string\">&#x27;translate-x-[-50%]&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">isChecked</span>=<span class=\"string\">&#123;isChecked&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">SwitchFunction</span>=<span class=\"string\">&#123;handleSwitch&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>正如本篇文章开头展示的图片，这段代码实现了一个简单的信息卡片。当页面宽度不小于 <code>768px</code> 时，卡片为固定尺寸，可以显示背景背景；当页面宽度小于 <code>768px</code> 时，这个卡片会占满全屏，遮挡住页面背景。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171533.png\" alt=\"对比展示\"></p>\n<h3 id=\"主题切换\"><a href=\"#主题切换\" class=\"headerlink\" title=\"主题切换\"></a>主题切换</h3><p>在展示页面中，我只做了亮暗色主题。</p>\n<p>如果你想要在 UnoCSS 中使用亮暗色主题，需要在配置文件中进行设置。我使用的方法参考了该框架作者 <code>Anthony Fu</code> 的一条推文。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171653.png\" alt=\"展示\"></p>\n<p>该条推文至今已有一年时间，或许已经出现了更加优秀的主题切换方案。<br>​<br>首先，我们需要在配置文件中进行配置，设置 <code>shortcuts</code> 并设置了亮暗色主题的不同颜色。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineConfig</span>(&#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">    <span class=\"attr\">shortcuts</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;switch-animation&#x27;</span>: <span class=\"string\">&#x27;transition duration-300&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;bg-base&#x27;</span>: <span class=\"string\">&#x27;bg-[#f0f0f0] dark:bg-[#20202a] switch-animation&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;card-base&#x27;</span>: <span class=\"string\">&#x27;bg-[#ffffff] dark:bg-[#10101a] switch-animation&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;text-base&#x27;</span>: <span class=\"string\">&#x27;text-[#20202a] dark:text-[#f0f0f0] switch-animation&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;switch-label-base&#x27;</span>: <span class=\"string\">&#x27;bg-gray-200 dark:bg-gray-800 switch-animation&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;switch-span-base&#x27;</span>: <span class=\"string\">&#x27;bg-white dark:bg-gray-300 switch-animation&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们编写一个 <code>SwitchButton.jsx</code> 组件，用于切换主题状态。为了使这个状态能够应用到主页面，我们将这个 <code>theme</code> 状态提升到其父组件中，并将其值绑定到相对底层的 div 元素中，以控制颜色主题。具体代码实现如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SwitchButton/index.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;prop-types&#x27;</span>;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SwitchButton</span>(<span class=\"params\">&#123; height, width, layout, theme, SwitchFunction &#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">handleSwitch</span> = (<span class=\"params\">event</span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"title class_\">SwitchFunction</span>(event.<span class=\"property\">target</span>.<span class=\"property\">checked</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">relative</span> <span class=\"attr\">h-</span>[$&#123;<span class=\"attr\">height</span>&#125;] <span class=\"attr\">w-</span>[$&#123;<span class=\"attr\">width</span>&#125;] <span class=\"attr\">flex</span> <span class=\"attr\">items-center</span> <span class=\"attr\">justify-center</span> $&#123;<span class=\"attr\">layout</span>&#125;`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">id</span>=<span class=\"string\">&quot;dark-light&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">className</span>=<span class=\"string\">&quot;absolute z-1 w-12 h-5&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;handleSwitch&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">label</span> </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">htmlFor</span>=<span class=\"string\">&quot;dark-light&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">className</span>=<span class=\"string\">&#x27;absolute z-2 block w-11 h-6 switch-label-base rounded-full shadow-inner cursor-pointer switch-animation hover:cursor-pointer&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">span</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">absolute</span> <span class=\"attr\">top-1</span> <span class=\"attr\">left-1.5</span> <span class=\"attr\">w-4</span> <span class=\"attr\">h-4</span> <span class=\"attr\">switch-span-base</span> <span class=\"attr\">rounded-full</span> <span class=\"attr\">shadow-md</span> <span class=\"attr\">switch-animation</span> $&#123;<span class=\"attr\">theme</span>==<span class=\"string\">&#x27;dark&#x27;</span> ? &#x27;<span class=\"attr\">translate-x-</span>[<span class=\"attr\">100</span>%]&#x27; <span class=\"attr\">:</span> &#x27;&#x27;&#125;`&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                &gt;</span>   </span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"title class_\">SwitchButton</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">height</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">width</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">layout</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">theme</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"title class_\">SwitchFunction</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">SwitchButton</span>;</span><br></pre></td></tr></table></figure>\n\n<br/>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">SwitchButton</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./SwitchButton/index&#x27;</span>;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [theme, setTheme] = <span class=\"title function_\">useState</span>(<span class=\"string\">&#x27;dark&#x27;</span>);</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleSwitch</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setTheme</span>(<span class=\"function\">(<span class=\"params\">prevChecked</span>) =&gt;</span> (prevChecked === <span class=\"string\">&#x27;dark&#x27;</span> ? <span class=\"string\">&#x27;light&#x27;</span> : <span class=\"string\">&#x27;dark&#x27;</span>));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">w-100vw</span> <span class=\"attr\">h-100vh</span> <span class=\"attr\">flex</span> <span class=\"attr\">flex-col</span> $&#123;<span class=\"attr\">theme</span>&#125;`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">main</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;w-100vw flex-1 flex justify-center items-center bg-base&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>` <span class=\"attr\">shadow</span> <span class=\"attr\">card-base</span> <span class=\"attr\">text-base</span> <span class=\"attr\">flex</span> <span class=\"attr\">flex-col</span> <span class=\"attr\">p-10</span>  <span class=\"attr\">md:w-fit</span> <span class=\"attr\">md:h-fit</span> <span class=\"attr\">xxs:box-border</span> <span class=\"attr\">xxs:items-center</span> <span class=\"attr\">xxs:justify-center</span> <span class=\"attr\">xxs:w-full</span> <span class=\"attr\">xxs:h-full</span>`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;text-lg font-bold m-0&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            Responsive Design &amp; Theme</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;mb-4 text-center&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            Change window size or click the following button.</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#x27;h-30px w-full flex items-center justify-center&#x27;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">SwitchButton</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">height</span>=<span class=\"string\">&#x27;50px&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">width</span>=<span class=\"string\">&#x27;60px&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">layout</span>=<span class=\"string\">&#x27;translate-x-[-50%]&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">theme</span>=<span class=\"string\">&#123;theme&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">SwitchFunction</span>=<span class=\"string\">&#123;handleSwitch&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们的颜色主题切换效果也已经实现了，具体效果请移步 <code>demo</code> 网站查看：<a href=\"http://example.ma5hr00m.top/\">demo</a></p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>写这个 demo 的时候其实还不会用状态管理库，所以选择了状态提升，现在看起来很捞。</p>\n<p>跨组件传参的话，建议直接使用状态管理库，比如 <code>jotai</code>.</p>\n","excerpt":"","more":"<p>UnoCSS 是一个 🔥火热的原子级 CSS 引擎。具体介绍不多说，本篇文章主题是实践，概念性的知识请去其官方网站了解：<a href=\"https://alfred-skyblue.github.io/unocss-docs-cn/\">UnoCSS 中文文档</a>。</p>\n<p>此外，本篇文章撸出来的小页面在线展示链接如下，对最终效果感兴趣的话可以看看：<a href=\"http://example.ma5hr00m.top/\">Online Demo</a>。</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>使用 React&amp;UnoCSS 的组合。先撸个简单的 Demo 页面，用于展示本篇的主题：<br>​<br><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926170511.png\" alt=\"Demo页面\"></p>\n<p>实际上就是一个简单的信息卡片，卡片底部是一个用于切换颜色主题的复选框。</p>\n<h2 id=\"响应式设计\"><a href=\"#响应式设计\" class=\"headerlink\" title=\"响应式设计\"></a>响应式设计</h2><h3 id=\"历史\"><a href=\"#历史\" class=\"headerlink\" title=\"历史\"></a>历史</h3><p>在 Web 发展的洪荒年代，大家搭建的网页多是使用固定布局，如果用户使用的屏幕尺寸与设计者考虑的屏幕尺寸不同，就会出现多余的滚动条或者多余的页面空白，严重降低了用户体验😵‍💫。</p>\n<p>如果你想感受一下早期的 Web 前端页面，可以看看这个<a href=\"https://nic.eu.org/\">👉历史悠久的网站</a>，并尝试分别使用不同设备访问它（或者使用 DevTools 自带的工具）。</p>\n<blockquote>\n<p>这个网站本身也比较有趣，以后我可能会讲讲它。</p>\n</blockquote>\n<p>随着科技的发展，人们使用的屏幕尺寸越来越多，逐渐出现了响应式网页设计的概念（<em>responsive web design，RWD</em>）。<em>RWD</em> 是一种让网页能够根据不同的设备和屏幕尺寸自动适应的设计方法。它可以让网页在手机、电脑等设不同备上保持良好的布局。你现在能看到的大多数网站都使用了响应式设计，最常见的就是顶部导航栏的标签：</p>\n<blockquote>\n<p>在此页面打开 Devtools，改变页面尺寸，看看会发生什么！<br>​</p>\n</blockquote>\n<h3 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h3><p>在正式开始之前，有一些常见概念需要你了解🧐：</p>\n<ul>\n<li><em>视口 viewport</em><br>视口是浏览器窗口中显示网页内容的区域。不同的设备有不同的视口大小，你可以使用meta标签来设置视口的宽度和缩放比例。</li>\n<li><em>媒体查询 media query</em><br>媒体查询是一种CSS技术，可以让你根据不同的媒体类型和特征（如屏幕宽度、高度、分辨率等）来应用不同的样式规则。</li>\n<li><em>流式布局 fluid layout</em><br>流式布局是一种使用百分比或相对单位（如em、rem、vw、vh等）来定义网页元素宽度和高度的布局方法。它可以让网页元素随着视口大小的变化而自动调整。</li>\n<li><em>断点 breakpoint</em><br>断点是指在不同的视口大小下，网页布局发生变化的临界点。你可以使用媒体查询来定义不同的断点，并在每个断点下应用不同的样式规则。</li>\n<li><em>弹性盒子 flexbox</em><br>弹性盒子是一种CSS布局模块，可以让你轻松地对齐和分配网页元素。它可以让你在水平或垂直方向上创建弹性的网格系统，并根据视口大小自动调整元素的大小和顺序。</li>\n<li><em>网格 grid</em><br>网格是另一种CSS布局模块，可以让你创建复杂的二维网格系统，并在每个网格单元中放置网页元素。它可以让你定义不同的行和列，并根据视口大小自动调整它们的大小和位置。</li>\n</ul>\n<h2 id=\"颜色主题\"><a href=\"#颜色主题\" class=\"headerlink\" title=\"颜色主题\"></a>颜色主题</h2><p>这个无需多言，很多网站都已经配置了亮色主题和暗色主题，用户可以自行选择。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"响应式设计-1\"><a href=\"#响应式设计-1\" class=\"headerlink\" title=\"响应式设计\"></a>响应式设计</h3><p><code>UnoCSS</code> 基本兼容了 <code>Tailwind CSS</code> 的语法，我们可以使用类似的方法使用断点，编写在不同尺寸下的组件样式。</p>\n<p>首先，我们可以在配置文件中手动设置不同层级的断点。当然，你也可以使用默认值，我这里稍微做了些修改，添加了 <code>xxs</code>、<code>xxl</code> 断点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uno.config.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineConfig</span>(&#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">    <span class=\"attr\">theme</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">breakpoints</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">xxs</span>: <span class=\"string\">&#x27;0px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">xs</span>: <span class=\"string\">&#x27;320px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">sm</span>: <span class=\"string\">&#x27;480px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">md</span>: <span class=\"string\">&#x27;768px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">lg</span>: <span class=\"string\">&#x27;1024px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">xl</span>: <span class=\"string\">&#x27;1280px&#x27;</span>,</span><br><span class=\"line\">            <span class=\"attr\">xxl</span>: <span class=\"string\">&#x27;1600px&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>按照如上代码进行配置后，我们可以在 React 的 <code>.jsx</code> 文件中通过 <code>md:</code> 语法设置不同断点下的样式：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div className=&#123;<span class=\"string\">`shadow card-base text-base flex flex-col p-10 md:w-fit md:h-fit xxs:box-border xxs:items-center xxs:justify-center xxs:w-full xxs:h-full`</span>&#125;&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;text-lg font-bold m-0&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        Responsive Design &amp; Theme</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;mb-4 text-center&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        Change window size or click the following button.</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#x27;h-30px w-full flex items-center justify-center&#x27;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">SwitchButton</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">height</span>=<span class=\"string\">&#x27;50px&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">width</span>=<span class=\"string\">&#x27;60px&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">layout</span>=<span class=\"string\">&#x27;translate-x-[-50%]&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">isChecked</span>=<span class=\"string\">&#123;isChecked&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">SwitchFunction</span>=<span class=\"string\">&#123;handleSwitch&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>正如本篇文章开头展示的图片，这段代码实现了一个简单的信息卡片。当页面宽度不小于 <code>768px</code> 时，卡片为固定尺寸，可以显示背景背景；当页面宽度小于 <code>768px</code> 时，这个卡片会占满全屏，遮挡住页面背景。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171533.png\" alt=\"对比展示\"></p>\n<h3 id=\"主题切换\"><a href=\"#主题切换\" class=\"headerlink\" title=\"主题切换\"></a>主题切换</h3><p>在展示页面中，我只做了亮暗色主题。</p>\n<p>如果你想要在 UnoCSS 中使用亮暗色主题，需要在配置文件中进行设置。我使用的方法参考了该框架作者 <code>Anthony Fu</code> 的一条推文。</p>\n<p><img src=\"https://agu-img.oss-cn-hangzhou.aliyuncs.com/blog/20230926171653.png\" alt=\"展示\"></p>\n<p>该条推文至今已有一年时间，或许已经出现了更加优秀的主题切换方案。<br>​<br>首先，我们需要在配置文件中进行配置，设置 <code>shortcuts</code> 并设置了亮暗色主题的不同颜色。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineConfig</span>(&#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">    <span class=\"attr\">shortcuts</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;switch-animation&#x27;</span>: <span class=\"string\">&#x27;transition duration-300&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;bg-base&#x27;</span>: <span class=\"string\">&#x27;bg-[#f0f0f0] dark:bg-[#20202a] switch-animation&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;card-base&#x27;</span>: <span class=\"string\">&#x27;bg-[#ffffff] dark:bg-[#10101a] switch-animation&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;text-base&#x27;</span>: <span class=\"string\">&#x27;text-[#20202a] dark:text-[#f0f0f0] switch-animation&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;switch-label-base&#x27;</span>: <span class=\"string\">&#x27;bg-gray-200 dark:bg-gray-800 switch-animation&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;switch-span-base&#x27;</span>: <span class=\"string\">&#x27;bg-white dark:bg-gray-300 switch-animation&#x27;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们编写一个 <code>SwitchButton.jsx</code> 组件，用于切换主题状态。为了使这个状态能够应用到主页面，我们将这个 <code>theme</code> 状态提升到其父组件中，并将其值绑定到相对底层的 div 元素中，以控制颜色主题。具体代码实现如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SwitchButton/index.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">PropTypes</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;prop-types&#x27;</span>;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SwitchButton</span>(<span class=\"params\">&#123; height, width, layout, theme, SwitchFunction &#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">handleSwitch</span> = (<span class=\"params\">event</span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"title class_\">SwitchFunction</span>(event.<span class=\"property\">target</span>.<span class=\"property\">checked</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">​</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">relative</span> <span class=\"attr\">h-</span>[$&#123;<span class=\"attr\">height</span>&#125;] <span class=\"attr\">w-</span>[$&#123;<span class=\"attr\">width</span>&#125;] <span class=\"attr\">flex</span> <span class=\"attr\">items-center</span> <span class=\"attr\">justify-center</span> $&#123;<span class=\"attr\">layout</span>&#125;`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">input</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">id</span>=<span class=\"string\">&quot;dark-light&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">className</span>=<span class=\"string\">&quot;absolute z-1 w-12 h-5&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;handleSwitch&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">label</span> </span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">htmlFor</span>=<span class=\"string\">&quot;dark-light&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                <span class=\"attr\">className</span>=<span class=\"string\">&#x27;absolute z-2 block w-11 h-6 switch-label-base rounded-full shadow-inner cursor-pointer switch-animation hover:cursor-pointer&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">span</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                    <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">absolute</span> <span class=\"attr\">top-1</span> <span class=\"attr\">left-1.5</span> <span class=\"attr\">w-4</span> <span class=\"attr\">h-4</span> <span class=\"attr\">switch-span-base</span> <span class=\"attr\">rounded-full</span> <span class=\"attr\">shadow-md</span> <span class=\"attr\">switch-animation</span> $&#123;<span class=\"attr\">theme</span>==<span class=\"string\">&#x27;dark&#x27;</span> ? &#x27;<span class=\"attr\">translate-x-</span>[<span class=\"attr\">100</span>%]&#x27; <span class=\"attr\">:</span> &#x27;&#x27;&#125;`&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">                &gt;</span>   </span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"title class_\">SwitchButton</span>.<span class=\"property\">propTypes</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">height</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">width</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">layout</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"attr\">theme</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">string</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">    <span class=\"title class_\">SwitchFunction</span>: <span class=\"title class_\">PropTypes</span>.<span class=\"property\">func</span>.<span class=\"property\">isRequired</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">SwitchButton</span>;</span><br></pre></td></tr></table></figure>\n\n<br/>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">SwitchButton</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./SwitchButton/index&#x27;</span>;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [theme, setTheme] = <span class=\"title function_\">useState</span>(<span class=\"string\">&#x27;dark&#x27;</span>);</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleSwitch</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setTheme</span>(<span class=\"function\">(<span class=\"params\">prevChecked</span>) =&gt;</span> (prevChecked === <span class=\"string\">&#x27;dark&#x27;</span> ? <span class=\"string\">&#x27;light&#x27;</span> : <span class=\"string\">&#x27;dark&#x27;</span>));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">​</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">w-100vw</span> <span class=\"attr\">h-100vh</span> <span class=\"attr\">flex</span> <span class=\"attr\">flex-col</span> $&#123;<span class=\"attr\">theme</span>&#125;`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">main</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;w-100vw flex-1 flex justify-center items-center bg-base&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>` <span class=\"attr\">shadow</span> <span class=\"attr\">card-base</span> <span class=\"attr\">text-base</span> <span class=\"attr\">flex</span> <span class=\"attr\">flex-col</span> <span class=\"attr\">p-10</span>  <span class=\"attr\">md:w-fit</span> <span class=\"attr\">md:h-fit</span> <span class=\"attr\">xxs:box-border</span> <span class=\"attr\">xxs:items-center</span> <span class=\"attr\">xxs:justify-center</span> <span class=\"attr\">xxs:w-full</span> <span class=\"attr\">xxs:h-full</span>`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">h2</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;text-lg font-bold m-0&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            Responsive Design &amp; Theme</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;mb-4 text-center&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            Change window size or click the following button.</span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#x27;h-30px w-full flex items-center justify-center&#x27;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">SwitchButton</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">height</span>=<span class=\"string\">&#x27;50px&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">width</span>=<span class=\"string\">&#x27;60px&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">layout</span>=<span class=\"string\">&#x27;translate-x-[-50%]&#x27;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">theme</span>=<span class=\"string\">&#123;theme&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">              <span class=\"attr\">SwitchFunction</span>=<span class=\"string\">&#123;handleSwitch&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">            /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们的颜色主题切换效果也已经实现了，具体效果请移步 <code>demo</code> 网站查看：<a href=\"http://example.ma5hr00m.top/\">demo</a></p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>写这个 demo 的时候其实还不会用状态管理库，所以选择了状态提升，现在看起来很捞。</p>\n<p>跨组件传参的话，建议直接使用状态管理库，比如 <code>jotai</code>.</p>\n"},{"title":"Promise 使用一览","date":"2024-06-08T16:00:00.000Z","author":"ma5hr00m","_content":"\nPromise 规范最早由 CommonJS 社区提出，后来成为 ES2015（ES6） 语言规范，到现在可以说已经成了异步编程的首选方案。\n\n- [使用 Promise - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)\n- [Promise](https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544)\n\n## 状态\n\n- `Penfing`  等待\n- `Fulfilled` 成功\n- `rejected` 失败\n\n## 构造函数 Promise(excutor)\n\n`Promise` 构造函数是 JavaScript 中用于处理异步操作的一个重要工具。\n\n- **构造函数 `Promise(executor)`**：\n    - `Promise` 构造函数接受一个名为 `executor` 的回调函数作为参数。当你创建一个 `Promise` 实例时，这个 `executor` 函数会被立即执行。\n    - `executor` 函数接收两个参数：`resolve` 和 `reject`。这两个参数也是函数，你可以在 `executor` 函数内部调用它们来改变 `Promise` 的状态。\n- **状态变更**：\n    - 当 `resolve` 被调用时，它会将 `Promise` 的状态从 “pending”（等待）变更为 “fulfilled”（已完成）。\n    - 当 `reject` 被调用时，它会将 `Promise` 的状态从 “pending”（等待）变更为 “rejected”（已失败）。\n    - 如果 `executor` 函数中抛出了一个错误，那么 `Promise` 会自动变更为 “rejected” 状态，并且错误对象会被作为 `reject` 函数的参数传递出去。\n- **返回新的 `Promise`**：\n    - 在 `executor` 函数中，你可以通过 `resolve` 返回一个值，或者通过 `reject` 返回一个错误。\n    - 如果你在 `resolve` 中传递了另一个 `Promise`（比如 `Promise.reject(\"err\")`），那么当前 `Promise` 的状态将会跟随传递进来的 `Promise` 的状态。\n\n这是一个简单的例子来说明这个概念：\n\n```jsx\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  setTimeout(() => {\n    const data = fetchData(); // 假设这是一个获取数据的函数\n    if (data) {\n      resolve(data); // 如果数据获取成功，使用resolve改变Promise状态为fulfilled\n    } else {\n      reject('数据获取失败'); // 如果数据获取失败，使用reject改变Promise状态为rejected\n    }\n  }, 1000);\n});\n\npromise.then(data => {\n  console.log(data); // 如果Promise状态为fulfilled，这里将输出获取到的数据\n}).catch(error => {\n  console.error(error); // 如果Promise状态为rejected，这里将输出错误信息\n});\n\n```\n\n在这个例子中，`promise` 是一个新创建的 `Promise` 对象。我们传递了一个 `executor` 函数给 `Promise` 构造函数，这个函数内部执行了一个异步操作（`setTimeout`）。当异步操作完成后，我们根据结果调用 `resolve` 或 `reject` 来改变 `Promise` 的状态。然后我们可以使用 `.then()` 和 `.catch()` 方法来处理 `Promise` 成功或失败的结果。\n\n## 实例方法\n\n### then(onFulfilled, onRejected)\n\n![20240609140952](https://img.ma5hr00m.top/blog/20240609140952.png)\n\n`then(onFulfilled, onRejected)` 方法是 `Promise` 对象的一个非常重要的特性，它允许你为 `Promise` 注册 `onFulfilled` 和 `onRejected` 回调函数。\n\n- **作用**：\n    - 为 `Promise` 注册 `onFulfilled` 和 `onRejected` 回调函数，这些函数分别在 `Promise` 成功（fulfilled）或失败（rejected）时被调用。\n    - 返回一个新的 `Promise` 对象，使得可以实现链式调用。这意味着你可以在一个 `then` 调用后继续添加更多的 `then` 或 `catch` 方法。\n- **特性**：\n    - `then` 方法会自动返回一个新的 `Promise` 对象。这个新的 `Promise` 对象的状态（fulfilled 或 rejected）将由 `onFulfilled` 或 `onRejected` 回调函数的返回值决定。\n    - 如果 `onFulfilled` 或 `onRejected` 回调函数返回一个值，那么新的 `Promise` 将以这个值为结果被解决（resolve）。\n    - 如果回调函数返回另一个 `Promise`，那么新的 `Promise` 将“跟随”这个 `Promise` 的状态，即如果返回的 `Promise` 被解决，新的 `Promise` 也会被解决；如果返回的 `Promise` 被拒绝，新的 `Promise` 也会被拒绝。\n\n这种机制允许你创建复杂的异步代码序列，其中一个操作的完成可以链接到下一个操作，而不需要嵌套回调函数。这样做可以提高代码的可读性和可维护性。\n\n例如，你可以这样使用 `then` 方法：\n\n```jsx\ndoSomething()\n  .then(function(result) {\n    return doSomethingElse(result);\n  })\n  .then(function(newResult) {\n    return doThirdThing(newResult);\n  })\n  .then(function(finalResult) {\n    console.log('最终结果: ' + finalResult);\n  })\n  .catch(failureCallback);\n\n```\n\n在这个例子中，每个 `then` 都返回一个新的 `Promise`，并且每个 `Promise` 的解决值都是上一个回调函数的返回值。如果在任何一个步骤中出现错误，`catch` 方法将捕获这个错误，你可以在这里处理错误。这就是 `Promise` 链式调用的强大之处。\n\n### catch(onRejected)\n\n`catch(onRejected)` 方法是 `Promise` 对象的一个方法，它用于处理 `Promise` 被拒绝（即执行了 `reject` 函数）的情况。\n\n- **作用**：\n    - `catch(onRejected)` 方法为 `Promise` 添加一个 `onRejected` 回调函数，这个函数在 `Promise` 被拒绝时执行。\n- **特性**：\n    - `catch` 方法会返回一个新的 `Promise` 对象。\n    - 这个新的 `Promise` 将以 `catch` 方法中回调函数的返回值来解决（resolve）。\n\n```jsx\nconst promise = new Promise((resolve, reject) => {\n  // 这里的 Promise 被明确地拒绝了\n  reject(100);\n});\n\npromise\n  .catch((reason) => {\n    // 这里处理 Promise 被拒绝的情况\n    console.log(reason); // 输出：100\n    return 200; // 'catch' 函数的返回值将作为新 Promise 的解决结果\n  })\n  .then((res) => {\n    // 这里处理上一个 'catch' 返回的新 Promise 的解决结果\n    console.log(res); // 输出：200\n  });\n```\n\n在以上代码示例中，`promise` 是一个被明确拒绝（`reject(100)`）的 `Promise` 对象。当 `promise` 被拒绝时，`.catch` 方法中的回调函数被调用，并打印出拒绝的原因（在这个例子中是数字 `100`）。然后，`catch` 方法中的回调函数返回了一个值 `200`，这个值将作为新 `Promise` 的解决结果。\n\n接下来，`.then` 方法被用来处理这个新 `Promise` 的解决结果。因为 `catch` 方法返回的新 `Promise` 被解决（resolve）了，所以 `.then` 方法中的回调函数会被执行，并打印出 `200`。\n\n通过这种方式，`catch` 不仅允许我们处理错误，还可以恢复代码执行流程，允许后续的 `then` 方法继续正常工作。这是 `Promise` 链式调用中错误处理的一个重要部分。\n\n### finally(finallyCallback)\n\n`finally(finallyCallback)` 方法是 `Promise` 对象的一个方法，它允许你添加一个不依赖于 `Promise` 最终状态的回调函数。这个 `finallyCallback` 无论 `Promise` 成功（resolved）还是失败（rejected），都会被执行。\n\n- **作用**：\n    - `finally(finallyCallback)` 方法给 `Promise` 添加一个事件处理回调函数，这个函数在 `Promise` 完成后总会执行。\n- **特性**：\n    - `finally` 方法不接收任何参数，这意味着你不能从 `finallyCallback` 内部获取到 `Promise` 的执行结果。\n    - `finally` 方法会返回一个新的 `Promise`。这个新的 `Promise` 通常与原始 `Promise` 有相同的状态和值，除非 `finallyCallback` 中抛出了异常或返回了一个被拒绝的 `Promise`。\n\n```jsx\nconst promise = new Promise((resolve, reject) => {\n  // 这里的 Promise 被解决了\n  resolve(100);\n});\n\npromise\n  .finally(() => {\n    // 'finally' 回调函数无论成功或者失败，始终会被执行\n    console.log(\"finally回调函数无论成功或者失败，始终会被执行\");\n    // 'finally' 回调函数内获取不到promise执行结果，所以这里打印 undefined\n    console.log(res); // 输出：undefined\n  })\n  .then((res) => {\n    // 'finally' 回调函数返回一个新的promise，实现链式调用\n    // 这里的 'res' 是上一个 'resolve' 的结果\n    console.log(res); // 输出：100\n  });\n```\n\n在以上代码示例中，`promise` 是一个被解决（`resolve(100)`）的 `Promise` 对象。`.finally` 方法添加了一个回调函数，这个函数会在 `Promise` 完成后执行，但它不会接收任何参数，因此 `console.log(res);` 中的 `res` 是 `undefined`。\n\n然后，`.then` 方法处理 `Promise` 的解决结果。由于 `finally` 方法不改变 `Promise` 的状态或值（除非抛出异常或返回被拒绝的 `Promise`），所以 `.then` 方法中的回调函数会接收到 `100` 并打印出来。\n\n`finally` 方法通常用于执行清理操作，例如关闭文件、清除超时等，这些操作不依赖于操作的成功或失败。这使得代码更加简洁，因为你不需要在 `then` 和 `catch` 中重复相同的清理逻辑。\n\n## 静态方法\n\n### Promise.all(promiseArray)\n\n`Promise.all(promiseArray)` 是一个用于处理多个 `Promise` 对象的方法。它接受一个数组作为参数，这个数组可以包含 `Promise` 对象或其他值。\n\n- **作用**：\n    - `Promise.all` 接受一个数组作为参数，这个数组中可以包含 `Promise` 对象和其他类型的值。\n    - 它将并发执行数组中的所有 `Promise` 对象，并且会等待所有 `Promise` 对象执行完毕。\n- **特性**：\n    - 执行结果会以数组形式返回，数组中的元素顺序与传入的 `promiseArray` 一一对应。\n    - 如果数组中的元素是普通值，`Promise.all` 会直接将这些值放入结果数组中。\n    - 如果数组中的元素是 `Promise` 对象，`Promise.all` 会等待这些 `Promise` 对象执行结束，并将结果放入返回的数组中。\n\n```jsx\n// 创建两个 Promise 对象\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"p1\");\n  }, 2000);\n});\nconst promise2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"p2\");\n  }, 1000);\n});\n\n// 使用 Promise.all 处理包含普通值和 Promise 对象的数组\nconst promiseAll = Promise.all([1, 2, promise1, 3, 4, promise2, 5]);\npromiseAll.then((res) => {\n  // 并发执行 Promise，等待所有任务执行完毕后统一返回结果\n  console.log(res); // 输出：[1, 2, \"p1\", 3, 4, \"p2\", 5]\n});\n\n// 如果数组中的任何一个 Promise 执行失败，整个 Promise.all 将执行失败\nconst promiseAllFail = Promise.all([1, 2, promise1, 3, 4, Promise.reject('失败'), 5]);\npromiseAllFail.then((res) => {\n  console.log(res);\n}).catch(e => {\n  // 任何一个任务失败，将导致整个 Promise.all 执行失败\n  console.log('fail', e); // 输出：fail 失败\n});\n\n```\n\n在代码示例中，`promise1` 和 `promise2` 是两个 `Promise` 对象，它们分别在 2000 毫秒和 1000 毫秒后解决。`promise2` 被拒绝了。在这种情况下，`Promise.all` 返回的 `Promise` 也会被拒绝，并且 `catch` 方法会被调用。这意味着，如果 `promiseArray` 中任何一个 `Promise` 对象被拒绝，`Promise.all` 返回的 `Promise` 也会被拒绝，即使其他 `Promise` 对象已经成功解决。\n\n### Promise.allSettled\n\n`Promise.allSettled` 允许你同时处理多个 promise。这个方法会等待所有传入的 promises 要么完成（fulfilled），要么拒绝（rejected），然后返回一个对象数组，每个对象表示对应的 promise 结果。\n\n- **特性**\n    - **返回值**：它返回一个 promise，该 promise 在所有给定的 promises 已经完成或拒绝后解决。\n    - **结果对象**：每个结果都是一个对象，包含两个属性：`status` 和 `value` 或 `reason`。如果 promise 成功完成，`status` 为 `'fulfilled'`，并且 `value` 属性会包含 promise 的结果。如果 promise 被拒绝，`status` 为 `'rejected'`，并且 `reason` 属性会包含拒绝的原因。\n    - **错误处理**：与 `Promise.all` 不同，`Promise.allSettled` 不会在遇到第一个拒绝的 promise 时立即拒绝。它会等待所有的 promises 都已经完成或拒绝，给你一个完整的结果集。\n\n这里就不给代码示范了，直接把这个方法当作 `.all` 的改版就行。但注意，虽然 `Promise.allSettled` 目前已经是 ECMAScript 2020 标准的一部分，但在一些旧的浏览器版本中可能不被支持。在使用之前，最好检查目标环境是否支持这个特性。如果不支持，就需要使用一个 polyfill 来提供相同的功能。\n\n### **Promise.race**\n\n**`Promise.race`** 用来处理多个 promises。这个方法接受一个 promise 数组作为输入，并且会返回一个新的 promise，这个新的 promise 会以数组中**第一个**完成（无论是解决还是拒绝）的 promise 的结果来解决。\n\n- 特征\n    - **并发执行**：传入的所有 promises 会同时开始执行。\n    - **快速响应**：只要数组中的任何一个 promise 完成，**`Promise.race`** 就会立即解决。\n    - **结果**：返回的 promise 的结果是数组中第一个完成的 promise 的结果。\n    - **用途**：常用于实现超时功能，例如，如果一个网络请求在指定时间内没有响应，就会被认为是超时。\n\n```jsx\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"p1\");\n  }, 2000);\n});\nconst promise2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"p2\");\n  }, 1000);\n});\nconst promise3 = new Promise((resolve, reject) => {\n  // 假设500毫秒后网络超时\n  setTimeout(() => {\n    reject(\"超时了\");\n  }, 500);\n});\n\nconst promiseRace = Promise.race([promise1, promise2, promise3]);\npromiseRace\n  .then((res) => {\n    // 这里会打印出 \"超时了\"，因为 promise3 是最快完成的\n    console.log(res);\n  })\n  .catch((e) => {\n    // 如果 promise3 被拒绝，错误会在这里被捕获\n    console.log(\"fail\", e);\n  });\n```\n\n代码示例中，**`promise1`**、**`promise2`** 和 **`promise3`** 分别设置了不同的超时时间。**`Promise.race`** 会返回最快完成的 promise 的结果。在这个例子中，**`promise3`** 由于设置了最短的超时时间（500毫秒），所以它会首先完成，无论是解决还是拒绝，**`Promise.race`** 都会以 **`promise3`** 的结果来解决。\n\n在实际应用中，**`Promise.race`** 可以帮助你确保你的程序在遇到慢网络连接或者其他可能导致延迟的情况时，能够及时响应。\n\n### **Promise.reject**\n\n**`Promise.reject`** 方法在 JavaScript 中用于创建一个状态为拒绝（rejected）的 Promise。这个方法通常用于测试或者当你需要一个已知会失败的 Promise 时。\n\n- 特征\n    - 你可以传递任何理由（reason），这个理由会被传递给 **`.catch()`** 方法的回调函数。\n\n```jsx\nPromise.reject(\"rejected\")\n  .then((res) => {\n    // 这个回调不会被调用，因为 Promise 已经被拒绝\n    console.log('value', res);\n  })\n  .catch((reason) => {\n    // 这个回调会被调用，打印出 \"reason rejected\"\n    console.log('reason', reason);\n  });\n```\n\n代码示例中，**`Promise.reject`** 被用来创建一个立即失败的 Promise，并且提供了一个字符串 “rejected” 作为失败的理由。然后，使用 **`.then()`** 方法来设置一个处理成功解决的回调函数，以及使用 **`.catch()`** 方法来设置一个处理拒绝的回调函数。\n\n在实际应用中，**`Promise.reject`** 可以用于快速创建一个失败的 Promise，以便于在函数中进行错误处理或者在测试中模拟失败的异步操作。\n\n### Promise.resolve\n\n`Promise.resolve` 方法在 JavaScript 中用于创建一个状态为解决（fulfilled）的 Promise。这个方法可以接受任何值，并返回一个以该值解决的 Promise。\n\n- **特征**\n    - **普通值**：如果传递给 `Promise.resolve` 的是一个普通值，它会返回一个新的 Promise，该 Promise 会立即以该值解决。\n    - **Promise 值**：如果传递的值本身是一个 Promise，`Promise.resolve` 将不会创建一个新的 Promise，而是返回那个原始的 Promise。\n\n```jsx\n// 创建一个立即解决为100的Promise\nPromise.resolve(100).then((res) => {\n  // 这个回调会被调用，打印出100\n  console.log(res); //100\n});\n\n// 创建一个新的Promise，它将会被拒绝\nconst promise = new Promise((resolve, reject) => {\n  reject(200);\n});\n// 这里的.then()没有提供拒绝处理函数，所以拒绝将不会被处理\npromise\n  .then((res) => {\n    // 这个回调不会被调用，因为Promise已经被拒绝\n    console.log(res);\n  });\n\n```\n\n代码示例中，`Promise.resolve` 被用来创建一个立即以数字 `100` 解决的 Promise。然后，使用 `.then()` 方法来设置一个处理解决的回调函数。\n\n请注意，第二个例子中的 Promise 被拒绝了，但是没有提供 `.catch()` 方法或拒绝处理函数，所以拒绝不会被捕获或处理。在实际应用中，`Promise.resolve` 可以用于确保有一个解决的 Promise，这在处理同步和异步代码时非常有用。\n\n## 实现一个 Promise\n\n[segmentfault.com](https://segmentfault.com/a/1190000041414230)\n\n```jsx\nclass myPromise {\n    static PENDING = 'pending'\n    static FULFILLEd = 'fulfilled'\n    static REJECTED = 'rejected'\n    constructor(init){\n        this.state = myPromise.PENDING // promise状态\n        this.promiseRes = null  // promise返回值\n        this.resolveCallback = [] //成功回调集合\n        this.rejectCallback = [] //失败回调集合\n        const resolve = result=>{\n            // 只有当状态为pending时才改变，保证状态一旦改变就不会再变\n            if(this.state === myPromise.PENDING){\n                this.state = myPromise.FULFILLEd //改变状态\n                this.promiseRes = result //返回值\n                //依次调用成功回调\n                this.resolveCallback.forEach(fn=>fn())\n            }\n        }\n        const reject = result=>{\n            // 只有当状态为pending时才改变，保证状态一旦改变就不会再变\n            if(this.state === myPromise.PENDING){\n                this.state = myPromise.REJECTED //改变状态\n                this.promiseRes = result //返回值\n                // 依次调用失败回调\n                this.rejectCallback.forEach(fn=>fn())\n            }\n        }\n        try{\n            init(resolve,reject)  // 注意this指向\n        }catch(err){\n            reject(err)\n        }\n        \n    }\n    then(onFulfilled,onRejected){\n        const {promiseRes,state} = this\n        let promise = new myPromise((reso,reje)=>{\n            const resolveMyPromise = promiseRes => {\n                try{\n                    if(typeof onFulfilled !== 'function'){\n                        // 如果then的第一个回调不是一个函数，直接忽略，返回一个新的promise\n                        reso(promiseRes)\n                    }else{\n                        // 获取第一个回调的执行结果\n                        const res = onFulfilled(promiseRes)\n                        // 看该执行结果是否是一个promise\n                        if(res instanceof myPromise){\n                            // 是一个promise,等它状态改变后再改变then返回的promise状态\n                            res.then(reso,rej) \n                        }else{\n                            // 不是一个promise，将它作为新的promise的resolve\n                            reso(res)\n                        }\n                    }\n                }catch(err){\n                    //异常，直接将新的promise状态置为rejected\n                    reje(err)\n                }\n            }\n            const rejectMyPromise = promiseRes => {\n                try{\n                    if(typeof onRejected !== 'function'){\n                        // 如果then的第二个回调不是一个函数，直接忽略，返回一个新的promise\n                        reje(promiseRes)\n                    }else{\n                        // 获取第二个回调的执行结果\n                        const res = onRejected(promiseRes)\n                        // 看该执行结果是否是一个promise\n                        if(res instanceof myPromise){\n                            // 是一个promise,等它状态改变后再改变then返回的promise状态\n                            res.then(reso,rej) \n                        }else{\n                            // 不是一个promise，将它作为新的promise的resolve\n                            reje(res)\n                        }\n                    }\n                    \n                }catch(err){\n                    //异常，直接将新的promise状态置为rejected\n                    reje(err)\n                }\n            }\n            if(state === myPromise.FULFILLEd) {\n                resolveMyPromise(promiseRes)\n            }\n            if(state === myPromise.REJECTED) {\n                rejectMyPromise(promiseRes)\n            }\n            if(state === myPromise.PENDING){\n                if(onFulfilled && typeof onFulfilled === 'function'){\n                    this.resolveCallback.push(()=>\n                    // 这里我们用setTimeout来模拟实现then的微任务\n                    setTimeout(()=>{\n                        resolveMyPromise(this.promiseRes)\n                    },0)\n                    )\n                }\n                if(onRejected && typeof onRejected === 'function'){\n                    this.rejectCallback.push(()=>\n                    // 这里我们用setTimeout来模拟实现then的微任务\n                    setTimeout(()=>{\n                        rejectMyPromise(this.promiseRes)\n                    },0)\n                    )\n                }\n            }\n\n        })\n        return promise\n    }\n    catch(onRejected) {\n        return this.then(undefined,onRejected)\n    }\n    static all (promises){\n        return new myPromise((res,rej)=>{\n            let count = 0\n            const result = [];\n            function addFun(index,resf) {\n                result[index]=resf // 这里用索引别用push,保证返回的顺序\n                count++\n                if(count==promises.length) {\n                    res(result)\n                }\n            }\n            [].forEach.call(promises,(promise,index)=>{\n                if(promise instanceof myPromise) {\n                    promise.then(success=>{\n                        addFun(index,success)\n                    },err=>{\n                        rej(err)\n                    })\n                }else{\n                    addFun(index,promise)\n                }\n            })\n        })\n    }\n    static race(promises) {\n        return new myPromise((res,rej)=>{\n            [].forEach.call(promises,promise=>{\n                if(promise instanceof myPromise){\n                    promise.then(success=>{\n                        res(success)\n                    },error=>{\n                        rej(error)\n                    })\n                }else{\n                    res(promise)\n                } \n            })\n        })\n    }\n    static resolve(v){\n        //1.参数是一个Promise实例,直接返回\n        if(v instanceof myPromise){\n            return v\n        }\n        //2.参数是一个thenable对象，转为Promise后执行该对象的then方法\n        if(typeof v === 'object' && typeof v.then === 'function'){\n            return new myPromise((res,rej)=>{\n                v.then(res,rej)\n            })\n        }\n        //3.没有参数，直接返回一个resolved状态的promise\n        if(!v){\n            return new myPromise(res=>{\n                res()\n            })\n        }\n        //4.参数是一个原始值，返回一个新的Promise，状态为resolved\n        return new myPromise(res=>{\n            res(v)\n        })\n    }\n    static reject(v){\n        return new myPromise((res,rej)=>{\n            rej(v)\n        })\n    }\n}\n```","source":"_posts/promise.md","raw":"---\ntitle: Promise 使用一览\ndate: 2024/6/9\nauthor: ma5hr00m\ncategories:\n- JavaScript\n---\n\nPromise 规范最早由 CommonJS 社区提出，后来成为 ES2015（ES6） 语言规范，到现在可以说已经成了异步编程的首选方案。\n\n- [使用 Promise - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)\n- [Promise](https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544)\n\n## 状态\n\n- `Penfing`  等待\n- `Fulfilled` 成功\n- `rejected` 失败\n\n## 构造函数 Promise(excutor)\n\n`Promise` 构造函数是 JavaScript 中用于处理异步操作的一个重要工具。\n\n- **构造函数 `Promise(executor)`**：\n    - `Promise` 构造函数接受一个名为 `executor` 的回调函数作为参数。当你创建一个 `Promise` 实例时，这个 `executor` 函数会被立即执行。\n    - `executor` 函数接收两个参数：`resolve` 和 `reject`。这两个参数也是函数，你可以在 `executor` 函数内部调用它们来改变 `Promise` 的状态。\n- **状态变更**：\n    - 当 `resolve` 被调用时，它会将 `Promise` 的状态从 “pending”（等待）变更为 “fulfilled”（已完成）。\n    - 当 `reject` 被调用时，它会将 `Promise` 的状态从 “pending”（等待）变更为 “rejected”（已失败）。\n    - 如果 `executor` 函数中抛出了一个错误，那么 `Promise` 会自动变更为 “rejected” 状态，并且错误对象会被作为 `reject` 函数的参数传递出去。\n- **返回新的 `Promise`**：\n    - 在 `executor` 函数中，你可以通过 `resolve` 返回一个值，或者通过 `reject` 返回一个错误。\n    - 如果你在 `resolve` 中传递了另一个 `Promise`（比如 `Promise.reject(\"err\")`），那么当前 `Promise` 的状态将会跟随传递进来的 `Promise` 的状态。\n\n这是一个简单的例子来说明这个概念：\n\n```jsx\nconst promise = new Promise((resolve, reject) => {\n  // 异步操作\n  setTimeout(() => {\n    const data = fetchData(); // 假设这是一个获取数据的函数\n    if (data) {\n      resolve(data); // 如果数据获取成功，使用resolve改变Promise状态为fulfilled\n    } else {\n      reject('数据获取失败'); // 如果数据获取失败，使用reject改变Promise状态为rejected\n    }\n  }, 1000);\n});\n\npromise.then(data => {\n  console.log(data); // 如果Promise状态为fulfilled，这里将输出获取到的数据\n}).catch(error => {\n  console.error(error); // 如果Promise状态为rejected，这里将输出错误信息\n});\n\n```\n\n在这个例子中，`promise` 是一个新创建的 `Promise` 对象。我们传递了一个 `executor` 函数给 `Promise` 构造函数，这个函数内部执行了一个异步操作（`setTimeout`）。当异步操作完成后，我们根据结果调用 `resolve` 或 `reject` 来改变 `Promise` 的状态。然后我们可以使用 `.then()` 和 `.catch()` 方法来处理 `Promise` 成功或失败的结果。\n\n## 实例方法\n\n### then(onFulfilled, onRejected)\n\n![20240609140952](https://img.ma5hr00m.top/blog/20240609140952.png)\n\n`then(onFulfilled, onRejected)` 方法是 `Promise` 对象的一个非常重要的特性，它允许你为 `Promise` 注册 `onFulfilled` 和 `onRejected` 回调函数。\n\n- **作用**：\n    - 为 `Promise` 注册 `onFulfilled` 和 `onRejected` 回调函数，这些函数分别在 `Promise` 成功（fulfilled）或失败（rejected）时被调用。\n    - 返回一个新的 `Promise` 对象，使得可以实现链式调用。这意味着你可以在一个 `then` 调用后继续添加更多的 `then` 或 `catch` 方法。\n- **特性**：\n    - `then` 方法会自动返回一个新的 `Promise` 对象。这个新的 `Promise` 对象的状态（fulfilled 或 rejected）将由 `onFulfilled` 或 `onRejected` 回调函数的返回值决定。\n    - 如果 `onFulfilled` 或 `onRejected` 回调函数返回一个值，那么新的 `Promise` 将以这个值为结果被解决（resolve）。\n    - 如果回调函数返回另一个 `Promise`，那么新的 `Promise` 将“跟随”这个 `Promise` 的状态，即如果返回的 `Promise` 被解决，新的 `Promise` 也会被解决；如果返回的 `Promise` 被拒绝，新的 `Promise` 也会被拒绝。\n\n这种机制允许你创建复杂的异步代码序列，其中一个操作的完成可以链接到下一个操作，而不需要嵌套回调函数。这样做可以提高代码的可读性和可维护性。\n\n例如，你可以这样使用 `then` 方法：\n\n```jsx\ndoSomething()\n  .then(function(result) {\n    return doSomethingElse(result);\n  })\n  .then(function(newResult) {\n    return doThirdThing(newResult);\n  })\n  .then(function(finalResult) {\n    console.log('最终结果: ' + finalResult);\n  })\n  .catch(failureCallback);\n\n```\n\n在这个例子中，每个 `then` 都返回一个新的 `Promise`，并且每个 `Promise` 的解决值都是上一个回调函数的返回值。如果在任何一个步骤中出现错误，`catch` 方法将捕获这个错误，你可以在这里处理错误。这就是 `Promise` 链式调用的强大之处。\n\n### catch(onRejected)\n\n`catch(onRejected)` 方法是 `Promise` 对象的一个方法，它用于处理 `Promise` 被拒绝（即执行了 `reject` 函数）的情况。\n\n- **作用**：\n    - `catch(onRejected)` 方法为 `Promise` 添加一个 `onRejected` 回调函数，这个函数在 `Promise` 被拒绝时执行。\n- **特性**：\n    - `catch` 方法会返回一个新的 `Promise` 对象。\n    - 这个新的 `Promise` 将以 `catch` 方法中回调函数的返回值来解决（resolve）。\n\n```jsx\nconst promise = new Promise((resolve, reject) => {\n  // 这里的 Promise 被明确地拒绝了\n  reject(100);\n});\n\npromise\n  .catch((reason) => {\n    // 这里处理 Promise 被拒绝的情况\n    console.log(reason); // 输出：100\n    return 200; // 'catch' 函数的返回值将作为新 Promise 的解决结果\n  })\n  .then((res) => {\n    // 这里处理上一个 'catch' 返回的新 Promise 的解决结果\n    console.log(res); // 输出：200\n  });\n```\n\n在以上代码示例中，`promise` 是一个被明确拒绝（`reject(100)`）的 `Promise` 对象。当 `promise` 被拒绝时，`.catch` 方法中的回调函数被调用，并打印出拒绝的原因（在这个例子中是数字 `100`）。然后，`catch` 方法中的回调函数返回了一个值 `200`，这个值将作为新 `Promise` 的解决结果。\n\n接下来，`.then` 方法被用来处理这个新 `Promise` 的解决结果。因为 `catch` 方法返回的新 `Promise` 被解决（resolve）了，所以 `.then` 方法中的回调函数会被执行，并打印出 `200`。\n\n通过这种方式，`catch` 不仅允许我们处理错误，还可以恢复代码执行流程，允许后续的 `then` 方法继续正常工作。这是 `Promise` 链式调用中错误处理的一个重要部分。\n\n### finally(finallyCallback)\n\n`finally(finallyCallback)` 方法是 `Promise` 对象的一个方法，它允许你添加一个不依赖于 `Promise` 最终状态的回调函数。这个 `finallyCallback` 无论 `Promise` 成功（resolved）还是失败（rejected），都会被执行。\n\n- **作用**：\n    - `finally(finallyCallback)` 方法给 `Promise` 添加一个事件处理回调函数，这个函数在 `Promise` 完成后总会执行。\n- **特性**：\n    - `finally` 方法不接收任何参数，这意味着你不能从 `finallyCallback` 内部获取到 `Promise` 的执行结果。\n    - `finally` 方法会返回一个新的 `Promise`。这个新的 `Promise` 通常与原始 `Promise` 有相同的状态和值，除非 `finallyCallback` 中抛出了异常或返回了一个被拒绝的 `Promise`。\n\n```jsx\nconst promise = new Promise((resolve, reject) => {\n  // 这里的 Promise 被解决了\n  resolve(100);\n});\n\npromise\n  .finally(() => {\n    // 'finally' 回调函数无论成功或者失败，始终会被执行\n    console.log(\"finally回调函数无论成功或者失败，始终会被执行\");\n    // 'finally' 回调函数内获取不到promise执行结果，所以这里打印 undefined\n    console.log(res); // 输出：undefined\n  })\n  .then((res) => {\n    // 'finally' 回调函数返回一个新的promise，实现链式调用\n    // 这里的 'res' 是上一个 'resolve' 的结果\n    console.log(res); // 输出：100\n  });\n```\n\n在以上代码示例中，`promise` 是一个被解决（`resolve(100)`）的 `Promise` 对象。`.finally` 方法添加了一个回调函数，这个函数会在 `Promise` 完成后执行，但它不会接收任何参数，因此 `console.log(res);` 中的 `res` 是 `undefined`。\n\n然后，`.then` 方法处理 `Promise` 的解决结果。由于 `finally` 方法不改变 `Promise` 的状态或值（除非抛出异常或返回被拒绝的 `Promise`），所以 `.then` 方法中的回调函数会接收到 `100` 并打印出来。\n\n`finally` 方法通常用于执行清理操作，例如关闭文件、清除超时等，这些操作不依赖于操作的成功或失败。这使得代码更加简洁，因为你不需要在 `then` 和 `catch` 中重复相同的清理逻辑。\n\n## 静态方法\n\n### Promise.all(promiseArray)\n\n`Promise.all(promiseArray)` 是一个用于处理多个 `Promise` 对象的方法。它接受一个数组作为参数，这个数组可以包含 `Promise` 对象或其他值。\n\n- **作用**：\n    - `Promise.all` 接受一个数组作为参数，这个数组中可以包含 `Promise` 对象和其他类型的值。\n    - 它将并发执行数组中的所有 `Promise` 对象，并且会等待所有 `Promise` 对象执行完毕。\n- **特性**：\n    - 执行结果会以数组形式返回，数组中的元素顺序与传入的 `promiseArray` 一一对应。\n    - 如果数组中的元素是普通值，`Promise.all` 会直接将这些值放入结果数组中。\n    - 如果数组中的元素是 `Promise` 对象，`Promise.all` 会等待这些 `Promise` 对象执行结束，并将结果放入返回的数组中。\n\n```jsx\n// 创建两个 Promise 对象\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"p1\");\n  }, 2000);\n});\nconst promise2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"p2\");\n  }, 1000);\n});\n\n// 使用 Promise.all 处理包含普通值和 Promise 对象的数组\nconst promiseAll = Promise.all([1, 2, promise1, 3, 4, promise2, 5]);\npromiseAll.then((res) => {\n  // 并发执行 Promise，等待所有任务执行完毕后统一返回结果\n  console.log(res); // 输出：[1, 2, \"p1\", 3, 4, \"p2\", 5]\n});\n\n// 如果数组中的任何一个 Promise 执行失败，整个 Promise.all 将执行失败\nconst promiseAllFail = Promise.all([1, 2, promise1, 3, 4, Promise.reject('失败'), 5]);\npromiseAllFail.then((res) => {\n  console.log(res);\n}).catch(e => {\n  // 任何一个任务失败，将导致整个 Promise.all 执行失败\n  console.log('fail', e); // 输出：fail 失败\n});\n\n```\n\n在代码示例中，`promise1` 和 `promise2` 是两个 `Promise` 对象，它们分别在 2000 毫秒和 1000 毫秒后解决。`promise2` 被拒绝了。在这种情况下，`Promise.all` 返回的 `Promise` 也会被拒绝，并且 `catch` 方法会被调用。这意味着，如果 `promiseArray` 中任何一个 `Promise` 对象被拒绝，`Promise.all` 返回的 `Promise` 也会被拒绝，即使其他 `Promise` 对象已经成功解决。\n\n### Promise.allSettled\n\n`Promise.allSettled` 允许你同时处理多个 promise。这个方法会等待所有传入的 promises 要么完成（fulfilled），要么拒绝（rejected），然后返回一个对象数组，每个对象表示对应的 promise 结果。\n\n- **特性**\n    - **返回值**：它返回一个 promise，该 promise 在所有给定的 promises 已经完成或拒绝后解决。\n    - **结果对象**：每个结果都是一个对象，包含两个属性：`status` 和 `value` 或 `reason`。如果 promise 成功完成，`status` 为 `'fulfilled'`，并且 `value` 属性会包含 promise 的结果。如果 promise 被拒绝，`status` 为 `'rejected'`，并且 `reason` 属性会包含拒绝的原因。\n    - **错误处理**：与 `Promise.all` 不同，`Promise.allSettled` 不会在遇到第一个拒绝的 promise 时立即拒绝。它会等待所有的 promises 都已经完成或拒绝，给你一个完整的结果集。\n\n这里就不给代码示范了，直接把这个方法当作 `.all` 的改版就行。但注意，虽然 `Promise.allSettled` 目前已经是 ECMAScript 2020 标准的一部分，但在一些旧的浏览器版本中可能不被支持。在使用之前，最好检查目标环境是否支持这个特性。如果不支持，就需要使用一个 polyfill 来提供相同的功能。\n\n### **Promise.race**\n\n**`Promise.race`** 用来处理多个 promises。这个方法接受一个 promise 数组作为输入，并且会返回一个新的 promise，这个新的 promise 会以数组中**第一个**完成（无论是解决还是拒绝）的 promise 的结果来解决。\n\n- 特征\n    - **并发执行**：传入的所有 promises 会同时开始执行。\n    - **快速响应**：只要数组中的任何一个 promise 完成，**`Promise.race`** 就会立即解决。\n    - **结果**：返回的 promise 的结果是数组中第一个完成的 promise 的结果。\n    - **用途**：常用于实现超时功能，例如，如果一个网络请求在指定时间内没有响应，就会被认为是超时。\n\n```jsx\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"p1\");\n  }, 2000);\n});\nconst promise2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"p2\");\n  }, 1000);\n});\nconst promise3 = new Promise((resolve, reject) => {\n  // 假设500毫秒后网络超时\n  setTimeout(() => {\n    reject(\"超时了\");\n  }, 500);\n});\n\nconst promiseRace = Promise.race([promise1, promise2, promise3]);\npromiseRace\n  .then((res) => {\n    // 这里会打印出 \"超时了\"，因为 promise3 是最快完成的\n    console.log(res);\n  })\n  .catch((e) => {\n    // 如果 promise3 被拒绝，错误会在这里被捕获\n    console.log(\"fail\", e);\n  });\n```\n\n代码示例中，**`promise1`**、**`promise2`** 和 **`promise3`** 分别设置了不同的超时时间。**`Promise.race`** 会返回最快完成的 promise 的结果。在这个例子中，**`promise3`** 由于设置了最短的超时时间（500毫秒），所以它会首先完成，无论是解决还是拒绝，**`Promise.race`** 都会以 **`promise3`** 的结果来解决。\n\n在实际应用中，**`Promise.race`** 可以帮助你确保你的程序在遇到慢网络连接或者其他可能导致延迟的情况时，能够及时响应。\n\n### **Promise.reject**\n\n**`Promise.reject`** 方法在 JavaScript 中用于创建一个状态为拒绝（rejected）的 Promise。这个方法通常用于测试或者当你需要一个已知会失败的 Promise 时。\n\n- 特征\n    - 你可以传递任何理由（reason），这个理由会被传递给 **`.catch()`** 方法的回调函数。\n\n```jsx\nPromise.reject(\"rejected\")\n  .then((res) => {\n    // 这个回调不会被调用，因为 Promise 已经被拒绝\n    console.log('value', res);\n  })\n  .catch((reason) => {\n    // 这个回调会被调用，打印出 \"reason rejected\"\n    console.log('reason', reason);\n  });\n```\n\n代码示例中，**`Promise.reject`** 被用来创建一个立即失败的 Promise，并且提供了一个字符串 “rejected” 作为失败的理由。然后，使用 **`.then()`** 方法来设置一个处理成功解决的回调函数，以及使用 **`.catch()`** 方法来设置一个处理拒绝的回调函数。\n\n在实际应用中，**`Promise.reject`** 可以用于快速创建一个失败的 Promise，以便于在函数中进行错误处理或者在测试中模拟失败的异步操作。\n\n### Promise.resolve\n\n`Promise.resolve` 方法在 JavaScript 中用于创建一个状态为解决（fulfilled）的 Promise。这个方法可以接受任何值，并返回一个以该值解决的 Promise。\n\n- **特征**\n    - **普通值**：如果传递给 `Promise.resolve` 的是一个普通值，它会返回一个新的 Promise，该 Promise 会立即以该值解决。\n    - **Promise 值**：如果传递的值本身是一个 Promise，`Promise.resolve` 将不会创建一个新的 Promise，而是返回那个原始的 Promise。\n\n```jsx\n// 创建一个立即解决为100的Promise\nPromise.resolve(100).then((res) => {\n  // 这个回调会被调用，打印出100\n  console.log(res); //100\n});\n\n// 创建一个新的Promise，它将会被拒绝\nconst promise = new Promise((resolve, reject) => {\n  reject(200);\n});\n// 这里的.then()没有提供拒绝处理函数，所以拒绝将不会被处理\npromise\n  .then((res) => {\n    // 这个回调不会被调用，因为Promise已经被拒绝\n    console.log(res);\n  });\n\n```\n\n代码示例中，`Promise.resolve` 被用来创建一个立即以数字 `100` 解决的 Promise。然后，使用 `.then()` 方法来设置一个处理解决的回调函数。\n\n请注意，第二个例子中的 Promise 被拒绝了，但是没有提供 `.catch()` 方法或拒绝处理函数，所以拒绝不会被捕获或处理。在实际应用中，`Promise.resolve` 可以用于确保有一个解决的 Promise，这在处理同步和异步代码时非常有用。\n\n## 实现一个 Promise\n\n[segmentfault.com](https://segmentfault.com/a/1190000041414230)\n\n```jsx\nclass myPromise {\n    static PENDING = 'pending'\n    static FULFILLEd = 'fulfilled'\n    static REJECTED = 'rejected'\n    constructor(init){\n        this.state = myPromise.PENDING // promise状态\n        this.promiseRes = null  // promise返回值\n        this.resolveCallback = [] //成功回调集合\n        this.rejectCallback = [] //失败回调集合\n        const resolve = result=>{\n            // 只有当状态为pending时才改变，保证状态一旦改变就不会再变\n            if(this.state === myPromise.PENDING){\n                this.state = myPromise.FULFILLEd //改变状态\n                this.promiseRes = result //返回值\n                //依次调用成功回调\n                this.resolveCallback.forEach(fn=>fn())\n            }\n        }\n        const reject = result=>{\n            // 只有当状态为pending时才改变，保证状态一旦改变就不会再变\n            if(this.state === myPromise.PENDING){\n                this.state = myPromise.REJECTED //改变状态\n                this.promiseRes = result //返回值\n                // 依次调用失败回调\n                this.rejectCallback.forEach(fn=>fn())\n            }\n        }\n        try{\n            init(resolve,reject)  // 注意this指向\n        }catch(err){\n            reject(err)\n        }\n        \n    }\n    then(onFulfilled,onRejected){\n        const {promiseRes,state} = this\n        let promise = new myPromise((reso,reje)=>{\n            const resolveMyPromise = promiseRes => {\n                try{\n                    if(typeof onFulfilled !== 'function'){\n                        // 如果then的第一个回调不是一个函数，直接忽略，返回一个新的promise\n                        reso(promiseRes)\n                    }else{\n                        // 获取第一个回调的执行结果\n                        const res = onFulfilled(promiseRes)\n                        // 看该执行结果是否是一个promise\n                        if(res instanceof myPromise){\n                            // 是一个promise,等它状态改变后再改变then返回的promise状态\n                            res.then(reso,rej) \n                        }else{\n                            // 不是一个promise，将它作为新的promise的resolve\n                            reso(res)\n                        }\n                    }\n                }catch(err){\n                    //异常，直接将新的promise状态置为rejected\n                    reje(err)\n                }\n            }\n            const rejectMyPromise = promiseRes => {\n                try{\n                    if(typeof onRejected !== 'function'){\n                        // 如果then的第二个回调不是一个函数，直接忽略，返回一个新的promise\n                        reje(promiseRes)\n                    }else{\n                        // 获取第二个回调的执行结果\n                        const res = onRejected(promiseRes)\n                        // 看该执行结果是否是一个promise\n                        if(res instanceof myPromise){\n                            // 是一个promise,等它状态改变后再改变then返回的promise状态\n                            res.then(reso,rej) \n                        }else{\n                            // 不是一个promise，将它作为新的promise的resolve\n                            reje(res)\n                        }\n                    }\n                    \n                }catch(err){\n                    //异常，直接将新的promise状态置为rejected\n                    reje(err)\n                }\n            }\n            if(state === myPromise.FULFILLEd) {\n                resolveMyPromise(promiseRes)\n            }\n            if(state === myPromise.REJECTED) {\n                rejectMyPromise(promiseRes)\n            }\n            if(state === myPromise.PENDING){\n                if(onFulfilled && typeof onFulfilled === 'function'){\n                    this.resolveCallback.push(()=>\n                    // 这里我们用setTimeout来模拟实现then的微任务\n                    setTimeout(()=>{\n                        resolveMyPromise(this.promiseRes)\n                    },0)\n                    )\n                }\n                if(onRejected && typeof onRejected === 'function'){\n                    this.rejectCallback.push(()=>\n                    // 这里我们用setTimeout来模拟实现then的微任务\n                    setTimeout(()=>{\n                        rejectMyPromise(this.promiseRes)\n                    },0)\n                    )\n                }\n            }\n\n        })\n        return promise\n    }\n    catch(onRejected) {\n        return this.then(undefined,onRejected)\n    }\n    static all (promises){\n        return new myPromise((res,rej)=>{\n            let count = 0\n            const result = [];\n            function addFun(index,resf) {\n                result[index]=resf // 这里用索引别用push,保证返回的顺序\n                count++\n                if(count==promises.length) {\n                    res(result)\n                }\n            }\n            [].forEach.call(promises,(promise,index)=>{\n                if(promise instanceof myPromise) {\n                    promise.then(success=>{\n                        addFun(index,success)\n                    },err=>{\n                        rej(err)\n                    })\n                }else{\n                    addFun(index,promise)\n                }\n            })\n        })\n    }\n    static race(promises) {\n        return new myPromise((res,rej)=>{\n            [].forEach.call(promises,promise=>{\n                if(promise instanceof myPromise){\n                    promise.then(success=>{\n                        res(success)\n                    },error=>{\n                        rej(error)\n                    })\n                }else{\n                    res(promise)\n                } \n            })\n        })\n    }\n    static resolve(v){\n        //1.参数是一个Promise实例,直接返回\n        if(v instanceof myPromise){\n            return v\n        }\n        //2.参数是一个thenable对象，转为Promise后执行该对象的then方法\n        if(typeof v === 'object' && typeof v.then === 'function'){\n            return new myPromise((res,rej)=>{\n                v.then(res,rej)\n            })\n        }\n        //3.没有参数，直接返回一个resolved状态的promise\n        if(!v){\n            return new myPromise(res=>{\n                res()\n            })\n        }\n        //4.参数是一个原始值，返回一个新的Promise，状态为resolved\n        return new myPromise(res=>{\n            res(v)\n        })\n    }\n    static reject(v){\n        return new myPromise((res,rej)=>{\n            rej(v)\n        })\n    }\n}\n```","slug":"promise","published":1,"updated":"2024-06-12T02:37:18.008Z","comments":1,"layout":"post","photos":[],"_id":"clxhruapa0018f4ly70f0g35g","content":"<p>Promise 规范最早由 CommonJS 社区提出，后来成为 ES2015（ES6） 语言规范，到现在可以说已经成了异步编程的首选方案。</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises\">使用 Promise - JavaScript | MDN</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544\">Promise</a></li>\n</ul>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><ul>\n<li><code>Penfing</code>  等待</li>\n<li><code>Fulfilled</code> 成功</li>\n<li><code>rejected</code> 失败</li>\n</ul>\n<h2 id=\"构造函数-Promise-excutor\"><a href=\"#构造函数-Promise-excutor\" class=\"headerlink\" title=\"构造函数 Promise(excutor)\"></a>构造函数 Promise(excutor)</h2><p><code>Promise</code> 构造函数是 JavaScript 中用于处理异步操作的一个重要工具。</p>\n<ul>\n<li>**构造函数 <code>Promise(executor)</code>**：<ul>\n<li><code>Promise</code> 构造函数接受一个名为 <code>executor</code> 的回调函数作为参数。当你创建一个 <code>Promise</code> 实例时，这个 <code>executor</code> 函数会被立即执行。</li>\n<li><code>executor</code> 函数接收两个参数：<code>resolve</code> 和 <code>reject</code>。这两个参数也是函数，你可以在 <code>executor</code> 函数内部调用它们来改变 <code>Promise</code> 的状态。</li>\n</ul>\n</li>\n<li><strong>状态变更</strong>：<ul>\n<li>当 <code>resolve</code> 被调用时，它会将 <code>Promise</code> 的状态从 “pending”（等待）变更为 “fulfilled”（已完成）。</li>\n<li>当 <code>reject</code> 被调用时，它会将 <code>Promise</code> 的状态从 “pending”（等待）变更为 “rejected”（已失败）。</li>\n<li>如果 <code>executor</code> 函数中抛出了一个错误，那么 <code>Promise</code> 会自动变更为 “rejected” 状态，并且错误对象会被作为 <code>reject</code> 函数的参数传递出去。</li>\n</ul>\n</li>\n<li>**返回新的 <code>Promise</code>**：<ul>\n<li>在 <code>executor</code> 函数中，你可以通过 <code>resolve</code> 返回一个值，或者通过 <code>reject</code> 返回一个错误。</li>\n<li>如果你在 <code>resolve</code> 中传递了另一个 <code>Promise</code>（比如 <code>Promise.reject(&quot;err&quot;)</code>），那么当前 <code>Promise</code> 的状态将会跟随传递进来的 <code>Promise</code> 的状态。</li>\n</ul>\n</li>\n</ul>\n<p>这是一个简单的例子来说明这个概念：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 异步操作</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"title function_\">fetchData</span>(); <span class=\"comment\">// 假设这是一个获取数据的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(data); <span class=\"comment\">// 如果数据获取成功，使用resolve改变Promise状态为fulfilled</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;数据获取失败&#x27;</span>); <span class=\"comment\">// 如果数据获取失败，使用reject改变Promise状态为rejected</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data); <span class=\"comment\">// 如果Promise状态为fulfilled，这里将输出获取到的数据</span></span><br><span class=\"line\">&#125;).<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error); <span class=\"comment\">// 如果Promise状态为rejected，这里将输出错误信息</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>promise</code> 是一个新创建的 <code>Promise</code> 对象。我们传递了一个 <code>executor</code> 函数给 <code>Promise</code> 构造函数，这个函数内部执行了一个异步操作（<code>setTimeout</code>）。当异步操作完成后，我们根据结果调用 <code>resolve</code> 或 <code>reject</code> 来改变 <code>Promise</code> 的状态。然后我们可以使用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理 <code>Promise</code> 成功或失败的结果。</p>\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><h3 id=\"then-onFulfilled-onRejected\"><a href=\"#then-onFulfilled-onRejected\" class=\"headerlink\" title=\"then(onFulfilled, onRejected)\"></a>then(onFulfilled, onRejected)</h3><p><img src=\"https://img.ma5hr00m.top/blog/20240609140952.png\" alt=\"20240609140952\"></p>\n<p><code>then(onFulfilled, onRejected)</code> 方法是 <code>Promise</code> 对象的一个非常重要的特性，它允许你为 <code>Promise</code> 注册 <code>onFulfilled</code> 和 <code>onRejected</code> 回调函数。</p>\n<ul>\n<li><strong>作用</strong>：<ul>\n<li>为 <code>Promise</code> 注册 <code>onFulfilled</code> 和 <code>onRejected</code> 回调函数，这些函数分别在 <code>Promise</code> 成功（fulfilled）或失败（rejected）时被调用。</li>\n<li>返回一个新的 <code>Promise</code> 对象，使得可以实现链式调用。这意味着你可以在一个 <code>then</code> 调用后继续添加更多的 <code>then</code> 或 <code>catch</code> 方法。</li>\n</ul>\n</li>\n<li><strong>特性</strong>：<ul>\n<li><code>then</code> 方法会自动返回一个新的 <code>Promise</code> 对象。这个新的 <code>Promise</code> 对象的状态（fulfilled 或 rejected）将由 <code>onFulfilled</code> 或 <code>onRejected</code> 回调函数的返回值决定。</li>\n<li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 回调函数返回一个值，那么新的 <code>Promise</code> 将以这个值为结果被解决（resolve）。</li>\n<li>如果回调函数返回另一个 <code>Promise</code>，那么新的 <code>Promise</code> 将“跟随”这个 <code>Promise</code> 的状态，即如果返回的 <code>Promise</code> 被解决，新的 <code>Promise</code> 也会被解决；如果返回的 <code>Promise</code> 被拒绝，新的 <code>Promise</code> 也会被拒绝。</li>\n</ul>\n</li>\n</ul>\n<p>这种机制允许你创建复杂的异步代码序列，其中一个操作的完成可以链接到下一个操作，而不需要嵌套回调函数。这样做可以提高代码的可读性和可维护性。</p>\n<p>例如，你可以这样使用 <code>then</code> 方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">doSomething</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">result</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">doSomethingElse</span>(result);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">newResult</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">doThirdThing</span>(newResult);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">finalResult</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;最终结果: &#x27;</span> + finalResult);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(failureCallback);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，每个 <code>then</code> 都返回一个新的 <code>Promise</code>，并且每个 <code>Promise</code> 的解决值都是上一个回调函数的返回值。如果在任何一个步骤中出现错误，<code>catch</code> 方法将捕获这个错误，你可以在这里处理错误。这就是 <code>Promise</code> 链式调用的强大之处。</p>\n<h3 id=\"catch-onRejected\"><a href=\"#catch-onRejected\" class=\"headerlink\" title=\"catch(onRejected)\"></a>catch(onRejected)</h3><p><code>catch(onRejected)</code> 方法是 <code>Promise</code> 对象的一个方法，它用于处理 <code>Promise</code> 被拒绝（即执行了 <code>reject</code> 函数）的情况。</p>\n<ul>\n<li><strong>作用</strong>：<ul>\n<li><code>catch(onRejected)</code> 方法为 <code>Promise</code> 添加一个 <code>onRejected</code> 回调函数，这个函数在 <code>Promise</code> 被拒绝时执行。</li>\n</ul>\n</li>\n<li><strong>特性</strong>：<ul>\n<li><code>catch</code> 方法会返回一个新的 <code>Promise</code> 对象。</li>\n<li>这个新的 <code>Promise</code> 将以 <code>catch</code> 方法中回调函数的返回值来解决（resolve）。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里的 Promise 被明确地拒绝了</span></span><br><span class=\"line\">  <span class=\"title function_\">reject</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理 Promise 被拒绝的情况</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(reason); <span class=\"comment\">// 输出：100</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">200</span>; <span class=\"comment\">// &#x27;catch&#x27; 函数的返回值将作为新 Promise 的解决结果</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理上一个 &#x27;catch&#x27; 返回的新 Promise 的解决结果</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出：200</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码示例中，<code>promise</code> 是一个被明确拒绝（<code>reject(100)</code>）的 <code>Promise</code> 对象。当 <code>promise</code> 被拒绝时，<code>.catch</code> 方法中的回调函数被调用，并打印出拒绝的原因（在这个例子中是数字 <code>100</code>）。然后，<code>catch</code> 方法中的回调函数返回了一个值 <code>200</code>，这个值将作为新 <code>Promise</code> 的解决结果。</p>\n<p>接下来，<code>.then</code> 方法被用来处理这个新 <code>Promise</code> 的解决结果。因为 <code>catch</code> 方法返回的新 <code>Promise</code> 被解决（resolve）了，所以 <code>.then</code> 方法中的回调函数会被执行，并打印出 <code>200</code>。</p>\n<p>通过这种方式，<code>catch</code> 不仅允许我们处理错误，还可以恢复代码执行流程，允许后续的 <code>then</code> 方法继续正常工作。这是 <code>Promise</code> 链式调用中错误处理的一个重要部分。</p>\n<h3 id=\"finally-finallyCallback\"><a href=\"#finally-finallyCallback\" class=\"headerlink\" title=\"finally(finallyCallback)\"></a>finally(finallyCallback)</h3><p><code>finally(finallyCallback)</code> 方法是 <code>Promise</code> 对象的一个方法，它允许你添加一个不依赖于 <code>Promise</code> 最终状态的回调函数。这个 <code>finallyCallback</code> 无论 <code>Promise</code> 成功（resolved）还是失败（rejected），都会被执行。</p>\n<ul>\n<li><strong>作用</strong>：<ul>\n<li><code>finally(finallyCallback)</code> 方法给 <code>Promise</code> 添加一个事件处理回调函数，这个函数在 <code>Promise</code> 完成后总会执行。</li>\n</ul>\n</li>\n<li><strong>特性</strong>：<ul>\n<li><code>finally</code> 方法不接收任何参数，这意味着你不能从 <code>finallyCallback</code> 内部获取到 <code>Promise</code> 的执行结果。</li>\n<li><code>finally</code> 方法会返回一个新的 <code>Promise</code>。这个新的 <code>Promise</code> 通常与原始 <code>Promise</code> 有相同的状态和值，除非 <code>finallyCallback</code> 中抛出了异常或返回了一个被拒绝的 <code>Promise</code>。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里的 Promise 被解决了</span></span><br><span class=\"line\">  <span class=\"title function_\">resolve</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#x27;finally&#x27; 回调函数无论成功或者失败，始终会被执行</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;finally回调函数无论成功或者失败，始终会被执行&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// &#x27;finally&#x27; 回调函数内获取不到promise执行结果，所以这里打印 undefined</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出：undefined</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#x27;finally&#x27; 回调函数返回一个新的promise，实现链式调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里的 &#x27;res&#x27; 是上一个 &#x27;resolve&#x27; 的结果</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出：100</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码示例中，<code>promise</code> 是一个被解决（<code>resolve(100)</code>）的 <code>Promise</code> 对象。<code>.finally</code> 方法添加了一个回调函数，这个函数会在 <code>Promise</code> 完成后执行，但它不会接收任何参数，因此 <code>console.log(res);</code> 中的 <code>res</code> 是 <code>undefined</code>。</p>\n<p>然后，<code>.then</code> 方法处理 <code>Promise</code> 的解决结果。由于 <code>finally</code> 方法不改变 <code>Promise</code> 的状态或值（除非抛出异常或返回被拒绝的 <code>Promise</code>），所以 <code>.then</code> 方法中的回调函数会接收到 <code>100</code> 并打印出来。</p>\n<p><code>finally</code> 方法通常用于执行清理操作，例如关闭文件、清除超时等，这些操作不依赖于操作的成功或失败。这使得代码更加简洁，因为你不需要在 <code>then</code> 和 <code>catch</code> 中重复相同的清理逻辑。</p>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><h3 id=\"Promise-all-promiseArray\"><a href=\"#Promise-all-promiseArray\" class=\"headerlink\" title=\"Promise.all(promiseArray)\"></a>Promise.all(promiseArray)</h3><p><code>Promise.all(promiseArray)</code> 是一个用于处理多个 <code>Promise</code> 对象的方法。它接受一个数组作为参数，这个数组可以包含 <code>Promise</code> 对象或其他值。</p>\n<ul>\n<li><strong>作用</strong>：<ul>\n<li><code>Promise.all</code> 接受一个数组作为参数，这个数组中可以包含 <code>Promise</code> 对象和其他类型的值。</li>\n<li>它将并发执行数组中的所有 <code>Promise</code> 对象，并且会等待所有 <code>Promise</code> 对象执行完毕。</li>\n</ul>\n</li>\n<li><strong>特性</strong>：<ul>\n<li>执行结果会以数组形式返回，数组中的元素顺序与传入的 <code>promiseArray</code> 一一对应。</li>\n<li>如果数组中的元素是普通值，<code>Promise.all</code> 会直接将这些值放入结果数组中。</li>\n<li>如果数组中的元素是 <code>Promise</code> 对象，<code>Promise.all</code> 会等待这些 <code>Promise</code> 对象执行结束，并将结果放入返回的数组中。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建两个 Promise 对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promise1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;p1&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> promise2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;p2&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Promise.all 处理包含普通值和 Promise 对象的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseAll = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, promise1, <span class=\"number\">3</span>, <span class=\"number\">4</span>, promise2, <span class=\"number\">5</span>]);</span><br><span class=\"line\">promiseAll.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发执行 Promise，等待所有任务执行完毕后统一返回结果</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出：[1, 2, &quot;p1&quot;, 3, 4, &quot;p2&quot;, 5]</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果数组中的任何一个 Promise 执行失败，整个 Promise.all 将执行失败</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseAllFail = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, promise1, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;失败&#x27;</span>), <span class=\"number\">5</span>]);</span><br><span class=\"line\">promiseAllFail.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 任何一个任务失败，将导致整个 Promise.all 执行失败</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;fail&#x27;</span>, e); <span class=\"comment\">// 输出：fail 失败</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在代码示例中，<code>promise1</code> 和 <code>promise2</code> 是两个 <code>Promise</code> 对象，它们分别在 2000 毫秒和 1000 毫秒后解决。<code>promise2</code> 被拒绝了。在这种情况下，<code>Promise.all</code> 返回的 <code>Promise</code> 也会被拒绝，并且 <code>catch</code> 方法会被调用。这意味着，如果 <code>promiseArray</code> 中任何一个 <code>Promise</code> 对象被拒绝，<code>Promise.all</code> 返回的 <code>Promise</code> 也会被拒绝，即使其他 <code>Promise</code> 对象已经成功解决。</p>\n<h3 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled\"></a>Promise.allSettled</h3><p><code>Promise.allSettled</code> 允许你同时处理多个 promise。这个方法会等待所有传入的 promises 要么完成（fulfilled），要么拒绝（rejected），然后返回一个对象数组，每个对象表示对应的 promise 结果。</p>\n<ul>\n<li><strong>特性</strong><ul>\n<li><strong>返回值</strong>：它返回一个 promise，该 promise 在所有给定的 promises 已经完成或拒绝后解决。</li>\n<li><strong>结果对象</strong>：每个结果都是一个对象，包含两个属性：<code>status</code> 和 <code>value</code> 或 <code>reason</code>。如果 promise 成功完成，<code>status</code> 为 <code>&#39;fulfilled&#39;</code>，并且 <code>value</code> 属性会包含 promise 的结果。如果 promise 被拒绝，<code>status</code> 为 <code>&#39;rejected&#39;</code>，并且 <code>reason</code> 属性会包含拒绝的原因。</li>\n<li><strong>错误处理</strong>：与 <code>Promise.all</code> 不同，<code>Promise.allSettled</code> 不会在遇到第一个拒绝的 promise 时立即拒绝。它会等待所有的 promises 都已经完成或拒绝，给你一个完整的结果集。</li>\n</ul>\n</li>\n</ul>\n<p>这里就不给代码示范了，直接把这个方法当作 <code>.all</code> 的改版就行。但注意，虽然 <code>Promise.allSettled</code> 目前已经是 ECMAScript 2020 标准的一部分，但在一些旧的浏览器版本中可能不被支持。在使用之前，最好检查目标环境是否支持这个特性。如果不支持，就需要使用一个 polyfill 来提供相同的功能。</p>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a><strong>Promise.race</strong></h3><p><strong><code>Promise.race</code></strong> 用来处理多个 promises。这个方法接受一个 promise 数组作为输入，并且会返回一个新的 promise，这个新的 promise 会以数组中<strong>第一个</strong>完成（无论是解决还是拒绝）的 promise 的结果来解决。</p>\n<ul>\n<li>特征<ul>\n<li><strong>并发执行</strong>：传入的所有 promises 会同时开始执行。</li>\n<li><strong>快速响应</strong>：只要数组中的任何一个 promise 完成，**<code>Promise.race</code>** 就会立即解决。</li>\n<li><strong>结果</strong>：返回的 promise 的结果是数组中第一个完成的 promise 的结果。</li>\n<li><strong>用途</strong>：常用于实现超时功能，例如，如果一个网络请求在指定时间内没有响应，就会被认为是超时。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;p1&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> promise2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;p2&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> promise3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 假设500毫秒后网络超时</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">reject</span>(<span class=\"string\">&quot;超时了&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseRace = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">race</span>([promise1, promise2, promise3]);</span><br><span class=\"line\">promiseRace</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里会打印出 &quot;超时了&quot;，因为 promise3 是最快完成的</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 promise3 被拒绝，错误会在这里被捕获</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;fail&quot;</span>, e);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码示例中，**<code>promise1</code><strong>、</strong><code>promise2</code>** 和 <strong><code>promise3</code></strong> 分别设置了不同的超时时间。**<code>Promise.race</code>** 会返回最快完成的 promise 的结果。在这个例子中，**<code>promise3</code>** 由于设置了最短的超时时间（500毫秒），所以它会首先完成，无论是解决还是拒绝，**<code>Promise.race</code>** 都会以 <strong><code>promise3</code></strong> 的结果来解决。</p>\n<p>在实际应用中，**<code>Promise.race</code>** 可以帮助你确保你的程序在遇到慢网络连接或者其他可能导致延迟的情况时，能够及时响应。</p>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a><strong>Promise.reject</strong></h3><p><strong><code>Promise.reject</code></strong> 方法在 JavaScript 中用于创建一个状态为拒绝（rejected）的 Promise。这个方法通常用于测试或者当你需要一个已知会失败的 Promise 时。</p>\n<ul>\n<li>特征<ul>\n<li>你可以传递任何理由（reason），这个理由会被传递给 <strong><code>.catch()</code></strong> 方法的回调函数。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&quot;rejected&quot;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个回调不会被调用，因为 Promise 已经被拒绝</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;value&#x27;</span>, res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个回调会被调用，打印出 &quot;reason rejected&quot;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;reason&#x27;</span>, reason);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码示例中，**<code>Promise.reject</code>** 被用来创建一个立即失败的 Promise，并且提供了一个字符串 “rejected” 作为失败的理由。然后，使用 <strong><code>.then()</code></strong> 方法来设置一个处理成功解决的回调函数，以及使用 <strong><code>.catch()</code></strong> 方法来设置一个处理拒绝的回调函数。</p>\n<p>在实际应用中，**<code>Promise.reject</code>** 可以用于快速创建一个失败的 Promise，以便于在函数中进行错误处理或者在测试中模拟失败的异步操作。</p>\n<h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p><code>Promise.resolve</code> 方法在 JavaScript 中用于创建一个状态为解决（fulfilled）的 Promise。这个方法可以接受任何值，并返回一个以该值解决的 Promise。</p>\n<ul>\n<li><strong>特征</strong><ul>\n<li><strong>普通值</strong>：如果传递给 <code>Promise.resolve</code> 的是一个普通值，它会返回一个新的 Promise，该 Promise 会立即以该值解决。</li>\n<li><strong>Promise 值</strong>：如果传递的值本身是一个 Promise，<code>Promise.resolve</code> 将不会创建一个新的 Promise，而是返回那个原始的 Promise。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个立即解决为100的Promise</span></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">100</span>).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这个回调会被调用，打印出100</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">//100</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新的Promise，它将会被拒绝</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">reject</span>(<span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 这里的.then()没有提供拒绝处理函数，所以拒绝将不会被处理</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个回调不会被调用，因为Promise已经被拒绝</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>代码示例中，<code>Promise.resolve</code> 被用来创建一个立即以数字 <code>100</code> 解决的 Promise。然后，使用 <code>.then()</code> 方法来设置一个处理解决的回调函数。</p>\n<p>请注意，第二个例子中的 Promise 被拒绝了，但是没有提供 <code>.catch()</code> 方法或拒绝处理函数，所以拒绝不会被捕获或处理。在实际应用中，<code>Promise.resolve</code> 可以用于确保有一个解决的 Promise，这在处理同步和异步代码时非常有用。</p>\n<h2 id=\"实现一个-Promise\"><a href=\"#实现一个-Promise\" class=\"headerlink\" title=\"实现一个 Promise\"></a>实现一个 Promise</h2><p><a href=\"https://segmentfault.com/a/1190000041414230\">segmentfault.com</a></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">myPromise</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"variable constant_\">PENDING</span> = <span class=\"string\">&#x27;pending&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title class_\">FULFILLEd</span> = <span class=\"string\">&#x27;fulfilled&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"variable constant_\">REJECTED</span> = <span class=\"string\">&#x27;rejected&#x27;</span></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">init</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = myPromise.<span class=\"property\">PENDING</span> <span class=\"comment\">// promise状态</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span> = <span class=\"literal\">null</span>  <span class=\"comment\">// promise返回值</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resolveCallback</span> = [] <span class=\"comment\">//成功回调集合</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">rejectCallback</span> = [] <span class=\"comment\">//失败回调集合</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"title function_\">resolve</span> = result=&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只有当状态为pending时才改变，保证状态一旦改变就不会再变</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span> === myPromise.<span class=\"property\">PENDING</span>)&#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = myPromise.<span class=\"property\">FULFILLEd</span> <span class=\"comment\">//改变状态</span></span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span> = result <span class=\"comment\">//返回值</span></span><br><span class=\"line\">                <span class=\"comment\">//依次调用成功回调</span></span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">resolveCallback</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">fn</span>=&gt;</span><span class=\"title function_\">fn</span>())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"title function_\">reject</span> = result=&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只有当状态为pending时才改变，保证状态一旦改变就不会再变</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span> === myPromise.<span class=\"property\">PENDING</span>)&#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = myPromise.<span class=\"property\">REJECTED</span> <span class=\"comment\">//改变状态</span></span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span> = result <span class=\"comment\">//返回值</span></span><br><span class=\"line\">                <span class=\"comment\">// 依次调用失败回调</span></span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">rejectCallback</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">fn</span>=&gt;</span><span class=\"title function_\">fn</span>())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"title function_\">init</span>(resolve,reject)  <span class=\"comment\">// 注意this指向</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">            <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">then</span>(<span class=\"params\">onFulfilled,onRejected</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;promiseRes,state&#125; = <span class=\"variable language_\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">reso,reje</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"title function_\">resolveMyPromise</span> = promiseRes =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> onFulfilled !== <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果then的第一个回调不是一个函数，直接忽略，返回一个新的promise</span></span><br><span class=\"line\">                        <span class=\"title function_\">reso</span>(promiseRes)</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 获取第一个回调的执行结果</span></span><br><span class=\"line\">                        <span class=\"keyword\">const</span> res = <span class=\"title function_\">onFulfilled</span>(promiseRes)</span><br><span class=\"line\">                        <span class=\"comment\">// 看该执行结果是否是一个promise</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(res <span class=\"keyword\">instanceof</span> myPromise)&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 是一个promise,等它状态改变后再改变then返回的promise状态</span></span><br><span class=\"line\">                            res.<span class=\"title function_\">then</span>(reso,rej) </span><br><span class=\"line\">                        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 不是一个promise，将它作为新的promise的resolve</span></span><br><span class=\"line\">                            <span class=\"title function_\">reso</span>(res)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//异常，直接将新的promise状态置为rejected</span></span><br><span class=\"line\">                    <span class=\"title function_\">reje</span>(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"title function_\">rejectMyPromise</span> = promiseRes =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> onRejected !== <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果then的第二个回调不是一个函数，直接忽略，返回一个新的promise</span></span><br><span class=\"line\">                        <span class=\"title function_\">reje</span>(promiseRes)</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 获取第二个回调的执行结果</span></span><br><span class=\"line\">                        <span class=\"keyword\">const</span> res = <span class=\"title function_\">onRejected</span>(promiseRes)</span><br><span class=\"line\">                        <span class=\"comment\">// 看该执行结果是否是一个promise</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(res <span class=\"keyword\">instanceof</span> myPromise)&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 是一个promise,等它状态改变后再改变then返回的promise状态</span></span><br><span class=\"line\">                            res.<span class=\"title function_\">then</span>(reso,rej) </span><br><span class=\"line\">                        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 不是一个promise，将它作为新的promise的resolve</span></span><br><span class=\"line\">                            <span class=\"title function_\">reje</span>(res)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//异常，直接将新的promise状态置为rejected</span></span><br><span class=\"line\">                    <span class=\"title function_\">reje</span>(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(state === myPromise.<span class=\"property\">FULFILLEd</span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">resolveMyPromise</span>(promiseRes)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(state === myPromise.<span class=\"property\">REJECTED</span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">rejectMyPromise</span>(promiseRes)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(state === myPromise.<span class=\"property\">PENDING</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(onFulfilled &amp;&amp; <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"variable language_\">this</span>.<span class=\"property\">resolveCallback</span>.<span class=\"title function_\">push</span>(<span class=\"function\">()=&gt;</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里我们用setTimeout来模拟实现then的微任务</span></span><br><span class=\"line\">                    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">resolveMyPromise</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span>)</span><br><span class=\"line\">                    &#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(onRejected &amp;&amp; <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"variable language_\">this</span>.<span class=\"property\">rejectCallback</span>.<span class=\"title function_\">push</span>(<span class=\"function\">()=&gt;</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里我们用setTimeout来模拟实现then的微任务</span></span><br><span class=\"line\">                    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">rejectMyPromise</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span>)</span><br><span class=\"line\">                    &#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(onRejected) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">then</span>(<span class=\"literal\">undefined</span>,onRejected)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> all (promises)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">res,rej</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> count = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">            <span class=\"keyword\">function</span> <span class=\"title function_\">addFun</span>(<span class=\"params\">index,resf</span>) &#123;</span><br><span class=\"line\">                result[index]=resf <span class=\"comment\">// 这里用索引别用push,保证返回的顺序</span></span><br><span class=\"line\">                count++</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(count==promises.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">res</span>(result)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [].<span class=\"property\">forEach</span>.<span class=\"title function_\">call</span>(promises,<span class=\"function\">(<span class=\"params\">promise,index</span>)=&gt;</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(promise <span class=\"keyword\">instanceof</span> myPromise) &#123;</span><br><span class=\"line\">                    promise.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">success</span>=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">addFun</span>(index,success)</span><br><span class=\"line\">                    &#125;,<span class=\"function\"><span class=\"params\">err</span>=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">rej</span>(err)</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"title function_\">addFun</span>(index,promise)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">race</span>(<span class=\"params\">promises</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">res,rej</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            [].<span class=\"property\">forEach</span>.<span class=\"title function_\">call</span>(promises,<span class=\"function\"><span class=\"params\">promise</span>=&gt;</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(promise <span class=\"keyword\">instanceof</span> myPromise)&#123;</span><br><span class=\"line\">                    promise.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">success</span>=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">res</span>(success)</span><br><span class=\"line\">                    &#125;,<span class=\"function\"><span class=\"params\">error</span>=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">rej</span>(error)</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"title function_\">res</span>(promise)</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">resolve</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.参数是一个Promise实例,直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v <span class=\"keyword\">instanceof</span> myPromise)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//2.参数是一个thenable对象，转为Promise后执行该对象的then方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> v === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; <span class=\"keyword\">typeof</span> v.<span class=\"property\">then</span> === <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">res,rej</span>)=&gt;</span>&#123;</span><br><span class=\"line\">                v.<span class=\"title function_\">then</span>(res,rej)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//3.没有参数，直接返回一个resolved状态的promise</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!v)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</span><br><span class=\"line\">                <span class=\"title function_\">res</span>()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//4.参数是一个原始值，返回一个新的Promise，状态为resolved</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"title function_\">res</span>(v)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">reject</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">res,rej</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"title function_\">rej</span>(v)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>Promise 规范最早由 CommonJS 社区提出，后来成为 ES2015（ES6） 语言规范，到现在可以说已经成了异步编程的首选方案。</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises\">使用 Promise - JavaScript | MDN</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544\">Promise</a></li>\n</ul>\n<h2 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h2><ul>\n<li><code>Penfing</code>  等待</li>\n<li><code>Fulfilled</code> 成功</li>\n<li><code>rejected</code> 失败</li>\n</ul>\n<h2 id=\"构造函数-Promise-excutor\"><a href=\"#构造函数-Promise-excutor\" class=\"headerlink\" title=\"构造函数 Promise(excutor)\"></a>构造函数 Promise(excutor)</h2><p><code>Promise</code> 构造函数是 JavaScript 中用于处理异步操作的一个重要工具。</p>\n<ul>\n<li>**构造函数 <code>Promise(executor)</code>**：<ul>\n<li><code>Promise</code> 构造函数接受一个名为 <code>executor</code> 的回调函数作为参数。当你创建一个 <code>Promise</code> 实例时，这个 <code>executor</code> 函数会被立即执行。</li>\n<li><code>executor</code> 函数接收两个参数：<code>resolve</code> 和 <code>reject</code>。这两个参数也是函数，你可以在 <code>executor</code> 函数内部调用它们来改变 <code>Promise</code> 的状态。</li>\n</ul>\n</li>\n<li><strong>状态变更</strong>：<ul>\n<li>当 <code>resolve</code> 被调用时，它会将 <code>Promise</code> 的状态从 “pending”（等待）变更为 “fulfilled”（已完成）。</li>\n<li>当 <code>reject</code> 被调用时，它会将 <code>Promise</code> 的状态从 “pending”（等待）变更为 “rejected”（已失败）。</li>\n<li>如果 <code>executor</code> 函数中抛出了一个错误，那么 <code>Promise</code> 会自动变更为 “rejected” 状态，并且错误对象会被作为 <code>reject</code> 函数的参数传递出去。</li>\n</ul>\n</li>\n<li>**返回新的 <code>Promise</code>**：<ul>\n<li>在 <code>executor</code> 函数中，你可以通过 <code>resolve</code> 返回一个值，或者通过 <code>reject</code> 返回一个错误。</li>\n<li>如果你在 <code>resolve</code> 中传递了另一个 <code>Promise</code>（比如 <code>Promise.reject(&quot;err&quot;)</code>），那么当前 <code>Promise</code> 的状态将会跟随传递进来的 <code>Promise</code> 的状态。</li>\n</ul>\n</li>\n</ul>\n<p>这是一个简单的例子来说明这个概念：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 异步操作</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"title function_\">fetchData</span>(); <span class=\"comment\">// 假设这是一个获取数据的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data) &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>(data); <span class=\"comment\">// 如果数据获取成功，使用resolve改变Promise状态为fulfilled</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;数据获取失败&#x27;</span>); <span class=\"comment\">// 如果数据获取失败，使用reject改变Promise状态为rejected</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data); <span class=\"comment\">// 如果Promise状态为fulfilled，这里将输出获取到的数据</span></span><br><span class=\"line\">&#125;).<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error); <span class=\"comment\">// 如果Promise状态为rejected，这里将输出错误信息</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，<code>promise</code> 是一个新创建的 <code>Promise</code> 对象。我们传递了一个 <code>executor</code> 函数给 <code>Promise</code> 构造函数，这个函数内部执行了一个异步操作（<code>setTimeout</code>）。当异步操作完成后，我们根据结果调用 <code>resolve</code> 或 <code>reject</code> 来改变 <code>Promise</code> 的状态。然后我们可以使用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理 <code>Promise</code> 成功或失败的结果。</p>\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><h3 id=\"then-onFulfilled-onRejected\"><a href=\"#then-onFulfilled-onRejected\" class=\"headerlink\" title=\"then(onFulfilled, onRejected)\"></a>then(onFulfilled, onRejected)</h3><p><img src=\"https://img.ma5hr00m.top/blog/20240609140952.png\" alt=\"20240609140952\"></p>\n<p><code>then(onFulfilled, onRejected)</code> 方法是 <code>Promise</code> 对象的一个非常重要的特性，它允许你为 <code>Promise</code> 注册 <code>onFulfilled</code> 和 <code>onRejected</code> 回调函数。</p>\n<ul>\n<li><strong>作用</strong>：<ul>\n<li>为 <code>Promise</code> 注册 <code>onFulfilled</code> 和 <code>onRejected</code> 回调函数，这些函数分别在 <code>Promise</code> 成功（fulfilled）或失败（rejected）时被调用。</li>\n<li>返回一个新的 <code>Promise</code> 对象，使得可以实现链式调用。这意味着你可以在一个 <code>then</code> 调用后继续添加更多的 <code>then</code> 或 <code>catch</code> 方法。</li>\n</ul>\n</li>\n<li><strong>特性</strong>：<ul>\n<li><code>then</code> 方法会自动返回一个新的 <code>Promise</code> 对象。这个新的 <code>Promise</code> 对象的状态（fulfilled 或 rejected）将由 <code>onFulfilled</code> 或 <code>onRejected</code> 回调函数的返回值决定。</li>\n<li>如果 <code>onFulfilled</code> 或 <code>onRejected</code> 回调函数返回一个值，那么新的 <code>Promise</code> 将以这个值为结果被解决（resolve）。</li>\n<li>如果回调函数返回另一个 <code>Promise</code>，那么新的 <code>Promise</code> 将“跟随”这个 <code>Promise</code> 的状态，即如果返回的 <code>Promise</code> 被解决，新的 <code>Promise</code> 也会被解决；如果返回的 <code>Promise</code> 被拒绝，新的 <code>Promise</code> 也会被拒绝。</li>\n</ul>\n</li>\n</ul>\n<p>这种机制允许你创建复杂的异步代码序列，其中一个操作的完成可以链接到下一个操作，而不需要嵌套回调函数。这样做可以提高代码的可读性和可维护性。</p>\n<p>例如，你可以这样使用 <code>then</code> 方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">doSomething</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">result</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">doSomethingElse</span>(result);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">newResult</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">doThirdThing</span>(newResult);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span>(<span class=\"params\">finalResult</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;最终结果: &#x27;</span> + finalResult);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(failureCallback);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，每个 <code>then</code> 都返回一个新的 <code>Promise</code>，并且每个 <code>Promise</code> 的解决值都是上一个回调函数的返回值。如果在任何一个步骤中出现错误，<code>catch</code> 方法将捕获这个错误，你可以在这里处理错误。这就是 <code>Promise</code> 链式调用的强大之处。</p>\n<h3 id=\"catch-onRejected\"><a href=\"#catch-onRejected\" class=\"headerlink\" title=\"catch(onRejected)\"></a>catch(onRejected)</h3><p><code>catch(onRejected)</code> 方法是 <code>Promise</code> 对象的一个方法，它用于处理 <code>Promise</code> 被拒绝（即执行了 <code>reject</code> 函数）的情况。</p>\n<ul>\n<li><strong>作用</strong>：<ul>\n<li><code>catch(onRejected)</code> 方法为 <code>Promise</code> 添加一个 <code>onRejected</code> 回调函数，这个函数在 <code>Promise</code> 被拒绝时执行。</li>\n</ul>\n</li>\n<li><strong>特性</strong>：<ul>\n<li><code>catch</code> 方法会返回一个新的 <code>Promise</code> 对象。</li>\n<li>这个新的 <code>Promise</code> 将以 <code>catch</code> 方法中回调函数的返回值来解决（resolve）。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里的 Promise 被明确地拒绝了</span></span><br><span class=\"line\">  <span class=\"title function_\">reject</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理 Promise 被拒绝的情况</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(reason); <span class=\"comment\">// 输出：100</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">200</span>; <span class=\"comment\">// &#x27;catch&#x27; 函数的返回值将作为新 Promise 的解决结果</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理上一个 &#x27;catch&#x27; 返回的新 Promise 的解决结果</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出：200</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码示例中，<code>promise</code> 是一个被明确拒绝（<code>reject(100)</code>）的 <code>Promise</code> 对象。当 <code>promise</code> 被拒绝时，<code>.catch</code> 方法中的回调函数被调用，并打印出拒绝的原因（在这个例子中是数字 <code>100</code>）。然后，<code>catch</code> 方法中的回调函数返回了一个值 <code>200</code>，这个值将作为新 <code>Promise</code> 的解决结果。</p>\n<p>接下来，<code>.then</code> 方法被用来处理这个新 <code>Promise</code> 的解决结果。因为 <code>catch</code> 方法返回的新 <code>Promise</code> 被解决（resolve）了，所以 <code>.then</code> 方法中的回调函数会被执行，并打印出 <code>200</code>。</p>\n<p>通过这种方式，<code>catch</code> 不仅允许我们处理错误，还可以恢复代码执行流程，允许后续的 <code>then</code> 方法继续正常工作。这是 <code>Promise</code> 链式调用中错误处理的一个重要部分。</p>\n<h3 id=\"finally-finallyCallback\"><a href=\"#finally-finallyCallback\" class=\"headerlink\" title=\"finally(finallyCallback)\"></a>finally(finallyCallback)</h3><p><code>finally(finallyCallback)</code> 方法是 <code>Promise</code> 对象的一个方法，它允许你添加一个不依赖于 <code>Promise</code> 最终状态的回调函数。这个 <code>finallyCallback</code> 无论 <code>Promise</code> 成功（resolved）还是失败（rejected），都会被执行。</p>\n<ul>\n<li><strong>作用</strong>：<ul>\n<li><code>finally(finallyCallback)</code> 方法给 <code>Promise</code> 添加一个事件处理回调函数，这个函数在 <code>Promise</code> 完成后总会执行。</li>\n</ul>\n</li>\n<li><strong>特性</strong>：<ul>\n<li><code>finally</code> 方法不接收任何参数，这意味着你不能从 <code>finallyCallback</code> 内部获取到 <code>Promise</code> 的执行结果。</li>\n<li><code>finally</code> 方法会返回一个新的 <code>Promise</code>。这个新的 <code>Promise</code> 通常与原始 <code>Promise</code> 有相同的状态和值，除非 <code>finallyCallback</code> 中抛出了异常或返回了一个被拒绝的 <code>Promise</code>。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里的 Promise 被解决了</span></span><br><span class=\"line\">  <span class=\"title function_\">resolve</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .<span class=\"title function_\">finally</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#x27;finally&#x27; 回调函数无论成功或者失败，始终会被执行</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;finally回调函数无论成功或者失败，始终会被执行&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// &#x27;finally&#x27; 回调函数内获取不到promise执行结果，所以这里打印 undefined</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出：undefined</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// &#x27;finally&#x27; 回调函数返回一个新的promise，实现链式调用</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里的 &#x27;res&#x27; 是上一个 &#x27;resolve&#x27; 的结果</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出：100</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码示例中，<code>promise</code> 是一个被解决（<code>resolve(100)</code>）的 <code>Promise</code> 对象。<code>.finally</code> 方法添加了一个回调函数，这个函数会在 <code>Promise</code> 完成后执行，但它不会接收任何参数，因此 <code>console.log(res);</code> 中的 <code>res</code> 是 <code>undefined</code>。</p>\n<p>然后，<code>.then</code> 方法处理 <code>Promise</code> 的解决结果。由于 <code>finally</code> 方法不改变 <code>Promise</code> 的状态或值（除非抛出异常或返回被拒绝的 <code>Promise</code>），所以 <code>.then</code> 方法中的回调函数会接收到 <code>100</code> 并打印出来。</p>\n<p><code>finally</code> 方法通常用于执行清理操作，例如关闭文件、清除超时等，这些操作不依赖于操作的成功或失败。这使得代码更加简洁，因为你不需要在 <code>then</code> 和 <code>catch</code> 中重复相同的清理逻辑。</p>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><h3 id=\"Promise-all-promiseArray\"><a href=\"#Promise-all-promiseArray\" class=\"headerlink\" title=\"Promise.all(promiseArray)\"></a>Promise.all(promiseArray)</h3><p><code>Promise.all(promiseArray)</code> 是一个用于处理多个 <code>Promise</code> 对象的方法。它接受一个数组作为参数，这个数组可以包含 <code>Promise</code> 对象或其他值。</p>\n<ul>\n<li><strong>作用</strong>：<ul>\n<li><code>Promise.all</code> 接受一个数组作为参数，这个数组中可以包含 <code>Promise</code> 对象和其他类型的值。</li>\n<li>它将并发执行数组中的所有 <code>Promise</code> 对象，并且会等待所有 <code>Promise</code> 对象执行完毕。</li>\n</ul>\n</li>\n<li><strong>特性</strong>：<ul>\n<li>执行结果会以数组形式返回，数组中的元素顺序与传入的 <code>promiseArray</code> 一一对应。</li>\n<li>如果数组中的元素是普通值，<code>Promise.all</code> 会直接将这些值放入结果数组中。</li>\n<li>如果数组中的元素是 <code>Promise</code> 对象，<code>Promise.all</code> 会等待这些 <code>Promise</code> 对象执行结束，并将结果放入返回的数组中。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建两个 Promise 对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promise1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;p1&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> promise2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;p2&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 Promise.all 处理包含普通值和 Promise 对象的数组</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseAll = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, promise1, <span class=\"number\">3</span>, <span class=\"number\">4</span>, promise2, <span class=\"number\">5</span>]);</span><br><span class=\"line\">promiseAll.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发执行 Promise，等待所有任务执行完毕后统一返回结果</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">// 输出：[1, 2, &quot;p1&quot;, 3, 4, &quot;p2&quot;, 5]</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果数组中的任何一个 Promise 执行失败，整个 Promise.all 将执行失败</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseAllFail = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, promise1, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&#x27;失败&#x27;</span>), <span class=\"number\">5</span>]);</span><br><span class=\"line\">promiseAllFail.<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">&#125;).<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 任何一个任务失败，将导致整个 Promise.all 执行失败</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;fail&#x27;</span>, e); <span class=\"comment\">// 输出：fail 失败</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在代码示例中，<code>promise1</code> 和 <code>promise2</code> 是两个 <code>Promise</code> 对象，它们分别在 2000 毫秒和 1000 毫秒后解决。<code>promise2</code> 被拒绝了。在这种情况下，<code>Promise.all</code> 返回的 <code>Promise</code> 也会被拒绝，并且 <code>catch</code> 方法会被调用。这意味着，如果 <code>promiseArray</code> 中任何一个 <code>Promise</code> 对象被拒绝，<code>Promise.all</code> 返回的 <code>Promise</code> 也会被拒绝，即使其他 <code>Promise</code> 对象已经成功解决。</p>\n<h3 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled\"></a>Promise.allSettled</h3><p><code>Promise.allSettled</code> 允许你同时处理多个 promise。这个方法会等待所有传入的 promises 要么完成（fulfilled），要么拒绝（rejected），然后返回一个对象数组，每个对象表示对应的 promise 结果。</p>\n<ul>\n<li><strong>特性</strong><ul>\n<li><strong>返回值</strong>：它返回一个 promise，该 promise 在所有给定的 promises 已经完成或拒绝后解决。</li>\n<li><strong>结果对象</strong>：每个结果都是一个对象，包含两个属性：<code>status</code> 和 <code>value</code> 或 <code>reason</code>。如果 promise 成功完成，<code>status</code> 为 <code>&#39;fulfilled&#39;</code>，并且 <code>value</code> 属性会包含 promise 的结果。如果 promise 被拒绝，<code>status</code> 为 <code>&#39;rejected&#39;</code>，并且 <code>reason</code> 属性会包含拒绝的原因。</li>\n<li><strong>错误处理</strong>：与 <code>Promise.all</code> 不同，<code>Promise.allSettled</code> 不会在遇到第一个拒绝的 promise 时立即拒绝。它会等待所有的 promises 都已经完成或拒绝，给你一个完整的结果集。</li>\n</ul>\n</li>\n</ul>\n<p>这里就不给代码示范了，直接把这个方法当作 <code>.all</code> 的改版就行。但注意，虽然 <code>Promise.allSettled</code> 目前已经是 ECMAScript 2020 标准的一部分，但在一些旧的浏览器版本中可能不被支持。在使用之前，最好检查目标环境是否支持这个特性。如果不支持，就需要使用一个 polyfill 来提供相同的功能。</p>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a><strong>Promise.race</strong></h3><p><strong><code>Promise.race</code></strong> 用来处理多个 promises。这个方法接受一个 promise 数组作为输入，并且会返回一个新的 promise，这个新的 promise 会以数组中<strong>第一个</strong>完成（无论是解决还是拒绝）的 promise 的结果来解决。</p>\n<ul>\n<li>特征<ul>\n<li><strong>并发执行</strong>：传入的所有 promises 会同时开始执行。</li>\n<li><strong>快速响应</strong>：只要数组中的任何一个 promise 完成，**<code>Promise.race</code>** 就会立即解决。</li>\n<li><strong>结果</strong>：返回的 promise 的结果是数组中第一个完成的 promise 的结果。</li>\n<li><strong>用途</strong>：常用于实现超时功能，例如，如果一个网络请求在指定时间内没有响应，就会被认为是超时。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promise1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;p1&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> promise2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;p2&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> promise3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 假设500毫秒后网络超时</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">reject</span>(<span class=\"string\">&quot;超时了&quot;</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> promiseRace = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">race</span>([promise1, promise2, promise3]);</span><br><span class=\"line\">promiseRace</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里会打印出 &quot;超时了&quot;，因为 promise3 是最快完成的</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 promise3 被拒绝，错误会在这里被捕获</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;fail&quot;</span>, e);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码示例中，**<code>promise1</code><strong>、</strong><code>promise2</code>** 和 <strong><code>promise3</code></strong> 分别设置了不同的超时时间。**<code>Promise.race</code>** 会返回最快完成的 promise 的结果。在这个例子中，**<code>promise3</code>** 由于设置了最短的超时时间（500毫秒），所以它会首先完成，无论是解决还是拒绝，**<code>Promise.race</code>** 都会以 <strong><code>promise3</code></strong> 的结果来解决。</p>\n<p>在实际应用中，**<code>Promise.race</code>** 可以帮助你确保你的程序在遇到慢网络连接或者其他可能导致延迟的情况时，能够及时响应。</p>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a><strong>Promise.reject</strong></h3><p><strong><code>Promise.reject</code></strong> 方法在 JavaScript 中用于创建一个状态为拒绝（rejected）的 Promise。这个方法通常用于测试或者当你需要一个已知会失败的 Promise 时。</p>\n<ul>\n<li>特征<ul>\n<li>你可以传递任何理由（reason），这个理由会被传递给 <strong><code>.catch()</code></strong> 方法的回调函数。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&quot;rejected&quot;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个回调不会被调用，因为 Promise 已经被拒绝</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;value&#x27;</span>, res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">reason</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个回调会被调用，打印出 &quot;reason rejected&quot;</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;reason&#x27;</span>, reason);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>代码示例中，**<code>Promise.reject</code>** 被用来创建一个立即失败的 Promise，并且提供了一个字符串 “rejected” 作为失败的理由。然后，使用 <strong><code>.then()</code></strong> 方法来设置一个处理成功解决的回调函数，以及使用 <strong><code>.catch()</code></strong> 方法来设置一个处理拒绝的回调函数。</p>\n<p>在实际应用中，**<code>Promise.reject</code>** 可以用于快速创建一个失败的 Promise，以便于在函数中进行错误处理或者在测试中模拟失败的异步操作。</p>\n<h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p><code>Promise.resolve</code> 方法在 JavaScript 中用于创建一个状态为解决（fulfilled）的 Promise。这个方法可以接受任何值，并返回一个以该值解决的 Promise。</p>\n<ul>\n<li><strong>特征</strong><ul>\n<li><strong>普通值</strong>：如果传递给 <code>Promise.resolve</code> 的是一个普通值，它会返回一个新的 Promise，该 Promise 会立即以该值解决。</li>\n<li><strong>Promise 值</strong>：如果传递的值本身是一个 Promise，<code>Promise.resolve</code> 将不会创建一个新的 Promise，而是返回那个原始的 Promise。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个立即解决为100的Promise</span></span><br><span class=\"line\"><span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"number\">100</span>).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这个回调会被调用，打印出100</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res); <span class=\"comment\">//100</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新的Promise，它将会被拒绝</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">reject</span>(<span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 这里的.then()没有提供拒绝处理函数，所以拒绝将不会被处理</span></span><br><span class=\"line\">promise</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个回调不会被调用，因为Promise已经被拒绝</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(res);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>代码示例中，<code>Promise.resolve</code> 被用来创建一个立即以数字 <code>100</code> 解决的 Promise。然后，使用 <code>.then()</code> 方法来设置一个处理解决的回调函数。</p>\n<p>请注意，第二个例子中的 Promise 被拒绝了，但是没有提供 <code>.catch()</code> 方法或拒绝处理函数，所以拒绝不会被捕获或处理。在实际应用中，<code>Promise.resolve</code> 可以用于确保有一个解决的 Promise，这在处理同步和异步代码时非常有用。</p>\n<h2 id=\"实现一个-Promise\"><a href=\"#实现一个-Promise\" class=\"headerlink\" title=\"实现一个 Promise\"></a>实现一个 Promise</h2><p><a href=\"https://segmentfault.com/a/1190000041414230\">segmentfault.com</a></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">myPromise</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"variable constant_\">PENDING</span> = <span class=\"string\">&#x27;pending&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title class_\">FULFILLEd</span> = <span class=\"string\">&#x27;fulfilled&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"variable constant_\">REJECTED</span> = <span class=\"string\">&#x27;rejected&#x27;</span></span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">init</span>)&#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = myPromise.<span class=\"property\">PENDING</span> <span class=\"comment\">// promise状态</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span> = <span class=\"literal\">null</span>  <span class=\"comment\">// promise返回值</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">resolveCallback</span> = [] <span class=\"comment\">//成功回调集合</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">rejectCallback</span> = [] <span class=\"comment\">//失败回调集合</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"title function_\">resolve</span> = result=&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只有当状态为pending时才改变，保证状态一旦改变就不会再变</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span> === myPromise.<span class=\"property\">PENDING</span>)&#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = myPromise.<span class=\"property\">FULFILLEd</span> <span class=\"comment\">//改变状态</span></span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span> = result <span class=\"comment\">//返回值</span></span><br><span class=\"line\">                <span class=\"comment\">//依次调用成功回调</span></span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">resolveCallback</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">fn</span>=&gt;</span><span class=\"title function_\">fn</span>())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"title function_\">reject</span> = result=&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只有当状态为pending时才改变，保证状态一旦改变就不会再变</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span> === myPromise.<span class=\"property\">PENDING</span>)&#123;</span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = myPromise.<span class=\"property\">REJECTED</span> <span class=\"comment\">//改变状态</span></span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span> = result <span class=\"comment\">//返回值</span></span><br><span class=\"line\">                <span class=\"comment\">// 依次调用失败回调</span></span><br><span class=\"line\">                <span class=\"variable language_\">this</span>.<span class=\"property\">rejectCallback</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">fn</span>=&gt;</span><span class=\"title function_\">fn</span>())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"title function_\">init</span>(resolve,reject)  <span class=\"comment\">// 注意this指向</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">            <span class=\"title function_\">reject</span>(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">then</span>(<span class=\"params\">onFulfilled,onRejected</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;promiseRes,state&#125; = <span class=\"variable language_\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">reso,reje</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"title function_\">resolveMyPromise</span> = promiseRes =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> onFulfilled !== <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果then的第一个回调不是一个函数，直接忽略，返回一个新的promise</span></span><br><span class=\"line\">                        <span class=\"title function_\">reso</span>(promiseRes)</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 获取第一个回调的执行结果</span></span><br><span class=\"line\">                        <span class=\"keyword\">const</span> res = <span class=\"title function_\">onFulfilled</span>(promiseRes)</span><br><span class=\"line\">                        <span class=\"comment\">// 看该执行结果是否是一个promise</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(res <span class=\"keyword\">instanceof</span> myPromise)&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 是一个promise,等它状态改变后再改变then返回的promise状态</span></span><br><span class=\"line\">                            res.<span class=\"title function_\">then</span>(reso,rej) </span><br><span class=\"line\">                        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 不是一个promise，将它作为新的promise的resolve</span></span><br><span class=\"line\">                            <span class=\"title function_\">reso</span>(res)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//异常，直接将新的promise状态置为rejected</span></span><br><span class=\"line\">                    <span class=\"title function_\">reje</span>(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"title function_\">rejectMyPromise</span> = promiseRes =&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> onRejected !== <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 如果then的第二个回调不是一个函数，直接忽略，返回一个新的promise</span></span><br><span class=\"line\">                        <span class=\"title function_\">reje</span>(promiseRes)</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 获取第二个回调的执行结果</span></span><br><span class=\"line\">                        <span class=\"keyword\">const</span> res = <span class=\"title function_\">onRejected</span>(promiseRes)</span><br><span class=\"line\">                        <span class=\"comment\">// 看该执行结果是否是一个promise</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(res <span class=\"keyword\">instanceof</span> myPromise)&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 是一个promise,等它状态改变后再改变then返回的promise状态</span></span><br><span class=\"line\">                            res.<span class=\"title function_\">then</span>(reso,rej) </span><br><span class=\"line\">                        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 不是一个promise，将它作为新的promise的resolve</span></span><br><span class=\"line\">                            <span class=\"title function_\">reje</span>(res)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//异常，直接将新的promise状态置为rejected</span></span><br><span class=\"line\">                    <span class=\"title function_\">reje</span>(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(state === myPromise.<span class=\"property\">FULFILLEd</span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">resolveMyPromise</span>(promiseRes)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(state === myPromise.<span class=\"property\">REJECTED</span>) &#123;</span><br><span class=\"line\">                <span class=\"title function_\">rejectMyPromise</span>(promiseRes)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(state === myPromise.<span class=\"property\">PENDING</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(onFulfilled &amp;&amp; <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"variable language_\">this</span>.<span class=\"property\">resolveCallback</span>.<span class=\"title function_\">push</span>(<span class=\"function\">()=&gt;</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里我们用setTimeout来模拟实现then的微任务</span></span><br><span class=\"line\">                    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">resolveMyPromise</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span>)</span><br><span class=\"line\">                    &#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(onRejected &amp;&amp; <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"variable language_\">this</span>.<span class=\"property\">rejectCallback</span>.<span class=\"title function_\">push</span>(<span class=\"function\">()=&gt;</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里我们用setTimeout来模拟实现then的微任务</span></span><br><span class=\"line\">                    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">rejectMyPromise</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">promiseRes</span>)</span><br><span class=\"line\">                    &#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span>(onRejected) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">then</span>(<span class=\"literal\">undefined</span>,onRejected)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> all (promises)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">res,rej</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> count = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">            <span class=\"keyword\">function</span> <span class=\"title function_\">addFun</span>(<span class=\"params\">index,resf</span>) &#123;</span><br><span class=\"line\">                result[index]=resf <span class=\"comment\">// 这里用索引别用push,保证返回的顺序</span></span><br><span class=\"line\">                count++</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(count==promises.<span class=\"property\">length</span>) &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">res</span>(result)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            [].<span class=\"property\">forEach</span>.<span class=\"title function_\">call</span>(promises,<span class=\"function\">(<span class=\"params\">promise,index</span>)=&gt;</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(promise <span class=\"keyword\">instanceof</span> myPromise) &#123;</span><br><span class=\"line\">                    promise.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">success</span>=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">addFun</span>(index,success)</span><br><span class=\"line\">                    &#125;,<span class=\"function\"><span class=\"params\">err</span>=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">rej</span>(err)</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"title function_\">addFun</span>(index,promise)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">race</span>(<span class=\"params\">promises</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">res,rej</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            [].<span class=\"property\">forEach</span>.<span class=\"title function_\">call</span>(promises,<span class=\"function\"><span class=\"params\">promise</span>=&gt;</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(promise <span class=\"keyword\">instanceof</span> myPromise)&#123;</span><br><span class=\"line\">                    promise.<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">success</span>=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">res</span>(success)</span><br><span class=\"line\">                    &#125;,<span class=\"function\"><span class=\"params\">error</span>=&gt;</span>&#123;</span><br><span class=\"line\">                        <span class=\"title function_\">rej</span>(error)</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"title function_\">res</span>(promise)</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">resolve</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.参数是一个Promise实例,直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v <span class=\"keyword\">instanceof</span> myPromise)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//2.参数是一个thenable对象，转为Promise后执行该对象的then方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> v === <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; <span class=\"keyword\">typeof</span> v.<span class=\"property\">then</span> === <span class=\"string\">&#x27;function&#x27;</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">res,rej</span>)=&gt;</span>&#123;</span><br><span class=\"line\">                v.<span class=\"title function_\">then</span>(res,rej)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//3.没有参数，直接返回一个resolved状态的promise</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!v)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</span><br><span class=\"line\">                <span class=\"title function_\">res</span>()</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//4.参数是一个原始值，返回一个新的Promise，状态为resolved</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"title function_\">res</span>(v)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"title function_\">reject</span>(<span class=\"params\">v</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">myPromise</span>(<span class=\"function\">(<span class=\"params\">res,rej</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"title function_\">rej</span>(v)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"常见 Web 鉴权方案","date":"2023-09-13T16:00:00.000Z","author":"ma5hr00m","_content":"\n面向 Web 新生补全知识点。\n\n## 鉴权 & 持久化登陆\n### 鉴权\n**鉴权**（*Authentication*）是指确认用户身份的过程。\n在计算机系统中，鉴权是一种安全机制，用于验证用户是否具有访问系统资源的权限。通过鉴权机制，系统可以验证用户提供的凭据（如用户名和密码、数字证书等），并决定是否授予用户所请求的访问权限。\n\n传统的鉴权是通过密码来实现的。这种方式的前提是，每个获得密码的用户都已经被授权。在建立用户时，就为此用户分配一个密码，用户的密码可以由管理员指定，也可以由用户自行申请。\n\n### 持久化登陆\n**持久化登录**（*Persistent Login*）是一种使用户在多次会话之间保持登录状态的机制。\n一般情况下，每个 HTTP 请求都是独立的，服务器不会保存关于客户端的信息，因此服务器无法识两个连续请求是否来自相同用户。这被称为 **HTTP 协议的无状态性**。\n\n无状态性对于 Web 的可伸缩性和简单性至关重要。服务器不需要维护大量的客户端状态信息，这允许服务器更轻松地处理大量并发请求\n\n为了解决无状态性带来的问题，持久化登录机制应运而生。通常情况下，用户在登录后，系统会为其分配一个会话标识，并将该标识存储在客户端。这样，在用户下次访问网站时，系统可以通过检查客户端中的会话标识来自动识别用户，若验证成功，则将其视为已登录状态，而无需用户再次输入用户名和密码。\n\n## HTTP Basic Authentication\nHTTP 提供一个用于权限控制和认证的通用框架，`HTTP Basic Authentication` 是最常用的由 HTTP 协议定义的认证方式。\n\n常见的 *Basic HTTP 认证* 实现流程如下：\n\n1. 当客户端请求一个需要认证的资源时，服务器会返回一个 401 状态码，并在响应头中添加一个 WWW-Authenticate 字段，指明认证的方式（*Basic*）和安全域（*realm*）。\n2. 客户端收到 401 响应后，会弹出一个对话框，让用户输入用户名和密码。用户输入对应内容，然后客户端会将用户名和密码用冒号连接，使用 Base64 编码，再加上 Basic 前缀，作为 Authorization 字段的值，发送给服务器。\n3. 服务器收到 Authorization 字段后，会解码得到用户名和密码，然后进行验证。如果验证通过，服务器会返回请求的资源。如果验证失败，服务器会再次返回 401 响应。\n\n除此之外，还有 Bearer、Digest 等 HTTP 认证方案。如果你感兴趣，请移步此网址进行查看：[Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry](http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml)。\n\n如果你想给自己的网站添加鉴权功能，同时又不想编写一套前后端鉴权系统，可以尝试 `HTTP Basic Authentication`，它足以提供基本的鉴权功能，并且足够简单，简单到你只需要在 Nginx 中进行几句配置。\n\n使用 Nginx 为你的网站添加 HTTP 身份认证，可以参考这篇文章：[Nginx Http基本身份认证](`HTTP Basic Authentication` 足以提供一个基本的鉴权功能，简单易用，)。\n\n于此同时，`HTTP Basic Authentication` 的缺点也很明显：用户名和密码都是明文传输，容易被窃听或者重放，一般需要配合 HTTPS 来保证传输的安全性；不支持注销操作，只能关闭浏览器清除认证信息；只能为网站提供保护，很难实现私有路由；只能使用浏览器自带的提示框，不能自定义登陆页面……\n\n## session-cookie\n可以使用 session-cookie 实现前后端的鉴权认证。\n\n### cookie\n`Cookie`（*HTTP Cookie*）是一些 **字符串数据**，存储在客户端。\n\n服务器可以通过 HTTP 响应头将一个或多个 cookie 发送给客户端，客户端的浏览器会将这些 cookie 存储在本地。每次客户端向服务器发送请求时，浏览器会自动将与请求相关的 cookie 附加到请求头中发送给服务器。\n\n### session\n`Session`（*会话*）是服务器为了保存用户状态而创建的一个特殊的 **对象**。\n\n当浏览器第一次访问服务器时，服务器创建一个 session 对象 (该对象有一个唯一的 id ,一般称之为 `SessionId`)，服务器会将 SessionId 以 cookie 的方式发送给浏览器。当浏览器再次访问服务器时，会将 SessionId发送过来，服务器依据 SessionId 就可以找到对应的 session 对象，并对用户身份进行验证。\n\n### 实现流程\n1. 用户首次访问网站，服务器会创建一个 Session，并生成一个与之对应的 sid，创建的 Session 一般保存在服务器 *内存* 、*数据库* 或者 *redis* 中，通常是 redis；\n2. 服务器将 sid 填入 Cookie 中，然后将 Cookie 发送给客户端，客户端在接受到 Cookie 后将其保存在本地，通常存在 localStorage 或者 localCookie 中；\n3. 客户端在后续的请求中会携带这个 Cookie，服务器通过 Cookie 中的 sid 找到对应的 Session，从而识别用户状态，判断请求是否合法；\n4. 当用户退出登录或者 Session 过期后，服务器会销毁对应的 Session。\n\n你也可以参考下面这张图，更方便理解：\n\n![session实现流程](http://img.ma5hr00m.top//img/20230926223807.png)\n\n### 其他\nsession 和 cookie 经常同时使用，它们之间存在着很多区别，这里不做详细介绍，可阅读这篇文章：[Cookie和Session的区别](https://wangxiaoxi.cn/posts/http-cookie/)。\n\n当然，session-cookie 鉴权方案也存在一些不足：后端服务需要大量空间来存储用户身份信息；依赖 cookie 实现，无法在禁用 cookie 的浏览器中使用，同时容易出现 CSRF 漏洞；对移动端的支持不完善……\n\n## JWT\n`JSON Web Token`（*JWT*）是为在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准，一般被用来在服务端和客户端之间传递，以验证用户身份信息。\n\n`JWT` 是一个字符串，它由三部分组成：头部、载荷与签名，不同部分之间用 `.` 分隔。如果你对 JWT 的结构感兴趣，可以看看：[jwt.io](https://jwt.io/)，这个网站提供了对 JWT 的详细介绍以及在线编码、解码 jwt 的功能。\n\n使用 jwt 实现鉴权的一般流程如下：\n\n1. *用户登认证*\n   用户向服务器提交身份凭证，例如用户名和密码。\n2. *验证身份生成 jwt*\n   服务器验证用户提交的身份凭证的有效性，如果身份凭证有效，服务器会生成一个jwt，然后携带 jwt 返回给客户端。\n3. *客户端存储 jwt*\n   客户端接受到 jwt 后，将其保存在本地，之后的每次相关请求都会携带。\n4. *服务器验证 jwt*\n   服务器从请求头中获取 token，然后解析出用户信息和声明信息，并根据这些信息来验证用户是否有权访问特定资源。\n\n相比传统的 session-cookie 鉴权方案，JWT 鉴权有相当多的优势：\n- JWT 本身是无状态的，这意味着服务器不需要保存用户状态信息，节省了存储空间；\n- JWT 本身携带了部分用户信息，一定程度上可减轻查询数据库的需求；\n- JWT 不依赖于 Cookie，可以在禁用 cookie 的环境中运行，同时一定程度防止 CSRF 攻击；\n- JWT 体积小，传输速度快，\n- ……\n\n## OAuth\nOAuth 是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。\n这是一种很常见的鉴权方案，比如 GitHub 认证登陆。\n\n如果想学习 OAuth2.0，参考这篇文章：[理解 OAuth 2.0](https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n## SSO\n单点登录（SSO）是一种身份验证服务，用户只需要登录一次，就可以访问所有相互信任的应用系统。一般运作流程如下：\n\n1. *用户首次访问系统*  \n   当用户首次访问一个需要登录的应用时，该应用会发现用户未登录，然后将用户重定向到 SSO 认证中心，并将自己的地址作为参数。\n2. *用户在 SSO 认证中心进行登录*  \n   用户在 SSO 认证中心输入用户名和密码进行登录。如果登录成功，服务器会生成一个 ticket，并将该 ticket 追加到原始请求的 URL 参数中。\n3. *SSO系统进行认证*  \n   SSO 系统进行认证后，将登录状态写入 SSO 的 session，并在浏览器中写入 SSO 域下的 Cookie。\n4. *生成 Service Ticket*  \n   SSO 系统登录完成后会生成一个 ST（*Service Ticket*），然后跳转到原始请求的应用系统，同时将 ST 作为参数传递给该应用系统。\n5. *应用系统验证 ST*  \n   应用系统拿到 ST 后，从后台向 SSO 发送请求，验证 ST 是否有效。如果验证通过，应用系统将登录状态写入 session 并设置 app 域下的 Cookie。\n6. *访问受保护资源*  \n   此时用户可以访问原先请求的受保护资源。\n\n这就是单点登录（SSO）的工作原理和实现流程。值得注意的是，实现单点登录的关键在于如何让Session ID（或Token）在多个域中共享¹。\n\n探究 CAS 实现单点登陆的原理，参考这篇文章：[一篇文章彻底弄懂CAS实现SSO单点登录原理](https://www.cnblogs.com/wangsongbai/p/10299655.html)\n\n## PassKey\n一种新型的鉴权方式，摒弃了传统的账户密码的鉴权形式，实现无密码鉴权。\n\n原理参考这篇文章：[搞懂通行密钥](https://www.liaoxuefeng.com/article/1563183619768355)","source":"_posts/web-usual-auth.md","raw":"---\ntitle: 常见 Web 鉴权方案\ndate: 2023/09/14\nauthor: ma5hr00m\ncategories:\n- Web\n---\n\n面向 Web 新生补全知识点。\n\n## 鉴权 & 持久化登陆\n### 鉴权\n**鉴权**（*Authentication*）是指确认用户身份的过程。\n在计算机系统中，鉴权是一种安全机制，用于验证用户是否具有访问系统资源的权限。通过鉴权机制，系统可以验证用户提供的凭据（如用户名和密码、数字证书等），并决定是否授予用户所请求的访问权限。\n\n传统的鉴权是通过密码来实现的。这种方式的前提是，每个获得密码的用户都已经被授权。在建立用户时，就为此用户分配一个密码，用户的密码可以由管理员指定，也可以由用户自行申请。\n\n### 持久化登陆\n**持久化登录**（*Persistent Login*）是一种使用户在多次会话之间保持登录状态的机制。\n一般情况下，每个 HTTP 请求都是独立的，服务器不会保存关于客户端的信息，因此服务器无法识两个连续请求是否来自相同用户。这被称为 **HTTP 协议的无状态性**。\n\n无状态性对于 Web 的可伸缩性和简单性至关重要。服务器不需要维护大量的客户端状态信息，这允许服务器更轻松地处理大量并发请求\n\n为了解决无状态性带来的问题，持久化登录机制应运而生。通常情况下，用户在登录后，系统会为其分配一个会话标识，并将该标识存储在客户端。这样，在用户下次访问网站时，系统可以通过检查客户端中的会话标识来自动识别用户，若验证成功，则将其视为已登录状态，而无需用户再次输入用户名和密码。\n\n## HTTP Basic Authentication\nHTTP 提供一个用于权限控制和认证的通用框架，`HTTP Basic Authentication` 是最常用的由 HTTP 协议定义的认证方式。\n\n常见的 *Basic HTTP 认证* 实现流程如下：\n\n1. 当客户端请求一个需要认证的资源时，服务器会返回一个 401 状态码，并在响应头中添加一个 WWW-Authenticate 字段，指明认证的方式（*Basic*）和安全域（*realm*）。\n2. 客户端收到 401 响应后，会弹出一个对话框，让用户输入用户名和密码。用户输入对应内容，然后客户端会将用户名和密码用冒号连接，使用 Base64 编码，再加上 Basic 前缀，作为 Authorization 字段的值，发送给服务器。\n3. 服务器收到 Authorization 字段后，会解码得到用户名和密码，然后进行验证。如果验证通过，服务器会返回请求的资源。如果验证失败，服务器会再次返回 401 响应。\n\n除此之外，还有 Bearer、Digest 等 HTTP 认证方案。如果你感兴趣，请移步此网址进行查看：[Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry](http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml)。\n\n如果你想给自己的网站添加鉴权功能，同时又不想编写一套前后端鉴权系统，可以尝试 `HTTP Basic Authentication`，它足以提供基本的鉴权功能，并且足够简单，简单到你只需要在 Nginx 中进行几句配置。\n\n使用 Nginx 为你的网站添加 HTTP 身份认证，可以参考这篇文章：[Nginx Http基本身份认证](`HTTP Basic Authentication` 足以提供一个基本的鉴权功能，简单易用，)。\n\n于此同时，`HTTP Basic Authentication` 的缺点也很明显：用户名和密码都是明文传输，容易被窃听或者重放，一般需要配合 HTTPS 来保证传输的安全性；不支持注销操作，只能关闭浏览器清除认证信息；只能为网站提供保护，很难实现私有路由；只能使用浏览器自带的提示框，不能自定义登陆页面……\n\n## session-cookie\n可以使用 session-cookie 实现前后端的鉴权认证。\n\n### cookie\n`Cookie`（*HTTP Cookie*）是一些 **字符串数据**，存储在客户端。\n\n服务器可以通过 HTTP 响应头将一个或多个 cookie 发送给客户端，客户端的浏览器会将这些 cookie 存储在本地。每次客户端向服务器发送请求时，浏览器会自动将与请求相关的 cookie 附加到请求头中发送给服务器。\n\n### session\n`Session`（*会话*）是服务器为了保存用户状态而创建的一个特殊的 **对象**。\n\n当浏览器第一次访问服务器时，服务器创建一个 session 对象 (该对象有一个唯一的 id ,一般称之为 `SessionId`)，服务器会将 SessionId 以 cookie 的方式发送给浏览器。当浏览器再次访问服务器时，会将 SessionId发送过来，服务器依据 SessionId 就可以找到对应的 session 对象，并对用户身份进行验证。\n\n### 实现流程\n1. 用户首次访问网站，服务器会创建一个 Session，并生成一个与之对应的 sid，创建的 Session 一般保存在服务器 *内存* 、*数据库* 或者 *redis* 中，通常是 redis；\n2. 服务器将 sid 填入 Cookie 中，然后将 Cookie 发送给客户端，客户端在接受到 Cookie 后将其保存在本地，通常存在 localStorage 或者 localCookie 中；\n3. 客户端在后续的请求中会携带这个 Cookie，服务器通过 Cookie 中的 sid 找到对应的 Session，从而识别用户状态，判断请求是否合法；\n4. 当用户退出登录或者 Session 过期后，服务器会销毁对应的 Session。\n\n你也可以参考下面这张图，更方便理解：\n\n![session实现流程](http://img.ma5hr00m.top//img/20230926223807.png)\n\n### 其他\nsession 和 cookie 经常同时使用，它们之间存在着很多区别，这里不做详细介绍，可阅读这篇文章：[Cookie和Session的区别](https://wangxiaoxi.cn/posts/http-cookie/)。\n\n当然，session-cookie 鉴权方案也存在一些不足：后端服务需要大量空间来存储用户身份信息；依赖 cookie 实现，无法在禁用 cookie 的浏览器中使用，同时容易出现 CSRF 漏洞；对移动端的支持不完善……\n\n## JWT\n`JSON Web Token`（*JWT*）是为在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准，一般被用来在服务端和客户端之间传递，以验证用户身份信息。\n\n`JWT` 是一个字符串，它由三部分组成：头部、载荷与签名，不同部分之间用 `.` 分隔。如果你对 JWT 的结构感兴趣，可以看看：[jwt.io](https://jwt.io/)，这个网站提供了对 JWT 的详细介绍以及在线编码、解码 jwt 的功能。\n\n使用 jwt 实现鉴权的一般流程如下：\n\n1. *用户登认证*\n   用户向服务器提交身份凭证，例如用户名和密码。\n2. *验证身份生成 jwt*\n   服务器验证用户提交的身份凭证的有效性，如果身份凭证有效，服务器会生成一个jwt，然后携带 jwt 返回给客户端。\n3. *客户端存储 jwt*\n   客户端接受到 jwt 后，将其保存在本地，之后的每次相关请求都会携带。\n4. *服务器验证 jwt*\n   服务器从请求头中获取 token，然后解析出用户信息和声明信息，并根据这些信息来验证用户是否有权访问特定资源。\n\n相比传统的 session-cookie 鉴权方案，JWT 鉴权有相当多的优势：\n- JWT 本身是无状态的，这意味着服务器不需要保存用户状态信息，节省了存储空间；\n- JWT 本身携带了部分用户信息，一定程度上可减轻查询数据库的需求；\n- JWT 不依赖于 Cookie，可以在禁用 cookie 的环境中运行，同时一定程度防止 CSRF 攻击；\n- JWT 体积小，传输速度快，\n- ……\n\n## OAuth\nOAuth 是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。\n这是一种很常见的鉴权方案，比如 GitHub 认证登陆。\n\n如果想学习 OAuth2.0，参考这篇文章：[理解 OAuth 2.0](https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n\n## SSO\n单点登录（SSO）是一种身份验证服务，用户只需要登录一次，就可以访问所有相互信任的应用系统。一般运作流程如下：\n\n1. *用户首次访问系统*  \n   当用户首次访问一个需要登录的应用时，该应用会发现用户未登录，然后将用户重定向到 SSO 认证中心，并将自己的地址作为参数。\n2. *用户在 SSO 认证中心进行登录*  \n   用户在 SSO 认证中心输入用户名和密码进行登录。如果登录成功，服务器会生成一个 ticket，并将该 ticket 追加到原始请求的 URL 参数中。\n3. *SSO系统进行认证*  \n   SSO 系统进行认证后，将登录状态写入 SSO 的 session，并在浏览器中写入 SSO 域下的 Cookie。\n4. *生成 Service Ticket*  \n   SSO 系统登录完成后会生成一个 ST（*Service Ticket*），然后跳转到原始请求的应用系统，同时将 ST 作为参数传递给该应用系统。\n5. *应用系统验证 ST*  \n   应用系统拿到 ST 后，从后台向 SSO 发送请求，验证 ST 是否有效。如果验证通过，应用系统将登录状态写入 session 并设置 app 域下的 Cookie。\n6. *访问受保护资源*  \n   此时用户可以访问原先请求的受保护资源。\n\n这就是单点登录（SSO）的工作原理和实现流程。值得注意的是，实现单点登录的关键在于如何让Session ID（或Token）在多个域中共享¹。\n\n探究 CAS 实现单点登陆的原理，参考这篇文章：[一篇文章彻底弄懂CAS实现SSO单点登录原理](https://www.cnblogs.com/wangsongbai/p/10299655.html)\n\n## PassKey\n一种新型的鉴权方式，摒弃了传统的账户密码的鉴权形式，实现无密码鉴权。\n\n原理参考这篇文章：[搞懂通行密钥](https://www.liaoxuefeng.com/article/1563183619768355)","slug":"web-usual-auth","published":1,"updated":"2024-06-09T12:56:00.175Z","comments":1,"layout":"post","photos":[],"_id":"clxhruapb0019f4ly301z3d6e","content":"<p>面向 Web 新生补全知识点。</p>\n<h2 id=\"鉴权-持久化登陆\"><a href=\"#鉴权-持久化登陆\" class=\"headerlink\" title=\"鉴权 &amp; 持久化登陆\"></a>鉴权 &amp; 持久化登陆</h2><h3 id=\"鉴权\"><a href=\"#鉴权\" class=\"headerlink\" title=\"鉴权\"></a>鉴权</h3><p><strong>鉴权</strong>（<em>Authentication</em>）是指确认用户身份的过程。<br>在计算机系统中，鉴权是一种安全机制，用于验证用户是否具有访问系统资源的权限。通过鉴权机制，系统可以验证用户提供的凭据（如用户名和密码、数字证书等），并决定是否授予用户所请求的访问权限。</p>\n<p>传统的鉴权是通过密码来实现的。这种方式的前提是，每个获得密码的用户都已经被授权。在建立用户时，就为此用户分配一个密码，用户的密码可以由管理员指定，也可以由用户自行申请。</p>\n<h3 id=\"持久化登陆\"><a href=\"#持久化登陆\" class=\"headerlink\" title=\"持久化登陆\"></a>持久化登陆</h3><p><strong>持久化登录</strong>（<em>Persistent Login</em>）是一种使用户在多次会话之间保持登录状态的机制。<br>一般情况下，每个 HTTP 请求都是独立的，服务器不会保存关于客户端的信息，因此服务器无法识两个连续请求是否来自相同用户。这被称为 <strong>HTTP 协议的无状态性</strong>。</p>\n<p>无状态性对于 Web 的可伸缩性和简单性至关重要。服务器不需要维护大量的客户端状态信息，这允许服务器更轻松地处理大量并发请求</p>\n<p>为了解决无状态性带来的问题，持久化登录机制应运而生。通常情况下，用户在登录后，系统会为其分配一个会话标识，并将该标识存储在客户端。这样，在用户下次访问网站时，系统可以通过检查客户端中的会话标识来自动识别用户，若验证成功，则将其视为已登录状态，而无需用户再次输入用户名和密码。</p>\n<h2 id=\"HTTP-Basic-Authentication\"><a href=\"#HTTP-Basic-Authentication\" class=\"headerlink\" title=\"HTTP Basic Authentication\"></a>HTTP Basic Authentication</h2><p>HTTP 提供一个用于权限控制和认证的通用框架，<code>HTTP Basic Authentication</code> 是最常用的由 HTTP 协议定义的认证方式。</p>\n<p>常见的 <em>Basic HTTP 认证</em> 实现流程如下：</p>\n<ol>\n<li>当客户端请求一个需要认证的资源时，服务器会返回一个 401 状态码，并在响应头中添加一个 WWW-Authenticate 字段，指明认证的方式（<em>Basic</em>）和安全域（<em>realm</em>）。</li>\n<li>客户端收到 401 响应后，会弹出一个对话框，让用户输入用户名和密码。用户输入对应内容，然后客户端会将用户名和密码用冒号连接，使用 Base64 编码，再加上 Basic 前缀，作为 Authorization 字段的值，发送给服务器。</li>\n<li>服务器收到 Authorization 字段后，会解码得到用户名和密码，然后进行验证。如果验证通过，服务器会返回请求的资源。如果验证失败，服务器会再次返回 401 响应。</li>\n</ol>\n<p>除此之外，还有 Bearer、Digest 等 HTTP 认证方案。如果你感兴趣，请移步此网址进行查看：<a href=\"http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry</a>。</p>\n<p>如果你想给自己的网站添加鉴权功能，同时又不想编写一套前后端鉴权系统，可以尝试 <code>HTTP Basic Authentication</code>，它足以提供基本的鉴权功能，并且足够简单，简单到你只需要在 Nginx 中进行几句配置。</p>\n<p>使用 Nginx 为你的网站添加 HTTP 身份认证，可以参考这篇文章：[Nginx Http基本身份认证](<code>HTTP Basic Authentication</code> 足以提供一个基本的鉴权功能，简单易用，)。</p>\n<p>于此同时，<code>HTTP Basic Authentication</code> 的缺点也很明显：用户名和密码都是明文传输，容易被窃听或者重放，一般需要配合 HTTPS 来保证传输的安全性；不支持注销操作，只能关闭浏览器清除认证信息；只能为网站提供保护，很难实现私有路由；只能使用浏览器自带的提示框，不能自定义登陆页面……</p>\n<h2 id=\"session-cookie\"><a href=\"#session-cookie\" class=\"headerlink\" title=\"session-cookie\"></a>session-cookie</h2><p>可以使用 session-cookie 实现前后端的鉴权认证。</p>\n<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h3><p><code>Cookie</code>（<em>HTTP Cookie</em>）是一些 <strong>字符串数据</strong>，存储在客户端。</p>\n<p>服务器可以通过 HTTP 响应头将一个或多个 cookie 发送给客户端，客户端的浏览器会将这些 cookie 存储在本地。每次客户端向服务器发送请求时，浏览器会自动将与请求相关的 cookie 附加到请求头中发送给服务器。</p>\n<h3 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h3><p><code>Session</code>（<em>会话</em>）是服务器为了保存用户状态而创建的一个特殊的 <strong>对象</strong>。</p>\n<p>当浏览器第一次访问服务器时，服务器创建一个 session 对象 (该对象有一个唯一的 id ,一般称之为 <code>SessionId</code>)，服务器会将 SessionId 以 cookie 的方式发送给浏览器。当浏览器再次访问服务器时，会将 SessionId发送过来，服务器依据 SessionId 就可以找到对应的 session 对象，并对用户身份进行验证。</p>\n<h3 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h3><ol>\n<li>用户首次访问网站，服务器会创建一个 Session，并生成一个与之对应的 sid，创建的 Session 一般保存在服务器 <em>内存</em> 、<em>数据库</em> 或者 <em>redis</em> 中，通常是 redis；</li>\n<li>服务器将 sid 填入 Cookie 中，然后将 Cookie 发送给客户端，客户端在接受到 Cookie 后将其保存在本地，通常存在 localStorage 或者 localCookie 中；</li>\n<li>客户端在后续的请求中会携带这个 Cookie，服务器通过 Cookie 中的 sid 找到对应的 Session，从而识别用户状态，判断请求是否合法；</li>\n<li>当用户退出登录或者 Session 过期后，服务器会销毁对应的 Session。</li>\n</ol>\n<p>你也可以参考下面这张图，更方便理解：</p>\n<p><img src=\"http://img.ma5hr00m.top//img/20230926223807.png\" alt=\"session实现流程\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>session 和 cookie 经常同时使用，它们之间存在着很多区别，这里不做详细介绍，可阅读这篇文章：<a href=\"https://wangxiaoxi.cn/posts/http-cookie/\">Cookie和Session的区别</a>。</p>\n<p>当然，session-cookie 鉴权方案也存在一些不足：后端服务需要大量空间来存储用户身份信息；依赖 cookie 实现，无法在禁用 cookie 的浏览器中使用，同时容易出现 CSRF 漏洞；对移动端的支持不完善……</p>\n<h2 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h2><p><code>JSON Web Token</code>（<em>JWT</em>）是为在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准，一般被用来在服务端和客户端之间传递，以验证用户身份信息。</p>\n<p><code>JWT</code> 是一个字符串，它由三部分组成：头部、载荷与签名，不同部分之间用 <code>.</code> 分隔。如果你对 JWT 的结构感兴趣，可以看看：<a href=\"https://jwt.io/\">jwt.io</a>，这个网站提供了对 JWT 的详细介绍以及在线编码、解码 jwt 的功能。</p>\n<p>使用 jwt 实现鉴权的一般流程如下：</p>\n<ol>\n<li><em>用户登认证</em><br>用户向服务器提交身份凭证，例如用户名和密码。</li>\n<li><em>验证身份生成 jwt</em><br>服务器验证用户提交的身份凭证的有效性，如果身份凭证有效，服务器会生成一个jwt，然后携带 jwt 返回给客户端。</li>\n<li><em>客户端存储 jwt</em><br>客户端接受到 jwt 后，将其保存在本地，之后的每次相关请求都会携带。</li>\n<li><em>服务器验证 jwt</em><br>服务器从请求头中获取 token，然后解析出用户信息和声明信息，并根据这些信息来验证用户是否有权访问特定资源。</li>\n</ol>\n<p>相比传统的 session-cookie 鉴权方案，JWT 鉴权有相当多的优势：</p>\n<ul>\n<li>JWT 本身是无状态的，这意味着服务器不需要保存用户状态信息，节省了存储空间；</li>\n<li>JWT 本身携带了部分用户信息，一定程度上可减轻查询数据库的需求；</li>\n<li>JWT 不依赖于 Cookie，可以在禁用 cookie 的环境中运行，同时一定程度防止 CSRF 攻击；</li>\n<li>JWT 体积小，传输速度快，</li>\n<li>……</li>\n</ul>\n<h2 id=\"OAuth\"><a href=\"#OAuth\" class=\"headerlink\" title=\"OAuth\"></a>OAuth</h2><p>OAuth 是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。<br>这是一种很常见的鉴权方案，比如 GitHub 认证登陆。</p>\n<p>如果想学习 OAuth2.0，参考这篇文章：<a href=\"https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">理解 OAuth 2.0</a></p>\n<h2 id=\"SSO\"><a href=\"#SSO\" class=\"headerlink\" title=\"SSO\"></a>SSO</h2><p>单点登录（SSO）是一种身份验证服务，用户只需要登录一次，就可以访问所有相互信任的应用系统。一般运作流程如下：</p>\n<ol>\n<li><em>用户首次访问系统</em><br>当用户首次访问一个需要登录的应用时，该应用会发现用户未登录，然后将用户重定向到 SSO 认证中心，并将自己的地址作为参数。</li>\n<li><em>用户在 SSO 认证中心进行登录</em><br>用户在 SSO 认证中心输入用户名和密码进行登录。如果登录成功，服务器会生成一个 ticket，并将该 ticket 追加到原始请求的 URL 参数中。</li>\n<li><em>SSO系统进行认证</em><br>SSO 系统进行认证后，将登录状态写入 SSO 的 session，并在浏览器中写入 SSO 域下的 Cookie。</li>\n<li><em>生成 Service Ticket</em><br>SSO 系统登录完成后会生成一个 ST（<em>Service Ticket</em>），然后跳转到原始请求的应用系统，同时将 ST 作为参数传递给该应用系统。</li>\n<li><em>应用系统验证 ST</em><br>应用系统拿到 ST 后，从后台向 SSO 发送请求，验证 ST 是否有效。如果验证通过，应用系统将登录状态写入 session 并设置 app 域下的 Cookie。</li>\n<li><em>访问受保护资源</em><br>此时用户可以访问原先请求的受保护资源。</li>\n</ol>\n<p>这就是单点登录（SSO）的工作原理和实现流程。值得注意的是，实现单点登录的关键在于如何让Session ID（或Token）在多个域中共享¹。</p>\n<p>探究 CAS 实现单点登陆的原理，参考这篇文章：<a href=\"https://www.cnblogs.com/wangsongbai/p/10299655.html\">一篇文章彻底弄懂CAS实现SSO单点登录原理</a></p>\n<h2 id=\"PassKey\"><a href=\"#PassKey\" class=\"headerlink\" title=\"PassKey\"></a>PassKey</h2><p>一种新型的鉴权方式，摒弃了传统的账户密码的鉴权形式，实现无密码鉴权。</p>\n<p>原理参考这篇文章：<a href=\"https://www.liaoxuefeng.com/article/1563183619768355\">搞懂通行密钥</a></p>\n","excerpt":"","more":"<p>面向 Web 新生补全知识点。</p>\n<h2 id=\"鉴权-持久化登陆\"><a href=\"#鉴权-持久化登陆\" class=\"headerlink\" title=\"鉴权 &amp; 持久化登陆\"></a>鉴权 &amp; 持久化登陆</h2><h3 id=\"鉴权\"><a href=\"#鉴权\" class=\"headerlink\" title=\"鉴权\"></a>鉴权</h3><p><strong>鉴权</strong>（<em>Authentication</em>）是指确认用户身份的过程。<br>在计算机系统中，鉴权是一种安全机制，用于验证用户是否具有访问系统资源的权限。通过鉴权机制，系统可以验证用户提供的凭据（如用户名和密码、数字证书等），并决定是否授予用户所请求的访问权限。</p>\n<p>传统的鉴权是通过密码来实现的。这种方式的前提是，每个获得密码的用户都已经被授权。在建立用户时，就为此用户分配一个密码，用户的密码可以由管理员指定，也可以由用户自行申请。</p>\n<h3 id=\"持久化登陆\"><a href=\"#持久化登陆\" class=\"headerlink\" title=\"持久化登陆\"></a>持久化登陆</h3><p><strong>持久化登录</strong>（<em>Persistent Login</em>）是一种使用户在多次会话之间保持登录状态的机制。<br>一般情况下，每个 HTTP 请求都是独立的，服务器不会保存关于客户端的信息，因此服务器无法识两个连续请求是否来自相同用户。这被称为 <strong>HTTP 协议的无状态性</strong>。</p>\n<p>无状态性对于 Web 的可伸缩性和简单性至关重要。服务器不需要维护大量的客户端状态信息，这允许服务器更轻松地处理大量并发请求</p>\n<p>为了解决无状态性带来的问题，持久化登录机制应运而生。通常情况下，用户在登录后，系统会为其分配一个会话标识，并将该标识存储在客户端。这样，在用户下次访问网站时，系统可以通过检查客户端中的会话标识来自动识别用户，若验证成功，则将其视为已登录状态，而无需用户再次输入用户名和密码。</p>\n<h2 id=\"HTTP-Basic-Authentication\"><a href=\"#HTTP-Basic-Authentication\" class=\"headerlink\" title=\"HTTP Basic Authentication\"></a>HTTP Basic Authentication</h2><p>HTTP 提供一个用于权限控制和认证的通用框架，<code>HTTP Basic Authentication</code> 是最常用的由 HTTP 协议定义的认证方式。</p>\n<p>常见的 <em>Basic HTTP 认证</em> 实现流程如下：</p>\n<ol>\n<li>当客户端请求一个需要认证的资源时，服务器会返回一个 401 状态码，并在响应头中添加一个 WWW-Authenticate 字段，指明认证的方式（<em>Basic</em>）和安全域（<em>realm</em>）。</li>\n<li>客户端收到 401 响应后，会弹出一个对话框，让用户输入用户名和密码。用户输入对应内容，然后客户端会将用户名和密码用冒号连接，使用 Base64 编码，再加上 Basic 前缀，作为 Authorization 字段的值，发送给服务器。</li>\n<li>服务器收到 Authorization 字段后，会解码得到用户名和密码，然后进行验证。如果验证通过，服务器会返回请求的资源。如果验证失败，服务器会再次返回 401 响应。</li>\n</ol>\n<p>除此之外，还有 Bearer、Digest 等 HTTP 认证方案。如果你感兴趣，请移步此网址进行查看：<a href=\"http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml\">Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry</a>。</p>\n<p>如果你想给自己的网站添加鉴权功能，同时又不想编写一套前后端鉴权系统，可以尝试 <code>HTTP Basic Authentication</code>，它足以提供基本的鉴权功能，并且足够简单，简单到你只需要在 Nginx 中进行几句配置。</p>\n<p>使用 Nginx 为你的网站添加 HTTP 身份认证，可以参考这篇文章：[Nginx Http基本身份认证](<code>HTTP Basic Authentication</code> 足以提供一个基本的鉴权功能，简单易用，)。</p>\n<p>于此同时，<code>HTTP Basic Authentication</code> 的缺点也很明显：用户名和密码都是明文传输，容易被窃听或者重放，一般需要配合 HTTPS 来保证传输的安全性；不支持注销操作，只能关闭浏览器清除认证信息；只能为网站提供保护，很难实现私有路由；只能使用浏览器自带的提示框，不能自定义登陆页面……</p>\n<h2 id=\"session-cookie\"><a href=\"#session-cookie\" class=\"headerlink\" title=\"session-cookie\"></a>session-cookie</h2><p>可以使用 session-cookie 实现前后端的鉴权认证。</p>\n<h3 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h3><p><code>Cookie</code>（<em>HTTP Cookie</em>）是一些 <strong>字符串数据</strong>，存储在客户端。</p>\n<p>服务器可以通过 HTTP 响应头将一个或多个 cookie 发送给客户端，客户端的浏览器会将这些 cookie 存储在本地。每次客户端向服务器发送请求时，浏览器会自动将与请求相关的 cookie 附加到请求头中发送给服务器。</p>\n<h3 id=\"session\"><a href=\"#session\" class=\"headerlink\" title=\"session\"></a>session</h3><p><code>Session</code>（<em>会话</em>）是服务器为了保存用户状态而创建的一个特殊的 <strong>对象</strong>。</p>\n<p>当浏览器第一次访问服务器时，服务器创建一个 session 对象 (该对象有一个唯一的 id ,一般称之为 <code>SessionId</code>)，服务器会将 SessionId 以 cookie 的方式发送给浏览器。当浏览器再次访问服务器时，会将 SessionId发送过来，服务器依据 SessionId 就可以找到对应的 session 对象，并对用户身份进行验证。</p>\n<h3 id=\"实现流程\"><a href=\"#实现流程\" class=\"headerlink\" title=\"实现流程\"></a>实现流程</h3><ol>\n<li>用户首次访问网站，服务器会创建一个 Session，并生成一个与之对应的 sid，创建的 Session 一般保存在服务器 <em>内存</em> 、<em>数据库</em> 或者 <em>redis</em> 中，通常是 redis；</li>\n<li>服务器将 sid 填入 Cookie 中，然后将 Cookie 发送给客户端，客户端在接受到 Cookie 后将其保存在本地，通常存在 localStorage 或者 localCookie 中；</li>\n<li>客户端在后续的请求中会携带这个 Cookie，服务器通过 Cookie 中的 sid 找到对应的 Session，从而识别用户状态，判断请求是否合法；</li>\n<li>当用户退出登录或者 Session 过期后，服务器会销毁对应的 Session。</li>\n</ol>\n<p>你也可以参考下面这张图，更方便理解：</p>\n<p><img src=\"http://img.ma5hr00m.top//img/20230926223807.png\" alt=\"session实现流程\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>session 和 cookie 经常同时使用，它们之间存在着很多区别，这里不做详细介绍，可阅读这篇文章：<a href=\"https://wangxiaoxi.cn/posts/http-cookie/\">Cookie和Session的区别</a>。</p>\n<p>当然，session-cookie 鉴权方案也存在一些不足：后端服务需要大量空间来存储用户身份信息；依赖 cookie 实现，无法在禁用 cookie 的浏览器中使用，同时容易出现 CSRF 漏洞；对移动端的支持不完善……</p>\n<h2 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h2><p><code>JSON Web Token</code>（<em>JWT</em>）是为在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准，一般被用来在服务端和客户端之间传递，以验证用户身份信息。</p>\n<p><code>JWT</code> 是一个字符串，它由三部分组成：头部、载荷与签名，不同部分之间用 <code>.</code> 分隔。如果你对 JWT 的结构感兴趣，可以看看：<a href=\"https://jwt.io/\">jwt.io</a>，这个网站提供了对 JWT 的详细介绍以及在线编码、解码 jwt 的功能。</p>\n<p>使用 jwt 实现鉴权的一般流程如下：</p>\n<ol>\n<li><em>用户登认证</em><br>用户向服务器提交身份凭证，例如用户名和密码。</li>\n<li><em>验证身份生成 jwt</em><br>服务器验证用户提交的身份凭证的有效性，如果身份凭证有效，服务器会生成一个jwt，然后携带 jwt 返回给客户端。</li>\n<li><em>客户端存储 jwt</em><br>客户端接受到 jwt 后，将其保存在本地，之后的每次相关请求都会携带。</li>\n<li><em>服务器验证 jwt</em><br>服务器从请求头中获取 token，然后解析出用户信息和声明信息，并根据这些信息来验证用户是否有权访问特定资源。</li>\n</ol>\n<p>相比传统的 session-cookie 鉴权方案，JWT 鉴权有相当多的优势：</p>\n<ul>\n<li>JWT 本身是无状态的，这意味着服务器不需要保存用户状态信息，节省了存储空间；</li>\n<li>JWT 本身携带了部分用户信息，一定程度上可减轻查询数据库的需求；</li>\n<li>JWT 不依赖于 Cookie，可以在禁用 cookie 的环境中运行，同时一定程度防止 CSRF 攻击；</li>\n<li>JWT 体积小，传输速度快，</li>\n<li>……</li>\n</ul>\n<h2 id=\"OAuth\"><a href=\"#OAuth\" class=\"headerlink\" title=\"OAuth\"></a>OAuth</h2><p>OAuth 是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。<br>这是一种很常见的鉴权方案，比如 GitHub 认证登陆。</p>\n<p>如果想学习 OAuth2.0，参考这篇文章：<a href=\"https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">理解 OAuth 2.0</a></p>\n<h2 id=\"SSO\"><a href=\"#SSO\" class=\"headerlink\" title=\"SSO\"></a>SSO</h2><p>单点登录（SSO）是一种身份验证服务，用户只需要登录一次，就可以访问所有相互信任的应用系统。一般运作流程如下：</p>\n<ol>\n<li><em>用户首次访问系统</em><br>当用户首次访问一个需要登录的应用时，该应用会发现用户未登录，然后将用户重定向到 SSO 认证中心，并将自己的地址作为参数。</li>\n<li><em>用户在 SSO 认证中心进行登录</em><br>用户在 SSO 认证中心输入用户名和密码进行登录。如果登录成功，服务器会生成一个 ticket，并将该 ticket 追加到原始请求的 URL 参数中。</li>\n<li><em>SSO系统进行认证</em><br>SSO 系统进行认证后，将登录状态写入 SSO 的 session，并在浏览器中写入 SSO 域下的 Cookie。</li>\n<li><em>生成 Service Ticket</em><br>SSO 系统登录完成后会生成一个 ST（<em>Service Ticket</em>），然后跳转到原始请求的应用系统，同时将 ST 作为参数传递给该应用系统。</li>\n<li><em>应用系统验证 ST</em><br>应用系统拿到 ST 后，从后台向 SSO 发送请求，验证 ST 是否有效。如果验证通过，应用系统将登录状态写入 session 并设置 app 域下的 Cookie。</li>\n<li><em>访问受保护资源</em><br>此时用户可以访问原先请求的受保护资源。</li>\n</ol>\n<p>这就是单点登录（SSO）的工作原理和实现流程。值得注意的是，实现单点登录的关键在于如何让Session ID（或Token）在多个域中共享¹。</p>\n<p>探究 CAS 实现单点登陆的原理，参考这篇文章：<a href=\"https://www.cnblogs.com/wangsongbai/p/10299655.html\">一篇文章彻底弄懂CAS实现SSO单点登录原理</a></p>\n<h2 id=\"PassKey\"><a href=\"#PassKey\" class=\"headerlink\" title=\"PassKey\"></a>PassKey</h2><p>一种新型的鉴权方式，摒弃了传统的账户密码的鉴权形式，实现无密码鉴权。</p>\n<p>原理参考这篇文章：<a href=\"https://www.liaoxuefeng.com/article/1563183619768355\">搞懂通行密钥</a></p>\n"},{"title":"旧文章在哪里","date":"2021-12-31T16:00:00.000Z","_content":"\n原博客地址：https://vitepress.ma5gr00m.top","source":"_posts/where_is_posts.md","raw":"---\ntitle: 旧文章在哪里\ndate: 2022/1/1\ncategories:\n- Life\n---\n\n原博客地址：https://vitepress.ma5gr00m.top","slug":"where_is_posts","published":1,"updated":"2024-06-09T13:50:33.990Z","comments":1,"layout":"post","photos":[],"_id":"clxhruapb001cf4lyb3huerm4","content":"<p>原博客地址：<a href=\"https://vitepress.ma5gr00m.top/\">https://vitepress.ma5gr00m.top</a></p>\n","excerpt":"","more":"<p>原博客地址：<a href=\"https://vitepress.ma5gr00m.top/\">https://vitepress.ma5gr00m.top</a></p>\n"},{"title":"Linux 中 Python 环境与版本管理","date":"2023-11-22T16:00:00.000Z","author":"ma5hr00m","_content":"\n阿菇觉得 Python 的环境/版本管理实在是依托，感觉不如 Node.js。\n尤其是在 Linux 环境下，多数发行版的系统组件、工具依赖自带的 Python，折腾系统自带的 Python 环境时，一个搞不好就会把整个系统干掉。\n\n同时，研究安全的小伙伴经常用各种工具，而很多工具又是是基于 python2 的，而当前使用的绝大多数 Linux 发行版都自带的 python3，不方便。\n\n另一方面，我们的各种 python 项目都会有各自需要的依赖，而我们总不可能把所有需要的依赖库都直接全局安装，这很丑陋，而且很多情况下不方便项目的迁移。\n\n> 流行的 python 项目/工具基本都是提供了 `requirements.txt`，用户需要手动本地安装。\n\nWindows 系统中，我们可以直接使用强大的 [Anaconda](https://www.anaconda.com/) 管理我们的 python 环境以及版本，Linux 就不行了。\n这篇文章，总结了阿菇在 python 环境/版本管理方面的经验，可供参考。\n\n::: warning  \n本篇文章使用环境：系统 `Ubuntu22.04`，自带 `python3.10.12`。\n:::\n\n## py3环境管理 - venv\npython3 推出了 `venv` 模块，python3.6 及以上已经默认安装，python3.5 需要手动安装：\n\n```bash\nsudo apt install python3-venv\n```\n\nvenv 模块支持创建轻量级的虚拟环境，每个环境拥有它们自己安装在其 `/site` 目录下的 python 软件包（依赖）集合。\n\n### 使用\n\n使用以下指令可以创建一个 python 虚拟环境，python 版本与当前系统使用的 python 版本相同：\n\n```bash\npython3 -m venv env\n```\n\n实际效果就是在你的当前目录下创建一个名为 `env` 的目录，其中包括了特定的 python 解释器、软件库和二进制文件。你可以把上面指令中的 `env` 替换为你想要的虚拟环境名称（也就是那个目录名称），习惯上我们会将其命名为 `venv` 或者 `.venv`，通常放在项目根目录下。\n\n需要遵守一些默认规范。python 虚拟环境是可丢弃的，也就是说，我们不会将其一并打包的项目中，我们只需要给用户提供 `requirements.txt` 文件，用户自己创建一个虚拟环境并安装所需依赖。开发者不应该把任何项目代码放到虚拟环境目录中。同时，我们也不会移动虚拟环境，哪里需要就在哪里创建。\n\n创建好虚拟环境后，它只是一个放在那儿的目录，需要手动激活。\n\n假设你是在当前目录下创建了名为 `venv` 的虚拟环境，你使用以下指令将这个虚拟环境激活：\n\n```bash\nsource ./venv/bin/active\n```\n\n然后你可以发现命令行中标志出当前命令行使用了虚拟环境，虚拟环境名称默认与当前项目名称相同。\n\n![20231102001458](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d4846c761b4d5bb86b8863cd745a83~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980\\&h=365\\&s=57542\\&e=png\\&b=0e1019)\n\n>图中是 [zsh](https://www.zsh.org/)，配置了 [oh-my-zsh](https://ohmyz.sh/)，应用了 [powerlevel10K 主题](https://github.com/romkatv/powerlevel10k)，通过 [tabby 模拟终端工具](https://tabby.sh/) 使用，是一个非常 nice 的组合，可以试试看！\n\n此时使用 `pip --version` 会提示用户使用的是虚拟环境中的 `pip` 包管理工具。激活虚拟环境后我们就可以在这里面肆意安装我们需要的各种依赖了，虚拟环境与外界是隔离的，你可以想象成虚拟机，一般不会影响到系统本身。\n\n使用完虚拟环境后，执行以下指令关闭虚拟环境：\n\n```bash\ndeactivate\n```\n\n### 进一步\n\n就是如此的干净清爽，我们只需用系统自带的 python 创建虚拟环境即可，之后的一切依赖都放在各自的虚拟环境中，不用把自己系统的 python 软件包搞得一团糟。\n\n阿菇的建议是：*不要在自己的系统中安装任何额外的 python 软件包，把自带的 python 当作一个虚拟环境创建器，所有需要依赖的项目都单独创建一个虚拟环境*。\n\n现在问题来了。我们使用这个指令只能创建与当前版本相同的 python 虚拟环境，并不能满足我们的需求，下一步该怎么做呢？\n\n## Linux中使用python2\n\n很多 Linux 发行版不带 python2 环境，但我们有时需要用。可以在系统中配置一个 python2 环境。\n\n### python2\n\n包管理工具直接安装：\n\n```bash\nsudo apt install python2\n```\n\n安装好之后指定使用 `python2` 即可，默认路径是 `/usr/bin/python2`，此时可以使用 `python2` 来运行代码了。\n\n> 这里默认安装 python2.7\n\n### pip2\n\n为了方便地管理 python2 依赖，我们还需要 pip2。\n\n但通过 ubuntu 软件源安装的 python2 不自带 pip2 管理工具。这是因为 Python 2.7 的支持周期已于 2020 年 1 月 1 日结束，pip 21.0 也于 2021 年 1 月停止对 Python 2.7 的支持。\n\n只能手动安装。\n\n假设你已经按照上文描述安装好了 python2，使用以下命令拉取 [pypa.io](pypa.io) 的安装脚本并用 python2 执行即可：\n\n```bash\nwget -O - https://bootstrap.pypa.io/pip/2.7/get-pip.py | python2\n```\n\n安装成功后重启终端，然后使用 `pip2 --version` 检查是否安装成功。现在，你已经在本地有了 python2.7 环境和对应的 pip2 包管理工具。\n\n## py2环境管理 - virtualenv\n\n只有本地 python2 环境肯定不行，我们不能容忍我们的软件包变成依托。\n\n管理 python2.7 环境，我们可以使用 venv 的前身 —— `virtualenv`。\n\n### 使用\n\n与 venv 基本一致，这里不再赘述：\n\n```bash\n# 安装\npip2 install virtualenv\n\n# 创建虚拟环境 env\nvirtualenv env\n\n# 激活虚拟环境\nsource ./env/bin/avtivate\n\n# 关闭虚拟环境\ndeactivate\n```\n\n激活虚拟环境后，使用 `python --version` 查看虚拟环境的 python 版本，会提示：`Python 2.7.18`。这与你安装的 python2 版本有关，自行判断。\n\n### 为什么不用 venv\n\n尝试 `pip2 install venv` 会提示：`ERROR: Could not find a version that satisfies the requirement venv (from versions: none)`，也就是官方没有提供对应的模块版本。\n\n或许你在什么地方看到过使用 venv 指定 python 解释器来创建对应虚拟环境，比如：\n\n```bash\npython3 -m venv --python=/usr/bin/python2 venv\n```\n\n不知道是否真的可行，至少阿菇这里行不通，会提示没有存在不支持的参数 `--python`，不知道是不是 venv 版本问题。\n\n### 再进一步\n\n现在有了 python2.7 和 python3.10，也做到了虚拟环境，已经能胜任多数使用场景了。\n\n但阿菇并不满意，版本管理不够精细。我们该如何使用其他更细分的版本呢，比如 python3.8？\n\n## py版本管理工具 - pyenv\n\n有一款合适的 Python 版本管理工具—— `pyenv`。\n\n### 使用\n\n使用 Git 直接拉取 pyenv 到本地就行：\n\n```bash\ngit clone https://github.com/pyenv/pyenv.git ~/.pyenv\n```\n\n然后需要修改环境变量，这个和的命令行有关，这里提供 zsh 和 bash 两个版本的：\n\n```bash\n# zsh\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.zprofile\necho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.zprofile\necho 'eval \"$(pyenv init --path)\"' >> ~/.zprofile\necho 'eval \"$(pyenv init -)\"' >> ~/.zshrc\n\n# bash\necho -e 'if shopt -q login_shell; then' \\\n      '\\n  export PYENV_ROOT=\"$HOME/.pyenv\"' \\\n      '\\n  export PATH=\"$PYENV_ROOT/bin:$PATH\"' \\\n      '\\n eval \"$(pyenv init --path)\"' \\\n      '\\nfi' >> ~/.bashrc\necho -e 'if [ -z \"$BASH_VERSION\" ]; then'\\\n      '\\n  export PYENV_ROOT=\"$HOME/.pyenv\"'\\\n      '\\n  export PATH=\"$PYENV_ROOT/bin:$PATH\"'\\\n      '\\n  eval \"$(pyenv init --path)\"'\\\n      '\\nfi' >>~/.profile\necho 'if command -v pyenv >/dev/null; then eval \"$(pyenv init -)\"; fi' >> ~/.bashrc\n```\n\n执行完成后就可以使用 pyenv 了。\n\n> 上面的指令中中已经包括重新加载命令行配置的指令。\n\n执行 `pyenv -h` 可以查看手册，然后上手用就行。\n\n```bash\n# 查看当前 python 版本\npyenv version\n\n# 查看所有 python 版本\npyenv versions\n\n# 查看所有可安装的 python 版本\npyenv install --list\n\n# 安装指定 python 版本\npyenv install 3.8.12\n\n# 安装新版本后 rehash\npyenv rehash\n\n# 指定全局 python 版本\npyenv global 3.8.12\n\n# 删除指定 python 版本\npyenv uninstall 3.8.12\n\n# 指定多个全局版本, python3版本优先\npyenv global 3.8.12 2.7.10\n```\n\n### 加速pyenv\n\n国内访问外网不方便，执行 `pyenv install` 时可能会非常慢，甚至超时终止访问。我们有几种方案解决这个问题。\n\n#### 01 手动下载压缩包\n\n网上最多的是手动下载压缩包到 pyenv 缓存，然后再用 `pyenv install` 安装。\n\n国内有 python 镜像站，我们进去找到对应版本压缩包下载就行：[国内镜像站](https://registry.npmmirror.com/binary.html?path=python/)\n\n![20231102104041](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823d54c959b8426bb3b901c9a28838a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672\\&h=755\\&s=175052\\&e=png\\&b=ffffff)\n\n先找到所需版本的下载链接，右键复制链接地址，然后使用 wget 拉取到本地 pyenv 缓存中，再执行命令下载：\n\n```bash\nwget https://registry.npmmirror.com/-/binary/python/2.7.10/Python-2.7.10.tar.xz -P ~/.pyenv/cache\npyenv install 2.7.10\n```\n\n#### 02 终端代理\n\n这个同样适用于其他下载慢的情况，设置 shell 的 `http_proxy` 环境变量，让终端走代理。\n\n前提是你要有一个代理服务器，或者有相应的工具。\n\n```bash\nexport https_proxy=http://127.0.0.1:7890\n```\n\n#### 03 pyenv镜像\n\n使用国内镜像站中的压缩包资源，这里以[搜狐 pyenv 镜像源](http://mirrors.sohu.com/python/)为例：\n\n```bash\nv=3.5.2|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\n```\n\n## py环境管理工具 - pyenv-virtualenv\n\npyenv 可以实现快捷的 python 版本管理，我们可以使用它的 `virtualenv` 插件一并实现虚拟环境管理。\n\n### 使用\n\n拉取脚本然后添加环境变量，再重启 shell 即可，这里以 zsh 为例：\n\n```bash\n# 安装插件\ngit clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv\n\n# 添加环境变量到 zsh\necho 'eval \"$(pyenv virtualenv-init -)\"' >> ~/.zshrc\n\n# 重启 zsh\nexec zsh\n```\n\n然后我们就可以使用 pyenv 的 virtualenv 插件管理虚拟环境了。只要是你已经通过 pyenv 安装的版本，都可以使用该插件创建对应的虚拟环境。\n\n```bash\npyenv virtualenv 3.8.12 v3812env\n```\n\n但是要注意，`virtualenv`  插件的逻辑和 venv 以及 py2 的 virtualenv 模块不同，它不是在当前目录下创建虚拟环境目录，而是在 `～/.pyenv` 目录中安装。\n\n![20231102133150](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8a617a9327746d69b0573d010a4d8a3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880\\&h=167\\&s=36334\\&e=png\\&b=15192b)\n\n使用 virtualenv 插件的虚拟环境也很方便：\n\n```bash\n# 列出当前虚拟环境\npyenv virtualenvs\n\n# 激活虚拟环境\npyenv activate v3812env\n\n# 退出虚拟环境\npyenv deactivate v3812env \n```\n\n至此，我们基本实现了 Linux 下方便的管理各版本的 python 虚拟环境，这允许我们为每个项目/工具创建独立的虚拟环境，有效的维护了系统本身的整洁。\n\n### 或许，还可以……？\n\n以上是我们的 python 版本/环境管理方案，已经够用了，但或许你并不满足。身为合格的程序员，你对环境管理有着更高的需求。\n\n那还有更优秀的解决方案吗？\n\n有！\n\n## Nox 堂堂登场！\n\n![20231102192818](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7653602e147c43ccab1438a4589f7dfb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932\\&h=287\\&s=90851\\&e=png\\&b=fffefe)\n\n`Nox` 是一个命令行工具，用于在多个 Python 环境中进行自动测试，开发者可以使用标准的 Python 文件对项目进行配置。\n\n我们可以在项目根目录下创建一个 `noxfile.py` 文件，使用安装好的 `nox` 模块运行这个文件，以创建 python 虚拟环境并运行一些预定的指令。我们也可以手动激活 python 虚拟环境，就像前面的 venv 一样。\n\n### 使用案例\n\n新建个 `app` 目录，在里面配置一份 `noxfile.py`：\n\n```python\nimport nox # 引用 nox 模块\n\n@nox.session(python='3.8.12') # 使用 python3.8.12\ndef install_flask(session): # 创建一个名为 install_flask 的会话\n    session.install('flask') # 安装 flask 依赖\n```\n\n然后，我们在当前目录下执行以下指令，初始化这个虚拟环境：\n\n```bash\n$ python3 -m nox   \n\nnox > Running session install_flask\nnox > Creating virtual environment (virtualenv) using python3.8 in .nox/install_flask\nnox > python -m pip install flask\nnox > Session install_flask was successful.\n```\n\n初始化完成后，当前目录下多出 `__pycache__` 和 `.nox` 文件，前者是缓存目录，存储编译后的 python 代码，后者就是我们的虚拟环境目录，类似与使用 \\`python -m venv env\\`\\` 创建的 env 目录。\n\n有了虚拟环境之后，常用的指令就和 venv 没有太大差别了：\n\n```bash\n# 激活 install_flask 虚拟环境\nsource .nox/install_flask/bin/activate\n\n# 退出虚拟环境\ndeactivate\n```\n\n你可以把下面这段 `app.py` 写入当前目录下，作用是实现一个 flask Web 服务，你可以激活刚创建好的这个虚拟环境，然后尝试运行这个服务。\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello, World!'\n\nif __name__ == '__main__':\n    app.run()\n```\n\n如果运行结果与下图类似，即 flask web 服务正常运行，则代表你的 nox 与刚创建的虚拟环境没有问题。\n\n![20231102194422](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc32ac6fac94f3188fe1648edb07a62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=881\\&h=211\\&s=31011\\&e=png\\&b=15172a)\n\n> nox 只能创建当前系统已有 python 解释器对应版本的虚拟环境，也就是说你本地没有 python2.7.10 环境，你也无法创建 2.7.10 虚拟环境。\n\n### More\n\n可以从以下渠道继续学习 nox，它的功能远比我这个案例中所演示的强大得多。\n\n*   官方文档：[Welcome to Nox](https://nox.thea.codes/en/stable/index.html)\n*   中文文档：[欢迎来到 Nox](https://daobook.github.io/nox/index.html)\n*   项目地址：[Winterbloom/nox](https://github.com/wntrblm/nox)\n\n## 另一选择 - Tox\n\n`Nox` 与 `Tox` 十分相似，二者都是 python 任务自动化工具，都可以创建虚拟环境以隔绝项目与本地系统。\n\n- 官方文档：[欢迎来到tox自动化项目](https://www.osgeo.cn/tox/)\n- GitHub 仓库：[tox-dev/tox](https://github.com/tox-dev/tox)","source":"_posts/python_in_linux.md","raw":"---\ntitle: Linux 中 Python 环境与版本管理\ndate: 2023/11/23\nauthor: ma5hr00m\ncategories:\n- Python\n---\n\n阿菇觉得 Python 的环境/版本管理实在是依托，感觉不如 Node.js。\n尤其是在 Linux 环境下，多数发行版的系统组件、工具依赖自带的 Python，折腾系统自带的 Python 环境时，一个搞不好就会把整个系统干掉。\n\n同时，研究安全的小伙伴经常用各种工具，而很多工具又是是基于 python2 的，而当前使用的绝大多数 Linux 发行版都自带的 python3，不方便。\n\n另一方面，我们的各种 python 项目都会有各自需要的依赖，而我们总不可能把所有需要的依赖库都直接全局安装，这很丑陋，而且很多情况下不方便项目的迁移。\n\n> 流行的 python 项目/工具基本都是提供了 `requirements.txt`，用户需要手动本地安装。\n\nWindows 系统中，我们可以直接使用强大的 [Anaconda](https://www.anaconda.com/) 管理我们的 python 环境以及版本，Linux 就不行了。\n这篇文章，总结了阿菇在 python 环境/版本管理方面的经验，可供参考。\n\n::: warning  \n本篇文章使用环境：系统 `Ubuntu22.04`，自带 `python3.10.12`。\n:::\n\n## py3环境管理 - venv\npython3 推出了 `venv` 模块，python3.6 及以上已经默认安装，python3.5 需要手动安装：\n\n```bash\nsudo apt install python3-venv\n```\n\nvenv 模块支持创建轻量级的虚拟环境，每个环境拥有它们自己安装在其 `/site` 目录下的 python 软件包（依赖）集合。\n\n### 使用\n\n使用以下指令可以创建一个 python 虚拟环境，python 版本与当前系统使用的 python 版本相同：\n\n```bash\npython3 -m venv env\n```\n\n实际效果就是在你的当前目录下创建一个名为 `env` 的目录，其中包括了特定的 python 解释器、软件库和二进制文件。你可以把上面指令中的 `env` 替换为你想要的虚拟环境名称（也就是那个目录名称），习惯上我们会将其命名为 `venv` 或者 `.venv`，通常放在项目根目录下。\n\n需要遵守一些默认规范。python 虚拟环境是可丢弃的，也就是说，我们不会将其一并打包的项目中，我们只需要给用户提供 `requirements.txt` 文件，用户自己创建一个虚拟环境并安装所需依赖。开发者不应该把任何项目代码放到虚拟环境目录中。同时，我们也不会移动虚拟环境，哪里需要就在哪里创建。\n\n创建好虚拟环境后，它只是一个放在那儿的目录，需要手动激活。\n\n假设你是在当前目录下创建了名为 `venv` 的虚拟环境，你使用以下指令将这个虚拟环境激活：\n\n```bash\nsource ./venv/bin/active\n```\n\n然后你可以发现命令行中标志出当前命令行使用了虚拟环境，虚拟环境名称默认与当前项目名称相同。\n\n![20231102001458](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d4846c761b4d5bb86b8863cd745a83~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980\\&h=365\\&s=57542\\&e=png\\&b=0e1019)\n\n>图中是 [zsh](https://www.zsh.org/)，配置了 [oh-my-zsh](https://ohmyz.sh/)，应用了 [powerlevel10K 主题](https://github.com/romkatv/powerlevel10k)，通过 [tabby 模拟终端工具](https://tabby.sh/) 使用，是一个非常 nice 的组合，可以试试看！\n\n此时使用 `pip --version` 会提示用户使用的是虚拟环境中的 `pip` 包管理工具。激活虚拟环境后我们就可以在这里面肆意安装我们需要的各种依赖了，虚拟环境与外界是隔离的，你可以想象成虚拟机，一般不会影响到系统本身。\n\n使用完虚拟环境后，执行以下指令关闭虚拟环境：\n\n```bash\ndeactivate\n```\n\n### 进一步\n\n就是如此的干净清爽，我们只需用系统自带的 python 创建虚拟环境即可，之后的一切依赖都放在各自的虚拟环境中，不用把自己系统的 python 软件包搞得一团糟。\n\n阿菇的建议是：*不要在自己的系统中安装任何额外的 python 软件包，把自带的 python 当作一个虚拟环境创建器，所有需要依赖的项目都单独创建一个虚拟环境*。\n\n现在问题来了。我们使用这个指令只能创建与当前版本相同的 python 虚拟环境，并不能满足我们的需求，下一步该怎么做呢？\n\n## Linux中使用python2\n\n很多 Linux 发行版不带 python2 环境，但我们有时需要用。可以在系统中配置一个 python2 环境。\n\n### python2\n\n包管理工具直接安装：\n\n```bash\nsudo apt install python2\n```\n\n安装好之后指定使用 `python2` 即可，默认路径是 `/usr/bin/python2`，此时可以使用 `python2` 来运行代码了。\n\n> 这里默认安装 python2.7\n\n### pip2\n\n为了方便地管理 python2 依赖，我们还需要 pip2。\n\n但通过 ubuntu 软件源安装的 python2 不自带 pip2 管理工具。这是因为 Python 2.7 的支持周期已于 2020 年 1 月 1 日结束，pip 21.0 也于 2021 年 1 月停止对 Python 2.7 的支持。\n\n只能手动安装。\n\n假设你已经按照上文描述安装好了 python2，使用以下命令拉取 [pypa.io](pypa.io) 的安装脚本并用 python2 执行即可：\n\n```bash\nwget -O - https://bootstrap.pypa.io/pip/2.7/get-pip.py | python2\n```\n\n安装成功后重启终端，然后使用 `pip2 --version` 检查是否安装成功。现在，你已经在本地有了 python2.7 环境和对应的 pip2 包管理工具。\n\n## py2环境管理 - virtualenv\n\n只有本地 python2 环境肯定不行，我们不能容忍我们的软件包变成依托。\n\n管理 python2.7 环境，我们可以使用 venv 的前身 —— `virtualenv`。\n\n### 使用\n\n与 venv 基本一致，这里不再赘述：\n\n```bash\n# 安装\npip2 install virtualenv\n\n# 创建虚拟环境 env\nvirtualenv env\n\n# 激活虚拟环境\nsource ./env/bin/avtivate\n\n# 关闭虚拟环境\ndeactivate\n```\n\n激活虚拟环境后，使用 `python --version` 查看虚拟环境的 python 版本，会提示：`Python 2.7.18`。这与你安装的 python2 版本有关，自行判断。\n\n### 为什么不用 venv\n\n尝试 `pip2 install venv` 会提示：`ERROR: Could not find a version that satisfies the requirement venv (from versions: none)`，也就是官方没有提供对应的模块版本。\n\n或许你在什么地方看到过使用 venv 指定 python 解释器来创建对应虚拟环境，比如：\n\n```bash\npython3 -m venv --python=/usr/bin/python2 venv\n```\n\n不知道是否真的可行，至少阿菇这里行不通，会提示没有存在不支持的参数 `--python`，不知道是不是 venv 版本问题。\n\n### 再进一步\n\n现在有了 python2.7 和 python3.10，也做到了虚拟环境，已经能胜任多数使用场景了。\n\n但阿菇并不满意，版本管理不够精细。我们该如何使用其他更细分的版本呢，比如 python3.8？\n\n## py版本管理工具 - pyenv\n\n有一款合适的 Python 版本管理工具—— `pyenv`。\n\n### 使用\n\n使用 Git 直接拉取 pyenv 到本地就行：\n\n```bash\ngit clone https://github.com/pyenv/pyenv.git ~/.pyenv\n```\n\n然后需要修改环境变量，这个和的命令行有关，这里提供 zsh 和 bash 两个版本的：\n\n```bash\n# zsh\necho 'export PYENV_ROOT=\"$HOME/.pyenv\"' >> ~/.zprofile\necho 'export PATH=\"$PYENV_ROOT/bin:$PATH\"' >> ~/.zprofile\necho 'eval \"$(pyenv init --path)\"' >> ~/.zprofile\necho 'eval \"$(pyenv init -)\"' >> ~/.zshrc\n\n# bash\necho -e 'if shopt -q login_shell; then' \\\n      '\\n  export PYENV_ROOT=\"$HOME/.pyenv\"' \\\n      '\\n  export PATH=\"$PYENV_ROOT/bin:$PATH\"' \\\n      '\\n eval \"$(pyenv init --path)\"' \\\n      '\\nfi' >> ~/.bashrc\necho -e 'if [ -z \"$BASH_VERSION\" ]; then'\\\n      '\\n  export PYENV_ROOT=\"$HOME/.pyenv\"'\\\n      '\\n  export PATH=\"$PYENV_ROOT/bin:$PATH\"'\\\n      '\\n  eval \"$(pyenv init --path)\"'\\\n      '\\nfi' >>~/.profile\necho 'if command -v pyenv >/dev/null; then eval \"$(pyenv init -)\"; fi' >> ~/.bashrc\n```\n\n执行完成后就可以使用 pyenv 了。\n\n> 上面的指令中中已经包括重新加载命令行配置的指令。\n\n执行 `pyenv -h` 可以查看手册，然后上手用就行。\n\n```bash\n# 查看当前 python 版本\npyenv version\n\n# 查看所有 python 版本\npyenv versions\n\n# 查看所有可安装的 python 版本\npyenv install --list\n\n# 安装指定 python 版本\npyenv install 3.8.12\n\n# 安装新版本后 rehash\npyenv rehash\n\n# 指定全局 python 版本\npyenv global 3.8.12\n\n# 删除指定 python 版本\npyenv uninstall 3.8.12\n\n# 指定多个全局版本, python3版本优先\npyenv global 3.8.12 2.7.10\n```\n\n### 加速pyenv\n\n国内访问外网不方便，执行 `pyenv install` 时可能会非常慢，甚至超时终止访问。我们有几种方案解决这个问题。\n\n#### 01 手动下载压缩包\n\n网上最多的是手动下载压缩包到 pyenv 缓存，然后再用 `pyenv install` 安装。\n\n国内有 python 镜像站，我们进去找到对应版本压缩包下载就行：[国内镜像站](https://registry.npmmirror.com/binary.html?path=python/)\n\n![20231102104041](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823d54c959b8426bb3b901c9a28838a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672\\&h=755\\&s=175052\\&e=png\\&b=ffffff)\n\n先找到所需版本的下载链接，右键复制链接地址，然后使用 wget 拉取到本地 pyenv 缓存中，再执行命令下载：\n\n```bash\nwget https://registry.npmmirror.com/-/binary/python/2.7.10/Python-2.7.10.tar.xz -P ~/.pyenv/cache\npyenv install 2.7.10\n```\n\n#### 02 终端代理\n\n这个同样适用于其他下载慢的情况，设置 shell 的 `http_proxy` 环境变量，让终端走代理。\n\n前提是你要有一个代理服务器，或者有相应的工具。\n\n```bash\nexport https_proxy=http://127.0.0.1:7890\n```\n\n#### 03 pyenv镜像\n\n使用国内镜像站中的压缩包资源，这里以[搜狐 pyenv 镜像源](http://mirrors.sohu.com/python/)为例：\n\n```bash\nv=3.5.2|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v\n```\n\n## py环境管理工具 - pyenv-virtualenv\n\npyenv 可以实现快捷的 python 版本管理，我们可以使用它的 `virtualenv` 插件一并实现虚拟环境管理。\n\n### 使用\n\n拉取脚本然后添加环境变量，再重启 shell 即可，这里以 zsh 为例：\n\n```bash\n# 安装插件\ngit clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv\n\n# 添加环境变量到 zsh\necho 'eval \"$(pyenv virtualenv-init -)\"' >> ~/.zshrc\n\n# 重启 zsh\nexec zsh\n```\n\n然后我们就可以使用 pyenv 的 virtualenv 插件管理虚拟环境了。只要是你已经通过 pyenv 安装的版本，都可以使用该插件创建对应的虚拟环境。\n\n```bash\npyenv virtualenv 3.8.12 v3812env\n```\n\n但是要注意，`virtualenv`  插件的逻辑和 venv 以及 py2 的 virtualenv 模块不同，它不是在当前目录下创建虚拟环境目录，而是在 `～/.pyenv` 目录中安装。\n\n![20231102133150](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8a617a9327746d69b0573d010a4d8a3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880\\&h=167\\&s=36334\\&e=png\\&b=15192b)\n\n使用 virtualenv 插件的虚拟环境也很方便：\n\n```bash\n# 列出当前虚拟环境\npyenv virtualenvs\n\n# 激活虚拟环境\npyenv activate v3812env\n\n# 退出虚拟环境\npyenv deactivate v3812env \n```\n\n至此，我们基本实现了 Linux 下方便的管理各版本的 python 虚拟环境，这允许我们为每个项目/工具创建独立的虚拟环境，有效的维护了系统本身的整洁。\n\n### 或许，还可以……？\n\n以上是我们的 python 版本/环境管理方案，已经够用了，但或许你并不满足。身为合格的程序员，你对环境管理有着更高的需求。\n\n那还有更优秀的解决方案吗？\n\n有！\n\n## Nox 堂堂登场！\n\n![20231102192818](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7653602e147c43ccab1438a4589f7dfb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932\\&h=287\\&s=90851\\&e=png\\&b=fffefe)\n\n`Nox` 是一个命令行工具，用于在多个 Python 环境中进行自动测试，开发者可以使用标准的 Python 文件对项目进行配置。\n\n我们可以在项目根目录下创建一个 `noxfile.py` 文件，使用安装好的 `nox` 模块运行这个文件，以创建 python 虚拟环境并运行一些预定的指令。我们也可以手动激活 python 虚拟环境，就像前面的 venv 一样。\n\n### 使用案例\n\n新建个 `app` 目录，在里面配置一份 `noxfile.py`：\n\n```python\nimport nox # 引用 nox 模块\n\n@nox.session(python='3.8.12') # 使用 python3.8.12\ndef install_flask(session): # 创建一个名为 install_flask 的会话\n    session.install('flask') # 安装 flask 依赖\n```\n\n然后，我们在当前目录下执行以下指令，初始化这个虚拟环境：\n\n```bash\n$ python3 -m nox   \n\nnox > Running session install_flask\nnox > Creating virtual environment (virtualenv) using python3.8 in .nox/install_flask\nnox > python -m pip install flask\nnox > Session install_flask was successful.\n```\n\n初始化完成后，当前目录下多出 `__pycache__` 和 `.nox` 文件，前者是缓存目录，存储编译后的 python 代码，后者就是我们的虚拟环境目录，类似与使用 \\`python -m venv env\\`\\` 创建的 env 目录。\n\n有了虚拟环境之后，常用的指令就和 venv 没有太大差别了：\n\n```bash\n# 激活 install_flask 虚拟环境\nsource .nox/install_flask/bin/activate\n\n# 退出虚拟环境\ndeactivate\n```\n\n你可以把下面这段 `app.py` 写入当前目录下，作用是实现一个 flask Web 服务，你可以激活刚创建好的这个虚拟环境，然后尝试运行这个服务。\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello, World!'\n\nif __name__ == '__main__':\n    app.run()\n```\n\n如果运行结果与下图类似，即 flask web 服务正常运行，则代表你的 nox 与刚创建的虚拟环境没有问题。\n\n![20231102194422](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc32ac6fac94f3188fe1648edb07a62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=881\\&h=211\\&s=31011\\&e=png\\&b=15172a)\n\n> nox 只能创建当前系统已有 python 解释器对应版本的虚拟环境，也就是说你本地没有 python2.7.10 环境，你也无法创建 2.7.10 虚拟环境。\n\n### More\n\n可以从以下渠道继续学习 nox，它的功能远比我这个案例中所演示的强大得多。\n\n*   官方文档：[Welcome to Nox](https://nox.thea.codes/en/stable/index.html)\n*   中文文档：[欢迎来到 Nox](https://daobook.github.io/nox/index.html)\n*   项目地址：[Winterbloom/nox](https://github.com/wntrblm/nox)\n\n## 另一选择 - Tox\n\n`Nox` 与 `Tox` 十分相似，二者都是 python 任务自动化工具，都可以创建虚拟环境以隔绝项目与本地系统。\n\n- 官方文档：[欢迎来到tox自动化项目](https://www.osgeo.cn/tox/)\n- GitHub 仓库：[tox-dev/tox](https://github.com/tox-dev/tox)","slug":"python_in_linux","published":1,"updated":"2024-06-09T12:55:36.568Z","comments":1,"layout":"post","photos":[],"_id":"clxhruapf001tf4ly6pvkf6qj","content":"<p>阿菇觉得 Python 的环境&#x2F;版本管理实在是依托，感觉不如 Node.js。<br>尤其是在 Linux 环境下，多数发行版的系统组件、工具依赖自带的 Python，折腾系统自带的 Python 环境时，一个搞不好就会把整个系统干掉。</p>\n<p>同时，研究安全的小伙伴经常用各种工具，而很多工具又是是基于 python2 的，而当前使用的绝大多数 Linux 发行版都自带的 python3，不方便。</p>\n<p>另一方面，我们的各种 python 项目都会有各自需要的依赖，而我们总不可能把所有需要的依赖库都直接全局安装，这很丑陋，而且很多情况下不方便项目的迁移。</p>\n<blockquote>\n<p>流行的 python 项目&#x2F;工具基本都是提供了 <code>requirements.txt</code>，用户需要手动本地安装。</p>\n</blockquote>\n<p>Windows 系统中，我们可以直接使用强大的 <a href=\"https://www.anaconda.com/\">Anaconda</a> 管理我们的 python 环境以及版本，Linux 就不行了。<br>这篇文章，总结了阿菇在 python 环境&#x2F;版本管理方面的经验，可供参考。</p>\n<p>::: warning<br>本篇文章使用环境：系统 <code>Ubuntu22.04</code>，自带 <code>python3.10.12</code>。<br>:::</p>\n<h2 id=\"py3环境管理-venv\"><a href=\"#py3环境管理-venv\" class=\"headerlink\" title=\"py3环境管理 - venv\"></a>py3环境管理 - venv</h2><p>python3 推出了 <code>venv</code> 模块，python3.6 及以上已经默认安装，python3.5 需要手动安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install python3-venv</span><br></pre></td></tr></table></figure>\n\n<p>venv 模块支持创建轻量级的虚拟环境，每个环境拥有它们自己安装在其 <code>/site</code> 目录下的 python 软件包（依赖）集合。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>使用以下指令可以创建一个 python 虚拟环境，python 版本与当前系统使用的 python 版本相同：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m venv <span class=\"built_in\">env</span></span><br></pre></td></tr></table></figure>\n\n<p>实际效果就是在你的当前目录下创建一个名为 <code>env</code> 的目录，其中包括了特定的 python 解释器、软件库和二进制文件。你可以把上面指令中的 <code>env</code> 替换为你想要的虚拟环境名称（也就是那个目录名称），习惯上我们会将其命名为 <code>venv</code> 或者 <code>.venv</code>，通常放在项目根目录下。</p>\n<p>需要遵守一些默认规范。python 虚拟环境是可丢弃的，也就是说，我们不会将其一并打包的项目中，我们只需要给用户提供 <code>requirements.txt</code> 文件，用户自己创建一个虚拟环境并安装所需依赖。开发者不应该把任何项目代码放到虚拟环境目录中。同时，我们也不会移动虚拟环境，哪里需要就在哪里创建。</p>\n<p>创建好虚拟环境后，它只是一个放在那儿的目录，需要手动激活。</p>\n<p>假设你是在当前目录下创建了名为 <code>venv</code> 的虚拟环境，你使用以下指令将这个虚拟环境激活：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ./venv/bin/active</span><br></pre></td></tr></table></figure>\n\n<p>然后你可以发现命令行中标志出当前命令行使用了虚拟环境，虚拟环境名称默认与当前项目名称相同。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d4846c761b4d5bb86b8863cd745a83~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=365&s=57542&e=png&b=0e1019\" alt=\"20231102001458\"></p>\n<blockquote>\n<p>图中是 <a href=\"https://www.zsh.org/\">zsh</a>，配置了 <a href=\"https://ohmyz.sh/\">oh-my-zsh</a>，应用了 <a href=\"https://github.com/romkatv/powerlevel10k\">powerlevel10K 主题</a>，通过 <a href=\"https://tabby.sh/\">tabby 模拟终端工具</a> 使用，是一个非常 nice 的组合，可以试试看！</p>\n</blockquote>\n<p>此时使用 <code>pip --version</code> 会提示用户使用的是虚拟环境中的 <code>pip</code> 包管理工具。激活虚拟环境后我们就可以在这里面肆意安装我们需要的各种依赖了，虚拟环境与外界是隔离的，你可以想象成虚拟机，一般不会影响到系统本身。</p>\n<p>使用完虚拟环境后，执行以下指令关闭虚拟环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deactivate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进一步\"><a href=\"#进一步\" class=\"headerlink\" title=\"进一步\"></a>进一步</h3><p>就是如此的干净清爽，我们只需用系统自带的 python 创建虚拟环境即可，之后的一切依赖都放在各自的虚拟环境中，不用把自己系统的 python 软件包搞得一团糟。</p>\n<p>阿菇的建议是：<em>不要在自己的系统中安装任何额外的 python 软件包，把自带的 python 当作一个虚拟环境创建器，所有需要依赖的项目都单独创建一个虚拟环境</em>。</p>\n<p>现在问题来了。我们使用这个指令只能创建与当前版本相同的 python 虚拟环境，并不能满足我们的需求，下一步该怎么做呢？</p>\n<h2 id=\"Linux中使用python2\"><a href=\"#Linux中使用python2\" class=\"headerlink\" title=\"Linux中使用python2\"></a>Linux中使用python2</h2><p>很多 Linux 发行版不带 python2 环境，但我们有时需要用。可以在系统中配置一个 python2 环境。</p>\n<h3 id=\"python2\"><a href=\"#python2\" class=\"headerlink\" title=\"python2\"></a>python2</h3><p>包管理工具直接安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install python2</span><br></pre></td></tr></table></figure>\n\n<p>安装好之后指定使用 <code>python2</code> 即可，默认路径是 <code>/usr/bin/python2</code>，此时可以使用 <code>python2</code> 来运行代码了。</p>\n<blockquote>\n<p>这里默认安装 python2.7</p>\n</blockquote>\n<h3 id=\"pip2\"><a href=\"#pip2\" class=\"headerlink\" title=\"pip2\"></a>pip2</h3><p>为了方便地管理 python2 依赖，我们还需要 pip2。</p>\n<p>但通过 ubuntu 软件源安装的 python2 不自带 pip2 管理工具。这是因为 Python 2.7 的支持周期已于 2020 年 1 月 1 日结束，pip 21.0 也于 2021 年 1 月停止对 Python 2.7 的支持。</p>\n<p>只能手动安装。</p>\n<p>假设你已经按照上文描述安装好了 python2，使用以下命令拉取 <a href=\"pypa.io\">pypa.io</a> 的安装脚本并用 python2 执行即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O - https://bootstrap.pypa.io/pip/2.7/get-pip.py | python2</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后重启终端，然后使用 <code>pip2 --version</code> 检查是否安装成功。现在，你已经在本地有了 python2.7 环境和对应的 pip2 包管理工具。</p>\n<h2 id=\"py2环境管理-virtualenv\"><a href=\"#py2环境管理-virtualenv\" class=\"headerlink\" title=\"py2环境管理 - virtualenv\"></a>py2环境管理 - virtualenv</h2><p>只有本地 python2 环境肯定不行，我们不能容忍我们的软件包变成依托。</p>\n<p>管理 python2.7 环境，我们可以使用 venv 的前身 —— <code>virtualenv</code>。</p>\n<h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>与 venv 基本一致，这里不再赘述：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">pip2 install virtualenv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建虚拟环境 env</span></span><br><span class=\"line\">virtualenv <span class=\"built_in\">env</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 激活虚拟环境</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ./env/bin/avtivate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭虚拟环境</span></span><br><span class=\"line\">deactivate</span><br></pre></td></tr></table></figure>\n\n<p>激活虚拟环境后，使用 <code>python --version</code> 查看虚拟环境的 python 版本，会提示：<code>Python 2.7.18</code>。这与你安装的 python2 版本有关，自行判断。</p>\n<h3 id=\"为什么不用-venv\"><a href=\"#为什么不用-venv\" class=\"headerlink\" title=\"为什么不用 venv\"></a>为什么不用 venv</h3><p>尝试 <code>pip2 install venv</code> 会提示：<code>ERROR: Could not find a version that satisfies the requirement venv (from versions: none)</code>，也就是官方没有提供对应的模块版本。</p>\n<p>或许你在什么地方看到过使用 venv 指定 python 解释器来创建对应虚拟环境，比如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m venv --python=/usr/bin/python2 venv</span><br></pre></td></tr></table></figure>\n\n<p>不知道是否真的可行，至少阿菇这里行不通，会提示没有存在不支持的参数 <code>--python</code>，不知道是不是 venv 版本问题。</p>\n<h3 id=\"再进一步\"><a href=\"#再进一步\" class=\"headerlink\" title=\"再进一步\"></a>再进一步</h3><p>现在有了 python2.7 和 python3.10，也做到了虚拟环境，已经能胜任多数使用场景了。</p>\n<p>但阿菇并不满意，版本管理不够精细。我们该如何使用其他更细分的版本呢，比如 python3.8？</p>\n<h2 id=\"py版本管理工具-pyenv\"><a href=\"#py版本管理工具-pyenv\" class=\"headerlink\" title=\"py版本管理工具 - pyenv\"></a>py版本管理工具 - pyenv</h2><p>有一款合适的 Python 版本管理工具—— <code>pyenv</code>。</p>\n<h3 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>使用 Git 直接拉取 pyenv 到本地就行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/pyenv/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure>\n\n<p>然后需要修改环境变量，这个和的命令行有关，这里提供 zsh 和 bash 两个版本的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># zsh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;eval &quot;$(pyenv init --path)&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># bash</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&#x27;if shopt -q login_shell; then&#x27;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n eval &quot;$(pyenv init --path)&quot;&#x27;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\nfi&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&#x27;if [ -z &quot;$BASH_VERSION&quot; ]; then&#x27;</span>\\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span>\\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span>\\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  eval &quot;$(pyenv init --path)&quot;&#x27;</span>\\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\nfi&#x27;</span> &gt;&gt;~/.profile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;if command -v pyenv &gt;/dev/null; then eval &quot;$(pyenv init -)&quot;; fi&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>执行完成后就可以使用 pyenv 了。</p>\n<blockquote>\n<p>上面的指令中中已经包括重新加载命令行配置的指令。</p>\n</blockquote>\n<p>执行 <code>pyenv -h</code> 可以查看手册，然后上手用就行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前 python 版本</span></span><br><span class=\"line\">pyenv version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有 python 版本</span></span><br><span class=\"line\">pyenv versions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有可安装的 python 版本</span></span><br><span class=\"line\">pyenv install --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装指定 python 版本</span></span><br><span class=\"line\">pyenv install 3.8.12</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装新版本后 rehash</span></span><br><span class=\"line\">pyenv <span class=\"built_in\">rehash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定全局 python 版本</span></span><br><span class=\"line\">pyenv global 3.8.12</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除指定 python 版本</span></span><br><span class=\"line\">pyenv uninstall 3.8.12</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定多个全局版本, python3版本优先</span></span><br><span class=\"line\">pyenv global 3.8.12 2.7.10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"加速pyenv\"><a href=\"#加速pyenv\" class=\"headerlink\" title=\"加速pyenv\"></a>加速pyenv</h3><p>国内访问外网不方便，执行 <code>pyenv install</code> 时可能会非常慢，甚至超时终止访问。我们有几种方案解决这个问题。</p>\n<h4 id=\"01-手动下载压缩包\"><a href=\"#01-手动下载压缩包\" class=\"headerlink\" title=\"01 手动下载压缩包\"></a>01 手动下载压缩包</h4><p>网上最多的是手动下载压缩包到 pyenv 缓存，然后再用 <code>pyenv install</code> 安装。</p>\n<p>国内有 python 镜像站，我们进去找到对应版本压缩包下载就行：<a href=\"https://registry.npmmirror.com/binary.html?path=python/\">国内镜像站</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823d54c959b8426bb3b901c9a28838a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672&h=755&s=175052&e=png&b=ffffff\" alt=\"20231102104041\"></p>\n<p>先找到所需版本的下载链接，右键复制链接地址，然后使用 wget 拉取到本地 pyenv 缓存中，再执行命令下载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://registry.npmmirror.com/-/binary/python/2.7.10/Python-2.7.10.tar.xz -P ~/.pyenv/cache</span><br><span class=\"line\">pyenv install 2.7.10</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"02-终端代理\"><a href=\"#02-终端代理\" class=\"headerlink\" title=\"02 终端代理\"></a>02 终端代理</h4><p>这个同样适用于其他下载慢的情况，设置 shell 的 <code>http_proxy</code> 环境变量，让终端走代理。</p>\n<p>前提是你要有一个代理服务器，或者有相应的工具。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"03-pyenv镜像\"><a href=\"#03-pyenv镜像\" class=\"headerlink\" title=\"03 pyenv镜像\"></a>03 pyenv镜像</h4><p>使用国内镜像站中的压缩包资源，这里以<a href=\"http://mirrors.sohu.com/python/\">搜狐 pyenv 镜像源</a>为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v=3.5.2|wget http://mirrors.sohu.com/python/<span class=\"variable\">$v</span>/Python-<span class=\"variable\">$v</span>.tar.xz -P ~/.pyenv/cache/;pyenv install <span class=\"variable\">$v</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"py环境管理工具-pyenv-virtualenv\"><a href=\"#py环境管理工具-pyenv-virtualenv\" class=\"headerlink\" title=\"py环境管理工具 - pyenv-virtualenv\"></a>py环境管理工具 - pyenv-virtualenv</h2><p>pyenv 可以实现快捷的 python 版本管理，我们可以使用它的 <code>virtualenv</code> 插件一并实现虚拟环境管理。</p>\n<h3 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>拉取脚本然后添加环境变量，再重启 shell 即可，这里以 zsh 为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装插件</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加环境变量到 zsh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启 zsh</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> zsh</span><br></pre></td></tr></table></figure>\n\n<p>然后我们就可以使用 pyenv 的 virtualenv 插件管理虚拟环境了。只要是你已经通过 pyenv 安装的版本，都可以使用该插件创建对应的虚拟环境。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pyenv virtualenv 3.8.12 v3812env</span><br></pre></td></tr></table></figure>\n\n<p>但是要注意，<code>virtualenv</code>  插件的逻辑和 venv 以及 py2 的 virtualenv 模块不同，它不是在当前目录下创建虚拟环境目录，而是在 <code>～/.pyenv</code> 目录中安装。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8a617a9327746d69b0573d010a4d8a3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=167&s=36334&e=png&b=15192b\" alt=\"20231102133150\"></p>\n<p>使用 virtualenv 插件的虚拟环境也很方便：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出当前虚拟环境</span></span><br><span class=\"line\">pyenv virtualenvs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 激活虚拟环境</span></span><br><span class=\"line\">pyenv activate v3812env</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出虚拟环境</span></span><br><span class=\"line\">pyenv deactivate v3812env </span><br></pre></td></tr></table></figure>\n\n<p>至此，我们基本实现了 Linux 下方便的管理各版本的 python 虚拟环境，这允许我们为每个项目&#x2F;工具创建独立的虚拟环境，有效的维护了系统本身的整洁。</p>\n<h3 id=\"或许，还可以……？\"><a href=\"#或许，还可以……？\" class=\"headerlink\" title=\"或许，还可以……？\"></a>或许，还可以……？</h3><p>以上是我们的 python 版本&#x2F;环境管理方案，已经够用了，但或许你并不满足。身为合格的程序员，你对环境管理有着更高的需求。</p>\n<p>那还有更优秀的解决方案吗？</p>\n<p>有！</p>\n<h2 id=\"Nox-堂堂登场！\"><a href=\"#Nox-堂堂登场！\" class=\"headerlink\" title=\"Nox 堂堂登场！\"></a>Nox 堂堂登场！</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7653602e147c43ccab1438a4589f7dfb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932&h=287&s=90851&e=png&b=fffefe\" alt=\"20231102192818\"></p>\n<p><code>Nox</code> 是一个命令行工具，用于在多个 Python 环境中进行自动测试，开发者可以使用标准的 Python 文件对项目进行配置。</p>\n<p>我们可以在项目根目录下创建一个 <code>noxfile.py</code> 文件，使用安装好的 <code>nox</code> 模块运行这个文件，以创建 python 虚拟环境并运行一些预定的指令。我们也可以手动激活 python 虚拟环境，就像前面的 venv 一样。</p>\n<h3 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h3><p>新建个 <code>app</code> 目录，在里面配置一份 <code>noxfile.py</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> nox <span class=\"comment\"># 引用 nox 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@nox.session(<span class=\"params\">python=<span class=\"string\">&#x27;3.8.12&#x27;</span></span>) </span><span class=\"comment\"># 使用 python3.8.12</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">install_flask</span>(<span class=\"params\">session</span>): <span class=\"comment\"># 创建一个名为 install_flask 的会话</span></span><br><span class=\"line\">    session.install(<span class=\"string\">&#x27;flask&#x27;</span>) <span class=\"comment\"># 安装 flask 依赖</span></span><br></pre></td></tr></table></figure>\n\n<p>然后，我们在当前目录下执行以下指令，初始化这个虚拟环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 -m nox   </span><br><span class=\"line\"></span><br><span class=\"line\">nox &gt; Running session install_flask</span><br><span class=\"line\">nox &gt; Creating virtual environment (virtualenv) using python3.8 <span class=\"keyword\">in</span> .nox/install_flask</span><br><span class=\"line\">nox &gt; python -m pip install flask</span><br><span class=\"line\">nox &gt; Session install_flask was successful.</span><br></pre></td></tr></table></figure>\n\n<p>初始化完成后，当前目录下多出 <code>__pycache__</code> 和 <code>.nox</code> 文件，前者是缓存目录，存储编译后的 python 代码，后者就是我们的虚拟环境目录，类似与使用 `python -m venv env`` 创建的 env 目录。</p>\n<p>有了虚拟环境之后，常用的指令就和 venv 没有太大差别了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 激活 install_flask 虚拟环境</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> .nox/install_flask/bin/activate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出虚拟环境</span></span><br><span class=\"line\">deactivate</span><br></pre></td></tr></table></figure>\n\n<p>你可以把下面这段 <code>app.py</code> 写入当前目录下，作用是实现一个 flask Web 服务，你可以激活刚创建好的这个虚拟环境，然后尝试运行这个服务。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hello_world</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello, World!&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n\n<p>如果运行结果与下图类似，即 flask web 服务正常运行，则代表你的 nox 与刚创建的虚拟环境没有问题。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc32ac6fac94f3188fe1648edb07a62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=881&h=211&s=31011&e=png&b=15172a\" alt=\"20231102194422\"></p>\n<blockquote>\n<p>nox 只能创建当前系统已有 python 解释器对应版本的虚拟环境，也就是说你本地没有 python2.7.10 环境，你也无法创建 2.7.10 虚拟环境。</p>\n</blockquote>\n<h3 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h3><p>可以从以下渠道继续学习 nox，它的功能远比我这个案例中所演示的强大得多。</p>\n<ul>\n<li>官方文档：<a href=\"https://nox.thea.codes/en/stable/index.html\">Welcome to Nox</a></li>\n<li>中文文档：<a href=\"https://daobook.github.io/nox/index.html\">欢迎来到 Nox</a></li>\n<li>项目地址：<a href=\"https://github.com/wntrblm/nox\">Winterbloom&#x2F;nox</a></li>\n</ul>\n<h2 id=\"另一选择-Tox\"><a href=\"#另一选择-Tox\" class=\"headerlink\" title=\"另一选择 - Tox\"></a>另一选择 - Tox</h2><p><code>Nox</code> 与 <code>Tox</code> 十分相似，二者都是 python 任务自动化工具，都可以创建虚拟环境以隔绝项目与本地系统。</p>\n<ul>\n<li>官方文档：<a href=\"https://www.osgeo.cn/tox/\">欢迎来到tox自动化项目</a></li>\n<li>GitHub 仓库：<a href=\"https://github.com/tox-dev/tox\">tox-dev&#x2F;tox</a></li>\n</ul>\n","excerpt":"","more":"<p>阿菇觉得 Python 的环境&#x2F;版本管理实在是依托，感觉不如 Node.js。<br>尤其是在 Linux 环境下，多数发行版的系统组件、工具依赖自带的 Python，折腾系统自带的 Python 环境时，一个搞不好就会把整个系统干掉。</p>\n<p>同时，研究安全的小伙伴经常用各种工具，而很多工具又是是基于 python2 的，而当前使用的绝大多数 Linux 发行版都自带的 python3，不方便。</p>\n<p>另一方面，我们的各种 python 项目都会有各自需要的依赖，而我们总不可能把所有需要的依赖库都直接全局安装，这很丑陋，而且很多情况下不方便项目的迁移。</p>\n<blockquote>\n<p>流行的 python 项目&#x2F;工具基本都是提供了 <code>requirements.txt</code>，用户需要手动本地安装。</p>\n</blockquote>\n<p>Windows 系统中，我们可以直接使用强大的 <a href=\"https://www.anaconda.com/\">Anaconda</a> 管理我们的 python 环境以及版本，Linux 就不行了。<br>这篇文章，总结了阿菇在 python 环境&#x2F;版本管理方面的经验，可供参考。</p>\n<p>::: warning<br>本篇文章使用环境：系统 <code>Ubuntu22.04</code>，自带 <code>python3.10.12</code>。<br>:::</p>\n<h2 id=\"py3环境管理-venv\"><a href=\"#py3环境管理-venv\" class=\"headerlink\" title=\"py3环境管理 - venv\"></a>py3环境管理 - venv</h2><p>python3 推出了 <code>venv</code> 模块，python3.6 及以上已经默认安装，python3.5 需要手动安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install python3-venv</span><br></pre></td></tr></table></figure>\n\n<p>venv 模块支持创建轻量级的虚拟环境，每个环境拥有它们自己安装在其 <code>/site</code> 目录下的 python 软件包（依赖）集合。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>使用以下指令可以创建一个 python 虚拟环境，python 版本与当前系统使用的 python 版本相同：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m venv <span class=\"built_in\">env</span></span><br></pre></td></tr></table></figure>\n\n<p>实际效果就是在你的当前目录下创建一个名为 <code>env</code> 的目录，其中包括了特定的 python 解释器、软件库和二进制文件。你可以把上面指令中的 <code>env</code> 替换为你想要的虚拟环境名称（也就是那个目录名称），习惯上我们会将其命名为 <code>venv</code> 或者 <code>.venv</code>，通常放在项目根目录下。</p>\n<p>需要遵守一些默认规范。python 虚拟环境是可丢弃的，也就是说，我们不会将其一并打包的项目中，我们只需要给用户提供 <code>requirements.txt</code> 文件，用户自己创建一个虚拟环境并安装所需依赖。开发者不应该把任何项目代码放到虚拟环境目录中。同时，我们也不会移动虚拟环境，哪里需要就在哪里创建。</p>\n<p>创建好虚拟环境后，它只是一个放在那儿的目录，需要手动激活。</p>\n<p>假设你是在当前目录下创建了名为 <code>venv</code> 的虚拟环境，你使用以下指令将这个虚拟环境激活：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ./venv/bin/active</span><br></pre></td></tr></table></figure>\n\n<p>然后你可以发现命令行中标志出当前命令行使用了虚拟环境，虚拟环境名称默认与当前项目名称相同。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d4846c761b4d5bb86b8863cd745a83~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=365&s=57542&e=png&b=0e1019\" alt=\"20231102001458\"></p>\n<blockquote>\n<p>图中是 <a href=\"https://www.zsh.org/\">zsh</a>，配置了 <a href=\"https://ohmyz.sh/\">oh-my-zsh</a>，应用了 <a href=\"https://github.com/romkatv/powerlevel10k\">powerlevel10K 主题</a>，通过 <a href=\"https://tabby.sh/\">tabby 模拟终端工具</a> 使用，是一个非常 nice 的组合，可以试试看！</p>\n</blockquote>\n<p>此时使用 <code>pip --version</code> 会提示用户使用的是虚拟环境中的 <code>pip</code> 包管理工具。激活虚拟环境后我们就可以在这里面肆意安装我们需要的各种依赖了，虚拟环境与外界是隔离的，你可以想象成虚拟机，一般不会影响到系统本身。</p>\n<p>使用完虚拟环境后，执行以下指令关闭虚拟环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deactivate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进一步\"><a href=\"#进一步\" class=\"headerlink\" title=\"进一步\"></a>进一步</h3><p>就是如此的干净清爽，我们只需用系统自带的 python 创建虚拟环境即可，之后的一切依赖都放在各自的虚拟环境中，不用把自己系统的 python 软件包搞得一团糟。</p>\n<p>阿菇的建议是：<em>不要在自己的系统中安装任何额外的 python 软件包，把自带的 python 当作一个虚拟环境创建器，所有需要依赖的项目都单独创建一个虚拟环境</em>。</p>\n<p>现在问题来了。我们使用这个指令只能创建与当前版本相同的 python 虚拟环境，并不能满足我们的需求，下一步该怎么做呢？</p>\n<h2 id=\"Linux中使用python2\"><a href=\"#Linux中使用python2\" class=\"headerlink\" title=\"Linux中使用python2\"></a>Linux中使用python2</h2><p>很多 Linux 发行版不带 python2 环境，但我们有时需要用。可以在系统中配置一个 python2 环境。</p>\n<h3 id=\"python2\"><a href=\"#python2\" class=\"headerlink\" title=\"python2\"></a>python2</h3><p>包管理工具直接安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install python2</span><br></pre></td></tr></table></figure>\n\n<p>安装好之后指定使用 <code>python2</code> 即可，默认路径是 <code>/usr/bin/python2</code>，此时可以使用 <code>python2</code> 来运行代码了。</p>\n<blockquote>\n<p>这里默认安装 python2.7</p>\n</blockquote>\n<h3 id=\"pip2\"><a href=\"#pip2\" class=\"headerlink\" title=\"pip2\"></a>pip2</h3><p>为了方便地管理 python2 依赖，我们还需要 pip2。</p>\n<p>但通过 ubuntu 软件源安装的 python2 不自带 pip2 管理工具。这是因为 Python 2.7 的支持周期已于 2020 年 1 月 1 日结束，pip 21.0 也于 2021 年 1 月停止对 Python 2.7 的支持。</p>\n<p>只能手动安装。</p>\n<p>假设你已经按照上文描述安装好了 python2，使用以下命令拉取 <a href=\"pypa.io\">pypa.io</a> 的安装脚本并用 python2 执行即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O - https://bootstrap.pypa.io/pip/2.7/get-pip.py | python2</span><br></pre></td></tr></table></figure>\n\n<p>安装成功后重启终端，然后使用 <code>pip2 --version</code> 检查是否安装成功。现在，你已经在本地有了 python2.7 环境和对应的 pip2 包管理工具。</p>\n<h2 id=\"py2环境管理-virtualenv\"><a href=\"#py2环境管理-virtualenv\" class=\"headerlink\" title=\"py2环境管理 - virtualenv\"></a>py2环境管理 - virtualenv</h2><p>只有本地 python2 环境肯定不行，我们不能容忍我们的软件包变成依托。</p>\n<p>管理 python2.7 环境，我们可以使用 venv 的前身 —— <code>virtualenv</code>。</p>\n<h3 id=\"使用-1\"><a href=\"#使用-1\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>与 venv 基本一致，这里不再赘述：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">pip2 install virtualenv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建虚拟环境 env</span></span><br><span class=\"line\">virtualenv <span class=\"built_in\">env</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 激活虚拟环境</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ./env/bin/avtivate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 关闭虚拟环境</span></span><br><span class=\"line\">deactivate</span><br></pre></td></tr></table></figure>\n\n<p>激活虚拟环境后，使用 <code>python --version</code> 查看虚拟环境的 python 版本，会提示：<code>Python 2.7.18</code>。这与你安装的 python2 版本有关，自行判断。</p>\n<h3 id=\"为什么不用-venv\"><a href=\"#为什么不用-venv\" class=\"headerlink\" title=\"为什么不用 venv\"></a>为什么不用 venv</h3><p>尝试 <code>pip2 install venv</code> 会提示：<code>ERROR: Could not find a version that satisfies the requirement venv (from versions: none)</code>，也就是官方没有提供对应的模块版本。</p>\n<p>或许你在什么地方看到过使用 venv 指定 python 解释器来创建对应虚拟环境，比如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m venv --python=/usr/bin/python2 venv</span><br></pre></td></tr></table></figure>\n\n<p>不知道是否真的可行，至少阿菇这里行不通，会提示没有存在不支持的参数 <code>--python</code>，不知道是不是 venv 版本问题。</p>\n<h3 id=\"再进一步\"><a href=\"#再进一步\" class=\"headerlink\" title=\"再进一步\"></a>再进一步</h3><p>现在有了 python2.7 和 python3.10，也做到了虚拟环境，已经能胜任多数使用场景了。</p>\n<p>但阿菇并不满意，版本管理不够精细。我们该如何使用其他更细分的版本呢，比如 python3.8？</p>\n<h2 id=\"py版本管理工具-pyenv\"><a href=\"#py版本管理工具-pyenv\" class=\"headerlink\" title=\"py版本管理工具 - pyenv\"></a>py版本管理工具 - pyenv</h2><p>有一款合适的 Python 版本管理工具—— <code>pyenv</code>。</p>\n<h3 id=\"使用-2\"><a href=\"#使用-2\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>使用 Git 直接拉取 pyenv 到本地就行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/pyenv/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure>\n\n<p>然后需要修改环境变量，这个和的命令行有关，这里提供 zsh 和 bash 两个版本的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># zsh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;eval &quot;$(pyenv init --path)&quot;&#x27;</span> &gt;&gt; ~/.zprofile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># bash</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&#x27;if shopt -q login_shell; then&#x27;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n eval &quot;$(pyenv init --path)&quot;&#x27;</span> \\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\nfi&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">&#x27;if [ -z &quot;$BASH_VERSION&quot; ]; then&#x27;</span>\\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span>\\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span>\\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\n  eval &quot;$(pyenv init --path)&quot;&#x27;</span>\\</span><br><span class=\"line\">      <span class=\"string\">&#x27;\\nfi&#x27;</span> &gt;&gt;~/.profile</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;if command -v pyenv &gt;/dev/null; then eval &quot;$(pyenv init -)&quot;; fi&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>执行完成后就可以使用 pyenv 了。</p>\n<blockquote>\n<p>上面的指令中中已经包括重新加载命令行配置的指令。</p>\n</blockquote>\n<p>执行 <code>pyenv -h</code> 可以查看手册，然后上手用就行。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前 python 版本</span></span><br><span class=\"line\">pyenv version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有 python 版本</span></span><br><span class=\"line\">pyenv versions</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有可安装的 python 版本</span></span><br><span class=\"line\">pyenv install --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装指定 python 版本</span></span><br><span class=\"line\">pyenv install 3.8.12</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装新版本后 rehash</span></span><br><span class=\"line\">pyenv <span class=\"built_in\">rehash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定全局 python 版本</span></span><br><span class=\"line\">pyenv global 3.8.12</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除指定 python 版本</span></span><br><span class=\"line\">pyenv uninstall 3.8.12</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 指定多个全局版本, python3版本优先</span></span><br><span class=\"line\">pyenv global 3.8.12 2.7.10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"加速pyenv\"><a href=\"#加速pyenv\" class=\"headerlink\" title=\"加速pyenv\"></a>加速pyenv</h3><p>国内访问外网不方便，执行 <code>pyenv install</code> 时可能会非常慢，甚至超时终止访问。我们有几种方案解决这个问题。</p>\n<h4 id=\"01-手动下载压缩包\"><a href=\"#01-手动下载压缩包\" class=\"headerlink\" title=\"01 手动下载压缩包\"></a>01 手动下载压缩包</h4><p>网上最多的是手动下载压缩包到 pyenv 缓存，然后再用 <code>pyenv install</code> 安装。</p>\n<p>国内有 python 镜像站，我们进去找到对应版本压缩包下载就行：<a href=\"https://registry.npmmirror.com/binary.html?path=python/\">国内镜像站</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823d54c959b8426bb3b901c9a28838a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672&h=755&s=175052&e=png&b=ffffff\" alt=\"20231102104041\"></p>\n<p>先找到所需版本的下载链接，右键复制链接地址，然后使用 wget 拉取到本地 pyenv 缓存中，再执行命令下载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://registry.npmmirror.com/-/binary/python/2.7.10/Python-2.7.10.tar.xz -P ~/.pyenv/cache</span><br><span class=\"line\">pyenv install 2.7.10</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"02-终端代理\"><a href=\"#02-终端代理\" class=\"headerlink\" title=\"02 终端代理\"></a>02 终端代理</h4><p>这个同样适用于其他下载慢的情况，设置 shell 的 <code>http_proxy</code> 环境变量，让终端走代理。</p>\n<p>前提是你要有一个代理服务器，或者有相应的工具。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"03-pyenv镜像\"><a href=\"#03-pyenv镜像\" class=\"headerlink\" title=\"03 pyenv镜像\"></a>03 pyenv镜像</h4><p>使用国内镜像站中的压缩包资源，这里以<a href=\"http://mirrors.sohu.com/python/\">搜狐 pyenv 镜像源</a>为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v=3.5.2|wget http://mirrors.sohu.com/python/<span class=\"variable\">$v</span>/Python-<span class=\"variable\">$v</span>.tar.xz -P ~/.pyenv/cache/;pyenv install <span class=\"variable\">$v</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"py环境管理工具-pyenv-virtualenv\"><a href=\"#py环境管理工具-pyenv-virtualenv\" class=\"headerlink\" title=\"py环境管理工具 - pyenv-virtualenv\"></a>py环境管理工具 - pyenv-virtualenv</h2><p>pyenv 可以实现快捷的 python 版本管理，我们可以使用它的 <code>virtualenv</code> 插件一并实现虚拟环境管理。</p>\n<h3 id=\"使用-3\"><a href=\"#使用-3\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>拉取脚本然后添加环境变量，再重启 shell 即可，这里以 zsh 为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装插件</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加环境变量到 zsh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重启 zsh</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> zsh</span><br></pre></td></tr></table></figure>\n\n<p>然后我们就可以使用 pyenv 的 virtualenv 插件管理虚拟环境了。只要是你已经通过 pyenv 安装的版本，都可以使用该插件创建对应的虚拟环境。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pyenv virtualenv 3.8.12 v3812env</span><br></pre></td></tr></table></figure>\n\n<p>但是要注意，<code>virtualenv</code>  插件的逻辑和 venv 以及 py2 的 virtualenv 模块不同，它不是在当前目录下创建虚拟环境目录，而是在 <code>～/.pyenv</code> 目录中安装。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8a617a9327746d69b0573d010a4d8a3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=167&s=36334&e=png&b=15192b\" alt=\"20231102133150\"></p>\n<p>使用 virtualenv 插件的虚拟环境也很方便：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出当前虚拟环境</span></span><br><span class=\"line\">pyenv virtualenvs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 激活虚拟环境</span></span><br><span class=\"line\">pyenv activate v3812env</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出虚拟环境</span></span><br><span class=\"line\">pyenv deactivate v3812env </span><br></pre></td></tr></table></figure>\n\n<p>至此，我们基本实现了 Linux 下方便的管理各版本的 python 虚拟环境，这允许我们为每个项目&#x2F;工具创建独立的虚拟环境，有效的维护了系统本身的整洁。</p>\n<h3 id=\"或许，还可以……？\"><a href=\"#或许，还可以……？\" class=\"headerlink\" title=\"或许，还可以……？\"></a>或许，还可以……？</h3><p>以上是我们的 python 版本&#x2F;环境管理方案，已经够用了，但或许你并不满足。身为合格的程序员，你对环境管理有着更高的需求。</p>\n<p>那还有更优秀的解决方案吗？</p>\n<p>有！</p>\n<h2 id=\"Nox-堂堂登场！\"><a href=\"#Nox-堂堂登场！\" class=\"headerlink\" title=\"Nox 堂堂登场！\"></a>Nox 堂堂登场！</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7653602e147c43ccab1438a4589f7dfb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932&h=287&s=90851&e=png&b=fffefe\" alt=\"20231102192818\"></p>\n<p><code>Nox</code> 是一个命令行工具，用于在多个 Python 环境中进行自动测试，开发者可以使用标准的 Python 文件对项目进行配置。</p>\n<p>我们可以在项目根目录下创建一个 <code>noxfile.py</code> 文件，使用安装好的 <code>nox</code> 模块运行这个文件，以创建 python 虚拟环境并运行一些预定的指令。我们也可以手动激活 python 虚拟环境，就像前面的 venv 一样。</p>\n<h3 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h3><p>新建个 <code>app</code> 目录，在里面配置一份 <code>noxfile.py</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> nox <span class=\"comment\"># 引用 nox 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@nox.session(<span class=\"params\">python=<span class=\"string\">&#x27;3.8.12&#x27;</span></span>) </span><span class=\"comment\"># 使用 python3.8.12</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">install_flask</span>(<span class=\"params\">session</span>): <span class=\"comment\"># 创建一个名为 install_flask 的会话</span></span><br><span class=\"line\">    session.install(<span class=\"string\">&#x27;flask&#x27;</span>) <span class=\"comment\"># 安装 flask 依赖</span></span><br></pre></td></tr></table></figure>\n\n<p>然后，我们在当前目录下执行以下指令，初始化这个虚拟环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 -m nox   </span><br><span class=\"line\"></span><br><span class=\"line\">nox &gt; Running session install_flask</span><br><span class=\"line\">nox &gt; Creating virtual environment (virtualenv) using python3.8 <span class=\"keyword\">in</span> .nox/install_flask</span><br><span class=\"line\">nox &gt; python -m pip install flask</span><br><span class=\"line\">nox &gt; Session install_flask was successful.</span><br></pre></td></tr></table></figure>\n\n<p>初始化完成后，当前目录下多出 <code>__pycache__</code> 和 <code>.nox</code> 文件，前者是缓存目录，存储编译后的 python 代码，后者就是我们的虚拟环境目录，类似与使用 `python -m venv env`` 创建的 env 目录。</p>\n<p>有了虚拟环境之后，常用的指令就和 venv 没有太大差别了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 激活 install_flask 虚拟环境</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> .nox/install_flask/bin/activate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 退出虚拟环境</span></span><br><span class=\"line\">deactivate</span><br></pre></td></tr></table></figure>\n\n<p>你可以把下面这段 <code>app.py</code> 写入当前目录下，作用是实现一个 flask Web 服务，你可以激活刚创建好的这个虚拟环境，然后尝试运行这个服务。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hello_world</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello, World!&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    app.run()</span><br></pre></td></tr></table></figure>\n\n<p>如果运行结果与下图类似，即 flask web 服务正常运行，则代表你的 nox 与刚创建的虚拟环境没有问题。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc32ac6fac94f3188fe1648edb07a62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=881&h=211&s=31011&e=png&b=15172a\" alt=\"20231102194422\"></p>\n<blockquote>\n<p>nox 只能创建当前系统已有 python 解释器对应版本的虚拟环境，也就是说你本地没有 python2.7.10 环境，你也无法创建 2.7.10 虚拟环境。</p>\n</blockquote>\n<h3 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h3><p>可以从以下渠道继续学习 nox，它的功能远比我这个案例中所演示的强大得多。</p>\n<ul>\n<li>官方文档：<a href=\"https://nox.thea.codes/en/stable/index.html\">Welcome to Nox</a></li>\n<li>中文文档：<a href=\"https://daobook.github.io/nox/index.html\">欢迎来到 Nox</a></li>\n<li>项目地址：<a href=\"https://github.com/wntrblm/nox\">Winterbloom&#x2F;nox</a></li>\n</ul>\n<h2 id=\"另一选择-Tox\"><a href=\"#另一选择-Tox\" class=\"headerlink\" title=\"另一选择 - Tox\"></a>另一选择 - Tox</h2><p><code>Nox</code> 与 <code>Tox</code> 十分相似，二者都是 python 任务自动化工具，都可以创建虚拟环境以隔绝项目与本地系统。</p>\n<ul>\n<li>官方文档：<a href=\"https://www.osgeo.cn/tox/\">欢迎来到tox自动化项目</a></li>\n<li>GitHub 仓库：<a href=\"https://github.com/tox-dev/tox\">tox-dev&#x2F;tox</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clxhruaot0001f4ly6lskhpxg","category_id":"clxhruaow0004f4lyg9d916ih","_id":"clxhruap1000df4lyhgzd59lq"},{"post_id":"clxhruaov0003f4ly8zmgal7q","category_id":"clxhruaow0004f4lyg9d916ih","_id":"clxhruap2000gf4lyfksf5qmr"},{"post_id":"clxhruap1000bf4ly6kdf3925","category_id":"clxhruaow0004f4lyg9d916ih","_id":"clxhruap3000jf4lyeegf56qr"},{"post_id":"clxhruaox0006f4ly9ea00fve","category_id":"clxhruap1000cf4ly95u6988i","_id":"clxhruap4000mf4lya6yc3pdv"},{"post_id":"clxhruap2000ff4ly2cg2e96d","category_id":"clxhruap1000cf4ly95u6988i","_id":"clxhruap4000of4lycwfeatw7"},{"post_id":"clxhruaoy0007f4ly3u18dhkk","category_id":"clxhruap1000cf4ly95u6988i","_id":"clxhruap7000qf4ly7hz95daj"},{"post_id":"clxhruaoy0008f4ly09zx4dr8","category_id":"clxhruap4000lf4ly26uo4b7o","_id":"clxhruap8000uf4ly76jl6560"},{"post_id":"clxhruap4000pf4lyhxuy6cqo","category_id":"clxhruaow0004f4lyg9d916ih","_id":"clxhruap9000xf4lyd32yelxp"},{"post_id":"clxhruap7000sf4ly3kga2gj1","category_id":"clxhruaow0004f4lyg9d916ih","_id":"clxhruap9000zf4ly5jcvcnro"},{"post_id":"clxhruap0000af4lyfob6hsb3","category_id":"clxhruap7000rf4ly7fdm5j1s","_id":"clxhruap90012f4lyer6w6ygk"},{"post_id":"clxhruap8000tf4lygcko4722","category_id":"clxhruaow0004f4lyg9d916ih","_id":"clxhruapa0014f4ly5sz5ev81"},{"post_id":"clxhruap1000ef4ly37wq4vdb","category_id":"clxhruap8000vf4ly6lgd9gzo","_id":"clxhruapa0017f4ly69uicbip"},{"post_id":"clxhruap3000if4lybsx89lvc","category_id":"clxhruap90011f4lybxhfbb24","_id":"clxhruapb001af4ly8ftcbghe"},{"post_id":"clxhruapa0018f4ly70f0g35g","category_id":"clxhruaow0004f4lyg9d916ih","_id":"clxhruapc001df4ly7txye1k5"},{"post_id":"clxhruap3000kf4lyabvt4jyl","category_id":"clxhruapa0016f4ly8hiqgmrc","_id":"clxhruapc001ff4lyenpy4eyj"},{"post_id":"clxhruapb0019f4ly301z3d6e","category_id":"clxhruap8000vf4ly6lgd9gzo","_id":"clxhruapc001gf4ly4ovidjmy"},{"post_id":"clxhruap4000nf4lyg0t08wxm","category_id":"clxhruapb001bf4lyabed68vn","_id":"clxhruapc001hf4ly2r4z7c7l"},{"post_id":"clxhruap8000wf4lycx870b8u","category_id":"clxhruapc001ef4ly4cpc3bxd","_id":"clxhruapc001jf4lygu52ezae"},{"post_id":"clxhruap9000yf4ly6y2z6e7s","category_id":"clxhruapc001if4ly93qg323r","_id":"clxhruapc001mf4ly2kry390y"},{"post_id":"clxhruap90010f4lydrji24xy","category_id":"clxhruapc001if4ly93qg323r","_id":"clxhruapc001nf4lycmuv3wiu"},{"post_id":"clxhruapa0013f4ly8kec40m6","category_id":"clxhruapc001lf4lybnfucwza","_id":"clxhruapd001pf4lyaudo0cw8"},{"post_id":"clxhruapa0015f4lycz8s6ow8","category_id":"clxhruapd001of4ly97vldi1z","_id":"clxhruapd001rf4lydrc92gt5"},{"post_id":"clxhruapb001cf4lyb3huerm4","category_id":"clxhruapd001qf4lyer9k8056","_id":"clxhruapd001sf4ly96mn8doj"},{"post_id":"clxhruapf001tf4ly6pvkf6qj","category_id":"clxhruapg001uf4lyggmwgfyc","_id":"clxhruapg001vf4lygvaih253"}],"PostTag":[],"Tag":[]}}